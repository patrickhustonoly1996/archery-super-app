// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'database.dart';

// ignore_for_file: type=lint
class $RoundTypesTable extends RoundTypes
    with TableInfo<$RoundTypesTable, RoundType> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $RoundTypesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _categoryMeta = const VerificationMeta(
    'category',
  );
  @override
  late final GeneratedColumn<String> category = GeneratedColumn<String>(
    'category',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _distanceMeta = const VerificationMeta(
    'distance',
  );
  @override
  late final GeneratedColumn<int> distance = GeneratedColumn<int>(
    'distance',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _faceSizeMeta = const VerificationMeta(
    'faceSize',
  );
  @override
  late final GeneratedColumn<int> faceSize = GeneratedColumn<int>(
    'face_size',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _arrowsPerEndMeta = const VerificationMeta(
    'arrowsPerEnd',
  );
  @override
  late final GeneratedColumn<int> arrowsPerEnd = GeneratedColumn<int>(
    'arrows_per_end',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _totalEndsMeta = const VerificationMeta(
    'totalEnds',
  );
  @override
  late final GeneratedColumn<int> totalEnds = GeneratedColumn<int>(
    'total_ends',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _maxScoreMeta = const VerificationMeta(
    'maxScore',
  );
  @override
  late final GeneratedColumn<int> maxScore = GeneratedColumn<int>(
    'max_score',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _isIndoorMeta = const VerificationMeta(
    'isIndoor',
  );
  @override
  late final GeneratedColumn<bool> isIndoor = GeneratedColumn<bool>(
    'is_indoor',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_indoor" IN (0, 1))',
    ),
  );
  static const VerificationMeta _faceCountMeta = const VerificationMeta(
    'faceCount',
  );
  @override
  late final GeneratedColumn<int> faceCount = GeneratedColumn<int>(
    'face_count',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(1),
  );
  static const VerificationMeta _scoringTypeMeta = const VerificationMeta(
    'scoringType',
  );
  @override
  late final GeneratedColumn<String> scoringType = GeneratedColumn<String>(
    'scoring_type',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('10-zone'),
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    name,
    category,
    distance,
    faceSize,
    arrowsPerEnd,
    totalEnds,
    maxScore,
    isIndoor,
    faceCount,
    scoringType,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'round_types';
  @override
  VerificationContext validateIntegrity(
    Insertable<RoundType> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('category')) {
      context.handle(
        _categoryMeta,
        category.isAcceptableOrUnknown(data['category']!, _categoryMeta),
      );
    } else if (isInserting) {
      context.missing(_categoryMeta);
    }
    if (data.containsKey('distance')) {
      context.handle(
        _distanceMeta,
        distance.isAcceptableOrUnknown(data['distance']!, _distanceMeta),
      );
    } else if (isInserting) {
      context.missing(_distanceMeta);
    }
    if (data.containsKey('face_size')) {
      context.handle(
        _faceSizeMeta,
        faceSize.isAcceptableOrUnknown(data['face_size']!, _faceSizeMeta),
      );
    } else if (isInserting) {
      context.missing(_faceSizeMeta);
    }
    if (data.containsKey('arrows_per_end')) {
      context.handle(
        _arrowsPerEndMeta,
        arrowsPerEnd.isAcceptableOrUnknown(
          data['arrows_per_end']!,
          _arrowsPerEndMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_arrowsPerEndMeta);
    }
    if (data.containsKey('total_ends')) {
      context.handle(
        _totalEndsMeta,
        totalEnds.isAcceptableOrUnknown(data['total_ends']!, _totalEndsMeta),
      );
    } else if (isInserting) {
      context.missing(_totalEndsMeta);
    }
    if (data.containsKey('max_score')) {
      context.handle(
        _maxScoreMeta,
        maxScore.isAcceptableOrUnknown(data['max_score']!, _maxScoreMeta),
      );
    } else if (isInserting) {
      context.missing(_maxScoreMeta);
    }
    if (data.containsKey('is_indoor')) {
      context.handle(
        _isIndoorMeta,
        isIndoor.isAcceptableOrUnknown(data['is_indoor']!, _isIndoorMeta),
      );
    } else if (isInserting) {
      context.missing(_isIndoorMeta);
    }
    if (data.containsKey('face_count')) {
      context.handle(
        _faceCountMeta,
        faceCount.isAcceptableOrUnknown(data['face_count']!, _faceCountMeta),
      );
    }
    if (data.containsKey('scoring_type')) {
      context.handle(
        _scoringTypeMeta,
        scoringType.isAcceptableOrUnknown(
          data['scoring_type']!,
          _scoringTypeMeta,
        ),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  RoundType map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return RoundType(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      category: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}category'],
      )!,
      distance: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}distance'],
      )!,
      faceSize: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}face_size'],
      )!,
      arrowsPerEnd: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}arrows_per_end'],
      )!,
      totalEnds: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}total_ends'],
      )!,
      maxScore: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}max_score'],
      )!,
      isIndoor: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_indoor'],
      )!,
      faceCount: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}face_count'],
      )!,
      scoringType: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}scoring_type'],
      )!,
    );
  }

  @override
  $RoundTypesTable createAlias(String alias) {
    return $RoundTypesTable(attachedDatabase, alias);
  }
}

class RoundType extends DataClass implements Insertable<RoundType> {
  final String id;
  final String name;
  final String category;
  final int distance;
  final int faceSize;
  final int arrowsPerEnd;
  final int totalEnds;
  final int maxScore;
  final bool isIndoor;
  final int faceCount;
  final String scoringType;
  const RoundType({
    required this.id,
    required this.name,
    required this.category,
    required this.distance,
    required this.faceSize,
    required this.arrowsPerEnd,
    required this.totalEnds,
    required this.maxScore,
    required this.isIndoor,
    required this.faceCount,
    required this.scoringType,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['name'] = Variable<String>(name);
    map['category'] = Variable<String>(category);
    map['distance'] = Variable<int>(distance);
    map['face_size'] = Variable<int>(faceSize);
    map['arrows_per_end'] = Variable<int>(arrowsPerEnd);
    map['total_ends'] = Variable<int>(totalEnds);
    map['max_score'] = Variable<int>(maxScore);
    map['is_indoor'] = Variable<bool>(isIndoor);
    map['face_count'] = Variable<int>(faceCount);
    map['scoring_type'] = Variable<String>(scoringType);
    return map;
  }

  RoundTypesCompanion toCompanion(bool nullToAbsent) {
    return RoundTypesCompanion(
      id: Value(id),
      name: Value(name),
      category: Value(category),
      distance: Value(distance),
      faceSize: Value(faceSize),
      arrowsPerEnd: Value(arrowsPerEnd),
      totalEnds: Value(totalEnds),
      maxScore: Value(maxScore),
      isIndoor: Value(isIndoor),
      faceCount: Value(faceCount),
      scoringType: Value(scoringType),
    );
  }

  factory RoundType.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return RoundType(
      id: serializer.fromJson<String>(json['id']),
      name: serializer.fromJson<String>(json['name']),
      category: serializer.fromJson<String>(json['category']),
      distance: serializer.fromJson<int>(json['distance']),
      faceSize: serializer.fromJson<int>(json['faceSize']),
      arrowsPerEnd: serializer.fromJson<int>(json['arrowsPerEnd']),
      totalEnds: serializer.fromJson<int>(json['totalEnds']),
      maxScore: serializer.fromJson<int>(json['maxScore']),
      isIndoor: serializer.fromJson<bool>(json['isIndoor']),
      faceCount: serializer.fromJson<int>(json['faceCount']),
      scoringType: serializer.fromJson<String>(json['scoringType']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'name': serializer.toJson<String>(name),
      'category': serializer.toJson<String>(category),
      'distance': serializer.toJson<int>(distance),
      'faceSize': serializer.toJson<int>(faceSize),
      'arrowsPerEnd': serializer.toJson<int>(arrowsPerEnd),
      'totalEnds': serializer.toJson<int>(totalEnds),
      'maxScore': serializer.toJson<int>(maxScore),
      'isIndoor': serializer.toJson<bool>(isIndoor),
      'faceCount': serializer.toJson<int>(faceCount),
      'scoringType': serializer.toJson<String>(scoringType),
    };
  }

  RoundType copyWith({
    String? id,
    String? name,
    String? category,
    int? distance,
    int? faceSize,
    int? arrowsPerEnd,
    int? totalEnds,
    int? maxScore,
    bool? isIndoor,
    int? faceCount,
    String? scoringType,
  }) => RoundType(
    id: id ?? this.id,
    name: name ?? this.name,
    category: category ?? this.category,
    distance: distance ?? this.distance,
    faceSize: faceSize ?? this.faceSize,
    arrowsPerEnd: arrowsPerEnd ?? this.arrowsPerEnd,
    totalEnds: totalEnds ?? this.totalEnds,
    maxScore: maxScore ?? this.maxScore,
    isIndoor: isIndoor ?? this.isIndoor,
    faceCount: faceCount ?? this.faceCount,
    scoringType: scoringType ?? this.scoringType,
  );
  RoundType copyWithCompanion(RoundTypesCompanion data) {
    return RoundType(
      id: data.id.present ? data.id.value : this.id,
      name: data.name.present ? data.name.value : this.name,
      category: data.category.present ? data.category.value : this.category,
      distance: data.distance.present ? data.distance.value : this.distance,
      faceSize: data.faceSize.present ? data.faceSize.value : this.faceSize,
      arrowsPerEnd: data.arrowsPerEnd.present
          ? data.arrowsPerEnd.value
          : this.arrowsPerEnd,
      totalEnds: data.totalEnds.present ? data.totalEnds.value : this.totalEnds,
      maxScore: data.maxScore.present ? data.maxScore.value : this.maxScore,
      isIndoor: data.isIndoor.present ? data.isIndoor.value : this.isIndoor,
      faceCount: data.faceCount.present ? data.faceCount.value : this.faceCount,
      scoringType: data.scoringType.present
          ? data.scoringType.value
          : this.scoringType,
    );
  }

  @override
  String toString() {
    return (StringBuffer('RoundType(')
          ..write('id: $id, ')
          ..write('name: $name, ')
          ..write('category: $category, ')
          ..write('distance: $distance, ')
          ..write('faceSize: $faceSize, ')
          ..write('arrowsPerEnd: $arrowsPerEnd, ')
          ..write('totalEnds: $totalEnds, ')
          ..write('maxScore: $maxScore, ')
          ..write('isIndoor: $isIndoor, ')
          ..write('faceCount: $faceCount, ')
          ..write('scoringType: $scoringType')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    name,
    category,
    distance,
    faceSize,
    arrowsPerEnd,
    totalEnds,
    maxScore,
    isIndoor,
    faceCount,
    scoringType,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is RoundType &&
          other.id == this.id &&
          other.name == this.name &&
          other.category == this.category &&
          other.distance == this.distance &&
          other.faceSize == this.faceSize &&
          other.arrowsPerEnd == this.arrowsPerEnd &&
          other.totalEnds == this.totalEnds &&
          other.maxScore == this.maxScore &&
          other.isIndoor == this.isIndoor &&
          other.faceCount == this.faceCount &&
          other.scoringType == this.scoringType);
}

class RoundTypesCompanion extends UpdateCompanion<RoundType> {
  final Value<String> id;
  final Value<String> name;
  final Value<String> category;
  final Value<int> distance;
  final Value<int> faceSize;
  final Value<int> arrowsPerEnd;
  final Value<int> totalEnds;
  final Value<int> maxScore;
  final Value<bool> isIndoor;
  final Value<int> faceCount;
  final Value<String> scoringType;
  final Value<int> rowid;
  const RoundTypesCompanion({
    this.id = const Value.absent(),
    this.name = const Value.absent(),
    this.category = const Value.absent(),
    this.distance = const Value.absent(),
    this.faceSize = const Value.absent(),
    this.arrowsPerEnd = const Value.absent(),
    this.totalEnds = const Value.absent(),
    this.maxScore = const Value.absent(),
    this.isIndoor = const Value.absent(),
    this.faceCount = const Value.absent(),
    this.scoringType = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  RoundTypesCompanion.insert({
    required String id,
    required String name,
    required String category,
    required int distance,
    required int faceSize,
    required int arrowsPerEnd,
    required int totalEnds,
    required int maxScore,
    required bool isIndoor,
    this.faceCount = const Value.absent(),
    this.scoringType = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       name = Value(name),
       category = Value(category),
       distance = Value(distance),
       faceSize = Value(faceSize),
       arrowsPerEnd = Value(arrowsPerEnd),
       totalEnds = Value(totalEnds),
       maxScore = Value(maxScore),
       isIndoor = Value(isIndoor);
  static Insertable<RoundType> custom({
    Expression<String>? id,
    Expression<String>? name,
    Expression<String>? category,
    Expression<int>? distance,
    Expression<int>? faceSize,
    Expression<int>? arrowsPerEnd,
    Expression<int>? totalEnds,
    Expression<int>? maxScore,
    Expression<bool>? isIndoor,
    Expression<int>? faceCount,
    Expression<String>? scoringType,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (name != null) 'name': name,
      if (category != null) 'category': category,
      if (distance != null) 'distance': distance,
      if (faceSize != null) 'face_size': faceSize,
      if (arrowsPerEnd != null) 'arrows_per_end': arrowsPerEnd,
      if (totalEnds != null) 'total_ends': totalEnds,
      if (maxScore != null) 'max_score': maxScore,
      if (isIndoor != null) 'is_indoor': isIndoor,
      if (faceCount != null) 'face_count': faceCount,
      if (scoringType != null) 'scoring_type': scoringType,
      if (rowid != null) 'rowid': rowid,
    });
  }

  RoundTypesCompanion copyWith({
    Value<String>? id,
    Value<String>? name,
    Value<String>? category,
    Value<int>? distance,
    Value<int>? faceSize,
    Value<int>? arrowsPerEnd,
    Value<int>? totalEnds,
    Value<int>? maxScore,
    Value<bool>? isIndoor,
    Value<int>? faceCount,
    Value<String>? scoringType,
    Value<int>? rowid,
  }) {
    return RoundTypesCompanion(
      id: id ?? this.id,
      name: name ?? this.name,
      category: category ?? this.category,
      distance: distance ?? this.distance,
      faceSize: faceSize ?? this.faceSize,
      arrowsPerEnd: arrowsPerEnd ?? this.arrowsPerEnd,
      totalEnds: totalEnds ?? this.totalEnds,
      maxScore: maxScore ?? this.maxScore,
      isIndoor: isIndoor ?? this.isIndoor,
      faceCount: faceCount ?? this.faceCount,
      scoringType: scoringType ?? this.scoringType,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (category.present) {
      map['category'] = Variable<String>(category.value);
    }
    if (distance.present) {
      map['distance'] = Variable<int>(distance.value);
    }
    if (faceSize.present) {
      map['face_size'] = Variable<int>(faceSize.value);
    }
    if (arrowsPerEnd.present) {
      map['arrows_per_end'] = Variable<int>(arrowsPerEnd.value);
    }
    if (totalEnds.present) {
      map['total_ends'] = Variable<int>(totalEnds.value);
    }
    if (maxScore.present) {
      map['max_score'] = Variable<int>(maxScore.value);
    }
    if (isIndoor.present) {
      map['is_indoor'] = Variable<bool>(isIndoor.value);
    }
    if (faceCount.present) {
      map['face_count'] = Variable<int>(faceCount.value);
    }
    if (scoringType.present) {
      map['scoring_type'] = Variable<String>(scoringType.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('RoundTypesCompanion(')
          ..write('id: $id, ')
          ..write('name: $name, ')
          ..write('category: $category, ')
          ..write('distance: $distance, ')
          ..write('faceSize: $faceSize, ')
          ..write('arrowsPerEnd: $arrowsPerEnd, ')
          ..write('totalEnds: $totalEnds, ')
          ..write('maxScore: $maxScore, ')
          ..write('isIndoor: $isIndoor, ')
          ..write('faceCount: $faceCount, ')
          ..write('scoringType: $scoringType, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $BowsTable extends Bows with TableInfo<$BowsTable, Bow> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $BowsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _bowTypeMeta = const VerificationMeta(
    'bowType',
  );
  @override
  late final GeneratedColumn<String> bowType = GeneratedColumn<String>(
    'bow_type',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _settingsMeta = const VerificationMeta(
    'settings',
  );
  @override
  late final GeneratedColumn<String> settings = GeneratedColumn<String>(
    'settings',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _isDefaultMeta = const VerificationMeta(
    'isDefault',
  );
  @override
  late final GeneratedColumn<bool> isDefault = GeneratedColumn<bool>(
    'is_default',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_default" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _deletedAtMeta = const VerificationMeta(
    'deletedAt',
  );
  @override
  late final GeneratedColumn<DateTime> deletedAt = GeneratedColumn<DateTime>(
    'deleted_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _riserModelMeta = const VerificationMeta(
    'riserModel',
  );
  @override
  late final GeneratedColumn<String> riserModel = GeneratedColumn<String>(
    'riser_model',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _riserPurchaseDateMeta = const VerificationMeta(
    'riserPurchaseDate',
  );
  @override
  late final GeneratedColumn<DateTime> riserPurchaseDate =
      GeneratedColumn<DateTime>(
        'riser_purchase_date',
        aliasedName,
        true,
        type: DriftSqlType.dateTime,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _limbModelMeta = const VerificationMeta(
    'limbModel',
  );
  @override
  late final GeneratedColumn<String> limbModel = GeneratedColumn<String>(
    'limb_model',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _limbPurchaseDateMeta = const VerificationMeta(
    'limbPurchaseDate',
  );
  @override
  late final GeneratedColumn<DateTime> limbPurchaseDate =
      GeneratedColumn<DateTime>(
        'limb_purchase_date',
        aliasedName,
        true,
        type: DriftSqlType.dateTime,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _poundageMeta = const VerificationMeta(
    'poundage',
  );
  @override
  late final GeneratedColumn<double> poundage = GeneratedColumn<double>(
    'poundage',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _tillerTopMeta = const VerificationMeta(
    'tillerTop',
  );
  @override
  late final GeneratedColumn<double> tillerTop = GeneratedColumn<double>(
    'tiller_top',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _tillerBottomMeta = const VerificationMeta(
    'tillerBottom',
  );
  @override
  late final GeneratedColumn<double> tillerBottom = GeneratedColumn<double>(
    'tiller_bottom',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _braceHeightMeta = const VerificationMeta(
    'braceHeight',
  );
  @override
  late final GeneratedColumn<double> braceHeight = GeneratedColumn<double>(
    'brace_height',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _nockingPointHeightMeta =
      const VerificationMeta('nockingPointHeight');
  @override
  late final GeneratedColumn<double> nockingPointHeight =
      GeneratedColumn<double>(
        'nocking_point_height',
        aliasedName,
        true,
        type: DriftSqlType.double,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _buttonPositionMeta = const VerificationMeta(
    'buttonPosition',
  );
  @override
  late final GeneratedColumn<double> buttonPosition = GeneratedColumn<double>(
    'button_position',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _buttonTensionMeta = const VerificationMeta(
    'buttonTension',
  );
  @override
  late final GeneratedColumn<String> buttonTension = GeneratedColumn<String>(
    'button_tension',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _clickerPositionMeta = const VerificationMeta(
    'clickerPosition',
  );
  @override
  late final GeneratedColumn<double> clickerPosition = GeneratedColumn<double>(
    'clicker_position',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _eyeToArrowDistanceMeta =
      const VerificationMeta('eyeToArrowDistance');
  @override
  late final GeneratedColumn<double> eyeToArrowDistance =
      GeneratedColumn<double>(
        'eye_to_arrow_distance',
        aliasedName,
        true,
        type: DriftSqlType.double,
        requiredDuringInsert: false,
      );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    name,
    bowType,
    settings,
    isDefault,
    createdAt,
    updatedAt,
    deletedAt,
    riserModel,
    riserPurchaseDate,
    limbModel,
    limbPurchaseDate,
    poundage,
    tillerTop,
    tillerBottom,
    braceHeight,
    nockingPointHeight,
    buttonPosition,
    buttonTension,
    clickerPosition,
    eyeToArrowDistance,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'bows';
  @override
  VerificationContext validateIntegrity(
    Insertable<Bow> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('bow_type')) {
      context.handle(
        _bowTypeMeta,
        bowType.isAcceptableOrUnknown(data['bow_type']!, _bowTypeMeta),
      );
    } else if (isInserting) {
      context.missing(_bowTypeMeta);
    }
    if (data.containsKey('settings')) {
      context.handle(
        _settingsMeta,
        settings.isAcceptableOrUnknown(data['settings']!, _settingsMeta),
      );
    }
    if (data.containsKey('is_default')) {
      context.handle(
        _isDefaultMeta,
        isDefault.isAcceptableOrUnknown(data['is_default']!, _isDefaultMeta),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    }
    if (data.containsKey('deleted_at')) {
      context.handle(
        _deletedAtMeta,
        deletedAt.isAcceptableOrUnknown(data['deleted_at']!, _deletedAtMeta),
      );
    }
    if (data.containsKey('riser_model')) {
      context.handle(
        _riserModelMeta,
        riserModel.isAcceptableOrUnknown(data['riser_model']!, _riserModelMeta),
      );
    }
    if (data.containsKey('riser_purchase_date')) {
      context.handle(
        _riserPurchaseDateMeta,
        riserPurchaseDate.isAcceptableOrUnknown(
          data['riser_purchase_date']!,
          _riserPurchaseDateMeta,
        ),
      );
    }
    if (data.containsKey('limb_model')) {
      context.handle(
        _limbModelMeta,
        limbModel.isAcceptableOrUnknown(data['limb_model']!, _limbModelMeta),
      );
    }
    if (data.containsKey('limb_purchase_date')) {
      context.handle(
        _limbPurchaseDateMeta,
        limbPurchaseDate.isAcceptableOrUnknown(
          data['limb_purchase_date']!,
          _limbPurchaseDateMeta,
        ),
      );
    }
    if (data.containsKey('poundage')) {
      context.handle(
        _poundageMeta,
        poundage.isAcceptableOrUnknown(data['poundage']!, _poundageMeta),
      );
    }
    if (data.containsKey('tiller_top')) {
      context.handle(
        _tillerTopMeta,
        tillerTop.isAcceptableOrUnknown(data['tiller_top']!, _tillerTopMeta),
      );
    }
    if (data.containsKey('tiller_bottom')) {
      context.handle(
        _tillerBottomMeta,
        tillerBottom.isAcceptableOrUnknown(
          data['tiller_bottom']!,
          _tillerBottomMeta,
        ),
      );
    }
    if (data.containsKey('brace_height')) {
      context.handle(
        _braceHeightMeta,
        braceHeight.isAcceptableOrUnknown(
          data['brace_height']!,
          _braceHeightMeta,
        ),
      );
    }
    if (data.containsKey('nocking_point_height')) {
      context.handle(
        _nockingPointHeightMeta,
        nockingPointHeight.isAcceptableOrUnknown(
          data['nocking_point_height']!,
          _nockingPointHeightMeta,
        ),
      );
    }
    if (data.containsKey('button_position')) {
      context.handle(
        _buttonPositionMeta,
        buttonPosition.isAcceptableOrUnknown(
          data['button_position']!,
          _buttonPositionMeta,
        ),
      );
    }
    if (data.containsKey('button_tension')) {
      context.handle(
        _buttonTensionMeta,
        buttonTension.isAcceptableOrUnknown(
          data['button_tension']!,
          _buttonTensionMeta,
        ),
      );
    }
    if (data.containsKey('clicker_position')) {
      context.handle(
        _clickerPositionMeta,
        clickerPosition.isAcceptableOrUnknown(
          data['clicker_position']!,
          _clickerPositionMeta,
        ),
      );
    }
    if (data.containsKey('eye_to_arrow_distance')) {
      context.handle(
        _eyeToArrowDistanceMeta,
        eyeToArrowDistance.isAcceptableOrUnknown(
          data['eye_to_arrow_distance']!,
          _eyeToArrowDistanceMeta,
        ),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  Bow map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Bow(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      bowType: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}bow_type'],
      )!,
      settings: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}settings'],
      ),
      isDefault: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_default'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      )!,
      deletedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}deleted_at'],
      ),
      riserModel: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}riser_model'],
      ),
      riserPurchaseDate: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}riser_purchase_date'],
      ),
      limbModel: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}limb_model'],
      ),
      limbPurchaseDate: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}limb_purchase_date'],
      ),
      poundage: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}poundage'],
      ),
      tillerTop: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}tiller_top'],
      ),
      tillerBottom: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}tiller_bottom'],
      ),
      braceHeight: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}brace_height'],
      ),
      nockingPointHeight: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}nocking_point_height'],
      ),
      buttonPosition: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}button_position'],
      ),
      buttonTension: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}button_tension'],
      ),
      clickerPosition: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}clicker_position'],
      ),
      eyeToArrowDistance: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}eye_to_arrow_distance'],
      ),
    );
  }

  @override
  $BowsTable createAlias(String alias) {
    return $BowsTable(attachedDatabase, alias);
  }
}

class Bow extends DataClass implements Insertable<Bow> {
  final String id;
  final String name;
  final String bowType;
  final String? settings;
  final bool isDefault;
  final DateTime createdAt;
  final DateTime updatedAt;
  final DateTime? deletedAt;
  final String? riserModel;
  final DateTime? riserPurchaseDate;
  final String? limbModel;
  final DateTime? limbPurchaseDate;
  final double? poundage;
  final double? tillerTop;
  final double? tillerBottom;
  final double? braceHeight;
  final double? nockingPointHeight;
  final double? buttonPosition;
  final String? buttonTension;
  final double? clickerPosition;
  final double? eyeToArrowDistance;
  const Bow({
    required this.id,
    required this.name,
    required this.bowType,
    this.settings,
    required this.isDefault,
    required this.createdAt,
    required this.updatedAt,
    this.deletedAt,
    this.riserModel,
    this.riserPurchaseDate,
    this.limbModel,
    this.limbPurchaseDate,
    this.poundage,
    this.tillerTop,
    this.tillerBottom,
    this.braceHeight,
    this.nockingPointHeight,
    this.buttonPosition,
    this.buttonTension,
    this.clickerPosition,
    this.eyeToArrowDistance,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['name'] = Variable<String>(name);
    map['bow_type'] = Variable<String>(bowType);
    if (!nullToAbsent || settings != null) {
      map['settings'] = Variable<String>(settings);
    }
    map['is_default'] = Variable<bool>(isDefault);
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    if (!nullToAbsent || deletedAt != null) {
      map['deleted_at'] = Variable<DateTime>(deletedAt);
    }
    if (!nullToAbsent || riserModel != null) {
      map['riser_model'] = Variable<String>(riserModel);
    }
    if (!nullToAbsent || riserPurchaseDate != null) {
      map['riser_purchase_date'] = Variable<DateTime>(riserPurchaseDate);
    }
    if (!nullToAbsent || limbModel != null) {
      map['limb_model'] = Variable<String>(limbModel);
    }
    if (!nullToAbsent || limbPurchaseDate != null) {
      map['limb_purchase_date'] = Variable<DateTime>(limbPurchaseDate);
    }
    if (!nullToAbsent || poundage != null) {
      map['poundage'] = Variable<double>(poundage);
    }
    if (!nullToAbsent || tillerTop != null) {
      map['tiller_top'] = Variable<double>(tillerTop);
    }
    if (!nullToAbsent || tillerBottom != null) {
      map['tiller_bottom'] = Variable<double>(tillerBottom);
    }
    if (!nullToAbsent || braceHeight != null) {
      map['brace_height'] = Variable<double>(braceHeight);
    }
    if (!nullToAbsent || nockingPointHeight != null) {
      map['nocking_point_height'] = Variable<double>(nockingPointHeight);
    }
    if (!nullToAbsent || buttonPosition != null) {
      map['button_position'] = Variable<double>(buttonPosition);
    }
    if (!nullToAbsent || buttonTension != null) {
      map['button_tension'] = Variable<String>(buttonTension);
    }
    if (!nullToAbsent || clickerPosition != null) {
      map['clicker_position'] = Variable<double>(clickerPosition);
    }
    if (!nullToAbsent || eyeToArrowDistance != null) {
      map['eye_to_arrow_distance'] = Variable<double>(eyeToArrowDistance);
    }
    return map;
  }

  BowsCompanion toCompanion(bool nullToAbsent) {
    return BowsCompanion(
      id: Value(id),
      name: Value(name),
      bowType: Value(bowType),
      settings: settings == null && nullToAbsent
          ? const Value.absent()
          : Value(settings),
      isDefault: Value(isDefault),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
      deletedAt: deletedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(deletedAt),
      riserModel: riserModel == null && nullToAbsent
          ? const Value.absent()
          : Value(riserModel),
      riserPurchaseDate: riserPurchaseDate == null && nullToAbsent
          ? const Value.absent()
          : Value(riserPurchaseDate),
      limbModel: limbModel == null && nullToAbsent
          ? const Value.absent()
          : Value(limbModel),
      limbPurchaseDate: limbPurchaseDate == null && nullToAbsent
          ? const Value.absent()
          : Value(limbPurchaseDate),
      poundage: poundage == null && nullToAbsent
          ? const Value.absent()
          : Value(poundage),
      tillerTop: tillerTop == null && nullToAbsent
          ? const Value.absent()
          : Value(tillerTop),
      tillerBottom: tillerBottom == null && nullToAbsent
          ? const Value.absent()
          : Value(tillerBottom),
      braceHeight: braceHeight == null && nullToAbsent
          ? const Value.absent()
          : Value(braceHeight),
      nockingPointHeight: nockingPointHeight == null && nullToAbsent
          ? const Value.absent()
          : Value(nockingPointHeight),
      buttonPosition: buttonPosition == null && nullToAbsent
          ? const Value.absent()
          : Value(buttonPosition),
      buttonTension: buttonTension == null && nullToAbsent
          ? const Value.absent()
          : Value(buttonTension),
      clickerPosition: clickerPosition == null && nullToAbsent
          ? const Value.absent()
          : Value(clickerPosition),
      eyeToArrowDistance: eyeToArrowDistance == null && nullToAbsent
          ? const Value.absent()
          : Value(eyeToArrowDistance),
    );
  }

  factory Bow.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Bow(
      id: serializer.fromJson<String>(json['id']),
      name: serializer.fromJson<String>(json['name']),
      bowType: serializer.fromJson<String>(json['bowType']),
      settings: serializer.fromJson<String?>(json['settings']),
      isDefault: serializer.fromJson<bool>(json['isDefault']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
      deletedAt: serializer.fromJson<DateTime?>(json['deletedAt']),
      riserModel: serializer.fromJson<String?>(json['riserModel']),
      riserPurchaseDate: serializer.fromJson<DateTime?>(
        json['riserPurchaseDate'],
      ),
      limbModel: serializer.fromJson<String?>(json['limbModel']),
      limbPurchaseDate: serializer.fromJson<DateTime?>(
        json['limbPurchaseDate'],
      ),
      poundage: serializer.fromJson<double?>(json['poundage']),
      tillerTop: serializer.fromJson<double?>(json['tillerTop']),
      tillerBottom: serializer.fromJson<double?>(json['tillerBottom']),
      braceHeight: serializer.fromJson<double?>(json['braceHeight']),
      nockingPointHeight: serializer.fromJson<double?>(
        json['nockingPointHeight'],
      ),
      buttonPosition: serializer.fromJson<double?>(json['buttonPosition']),
      buttonTension: serializer.fromJson<String?>(json['buttonTension']),
      clickerPosition: serializer.fromJson<double?>(json['clickerPosition']),
      eyeToArrowDistance: serializer.fromJson<double?>(
        json['eyeToArrowDistance'],
      ),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'name': serializer.toJson<String>(name),
      'bowType': serializer.toJson<String>(bowType),
      'settings': serializer.toJson<String?>(settings),
      'isDefault': serializer.toJson<bool>(isDefault),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
      'deletedAt': serializer.toJson<DateTime?>(deletedAt),
      'riserModel': serializer.toJson<String?>(riserModel),
      'riserPurchaseDate': serializer.toJson<DateTime?>(riserPurchaseDate),
      'limbModel': serializer.toJson<String?>(limbModel),
      'limbPurchaseDate': serializer.toJson<DateTime?>(limbPurchaseDate),
      'poundage': serializer.toJson<double?>(poundage),
      'tillerTop': serializer.toJson<double?>(tillerTop),
      'tillerBottom': serializer.toJson<double?>(tillerBottom),
      'braceHeight': serializer.toJson<double?>(braceHeight),
      'nockingPointHeight': serializer.toJson<double?>(nockingPointHeight),
      'buttonPosition': serializer.toJson<double?>(buttonPosition),
      'buttonTension': serializer.toJson<String?>(buttonTension),
      'clickerPosition': serializer.toJson<double?>(clickerPosition),
      'eyeToArrowDistance': serializer.toJson<double?>(eyeToArrowDistance),
    };
  }

  Bow copyWith({
    String? id,
    String? name,
    String? bowType,
    Value<String?> settings = const Value.absent(),
    bool? isDefault,
    DateTime? createdAt,
    DateTime? updatedAt,
    Value<DateTime?> deletedAt = const Value.absent(),
    Value<String?> riserModel = const Value.absent(),
    Value<DateTime?> riserPurchaseDate = const Value.absent(),
    Value<String?> limbModel = const Value.absent(),
    Value<DateTime?> limbPurchaseDate = const Value.absent(),
    Value<double?> poundage = const Value.absent(),
    Value<double?> tillerTop = const Value.absent(),
    Value<double?> tillerBottom = const Value.absent(),
    Value<double?> braceHeight = const Value.absent(),
    Value<double?> nockingPointHeight = const Value.absent(),
    Value<double?> buttonPosition = const Value.absent(),
    Value<String?> buttonTension = const Value.absent(),
    Value<double?> clickerPosition = const Value.absent(),
    Value<double?> eyeToArrowDistance = const Value.absent(),
  }) => Bow(
    id: id ?? this.id,
    name: name ?? this.name,
    bowType: bowType ?? this.bowType,
    settings: settings.present ? settings.value : this.settings,
    isDefault: isDefault ?? this.isDefault,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
    deletedAt: deletedAt.present ? deletedAt.value : this.deletedAt,
    riserModel: riserModel.present ? riserModel.value : this.riserModel,
    riserPurchaseDate: riserPurchaseDate.present
        ? riserPurchaseDate.value
        : this.riserPurchaseDate,
    limbModel: limbModel.present ? limbModel.value : this.limbModel,
    limbPurchaseDate: limbPurchaseDate.present
        ? limbPurchaseDate.value
        : this.limbPurchaseDate,
    poundage: poundage.present ? poundage.value : this.poundage,
    tillerTop: tillerTop.present ? tillerTop.value : this.tillerTop,
    tillerBottom: tillerBottom.present ? tillerBottom.value : this.tillerBottom,
    braceHeight: braceHeight.present ? braceHeight.value : this.braceHeight,
    nockingPointHeight: nockingPointHeight.present
        ? nockingPointHeight.value
        : this.nockingPointHeight,
    buttonPosition: buttonPosition.present
        ? buttonPosition.value
        : this.buttonPosition,
    buttonTension: buttonTension.present
        ? buttonTension.value
        : this.buttonTension,
    clickerPosition: clickerPosition.present
        ? clickerPosition.value
        : this.clickerPosition,
    eyeToArrowDistance: eyeToArrowDistance.present
        ? eyeToArrowDistance.value
        : this.eyeToArrowDistance,
  );
  Bow copyWithCompanion(BowsCompanion data) {
    return Bow(
      id: data.id.present ? data.id.value : this.id,
      name: data.name.present ? data.name.value : this.name,
      bowType: data.bowType.present ? data.bowType.value : this.bowType,
      settings: data.settings.present ? data.settings.value : this.settings,
      isDefault: data.isDefault.present ? data.isDefault.value : this.isDefault,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
      deletedAt: data.deletedAt.present ? data.deletedAt.value : this.deletedAt,
      riserModel: data.riserModel.present
          ? data.riserModel.value
          : this.riserModel,
      riserPurchaseDate: data.riserPurchaseDate.present
          ? data.riserPurchaseDate.value
          : this.riserPurchaseDate,
      limbModel: data.limbModel.present ? data.limbModel.value : this.limbModel,
      limbPurchaseDate: data.limbPurchaseDate.present
          ? data.limbPurchaseDate.value
          : this.limbPurchaseDate,
      poundage: data.poundage.present ? data.poundage.value : this.poundage,
      tillerTop: data.tillerTop.present ? data.tillerTop.value : this.tillerTop,
      tillerBottom: data.tillerBottom.present
          ? data.tillerBottom.value
          : this.tillerBottom,
      braceHeight: data.braceHeight.present
          ? data.braceHeight.value
          : this.braceHeight,
      nockingPointHeight: data.nockingPointHeight.present
          ? data.nockingPointHeight.value
          : this.nockingPointHeight,
      buttonPosition: data.buttonPosition.present
          ? data.buttonPosition.value
          : this.buttonPosition,
      buttonTension: data.buttonTension.present
          ? data.buttonTension.value
          : this.buttonTension,
      clickerPosition: data.clickerPosition.present
          ? data.clickerPosition.value
          : this.clickerPosition,
      eyeToArrowDistance: data.eyeToArrowDistance.present
          ? data.eyeToArrowDistance.value
          : this.eyeToArrowDistance,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Bow(')
          ..write('id: $id, ')
          ..write('name: $name, ')
          ..write('bowType: $bowType, ')
          ..write('settings: $settings, ')
          ..write('isDefault: $isDefault, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('deletedAt: $deletedAt, ')
          ..write('riserModel: $riserModel, ')
          ..write('riserPurchaseDate: $riserPurchaseDate, ')
          ..write('limbModel: $limbModel, ')
          ..write('limbPurchaseDate: $limbPurchaseDate, ')
          ..write('poundage: $poundage, ')
          ..write('tillerTop: $tillerTop, ')
          ..write('tillerBottom: $tillerBottom, ')
          ..write('braceHeight: $braceHeight, ')
          ..write('nockingPointHeight: $nockingPointHeight, ')
          ..write('buttonPosition: $buttonPosition, ')
          ..write('buttonTension: $buttonTension, ')
          ..write('clickerPosition: $clickerPosition, ')
          ..write('eyeToArrowDistance: $eyeToArrowDistance')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hashAll([
    id,
    name,
    bowType,
    settings,
    isDefault,
    createdAt,
    updatedAt,
    deletedAt,
    riserModel,
    riserPurchaseDate,
    limbModel,
    limbPurchaseDate,
    poundage,
    tillerTop,
    tillerBottom,
    braceHeight,
    nockingPointHeight,
    buttonPosition,
    buttonTension,
    clickerPosition,
    eyeToArrowDistance,
  ]);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Bow &&
          other.id == this.id &&
          other.name == this.name &&
          other.bowType == this.bowType &&
          other.settings == this.settings &&
          other.isDefault == this.isDefault &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt &&
          other.deletedAt == this.deletedAt &&
          other.riserModel == this.riserModel &&
          other.riserPurchaseDate == this.riserPurchaseDate &&
          other.limbModel == this.limbModel &&
          other.limbPurchaseDate == this.limbPurchaseDate &&
          other.poundage == this.poundage &&
          other.tillerTop == this.tillerTop &&
          other.tillerBottom == this.tillerBottom &&
          other.braceHeight == this.braceHeight &&
          other.nockingPointHeight == this.nockingPointHeight &&
          other.buttonPosition == this.buttonPosition &&
          other.buttonTension == this.buttonTension &&
          other.clickerPosition == this.clickerPosition &&
          other.eyeToArrowDistance == this.eyeToArrowDistance);
}

class BowsCompanion extends UpdateCompanion<Bow> {
  final Value<String> id;
  final Value<String> name;
  final Value<String> bowType;
  final Value<String?> settings;
  final Value<bool> isDefault;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  final Value<DateTime?> deletedAt;
  final Value<String?> riserModel;
  final Value<DateTime?> riserPurchaseDate;
  final Value<String?> limbModel;
  final Value<DateTime?> limbPurchaseDate;
  final Value<double?> poundage;
  final Value<double?> tillerTop;
  final Value<double?> tillerBottom;
  final Value<double?> braceHeight;
  final Value<double?> nockingPointHeight;
  final Value<double?> buttonPosition;
  final Value<String?> buttonTension;
  final Value<double?> clickerPosition;
  final Value<double?> eyeToArrowDistance;
  final Value<int> rowid;
  const BowsCompanion({
    this.id = const Value.absent(),
    this.name = const Value.absent(),
    this.bowType = const Value.absent(),
    this.settings = const Value.absent(),
    this.isDefault = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.deletedAt = const Value.absent(),
    this.riserModel = const Value.absent(),
    this.riserPurchaseDate = const Value.absent(),
    this.limbModel = const Value.absent(),
    this.limbPurchaseDate = const Value.absent(),
    this.poundage = const Value.absent(),
    this.tillerTop = const Value.absent(),
    this.tillerBottom = const Value.absent(),
    this.braceHeight = const Value.absent(),
    this.nockingPointHeight = const Value.absent(),
    this.buttonPosition = const Value.absent(),
    this.buttonTension = const Value.absent(),
    this.clickerPosition = const Value.absent(),
    this.eyeToArrowDistance = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  BowsCompanion.insert({
    required String id,
    required String name,
    required String bowType,
    this.settings = const Value.absent(),
    this.isDefault = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.deletedAt = const Value.absent(),
    this.riserModel = const Value.absent(),
    this.riserPurchaseDate = const Value.absent(),
    this.limbModel = const Value.absent(),
    this.limbPurchaseDate = const Value.absent(),
    this.poundage = const Value.absent(),
    this.tillerTop = const Value.absent(),
    this.tillerBottom = const Value.absent(),
    this.braceHeight = const Value.absent(),
    this.nockingPointHeight = const Value.absent(),
    this.buttonPosition = const Value.absent(),
    this.buttonTension = const Value.absent(),
    this.clickerPosition = const Value.absent(),
    this.eyeToArrowDistance = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       name = Value(name),
       bowType = Value(bowType);
  static Insertable<Bow> custom({
    Expression<String>? id,
    Expression<String>? name,
    Expression<String>? bowType,
    Expression<String>? settings,
    Expression<bool>? isDefault,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
    Expression<DateTime>? deletedAt,
    Expression<String>? riserModel,
    Expression<DateTime>? riserPurchaseDate,
    Expression<String>? limbModel,
    Expression<DateTime>? limbPurchaseDate,
    Expression<double>? poundage,
    Expression<double>? tillerTop,
    Expression<double>? tillerBottom,
    Expression<double>? braceHeight,
    Expression<double>? nockingPointHeight,
    Expression<double>? buttonPosition,
    Expression<String>? buttonTension,
    Expression<double>? clickerPosition,
    Expression<double>? eyeToArrowDistance,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (name != null) 'name': name,
      if (bowType != null) 'bow_type': bowType,
      if (settings != null) 'settings': settings,
      if (isDefault != null) 'is_default': isDefault,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (deletedAt != null) 'deleted_at': deletedAt,
      if (riserModel != null) 'riser_model': riserModel,
      if (riserPurchaseDate != null) 'riser_purchase_date': riserPurchaseDate,
      if (limbModel != null) 'limb_model': limbModel,
      if (limbPurchaseDate != null) 'limb_purchase_date': limbPurchaseDate,
      if (poundage != null) 'poundage': poundage,
      if (tillerTop != null) 'tiller_top': tillerTop,
      if (tillerBottom != null) 'tiller_bottom': tillerBottom,
      if (braceHeight != null) 'brace_height': braceHeight,
      if (nockingPointHeight != null)
        'nocking_point_height': nockingPointHeight,
      if (buttonPosition != null) 'button_position': buttonPosition,
      if (buttonTension != null) 'button_tension': buttonTension,
      if (clickerPosition != null) 'clicker_position': clickerPosition,
      if (eyeToArrowDistance != null)
        'eye_to_arrow_distance': eyeToArrowDistance,
      if (rowid != null) 'rowid': rowid,
    });
  }

  BowsCompanion copyWith({
    Value<String>? id,
    Value<String>? name,
    Value<String>? bowType,
    Value<String?>? settings,
    Value<bool>? isDefault,
    Value<DateTime>? createdAt,
    Value<DateTime>? updatedAt,
    Value<DateTime?>? deletedAt,
    Value<String?>? riserModel,
    Value<DateTime?>? riserPurchaseDate,
    Value<String?>? limbModel,
    Value<DateTime?>? limbPurchaseDate,
    Value<double?>? poundage,
    Value<double?>? tillerTop,
    Value<double?>? tillerBottom,
    Value<double?>? braceHeight,
    Value<double?>? nockingPointHeight,
    Value<double?>? buttonPosition,
    Value<String?>? buttonTension,
    Value<double?>? clickerPosition,
    Value<double?>? eyeToArrowDistance,
    Value<int>? rowid,
  }) {
    return BowsCompanion(
      id: id ?? this.id,
      name: name ?? this.name,
      bowType: bowType ?? this.bowType,
      settings: settings ?? this.settings,
      isDefault: isDefault ?? this.isDefault,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      deletedAt: deletedAt ?? this.deletedAt,
      riserModel: riserModel ?? this.riserModel,
      riserPurchaseDate: riserPurchaseDate ?? this.riserPurchaseDate,
      limbModel: limbModel ?? this.limbModel,
      limbPurchaseDate: limbPurchaseDate ?? this.limbPurchaseDate,
      poundage: poundage ?? this.poundage,
      tillerTop: tillerTop ?? this.tillerTop,
      tillerBottom: tillerBottom ?? this.tillerBottom,
      braceHeight: braceHeight ?? this.braceHeight,
      nockingPointHeight: nockingPointHeight ?? this.nockingPointHeight,
      buttonPosition: buttonPosition ?? this.buttonPosition,
      buttonTension: buttonTension ?? this.buttonTension,
      clickerPosition: clickerPosition ?? this.clickerPosition,
      eyeToArrowDistance: eyeToArrowDistance ?? this.eyeToArrowDistance,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (bowType.present) {
      map['bow_type'] = Variable<String>(bowType.value);
    }
    if (settings.present) {
      map['settings'] = Variable<String>(settings.value);
    }
    if (isDefault.present) {
      map['is_default'] = Variable<bool>(isDefault.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (deletedAt.present) {
      map['deleted_at'] = Variable<DateTime>(deletedAt.value);
    }
    if (riserModel.present) {
      map['riser_model'] = Variable<String>(riserModel.value);
    }
    if (riserPurchaseDate.present) {
      map['riser_purchase_date'] = Variable<DateTime>(riserPurchaseDate.value);
    }
    if (limbModel.present) {
      map['limb_model'] = Variable<String>(limbModel.value);
    }
    if (limbPurchaseDate.present) {
      map['limb_purchase_date'] = Variable<DateTime>(limbPurchaseDate.value);
    }
    if (poundage.present) {
      map['poundage'] = Variable<double>(poundage.value);
    }
    if (tillerTop.present) {
      map['tiller_top'] = Variable<double>(tillerTop.value);
    }
    if (tillerBottom.present) {
      map['tiller_bottom'] = Variable<double>(tillerBottom.value);
    }
    if (braceHeight.present) {
      map['brace_height'] = Variable<double>(braceHeight.value);
    }
    if (nockingPointHeight.present) {
      map['nocking_point_height'] = Variable<double>(nockingPointHeight.value);
    }
    if (buttonPosition.present) {
      map['button_position'] = Variable<double>(buttonPosition.value);
    }
    if (buttonTension.present) {
      map['button_tension'] = Variable<String>(buttonTension.value);
    }
    if (clickerPosition.present) {
      map['clicker_position'] = Variable<double>(clickerPosition.value);
    }
    if (eyeToArrowDistance.present) {
      map['eye_to_arrow_distance'] = Variable<double>(eyeToArrowDistance.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('BowsCompanion(')
          ..write('id: $id, ')
          ..write('name: $name, ')
          ..write('bowType: $bowType, ')
          ..write('settings: $settings, ')
          ..write('isDefault: $isDefault, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('deletedAt: $deletedAt, ')
          ..write('riserModel: $riserModel, ')
          ..write('riserPurchaseDate: $riserPurchaseDate, ')
          ..write('limbModel: $limbModel, ')
          ..write('limbPurchaseDate: $limbPurchaseDate, ')
          ..write('poundage: $poundage, ')
          ..write('tillerTop: $tillerTop, ')
          ..write('tillerBottom: $tillerBottom, ')
          ..write('braceHeight: $braceHeight, ')
          ..write('nockingPointHeight: $nockingPointHeight, ')
          ..write('buttonPosition: $buttonPosition, ')
          ..write('buttonTension: $buttonTension, ')
          ..write('clickerPosition: $clickerPosition, ')
          ..write('eyeToArrowDistance: $eyeToArrowDistance, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $QuiversTable extends Quivers with TableInfo<$QuiversTable, Quiver> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $QuiversTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _bowIdMeta = const VerificationMeta('bowId');
  @override
  late final GeneratedColumn<String> bowId = GeneratedColumn<String>(
    'bow_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES bows (id)',
    ),
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _shaftCountMeta = const VerificationMeta(
    'shaftCount',
  );
  @override
  late final GeneratedColumn<int> shaftCount = GeneratedColumn<int>(
    'shaft_count',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(12),
  );
  static const VerificationMeta _settingsMeta = const VerificationMeta(
    'settings',
  );
  @override
  late final GeneratedColumn<String> settings = GeneratedColumn<String>(
    'settings',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _isDefaultMeta = const VerificationMeta(
    'isDefault',
  );
  @override
  late final GeneratedColumn<bool> isDefault = GeneratedColumn<bool>(
    'is_default',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_default" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _deletedAtMeta = const VerificationMeta(
    'deletedAt',
  );
  @override
  late final GeneratedColumn<DateTime> deletedAt = GeneratedColumn<DateTime>(
    'deleted_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    bowId,
    name,
    shaftCount,
    settings,
    isDefault,
    createdAt,
    updatedAt,
    deletedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'quivers';
  @override
  VerificationContext validateIntegrity(
    Insertable<Quiver> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('bow_id')) {
      context.handle(
        _bowIdMeta,
        bowId.isAcceptableOrUnknown(data['bow_id']!, _bowIdMeta),
      );
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('shaft_count')) {
      context.handle(
        _shaftCountMeta,
        shaftCount.isAcceptableOrUnknown(data['shaft_count']!, _shaftCountMeta),
      );
    }
    if (data.containsKey('settings')) {
      context.handle(
        _settingsMeta,
        settings.isAcceptableOrUnknown(data['settings']!, _settingsMeta),
      );
    }
    if (data.containsKey('is_default')) {
      context.handle(
        _isDefaultMeta,
        isDefault.isAcceptableOrUnknown(data['is_default']!, _isDefaultMeta),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    }
    if (data.containsKey('deleted_at')) {
      context.handle(
        _deletedAtMeta,
        deletedAt.isAcceptableOrUnknown(data['deleted_at']!, _deletedAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  Quiver map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Quiver(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      bowId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}bow_id'],
      ),
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      shaftCount: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}shaft_count'],
      )!,
      settings: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}settings'],
      ),
      isDefault: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_default'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      )!,
      deletedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}deleted_at'],
      ),
    );
  }

  @override
  $QuiversTable createAlias(String alias) {
    return $QuiversTable(attachedDatabase, alias);
  }
}

class Quiver extends DataClass implements Insertable<Quiver> {
  final String id;
  final String? bowId;
  final String name;
  final int shaftCount;
  final String? settings;
  final bool isDefault;
  final DateTime createdAt;
  final DateTime updatedAt;
  final DateTime? deletedAt;
  const Quiver({
    required this.id,
    this.bowId,
    required this.name,
    required this.shaftCount,
    this.settings,
    required this.isDefault,
    required this.createdAt,
    required this.updatedAt,
    this.deletedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    if (!nullToAbsent || bowId != null) {
      map['bow_id'] = Variable<String>(bowId);
    }
    map['name'] = Variable<String>(name);
    map['shaft_count'] = Variable<int>(shaftCount);
    if (!nullToAbsent || settings != null) {
      map['settings'] = Variable<String>(settings);
    }
    map['is_default'] = Variable<bool>(isDefault);
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    if (!nullToAbsent || deletedAt != null) {
      map['deleted_at'] = Variable<DateTime>(deletedAt);
    }
    return map;
  }

  QuiversCompanion toCompanion(bool nullToAbsent) {
    return QuiversCompanion(
      id: Value(id),
      bowId: bowId == null && nullToAbsent
          ? const Value.absent()
          : Value(bowId),
      name: Value(name),
      shaftCount: Value(shaftCount),
      settings: settings == null && nullToAbsent
          ? const Value.absent()
          : Value(settings),
      isDefault: Value(isDefault),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
      deletedAt: deletedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(deletedAt),
    );
  }

  factory Quiver.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Quiver(
      id: serializer.fromJson<String>(json['id']),
      bowId: serializer.fromJson<String?>(json['bowId']),
      name: serializer.fromJson<String>(json['name']),
      shaftCount: serializer.fromJson<int>(json['shaftCount']),
      settings: serializer.fromJson<String?>(json['settings']),
      isDefault: serializer.fromJson<bool>(json['isDefault']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
      deletedAt: serializer.fromJson<DateTime?>(json['deletedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'bowId': serializer.toJson<String?>(bowId),
      'name': serializer.toJson<String>(name),
      'shaftCount': serializer.toJson<int>(shaftCount),
      'settings': serializer.toJson<String?>(settings),
      'isDefault': serializer.toJson<bool>(isDefault),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
      'deletedAt': serializer.toJson<DateTime?>(deletedAt),
    };
  }

  Quiver copyWith({
    String? id,
    Value<String?> bowId = const Value.absent(),
    String? name,
    int? shaftCount,
    Value<String?> settings = const Value.absent(),
    bool? isDefault,
    DateTime? createdAt,
    DateTime? updatedAt,
    Value<DateTime?> deletedAt = const Value.absent(),
  }) => Quiver(
    id: id ?? this.id,
    bowId: bowId.present ? bowId.value : this.bowId,
    name: name ?? this.name,
    shaftCount: shaftCount ?? this.shaftCount,
    settings: settings.present ? settings.value : this.settings,
    isDefault: isDefault ?? this.isDefault,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
    deletedAt: deletedAt.present ? deletedAt.value : this.deletedAt,
  );
  Quiver copyWithCompanion(QuiversCompanion data) {
    return Quiver(
      id: data.id.present ? data.id.value : this.id,
      bowId: data.bowId.present ? data.bowId.value : this.bowId,
      name: data.name.present ? data.name.value : this.name,
      shaftCount: data.shaftCount.present
          ? data.shaftCount.value
          : this.shaftCount,
      settings: data.settings.present ? data.settings.value : this.settings,
      isDefault: data.isDefault.present ? data.isDefault.value : this.isDefault,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
      deletedAt: data.deletedAt.present ? data.deletedAt.value : this.deletedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Quiver(')
          ..write('id: $id, ')
          ..write('bowId: $bowId, ')
          ..write('name: $name, ')
          ..write('shaftCount: $shaftCount, ')
          ..write('settings: $settings, ')
          ..write('isDefault: $isDefault, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('deletedAt: $deletedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    bowId,
    name,
    shaftCount,
    settings,
    isDefault,
    createdAt,
    updatedAt,
    deletedAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Quiver &&
          other.id == this.id &&
          other.bowId == this.bowId &&
          other.name == this.name &&
          other.shaftCount == this.shaftCount &&
          other.settings == this.settings &&
          other.isDefault == this.isDefault &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt &&
          other.deletedAt == this.deletedAt);
}

class QuiversCompanion extends UpdateCompanion<Quiver> {
  final Value<String> id;
  final Value<String?> bowId;
  final Value<String> name;
  final Value<int> shaftCount;
  final Value<String?> settings;
  final Value<bool> isDefault;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  final Value<DateTime?> deletedAt;
  final Value<int> rowid;
  const QuiversCompanion({
    this.id = const Value.absent(),
    this.bowId = const Value.absent(),
    this.name = const Value.absent(),
    this.shaftCount = const Value.absent(),
    this.settings = const Value.absent(),
    this.isDefault = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.deletedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  QuiversCompanion.insert({
    required String id,
    this.bowId = const Value.absent(),
    required String name,
    this.shaftCount = const Value.absent(),
    this.settings = const Value.absent(),
    this.isDefault = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.deletedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       name = Value(name);
  static Insertable<Quiver> custom({
    Expression<String>? id,
    Expression<String>? bowId,
    Expression<String>? name,
    Expression<int>? shaftCount,
    Expression<String>? settings,
    Expression<bool>? isDefault,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
    Expression<DateTime>? deletedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (bowId != null) 'bow_id': bowId,
      if (name != null) 'name': name,
      if (shaftCount != null) 'shaft_count': shaftCount,
      if (settings != null) 'settings': settings,
      if (isDefault != null) 'is_default': isDefault,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (deletedAt != null) 'deleted_at': deletedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  QuiversCompanion copyWith({
    Value<String>? id,
    Value<String?>? bowId,
    Value<String>? name,
    Value<int>? shaftCount,
    Value<String?>? settings,
    Value<bool>? isDefault,
    Value<DateTime>? createdAt,
    Value<DateTime>? updatedAt,
    Value<DateTime?>? deletedAt,
    Value<int>? rowid,
  }) {
    return QuiversCompanion(
      id: id ?? this.id,
      bowId: bowId ?? this.bowId,
      name: name ?? this.name,
      shaftCount: shaftCount ?? this.shaftCount,
      settings: settings ?? this.settings,
      isDefault: isDefault ?? this.isDefault,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      deletedAt: deletedAt ?? this.deletedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (bowId.present) {
      map['bow_id'] = Variable<String>(bowId.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (shaftCount.present) {
      map['shaft_count'] = Variable<int>(shaftCount.value);
    }
    if (settings.present) {
      map['settings'] = Variable<String>(settings.value);
    }
    if (isDefault.present) {
      map['is_default'] = Variable<bool>(isDefault.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (deletedAt.present) {
      map['deleted_at'] = Variable<DateTime>(deletedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('QuiversCompanion(')
          ..write('id: $id, ')
          ..write('bowId: $bowId, ')
          ..write('name: $name, ')
          ..write('shaftCount: $shaftCount, ')
          ..write('settings: $settings, ')
          ..write('isDefault: $isDefault, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('deletedAt: $deletedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $SessionsTable extends Sessions with TableInfo<$SessionsTable, Session> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $SessionsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _roundTypeIdMeta = const VerificationMeta(
    'roundTypeId',
  );
  @override
  late final GeneratedColumn<String> roundTypeId = GeneratedColumn<String>(
    'round_type_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES round_types (id)',
    ),
  );
  static const VerificationMeta _sessionTypeMeta = const VerificationMeta(
    'sessionType',
  );
  @override
  late final GeneratedColumn<String> sessionType = GeneratedColumn<String>(
    'session_type',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('practice'),
  );
  static const VerificationMeta _locationMeta = const VerificationMeta(
    'location',
  );
  @override
  late final GeneratedColumn<String> location = GeneratedColumn<String>(
    'location',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _notesMeta = const VerificationMeta('notes');
  @override
  late final GeneratedColumn<String> notes = GeneratedColumn<String>(
    'notes',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _startedAtMeta = const VerificationMeta(
    'startedAt',
  );
  @override
  late final GeneratedColumn<DateTime> startedAt = GeneratedColumn<DateTime>(
    'started_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _completedAtMeta = const VerificationMeta(
    'completedAt',
  );
  @override
  late final GeneratedColumn<DateTime> completedAt = GeneratedColumn<DateTime>(
    'completed_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _totalScoreMeta = const VerificationMeta(
    'totalScore',
  );
  @override
  late final GeneratedColumn<int> totalScore = GeneratedColumn<int>(
    'total_score',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _totalXsMeta = const VerificationMeta(
    'totalXs',
  );
  @override
  late final GeneratedColumn<int> totalXs = GeneratedColumn<int>(
    'total_xs',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _bowIdMeta = const VerificationMeta('bowId');
  @override
  late final GeneratedColumn<String> bowId = GeneratedColumn<String>(
    'bow_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES bows (id)',
    ),
  );
  static const VerificationMeta _quiverIdMeta = const VerificationMeta(
    'quiverId',
  );
  @override
  late final GeneratedColumn<String> quiverId = GeneratedColumn<String>(
    'quiver_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES quivers (id)',
    ),
  );
  static const VerificationMeta _shaftTaggingEnabledMeta =
      const VerificationMeta('shaftTaggingEnabled');
  @override
  late final GeneratedColumn<bool> shaftTaggingEnabled = GeneratedColumn<bool>(
    'shaft_tagging_enabled',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("shaft_tagging_enabled" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _deletedAtMeta = const VerificationMeta(
    'deletedAt',
  );
  @override
  late final GeneratedColumn<DateTime> deletedAt = GeneratedColumn<DateTime>(
    'deleted_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    roundTypeId,
    sessionType,
    location,
    notes,
    startedAt,
    completedAt,
    totalScore,
    totalXs,
    bowId,
    quiverId,
    shaftTaggingEnabled,
    deletedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'sessions';
  @override
  VerificationContext validateIntegrity(
    Insertable<Session> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('round_type_id')) {
      context.handle(
        _roundTypeIdMeta,
        roundTypeId.isAcceptableOrUnknown(
          data['round_type_id']!,
          _roundTypeIdMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_roundTypeIdMeta);
    }
    if (data.containsKey('session_type')) {
      context.handle(
        _sessionTypeMeta,
        sessionType.isAcceptableOrUnknown(
          data['session_type']!,
          _sessionTypeMeta,
        ),
      );
    }
    if (data.containsKey('location')) {
      context.handle(
        _locationMeta,
        location.isAcceptableOrUnknown(data['location']!, _locationMeta),
      );
    }
    if (data.containsKey('notes')) {
      context.handle(
        _notesMeta,
        notes.isAcceptableOrUnknown(data['notes']!, _notesMeta),
      );
    }
    if (data.containsKey('started_at')) {
      context.handle(
        _startedAtMeta,
        startedAt.isAcceptableOrUnknown(data['started_at']!, _startedAtMeta),
      );
    }
    if (data.containsKey('completed_at')) {
      context.handle(
        _completedAtMeta,
        completedAt.isAcceptableOrUnknown(
          data['completed_at']!,
          _completedAtMeta,
        ),
      );
    }
    if (data.containsKey('total_score')) {
      context.handle(
        _totalScoreMeta,
        totalScore.isAcceptableOrUnknown(data['total_score']!, _totalScoreMeta),
      );
    }
    if (data.containsKey('total_xs')) {
      context.handle(
        _totalXsMeta,
        totalXs.isAcceptableOrUnknown(data['total_xs']!, _totalXsMeta),
      );
    }
    if (data.containsKey('bow_id')) {
      context.handle(
        _bowIdMeta,
        bowId.isAcceptableOrUnknown(data['bow_id']!, _bowIdMeta),
      );
    }
    if (data.containsKey('quiver_id')) {
      context.handle(
        _quiverIdMeta,
        quiverId.isAcceptableOrUnknown(data['quiver_id']!, _quiverIdMeta),
      );
    }
    if (data.containsKey('shaft_tagging_enabled')) {
      context.handle(
        _shaftTaggingEnabledMeta,
        shaftTaggingEnabled.isAcceptableOrUnknown(
          data['shaft_tagging_enabled']!,
          _shaftTaggingEnabledMeta,
        ),
      );
    }
    if (data.containsKey('deleted_at')) {
      context.handle(
        _deletedAtMeta,
        deletedAt.isAcceptableOrUnknown(data['deleted_at']!, _deletedAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  Session map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Session(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      roundTypeId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}round_type_id'],
      )!,
      sessionType: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}session_type'],
      )!,
      location: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}location'],
      ),
      notes: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}notes'],
      ),
      startedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}started_at'],
      )!,
      completedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}completed_at'],
      ),
      totalScore: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}total_score'],
      )!,
      totalXs: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}total_xs'],
      )!,
      bowId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}bow_id'],
      ),
      quiverId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}quiver_id'],
      ),
      shaftTaggingEnabled: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}shaft_tagging_enabled'],
      )!,
      deletedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}deleted_at'],
      ),
    );
  }

  @override
  $SessionsTable createAlias(String alias) {
    return $SessionsTable(attachedDatabase, alias);
  }
}

class Session extends DataClass implements Insertable<Session> {
  final String id;
  final String roundTypeId;
  final String sessionType;
  final String? location;
  final String? notes;
  final DateTime startedAt;
  final DateTime? completedAt;
  final int totalScore;
  final int totalXs;
  final String? bowId;
  final String? quiverId;
  final bool shaftTaggingEnabled;
  final DateTime? deletedAt;
  const Session({
    required this.id,
    required this.roundTypeId,
    required this.sessionType,
    this.location,
    this.notes,
    required this.startedAt,
    this.completedAt,
    required this.totalScore,
    required this.totalXs,
    this.bowId,
    this.quiverId,
    required this.shaftTaggingEnabled,
    this.deletedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['round_type_id'] = Variable<String>(roundTypeId);
    map['session_type'] = Variable<String>(sessionType);
    if (!nullToAbsent || location != null) {
      map['location'] = Variable<String>(location);
    }
    if (!nullToAbsent || notes != null) {
      map['notes'] = Variable<String>(notes);
    }
    map['started_at'] = Variable<DateTime>(startedAt);
    if (!nullToAbsent || completedAt != null) {
      map['completed_at'] = Variable<DateTime>(completedAt);
    }
    map['total_score'] = Variable<int>(totalScore);
    map['total_xs'] = Variable<int>(totalXs);
    if (!nullToAbsent || bowId != null) {
      map['bow_id'] = Variable<String>(bowId);
    }
    if (!nullToAbsent || quiverId != null) {
      map['quiver_id'] = Variable<String>(quiverId);
    }
    map['shaft_tagging_enabled'] = Variable<bool>(shaftTaggingEnabled);
    if (!nullToAbsent || deletedAt != null) {
      map['deleted_at'] = Variable<DateTime>(deletedAt);
    }
    return map;
  }

  SessionsCompanion toCompanion(bool nullToAbsent) {
    return SessionsCompanion(
      id: Value(id),
      roundTypeId: Value(roundTypeId),
      sessionType: Value(sessionType),
      location: location == null && nullToAbsent
          ? const Value.absent()
          : Value(location),
      notes: notes == null && nullToAbsent
          ? const Value.absent()
          : Value(notes),
      startedAt: Value(startedAt),
      completedAt: completedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(completedAt),
      totalScore: Value(totalScore),
      totalXs: Value(totalXs),
      bowId: bowId == null && nullToAbsent
          ? const Value.absent()
          : Value(bowId),
      quiverId: quiverId == null && nullToAbsent
          ? const Value.absent()
          : Value(quiverId),
      shaftTaggingEnabled: Value(shaftTaggingEnabled),
      deletedAt: deletedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(deletedAt),
    );
  }

  factory Session.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Session(
      id: serializer.fromJson<String>(json['id']),
      roundTypeId: serializer.fromJson<String>(json['roundTypeId']),
      sessionType: serializer.fromJson<String>(json['sessionType']),
      location: serializer.fromJson<String?>(json['location']),
      notes: serializer.fromJson<String?>(json['notes']),
      startedAt: serializer.fromJson<DateTime>(json['startedAt']),
      completedAt: serializer.fromJson<DateTime?>(json['completedAt']),
      totalScore: serializer.fromJson<int>(json['totalScore']),
      totalXs: serializer.fromJson<int>(json['totalXs']),
      bowId: serializer.fromJson<String?>(json['bowId']),
      quiverId: serializer.fromJson<String?>(json['quiverId']),
      shaftTaggingEnabled: serializer.fromJson<bool>(
        json['shaftTaggingEnabled'],
      ),
      deletedAt: serializer.fromJson<DateTime?>(json['deletedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'roundTypeId': serializer.toJson<String>(roundTypeId),
      'sessionType': serializer.toJson<String>(sessionType),
      'location': serializer.toJson<String?>(location),
      'notes': serializer.toJson<String?>(notes),
      'startedAt': serializer.toJson<DateTime>(startedAt),
      'completedAt': serializer.toJson<DateTime?>(completedAt),
      'totalScore': serializer.toJson<int>(totalScore),
      'totalXs': serializer.toJson<int>(totalXs),
      'bowId': serializer.toJson<String?>(bowId),
      'quiverId': serializer.toJson<String?>(quiverId),
      'shaftTaggingEnabled': serializer.toJson<bool>(shaftTaggingEnabled),
      'deletedAt': serializer.toJson<DateTime?>(deletedAt),
    };
  }

  Session copyWith({
    String? id,
    String? roundTypeId,
    String? sessionType,
    Value<String?> location = const Value.absent(),
    Value<String?> notes = const Value.absent(),
    DateTime? startedAt,
    Value<DateTime?> completedAt = const Value.absent(),
    int? totalScore,
    int? totalXs,
    Value<String?> bowId = const Value.absent(),
    Value<String?> quiverId = const Value.absent(),
    bool? shaftTaggingEnabled,
    Value<DateTime?> deletedAt = const Value.absent(),
  }) => Session(
    id: id ?? this.id,
    roundTypeId: roundTypeId ?? this.roundTypeId,
    sessionType: sessionType ?? this.sessionType,
    location: location.present ? location.value : this.location,
    notes: notes.present ? notes.value : this.notes,
    startedAt: startedAt ?? this.startedAt,
    completedAt: completedAt.present ? completedAt.value : this.completedAt,
    totalScore: totalScore ?? this.totalScore,
    totalXs: totalXs ?? this.totalXs,
    bowId: bowId.present ? bowId.value : this.bowId,
    quiverId: quiverId.present ? quiverId.value : this.quiverId,
    shaftTaggingEnabled: shaftTaggingEnabled ?? this.shaftTaggingEnabled,
    deletedAt: deletedAt.present ? deletedAt.value : this.deletedAt,
  );
  Session copyWithCompanion(SessionsCompanion data) {
    return Session(
      id: data.id.present ? data.id.value : this.id,
      roundTypeId: data.roundTypeId.present
          ? data.roundTypeId.value
          : this.roundTypeId,
      sessionType: data.sessionType.present
          ? data.sessionType.value
          : this.sessionType,
      location: data.location.present ? data.location.value : this.location,
      notes: data.notes.present ? data.notes.value : this.notes,
      startedAt: data.startedAt.present ? data.startedAt.value : this.startedAt,
      completedAt: data.completedAt.present
          ? data.completedAt.value
          : this.completedAt,
      totalScore: data.totalScore.present
          ? data.totalScore.value
          : this.totalScore,
      totalXs: data.totalXs.present ? data.totalXs.value : this.totalXs,
      bowId: data.bowId.present ? data.bowId.value : this.bowId,
      quiverId: data.quiverId.present ? data.quiverId.value : this.quiverId,
      shaftTaggingEnabled: data.shaftTaggingEnabled.present
          ? data.shaftTaggingEnabled.value
          : this.shaftTaggingEnabled,
      deletedAt: data.deletedAt.present ? data.deletedAt.value : this.deletedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Session(')
          ..write('id: $id, ')
          ..write('roundTypeId: $roundTypeId, ')
          ..write('sessionType: $sessionType, ')
          ..write('location: $location, ')
          ..write('notes: $notes, ')
          ..write('startedAt: $startedAt, ')
          ..write('completedAt: $completedAt, ')
          ..write('totalScore: $totalScore, ')
          ..write('totalXs: $totalXs, ')
          ..write('bowId: $bowId, ')
          ..write('quiverId: $quiverId, ')
          ..write('shaftTaggingEnabled: $shaftTaggingEnabled, ')
          ..write('deletedAt: $deletedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    roundTypeId,
    sessionType,
    location,
    notes,
    startedAt,
    completedAt,
    totalScore,
    totalXs,
    bowId,
    quiverId,
    shaftTaggingEnabled,
    deletedAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Session &&
          other.id == this.id &&
          other.roundTypeId == this.roundTypeId &&
          other.sessionType == this.sessionType &&
          other.location == this.location &&
          other.notes == this.notes &&
          other.startedAt == this.startedAt &&
          other.completedAt == this.completedAt &&
          other.totalScore == this.totalScore &&
          other.totalXs == this.totalXs &&
          other.bowId == this.bowId &&
          other.quiverId == this.quiverId &&
          other.shaftTaggingEnabled == this.shaftTaggingEnabled &&
          other.deletedAt == this.deletedAt);
}

class SessionsCompanion extends UpdateCompanion<Session> {
  final Value<String> id;
  final Value<String> roundTypeId;
  final Value<String> sessionType;
  final Value<String?> location;
  final Value<String?> notes;
  final Value<DateTime> startedAt;
  final Value<DateTime?> completedAt;
  final Value<int> totalScore;
  final Value<int> totalXs;
  final Value<String?> bowId;
  final Value<String?> quiverId;
  final Value<bool> shaftTaggingEnabled;
  final Value<DateTime?> deletedAt;
  final Value<int> rowid;
  const SessionsCompanion({
    this.id = const Value.absent(),
    this.roundTypeId = const Value.absent(),
    this.sessionType = const Value.absent(),
    this.location = const Value.absent(),
    this.notes = const Value.absent(),
    this.startedAt = const Value.absent(),
    this.completedAt = const Value.absent(),
    this.totalScore = const Value.absent(),
    this.totalXs = const Value.absent(),
    this.bowId = const Value.absent(),
    this.quiverId = const Value.absent(),
    this.shaftTaggingEnabled = const Value.absent(),
    this.deletedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  SessionsCompanion.insert({
    required String id,
    required String roundTypeId,
    this.sessionType = const Value.absent(),
    this.location = const Value.absent(),
    this.notes = const Value.absent(),
    this.startedAt = const Value.absent(),
    this.completedAt = const Value.absent(),
    this.totalScore = const Value.absent(),
    this.totalXs = const Value.absent(),
    this.bowId = const Value.absent(),
    this.quiverId = const Value.absent(),
    this.shaftTaggingEnabled = const Value.absent(),
    this.deletedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       roundTypeId = Value(roundTypeId);
  static Insertable<Session> custom({
    Expression<String>? id,
    Expression<String>? roundTypeId,
    Expression<String>? sessionType,
    Expression<String>? location,
    Expression<String>? notes,
    Expression<DateTime>? startedAt,
    Expression<DateTime>? completedAt,
    Expression<int>? totalScore,
    Expression<int>? totalXs,
    Expression<String>? bowId,
    Expression<String>? quiverId,
    Expression<bool>? shaftTaggingEnabled,
    Expression<DateTime>? deletedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (roundTypeId != null) 'round_type_id': roundTypeId,
      if (sessionType != null) 'session_type': sessionType,
      if (location != null) 'location': location,
      if (notes != null) 'notes': notes,
      if (startedAt != null) 'started_at': startedAt,
      if (completedAt != null) 'completed_at': completedAt,
      if (totalScore != null) 'total_score': totalScore,
      if (totalXs != null) 'total_xs': totalXs,
      if (bowId != null) 'bow_id': bowId,
      if (quiverId != null) 'quiver_id': quiverId,
      if (shaftTaggingEnabled != null)
        'shaft_tagging_enabled': shaftTaggingEnabled,
      if (deletedAt != null) 'deleted_at': deletedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  SessionsCompanion copyWith({
    Value<String>? id,
    Value<String>? roundTypeId,
    Value<String>? sessionType,
    Value<String?>? location,
    Value<String?>? notes,
    Value<DateTime>? startedAt,
    Value<DateTime?>? completedAt,
    Value<int>? totalScore,
    Value<int>? totalXs,
    Value<String?>? bowId,
    Value<String?>? quiverId,
    Value<bool>? shaftTaggingEnabled,
    Value<DateTime?>? deletedAt,
    Value<int>? rowid,
  }) {
    return SessionsCompanion(
      id: id ?? this.id,
      roundTypeId: roundTypeId ?? this.roundTypeId,
      sessionType: sessionType ?? this.sessionType,
      location: location ?? this.location,
      notes: notes ?? this.notes,
      startedAt: startedAt ?? this.startedAt,
      completedAt: completedAt ?? this.completedAt,
      totalScore: totalScore ?? this.totalScore,
      totalXs: totalXs ?? this.totalXs,
      bowId: bowId ?? this.bowId,
      quiverId: quiverId ?? this.quiverId,
      shaftTaggingEnabled: shaftTaggingEnabled ?? this.shaftTaggingEnabled,
      deletedAt: deletedAt ?? this.deletedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (roundTypeId.present) {
      map['round_type_id'] = Variable<String>(roundTypeId.value);
    }
    if (sessionType.present) {
      map['session_type'] = Variable<String>(sessionType.value);
    }
    if (location.present) {
      map['location'] = Variable<String>(location.value);
    }
    if (notes.present) {
      map['notes'] = Variable<String>(notes.value);
    }
    if (startedAt.present) {
      map['started_at'] = Variable<DateTime>(startedAt.value);
    }
    if (completedAt.present) {
      map['completed_at'] = Variable<DateTime>(completedAt.value);
    }
    if (totalScore.present) {
      map['total_score'] = Variable<int>(totalScore.value);
    }
    if (totalXs.present) {
      map['total_xs'] = Variable<int>(totalXs.value);
    }
    if (bowId.present) {
      map['bow_id'] = Variable<String>(bowId.value);
    }
    if (quiverId.present) {
      map['quiver_id'] = Variable<String>(quiverId.value);
    }
    if (shaftTaggingEnabled.present) {
      map['shaft_tagging_enabled'] = Variable<bool>(shaftTaggingEnabled.value);
    }
    if (deletedAt.present) {
      map['deleted_at'] = Variable<DateTime>(deletedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('SessionsCompanion(')
          ..write('id: $id, ')
          ..write('roundTypeId: $roundTypeId, ')
          ..write('sessionType: $sessionType, ')
          ..write('location: $location, ')
          ..write('notes: $notes, ')
          ..write('startedAt: $startedAt, ')
          ..write('completedAt: $completedAt, ')
          ..write('totalScore: $totalScore, ')
          ..write('totalXs: $totalXs, ')
          ..write('bowId: $bowId, ')
          ..write('quiverId: $quiverId, ')
          ..write('shaftTaggingEnabled: $shaftTaggingEnabled, ')
          ..write('deletedAt: $deletedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $EndsTable extends Ends with TableInfo<$EndsTable, End> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $EndsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _sessionIdMeta = const VerificationMeta(
    'sessionId',
  );
  @override
  late final GeneratedColumn<String> sessionId = GeneratedColumn<String>(
    'session_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES sessions (id)',
    ),
  );
  static const VerificationMeta _endNumberMeta = const VerificationMeta(
    'endNumber',
  );
  @override
  late final GeneratedColumn<int> endNumber = GeneratedColumn<int>(
    'end_number',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _endScoreMeta = const VerificationMeta(
    'endScore',
  );
  @override
  late final GeneratedColumn<int> endScore = GeneratedColumn<int>(
    'end_score',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _endXsMeta = const VerificationMeta('endXs');
  @override
  late final GeneratedColumn<int> endXs = GeneratedColumn<int>(
    'end_xs',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _statusMeta = const VerificationMeta('status');
  @override
  late final GeneratedColumn<String> status = GeneratedColumn<String>(
    'status',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('active'),
  );
  static const VerificationMeta _committedAtMeta = const VerificationMeta(
    'committedAt',
  );
  @override
  late final GeneratedColumn<DateTime> committedAt = GeneratedColumn<DateTime>(
    'committed_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    sessionId,
    endNumber,
    endScore,
    endXs,
    status,
    committedAt,
    createdAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'ends';
  @override
  VerificationContext validateIntegrity(
    Insertable<End> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('session_id')) {
      context.handle(
        _sessionIdMeta,
        sessionId.isAcceptableOrUnknown(data['session_id']!, _sessionIdMeta),
      );
    } else if (isInserting) {
      context.missing(_sessionIdMeta);
    }
    if (data.containsKey('end_number')) {
      context.handle(
        _endNumberMeta,
        endNumber.isAcceptableOrUnknown(data['end_number']!, _endNumberMeta),
      );
    } else if (isInserting) {
      context.missing(_endNumberMeta);
    }
    if (data.containsKey('end_score')) {
      context.handle(
        _endScoreMeta,
        endScore.isAcceptableOrUnknown(data['end_score']!, _endScoreMeta),
      );
    }
    if (data.containsKey('end_xs')) {
      context.handle(
        _endXsMeta,
        endXs.isAcceptableOrUnknown(data['end_xs']!, _endXsMeta),
      );
    }
    if (data.containsKey('status')) {
      context.handle(
        _statusMeta,
        status.isAcceptableOrUnknown(data['status']!, _statusMeta),
      );
    }
    if (data.containsKey('committed_at')) {
      context.handle(
        _committedAtMeta,
        committedAt.isAcceptableOrUnknown(
          data['committed_at']!,
          _committedAtMeta,
        ),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  End map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return End(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      sessionId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}session_id'],
      )!,
      endNumber: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}end_number'],
      )!,
      endScore: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}end_score'],
      )!,
      endXs: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}end_xs'],
      )!,
      status: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}status'],
      )!,
      committedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}committed_at'],
      ),
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
    );
  }

  @override
  $EndsTable createAlias(String alias) {
    return $EndsTable(attachedDatabase, alias);
  }
}

class End extends DataClass implements Insertable<End> {
  final String id;
  final String sessionId;
  final int endNumber;
  final int endScore;
  final int endXs;
  final String status;
  final DateTime? committedAt;
  final DateTime createdAt;
  const End({
    required this.id,
    required this.sessionId,
    required this.endNumber,
    required this.endScore,
    required this.endXs,
    required this.status,
    this.committedAt,
    required this.createdAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['session_id'] = Variable<String>(sessionId);
    map['end_number'] = Variable<int>(endNumber);
    map['end_score'] = Variable<int>(endScore);
    map['end_xs'] = Variable<int>(endXs);
    map['status'] = Variable<String>(status);
    if (!nullToAbsent || committedAt != null) {
      map['committed_at'] = Variable<DateTime>(committedAt);
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    return map;
  }

  EndsCompanion toCompanion(bool nullToAbsent) {
    return EndsCompanion(
      id: Value(id),
      sessionId: Value(sessionId),
      endNumber: Value(endNumber),
      endScore: Value(endScore),
      endXs: Value(endXs),
      status: Value(status),
      committedAt: committedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(committedAt),
      createdAt: Value(createdAt),
    );
  }

  factory End.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return End(
      id: serializer.fromJson<String>(json['id']),
      sessionId: serializer.fromJson<String>(json['sessionId']),
      endNumber: serializer.fromJson<int>(json['endNumber']),
      endScore: serializer.fromJson<int>(json['endScore']),
      endXs: serializer.fromJson<int>(json['endXs']),
      status: serializer.fromJson<String>(json['status']),
      committedAt: serializer.fromJson<DateTime?>(json['committedAt']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'sessionId': serializer.toJson<String>(sessionId),
      'endNumber': serializer.toJson<int>(endNumber),
      'endScore': serializer.toJson<int>(endScore),
      'endXs': serializer.toJson<int>(endXs),
      'status': serializer.toJson<String>(status),
      'committedAt': serializer.toJson<DateTime?>(committedAt),
      'createdAt': serializer.toJson<DateTime>(createdAt),
    };
  }

  End copyWith({
    String? id,
    String? sessionId,
    int? endNumber,
    int? endScore,
    int? endXs,
    String? status,
    Value<DateTime?> committedAt = const Value.absent(),
    DateTime? createdAt,
  }) => End(
    id: id ?? this.id,
    sessionId: sessionId ?? this.sessionId,
    endNumber: endNumber ?? this.endNumber,
    endScore: endScore ?? this.endScore,
    endXs: endXs ?? this.endXs,
    status: status ?? this.status,
    committedAt: committedAt.present ? committedAt.value : this.committedAt,
    createdAt: createdAt ?? this.createdAt,
  );
  End copyWithCompanion(EndsCompanion data) {
    return End(
      id: data.id.present ? data.id.value : this.id,
      sessionId: data.sessionId.present ? data.sessionId.value : this.sessionId,
      endNumber: data.endNumber.present ? data.endNumber.value : this.endNumber,
      endScore: data.endScore.present ? data.endScore.value : this.endScore,
      endXs: data.endXs.present ? data.endXs.value : this.endXs,
      status: data.status.present ? data.status.value : this.status,
      committedAt: data.committedAt.present
          ? data.committedAt.value
          : this.committedAt,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('End(')
          ..write('id: $id, ')
          ..write('sessionId: $sessionId, ')
          ..write('endNumber: $endNumber, ')
          ..write('endScore: $endScore, ')
          ..write('endXs: $endXs, ')
          ..write('status: $status, ')
          ..write('committedAt: $committedAt, ')
          ..write('createdAt: $createdAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    sessionId,
    endNumber,
    endScore,
    endXs,
    status,
    committedAt,
    createdAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is End &&
          other.id == this.id &&
          other.sessionId == this.sessionId &&
          other.endNumber == this.endNumber &&
          other.endScore == this.endScore &&
          other.endXs == this.endXs &&
          other.status == this.status &&
          other.committedAt == this.committedAt &&
          other.createdAt == this.createdAt);
}

class EndsCompanion extends UpdateCompanion<End> {
  final Value<String> id;
  final Value<String> sessionId;
  final Value<int> endNumber;
  final Value<int> endScore;
  final Value<int> endXs;
  final Value<String> status;
  final Value<DateTime?> committedAt;
  final Value<DateTime> createdAt;
  final Value<int> rowid;
  const EndsCompanion({
    this.id = const Value.absent(),
    this.sessionId = const Value.absent(),
    this.endNumber = const Value.absent(),
    this.endScore = const Value.absent(),
    this.endXs = const Value.absent(),
    this.status = const Value.absent(),
    this.committedAt = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  EndsCompanion.insert({
    required String id,
    required String sessionId,
    required int endNumber,
    this.endScore = const Value.absent(),
    this.endXs = const Value.absent(),
    this.status = const Value.absent(),
    this.committedAt = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       sessionId = Value(sessionId),
       endNumber = Value(endNumber);
  static Insertable<End> custom({
    Expression<String>? id,
    Expression<String>? sessionId,
    Expression<int>? endNumber,
    Expression<int>? endScore,
    Expression<int>? endXs,
    Expression<String>? status,
    Expression<DateTime>? committedAt,
    Expression<DateTime>? createdAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (sessionId != null) 'session_id': sessionId,
      if (endNumber != null) 'end_number': endNumber,
      if (endScore != null) 'end_score': endScore,
      if (endXs != null) 'end_xs': endXs,
      if (status != null) 'status': status,
      if (committedAt != null) 'committed_at': committedAt,
      if (createdAt != null) 'created_at': createdAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  EndsCompanion copyWith({
    Value<String>? id,
    Value<String>? sessionId,
    Value<int>? endNumber,
    Value<int>? endScore,
    Value<int>? endXs,
    Value<String>? status,
    Value<DateTime?>? committedAt,
    Value<DateTime>? createdAt,
    Value<int>? rowid,
  }) {
    return EndsCompanion(
      id: id ?? this.id,
      sessionId: sessionId ?? this.sessionId,
      endNumber: endNumber ?? this.endNumber,
      endScore: endScore ?? this.endScore,
      endXs: endXs ?? this.endXs,
      status: status ?? this.status,
      committedAt: committedAt ?? this.committedAt,
      createdAt: createdAt ?? this.createdAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (sessionId.present) {
      map['session_id'] = Variable<String>(sessionId.value);
    }
    if (endNumber.present) {
      map['end_number'] = Variable<int>(endNumber.value);
    }
    if (endScore.present) {
      map['end_score'] = Variable<int>(endScore.value);
    }
    if (endXs.present) {
      map['end_xs'] = Variable<int>(endXs.value);
    }
    if (status.present) {
      map['status'] = Variable<String>(status.value);
    }
    if (committedAt.present) {
      map['committed_at'] = Variable<DateTime>(committedAt.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('EndsCompanion(')
          ..write('id: $id, ')
          ..write('sessionId: $sessionId, ')
          ..write('endNumber: $endNumber, ')
          ..write('endScore: $endScore, ')
          ..write('endXs: $endXs, ')
          ..write('status: $status, ')
          ..write('committedAt: $committedAt, ')
          ..write('createdAt: $createdAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $ShaftsTable extends Shafts with TableInfo<$ShaftsTable, Shaft> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ShaftsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _quiverIdMeta = const VerificationMeta(
    'quiverId',
  );
  @override
  late final GeneratedColumn<String> quiverId = GeneratedColumn<String>(
    'quiver_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES quivers (id)',
    ),
  );
  static const VerificationMeta _numberMeta = const VerificationMeta('number');
  @override
  late final GeneratedColumn<int> number = GeneratedColumn<int>(
    'number',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _diameterMeta = const VerificationMeta(
    'diameter',
  );
  @override
  late final GeneratedColumn<String> diameter = GeneratedColumn<String>(
    'diameter',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _spineMeta = const VerificationMeta('spine');
  @override
  late final GeneratedColumn<int> spine = GeneratedColumn<int>(
    'spine',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _lengthInchesMeta = const VerificationMeta(
    'lengthInches',
  );
  @override
  late final GeneratedColumn<double> lengthInches = GeneratedColumn<double>(
    'length_inches',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _pointWeightMeta = const VerificationMeta(
    'pointWeight',
  );
  @override
  late final GeneratedColumn<int> pointWeight = GeneratedColumn<int>(
    'point_weight',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _fletchingTypeMeta = const VerificationMeta(
    'fletchingType',
  );
  @override
  late final GeneratedColumn<String> fletchingType = GeneratedColumn<String>(
    'fletching_type',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _fletchingColorMeta = const VerificationMeta(
    'fletchingColor',
  );
  @override
  late final GeneratedColumn<String> fletchingColor = GeneratedColumn<String>(
    'fletching_color',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _nockColorMeta = const VerificationMeta(
    'nockColor',
  );
  @override
  late final GeneratedColumn<String> nockColor = GeneratedColumn<String>(
    'nock_color',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _notesMeta = const VerificationMeta('notes');
  @override
  late final GeneratedColumn<String> notes = GeneratedColumn<String>(
    'notes',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _retiredAtMeta = const VerificationMeta(
    'retiredAt',
  );
  @override
  late final GeneratedColumn<DateTime> retiredAt = GeneratedColumn<DateTime>(
    'retired_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _totalWeightMeta = const VerificationMeta(
    'totalWeight',
  );
  @override
  late final GeneratedColumn<double> totalWeight = GeneratedColumn<double>(
    'total_weight',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _pointTypeMeta = const VerificationMeta(
    'pointType',
  );
  @override
  late final GeneratedColumn<String> pointType = GeneratedColumn<String>(
    'point_type',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _nockBrandMeta = const VerificationMeta(
    'nockBrand',
  );
  @override
  late final GeneratedColumn<String> nockBrand = GeneratedColumn<String>(
    'nock_brand',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _fletchingSizeMeta = const VerificationMeta(
    'fletchingSize',
  );
  @override
  late final GeneratedColumn<String> fletchingSize = GeneratedColumn<String>(
    'fletching_size',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _fletchingAngleMeta = const VerificationMeta(
    'fletchingAngle',
  );
  @override
  late final GeneratedColumn<double> fletchingAngle = GeneratedColumn<double>(
    'fletching_angle',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _hasWrapMeta = const VerificationMeta(
    'hasWrap',
  );
  @override
  late final GeneratedColumn<bool> hasWrap = GeneratedColumn<bool>(
    'has_wrap',
    aliasedName,
    true,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("has_wrap" IN (0, 1))',
    ),
  );
  static const VerificationMeta _wrapColorMeta = const VerificationMeta(
    'wrapColor',
  );
  @override
  late final GeneratedColumn<String> wrapColor = GeneratedColumn<String>(
    'wrap_color',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _purchaseDateMeta = const VerificationMeta(
    'purchaseDate',
  );
  @override
  late final GeneratedColumn<DateTime> purchaseDate = GeneratedColumn<DateTime>(
    'purchase_date',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    quiverId,
    number,
    diameter,
    spine,
    lengthInches,
    pointWeight,
    fletchingType,
    fletchingColor,
    nockColor,
    notes,
    createdAt,
    retiredAt,
    totalWeight,
    pointType,
    nockBrand,
    fletchingSize,
    fletchingAngle,
    hasWrap,
    wrapColor,
    purchaseDate,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'shafts';
  @override
  VerificationContext validateIntegrity(
    Insertable<Shaft> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('quiver_id')) {
      context.handle(
        _quiverIdMeta,
        quiverId.isAcceptableOrUnknown(data['quiver_id']!, _quiverIdMeta),
      );
    } else if (isInserting) {
      context.missing(_quiverIdMeta);
    }
    if (data.containsKey('number')) {
      context.handle(
        _numberMeta,
        number.isAcceptableOrUnknown(data['number']!, _numberMeta),
      );
    } else if (isInserting) {
      context.missing(_numberMeta);
    }
    if (data.containsKey('diameter')) {
      context.handle(
        _diameterMeta,
        diameter.isAcceptableOrUnknown(data['diameter']!, _diameterMeta),
      );
    }
    if (data.containsKey('spine')) {
      context.handle(
        _spineMeta,
        spine.isAcceptableOrUnknown(data['spine']!, _spineMeta),
      );
    }
    if (data.containsKey('length_inches')) {
      context.handle(
        _lengthInchesMeta,
        lengthInches.isAcceptableOrUnknown(
          data['length_inches']!,
          _lengthInchesMeta,
        ),
      );
    }
    if (data.containsKey('point_weight')) {
      context.handle(
        _pointWeightMeta,
        pointWeight.isAcceptableOrUnknown(
          data['point_weight']!,
          _pointWeightMeta,
        ),
      );
    }
    if (data.containsKey('fletching_type')) {
      context.handle(
        _fletchingTypeMeta,
        fletchingType.isAcceptableOrUnknown(
          data['fletching_type']!,
          _fletchingTypeMeta,
        ),
      );
    }
    if (data.containsKey('fletching_color')) {
      context.handle(
        _fletchingColorMeta,
        fletchingColor.isAcceptableOrUnknown(
          data['fletching_color']!,
          _fletchingColorMeta,
        ),
      );
    }
    if (data.containsKey('nock_color')) {
      context.handle(
        _nockColorMeta,
        nockColor.isAcceptableOrUnknown(data['nock_color']!, _nockColorMeta),
      );
    }
    if (data.containsKey('notes')) {
      context.handle(
        _notesMeta,
        notes.isAcceptableOrUnknown(data['notes']!, _notesMeta),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    if (data.containsKey('retired_at')) {
      context.handle(
        _retiredAtMeta,
        retiredAt.isAcceptableOrUnknown(data['retired_at']!, _retiredAtMeta),
      );
    }
    if (data.containsKey('total_weight')) {
      context.handle(
        _totalWeightMeta,
        totalWeight.isAcceptableOrUnknown(
          data['total_weight']!,
          _totalWeightMeta,
        ),
      );
    }
    if (data.containsKey('point_type')) {
      context.handle(
        _pointTypeMeta,
        pointType.isAcceptableOrUnknown(data['point_type']!, _pointTypeMeta),
      );
    }
    if (data.containsKey('nock_brand')) {
      context.handle(
        _nockBrandMeta,
        nockBrand.isAcceptableOrUnknown(data['nock_brand']!, _nockBrandMeta),
      );
    }
    if (data.containsKey('fletching_size')) {
      context.handle(
        _fletchingSizeMeta,
        fletchingSize.isAcceptableOrUnknown(
          data['fletching_size']!,
          _fletchingSizeMeta,
        ),
      );
    }
    if (data.containsKey('fletching_angle')) {
      context.handle(
        _fletchingAngleMeta,
        fletchingAngle.isAcceptableOrUnknown(
          data['fletching_angle']!,
          _fletchingAngleMeta,
        ),
      );
    }
    if (data.containsKey('has_wrap')) {
      context.handle(
        _hasWrapMeta,
        hasWrap.isAcceptableOrUnknown(data['has_wrap']!, _hasWrapMeta),
      );
    }
    if (data.containsKey('wrap_color')) {
      context.handle(
        _wrapColorMeta,
        wrapColor.isAcceptableOrUnknown(data['wrap_color']!, _wrapColorMeta),
      );
    }
    if (data.containsKey('purchase_date')) {
      context.handle(
        _purchaseDateMeta,
        purchaseDate.isAcceptableOrUnknown(
          data['purchase_date']!,
          _purchaseDateMeta,
        ),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  Shaft map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Shaft(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      quiverId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}quiver_id'],
      )!,
      number: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}number'],
      )!,
      diameter: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}diameter'],
      ),
      spine: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}spine'],
      ),
      lengthInches: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}length_inches'],
      ),
      pointWeight: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}point_weight'],
      ),
      fletchingType: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}fletching_type'],
      ),
      fletchingColor: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}fletching_color'],
      ),
      nockColor: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}nock_color'],
      ),
      notes: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}notes'],
      ),
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      retiredAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}retired_at'],
      ),
      totalWeight: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}total_weight'],
      ),
      pointType: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}point_type'],
      ),
      nockBrand: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}nock_brand'],
      ),
      fletchingSize: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}fletching_size'],
      ),
      fletchingAngle: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}fletching_angle'],
      ),
      hasWrap: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}has_wrap'],
      ),
      wrapColor: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}wrap_color'],
      ),
      purchaseDate: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}purchase_date'],
      ),
    );
  }

  @override
  $ShaftsTable createAlias(String alias) {
    return $ShaftsTable(attachedDatabase, alias);
  }
}

class Shaft extends DataClass implements Insertable<Shaft> {
  final String id;
  final String quiverId;
  final int number;
  final String? diameter;
  final int? spine;
  final double? lengthInches;
  final int? pointWeight;
  final String? fletchingType;
  final String? fletchingColor;
  final String? nockColor;
  final String? notes;
  final DateTime createdAt;
  final DateTime? retiredAt;
  final double? totalWeight;
  final String? pointType;
  final String? nockBrand;
  final String? fletchingSize;
  final double? fletchingAngle;
  final bool? hasWrap;
  final String? wrapColor;
  final DateTime? purchaseDate;
  const Shaft({
    required this.id,
    required this.quiverId,
    required this.number,
    this.diameter,
    this.spine,
    this.lengthInches,
    this.pointWeight,
    this.fletchingType,
    this.fletchingColor,
    this.nockColor,
    this.notes,
    required this.createdAt,
    this.retiredAt,
    this.totalWeight,
    this.pointType,
    this.nockBrand,
    this.fletchingSize,
    this.fletchingAngle,
    this.hasWrap,
    this.wrapColor,
    this.purchaseDate,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['quiver_id'] = Variable<String>(quiverId);
    map['number'] = Variable<int>(number);
    if (!nullToAbsent || diameter != null) {
      map['diameter'] = Variable<String>(diameter);
    }
    if (!nullToAbsent || spine != null) {
      map['spine'] = Variable<int>(spine);
    }
    if (!nullToAbsent || lengthInches != null) {
      map['length_inches'] = Variable<double>(lengthInches);
    }
    if (!nullToAbsent || pointWeight != null) {
      map['point_weight'] = Variable<int>(pointWeight);
    }
    if (!nullToAbsent || fletchingType != null) {
      map['fletching_type'] = Variable<String>(fletchingType);
    }
    if (!nullToAbsent || fletchingColor != null) {
      map['fletching_color'] = Variable<String>(fletchingColor);
    }
    if (!nullToAbsent || nockColor != null) {
      map['nock_color'] = Variable<String>(nockColor);
    }
    if (!nullToAbsent || notes != null) {
      map['notes'] = Variable<String>(notes);
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    if (!nullToAbsent || retiredAt != null) {
      map['retired_at'] = Variable<DateTime>(retiredAt);
    }
    if (!nullToAbsent || totalWeight != null) {
      map['total_weight'] = Variable<double>(totalWeight);
    }
    if (!nullToAbsent || pointType != null) {
      map['point_type'] = Variable<String>(pointType);
    }
    if (!nullToAbsent || nockBrand != null) {
      map['nock_brand'] = Variable<String>(nockBrand);
    }
    if (!nullToAbsent || fletchingSize != null) {
      map['fletching_size'] = Variable<String>(fletchingSize);
    }
    if (!nullToAbsent || fletchingAngle != null) {
      map['fletching_angle'] = Variable<double>(fletchingAngle);
    }
    if (!nullToAbsent || hasWrap != null) {
      map['has_wrap'] = Variable<bool>(hasWrap);
    }
    if (!nullToAbsent || wrapColor != null) {
      map['wrap_color'] = Variable<String>(wrapColor);
    }
    if (!nullToAbsent || purchaseDate != null) {
      map['purchase_date'] = Variable<DateTime>(purchaseDate);
    }
    return map;
  }

  ShaftsCompanion toCompanion(bool nullToAbsent) {
    return ShaftsCompanion(
      id: Value(id),
      quiverId: Value(quiverId),
      number: Value(number),
      diameter: diameter == null && nullToAbsent
          ? const Value.absent()
          : Value(diameter),
      spine: spine == null && nullToAbsent
          ? const Value.absent()
          : Value(spine),
      lengthInches: lengthInches == null && nullToAbsent
          ? const Value.absent()
          : Value(lengthInches),
      pointWeight: pointWeight == null && nullToAbsent
          ? const Value.absent()
          : Value(pointWeight),
      fletchingType: fletchingType == null && nullToAbsent
          ? const Value.absent()
          : Value(fletchingType),
      fletchingColor: fletchingColor == null && nullToAbsent
          ? const Value.absent()
          : Value(fletchingColor),
      nockColor: nockColor == null && nullToAbsent
          ? const Value.absent()
          : Value(nockColor),
      notes: notes == null && nullToAbsent
          ? const Value.absent()
          : Value(notes),
      createdAt: Value(createdAt),
      retiredAt: retiredAt == null && nullToAbsent
          ? const Value.absent()
          : Value(retiredAt),
      totalWeight: totalWeight == null && nullToAbsent
          ? const Value.absent()
          : Value(totalWeight),
      pointType: pointType == null && nullToAbsent
          ? const Value.absent()
          : Value(pointType),
      nockBrand: nockBrand == null && nullToAbsent
          ? const Value.absent()
          : Value(nockBrand),
      fletchingSize: fletchingSize == null && nullToAbsent
          ? const Value.absent()
          : Value(fletchingSize),
      fletchingAngle: fletchingAngle == null && nullToAbsent
          ? const Value.absent()
          : Value(fletchingAngle),
      hasWrap: hasWrap == null && nullToAbsent
          ? const Value.absent()
          : Value(hasWrap),
      wrapColor: wrapColor == null && nullToAbsent
          ? const Value.absent()
          : Value(wrapColor),
      purchaseDate: purchaseDate == null && nullToAbsent
          ? const Value.absent()
          : Value(purchaseDate),
    );
  }

  factory Shaft.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Shaft(
      id: serializer.fromJson<String>(json['id']),
      quiverId: serializer.fromJson<String>(json['quiverId']),
      number: serializer.fromJson<int>(json['number']),
      diameter: serializer.fromJson<String?>(json['diameter']),
      spine: serializer.fromJson<int?>(json['spine']),
      lengthInches: serializer.fromJson<double?>(json['lengthInches']),
      pointWeight: serializer.fromJson<int?>(json['pointWeight']),
      fletchingType: serializer.fromJson<String?>(json['fletchingType']),
      fletchingColor: serializer.fromJson<String?>(json['fletchingColor']),
      nockColor: serializer.fromJson<String?>(json['nockColor']),
      notes: serializer.fromJson<String?>(json['notes']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      retiredAt: serializer.fromJson<DateTime?>(json['retiredAt']),
      totalWeight: serializer.fromJson<double?>(json['totalWeight']),
      pointType: serializer.fromJson<String?>(json['pointType']),
      nockBrand: serializer.fromJson<String?>(json['nockBrand']),
      fletchingSize: serializer.fromJson<String?>(json['fletchingSize']),
      fletchingAngle: serializer.fromJson<double?>(json['fletchingAngle']),
      hasWrap: serializer.fromJson<bool?>(json['hasWrap']),
      wrapColor: serializer.fromJson<String?>(json['wrapColor']),
      purchaseDate: serializer.fromJson<DateTime?>(json['purchaseDate']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'quiverId': serializer.toJson<String>(quiverId),
      'number': serializer.toJson<int>(number),
      'diameter': serializer.toJson<String?>(diameter),
      'spine': serializer.toJson<int?>(spine),
      'lengthInches': serializer.toJson<double?>(lengthInches),
      'pointWeight': serializer.toJson<int?>(pointWeight),
      'fletchingType': serializer.toJson<String?>(fletchingType),
      'fletchingColor': serializer.toJson<String?>(fletchingColor),
      'nockColor': serializer.toJson<String?>(nockColor),
      'notes': serializer.toJson<String?>(notes),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'retiredAt': serializer.toJson<DateTime?>(retiredAt),
      'totalWeight': serializer.toJson<double?>(totalWeight),
      'pointType': serializer.toJson<String?>(pointType),
      'nockBrand': serializer.toJson<String?>(nockBrand),
      'fletchingSize': serializer.toJson<String?>(fletchingSize),
      'fletchingAngle': serializer.toJson<double?>(fletchingAngle),
      'hasWrap': serializer.toJson<bool?>(hasWrap),
      'wrapColor': serializer.toJson<String?>(wrapColor),
      'purchaseDate': serializer.toJson<DateTime?>(purchaseDate),
    };
  }

  Shaft copyWith({
    String? id,
    String? quiverId,
    int? number,
    Value<String?> diameter = const Value.absent(),
    Value<int?> spine = const Value.absent(),
    Value<double?> lengthInches = const Value.absent(),
    Value<int?> pointWeight = const Value.absent(),
    Value<String?> fletchingType = const Value.absent(),
    Value<String?> fletchingColor = const Value.absent(),
    Value<String?> nockColor = const Value.absent(),
    Value<String?> notes = const Value.absent(),
    DateTime? createdAt,
    Value<DateTime?> retiredAt = const Value.absent(),
    Value<double?> totalWeight = const Value.absent(),
    Value<String?> pointType = const Value.absent(),
    Value<String?> nockBrand = const Value.absent(),
    Value<String?> fletchingSize = const Value.absent(),
    Value<double?> fletchingAngle = const Value.absent(),
    Value<bool?> hasWrap = const Value.absent(),
    Value<String?> wrapColor = const Value.absent(),
    Value<DateTime?> purchaseDate = const Value.absent(),
  }) => Shaft(
    id: id ?? this.id,
    quiverId: quiverId ?? this.quiverId,
    number: number ?? this.number,
    diameter: diameter.present ? diameter.value : this.diameter,
    spine: spine.present ? spine.value : this.spine,
    lengthInches: lengthInches.present ? lengthInches.value : this.lengthInches,
    pointWeight: pointWeight.present ? pointWeight.value : this.pointWeight,
    fletchingType: fletchingType.present
        ? fletchingType.value
        : this.fletchingType,
    fletchingColor: fletchingColor.present
        ? fletchingColor.value
        : this.fletchingColor,
    nockColor: nockColor.present ? nockColor.value : this.nockColor,
    notes: notes.present ? notes.value : this.notes,
    createdAt: createdAt ?? this.createdAt,
    retiredAt: retiredAt.present ? retiredAt.value : this.retiredAt,
    totalWeight: totalWeight.present ? totalWeight.value : this.totalWeight,
    pointType: pointType.present ? pointType.value : this.pointType,
    nockBrand: nockBrand.present ? nockBrand.value : this.nockBrand,
    fletchingSize: fletchingSize.present
        ? fletchingSize.value
        : this.fletchingSize,
    fletchingAngle: fletchingAngle.present
        ? fletchingAngle.value
        : this.fletchingAngle,
    hasWrap: hasWrap.present ? hasWrap.value : this.hasWrap,
    wrapColor: wrapColor.present ? wrapColor.value : this.wrapColor,
    purchaseDate: purchaseDate.present ? purchaseDate.value : this.purchaseDate,
  );
  Shaft copyWithCompanion(ShaftsCompanion data) {
    return Shaft(
      id: data.id.present ? data.id.value : this.id,
      quiverId: data.quiverId.present ? data.quiverId.value : this.quiverId,
      number: data.number.present ? data.number.value : this.number,
      diameter: data.diameter.present ? data.diameter.value : this.diameter,
      spine: data.spine.present ? data.spine.value : this.spine,
      lengthInches: data.lengthInches.present
          ? data.lengthInches.value
          : this.lengthInches,
      pointWeight: data.pointWeight.present
          ? data.pointWeight.value
          : this.pointWeight,
      fletchingType: data.fletchingType.present
          ? data.fletchingType.value
          : this.fletchingType,
      fletchingColor: data.fletchingColor.present
          ? data.fletchingColor.value
          : this.fletchingColor,
      nockColor: data.nockColor.present ? data.nockColor.value : this.nockColor,
      notes: data.notes.present ? data.notes.value : this.notes,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      retiredAt: data.retiredAt.present ? data.retiredAt.value : this.retiredAt,
      totalWeight: data.totalWeight.present
          ? data.totalWeight.value
          : this.totalWeight,
      pointType: data.pointType.present ? data.pointType.value : this.pointType,
      nockBrand: data.nockBrand.present ? data.nockBrand.value : this.nockBrand,
      fletchingSize: data.fletchingSize.present
          ? data.fletchingSize.value
          : this.fletchingSize,
      fletchingAngle: data.fletchingAngle.present
          ? data.fletchingAngle.value
          : this.fletchingAngle,
      hasWrap: data.hasWrap.present ? data.hasWrap.value : this.hasWrap,
      wrapColor: data.wrapColor.present ? data.wrapColor.value : this.wrapColor,
      purchaseDate: data.purchaseDate.present
          ? data.purchaseDate.value
          : this.purchaseDate,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Shaft(')
          ..write('id: $id, ')
          ..write('quiverId: $quiverId, ')
          ..write('number: $number, ')
          ..write('diameter: $diameter, ')
          ..write('spine: $spine, ')
          ..write('lengthInches: $lengthInches, ')
          ..write('pointWeight: $pointWeight, ')
          ..write('fletchingType: $fletchingType, ')
          ..write('fletchingColor: $fletchingColor, ')
          ..write('nockColor: $nockColor, ')
          ..write('notes: $notes, ')
          ..write('createdAt: $createdAt, ')
          ..write('retiredAt: $retiredAt, ')
          ..write('totalWeight: $totalWeight, ')
          ..write('pointType: $pointType, ')
          ..write('nockBrand: $nockBrand, ')
          ..write('fletchingSize: $fletchingSize, ')
          ..write('fletchingAngle: $fletchingAngle, ')
          ..write('hasWrap: $hasWrap, ')
          ..write('wrapColor: $wrapColor, ')
          ..write('purchaseDate: $purchaseDate')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hashAll([
    id,
    quiverId,
    number,
    diameter,
    spine,
    lengthInches,
    pointWeight,
    fletchingType,
    fletchingColor,
    nockColor,
    notes,
    createdAt,
    retiredAt,
    totalWeight,
    pointType,
    nockBrand,
    fletchingSize,
    fletchingAngle,
    hasWrap,
    wrapColor,
    purchaseDate,
  ]);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Shaft &&
          other.id == this.id &&
          other.quiverId == this.quiverId &&
          other.number == this.number &&
          other.diameter == this.diameter &&
          other.spine == this.spine &&
          other.lengthInches == this.lengthInches &&
          other.pointWeight == this.pointWeight &&
          other.fletchingType == this.fletchingType &&
          other.fletchingColor == this.fletchingColor &&
          other.nockColor == this.nockColor &&
          other.notes == this.notes &&
          other.createdAt == this.createdAt &&
          other.retiredAt == this.retiredAt &&
          other.totalWeight == this.totalWeight &&
          other.pointType == this.pointType &&
          other.nockBrand == this.nockBrand &&
          other.fletchingSize == this.fletchingSize &&
          other.fletchingAngle == this.fletchingAngle &&
          other.hasWrap == this.hasWrap &&
          other.wrapColor == this.wrapColor &&
          other.purchaseDate == this.purchaseDate);
}

class ShaftsCompanion extends UpdateCompanion<Shaft> {
  final Value<String> id;
  final Value<String> quiverId;
  final Value<int> number;
  final Value<String?> diameter;
  final Value<int?> spine;
  final Value<double?> lengthInches;
  final Value<int?> pointWeight;
  final Value<String?> fletchingType;
  final Value<String?> fletchingColor;
  final Value<String?> nockColor;
  final Value<String?> notes;
  final Value<DateTime> createdAt;
  final Value<DateTime?> retiredAt;
  final Value<double?> totalWeight;
  final Value<String?> pointType;
  final Value<String?> nockBrand;
  final Value<String?> fletchingSize;
  final Value<double?> fletchingAngle;
  final Value<bool?> hasWrap;
  final Value<String?> wrapColor;
  final Value<DateTime?> purchaseDate;
  final Value<int> rowid;
  const ShaftsCompanion({
    this.id = const Value.absent(),
    this.quiverId = const Value.absent(),
    this.number = const Value.absent(),
    this.diameter = const Value.absent(),
    this.spine = const Value.absent(),
    this.lengthInches = const Value.absent(),
    this.pointWeight = const Value.absent(),
    this.fletchingType = const Value.absent(),
    this.fletchingColor = const Value.absent(),
    this.nockColor = const Value.absent(),
    this.notes = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.retiredAt = const Value.absent(),
    this.totalWeight = const Value.absent(),
    this.pointType = const Value.absent(),
    this.nockBrand = const Value.absent(),
    this.fletchingSize = const Value.absent(),
    this.fletchingAngle = const Value.absent(),
    this.hasWrap = const Value.absent(),
    this.wrapColor = const Value.absent(),
    this.purchaseDate = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  ShaftsCompanion.insert({
    required String id,
    required String quiverId,
    required int number,
    this.diameter = const Value.absent(),
    this.spine = const Value.absent(),
    this.lengthInches = const Value.absent(),
    this.pointWeight = const Value.absent(),
    this.fletchingType = const Value.absent(),
    this.fletchingColor = const Value.absent(),
    this.nockColor = const Value.absent(),
    this.notes = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.retiredAt = const Value.absent(),
    this.totalWeight = const Value.absent(),
    this.pointType = const Value.absent(),
    this.nockBrand = const Value.absent(),
    this.fletchingSize = const Value.absent(),
    this.fletchingAngle = const Value.absent(),
    this.hasWrap = const Value.absent(),
    this.wrapColor = const Value.absent(),
    this.purchaseDate = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       quiverId = Value(quiverId),
       number = Value(number);
  static Insertable<Shaft> custom({
    Expression<String>? id,
    Expression<String>? quiverId,
    Expression<int>? number,
    Expression<String>? diameter,
    Expression<int>? spine,
    Expression<double>? lengthInches,
    Expression<int>? pointWeight,
    Expression<String>? fletchingType,
    Expression<String>? fletchingColor,
    Expression<String>? nockColor,
    Expression<String>? notes,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? retiredAt,
    Expression<double>? totalWeight,
    Expression<String>? pointType,
    Expression<String>? nockBrand,
    Expression<String>? fletchingSize,
    Expression<double>? fletchingAngle,
    Expression<bool>? hasWrap,
    Expression<String>? wrapColor,
    Expression<DateTime>? purchaseDate,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (quiverId != null) 'quiver_id': quiverId,
      if (number != null) 'number': number,
      if (diameter != null) 'diameter': diameter,
      if (spine != null) 'spine': spine,
      if (lengthInches != null) 'length_inches': lengthInches,
      if (pointWeight != null) 'point_weight': pointWeight,
      if (fletchingType != null) 'fletching_type': fletchingType,
      if (fletchingColor != null) 'fletching_color': fletchingColor,
      if (nockColor != null) 'nock_color': nockColor,
      if (notes != null) 'notes': notes,
      if (createdAt != null) 'created_at': createdAt,
      if (retiredAt != null) 'retired_at': retiredAt,
      if (totalWeight != null) 'total_weight': totalWeight,
      if (pointType != null) 'point_type': pointType,
      if (nockBrand != null) 'nock_brand': nockBrand,
      if (fletchingSize != null) 'fletching_size': fletchingSize,
      if (fletchingAngle != null) 'fletching_angle': fletchingAngle,
      if (hasWrap != null) 'has_wrap': hasWrap,
      if (wrapColor != null) 'wrap_color': wrapColor,
      if (purchaseDate != null) 'purchase_date': purchaseDate,
      if (rowid != null) 'rowid': rowid,
    });
  }

  ShaftsCompanion copyWith({
    Value<String>? id,
    Value<String>? quiverId,
    Value<int>? number,
    Value<String?>? diameter,
    Value<int?>? spine,
    Value<double?>? lengthInches,
    Value<int?>? pointWeight,
    Value<String?>? fletchingType,
    Value<String?>? fletchingColor,
    Value<String?>? nockColor,
    Value<String?>? notes,
    Value<DateTime>? createdAt,
    Value<DateTime?>? retiredAt,
    Value<double?>? totalWeight,
    Value<String?>? pointType,
    Value<String?>? nockBrand,
    Value<String?>? fletchingSize,
    Value<double?>? fletchingAngle,
    Value<bool?>? hasWrap,
    Value<String?>? wrapColor,
    Value<DateTime?>? purchaseDate,
    Value<int>? rowid,
  }) {
    return ShaftsCompanion(
      id: id ?? this.id,
      quiverId: quiverId ?? this.quiverId,
      number: number ?? this.number,
      diameter: diameter ?? this.diameter,
      spine: spine ?? this.spine,
      lengthInches: lengthInches ?? this.lengthInches,
      pointWeight: pointWeight ?? this.pointWeight,
      fletchingType: fletchingType ?? this.fletchingType,
      fletchingColor: fletchingColor ?? this.fletchingColor,
      nockColor: nockColor ?? this.nockColor,
      notes: notes ?? this.notes,
      createdAt: createdAt ?? this.createdAt,
      retiredAt: retiredAt ?? this.retiredAt,
      totalWeight: totalWeight ?? this.totalWeight,
      pointType: pointType ?? this.pointType,
      nockBrand: nockBrand ?? this.nockBrand,
      fletchingSize: fletchingSize ?? this.fletchingSize,
      fletchingAngle: fletchingAngle ?? this.fletchingAngle,
      hasWrap: hasWrap ?? this.hasWrap,
      wrapColor: wrapColor ?? this.wrapColor,
      purchaseDate: purchaseDate ?? this.purchaseDate,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (quiverId.present) {
      map['quiver_id'] = Variable<String>(quiverId.value);
    }
    if (number.present) {
      map['number'] = Variable<int>(number.value);
    }
    if (diameter.present) {
      map['diameter'] = Variable<String>(diameter.value);
    }
    if (spine.present) {
      map['spine'] = Variable<int>(spine.value);
    }
    if (lengthInches.present) {
      map['length_inches'] = Variable<double>(lengthInches.value);
    }
    if (pointWeight.present) {
      map['point_weight'] = Variable<int>(pointWeight.value);
    }
    if (fletchingType.present) {
      map['fletching_type'] = Variable<String>(fletchingType.value);
    }
    if (fletchingColor.present) {
      map['fletching_color'] = Variable<String>(fletchingColor.value);
    }
    if (nockColor.present) {
      map['nock_color'] = Variable<String>(nockColor.value);
    }
    if (notes.present) {
      map['notes'] = Variable<String>(notes.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (retiredAt.present) {
      map['retired_at'] = Variable<DateTime>(retiredAt.value);
    }
    if (totalWeight.present) {
      map['total_weight'] = Variable<double>(totalWeight.value);
    }
    if (pointType.present) {
      map['point_type'] = Variable<String>(pointType.value);
    }
    if (nockBrand.present) {
      map['nock_brand'] = Variable<String>(nockBrand.value);
    }
    if (fletchingSize.present) {
      map['fletching_size'] = Variable<String>(fletchingSize.value);
    }
    if (fletchingAngle.present) {
      map['fletching_angle'] = Variable<double>(fletchingAngle.value);
    }
    if (hasWrap.present) {
      map['has_wrap'] = Variable<bool>(hasWrap.value);
    }
    if (wrapColor.present) {
      map['wrap_color'] = Variable<String>(wrapColor.value);
    }
    if (purchaseDate.present) {
      map['purchase_date'] = Variable<DateTime>(purchaseDate.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ShaftsCompanion(')
          ..write('id: $id, ')
          ..write('quiverId: $quiverId, ')
          ..write('number: $number, ')
          ..write('diameter: $diameter, ')
          ..write('spine: $spine, ')
          ..write('lengthInches: $lengthInches, ')
          ..write('pointWeight: $pointWeight, ')
          ..write('fletchingType: $fletchingType, ')
          ..write('fletchingColor: $fletchingColor, ')
          ..write('nockColor: $nockColor, ')
          ..write('notes: $notes, ')
          ..write('createdAt: $createdAt, ')
          ..write('retiredAt: $retiredAt, ')
          ..write('totalWeight: $totalWeight, ')
          ..write('pointType: $pointType, ')
          ..write('nockBrand: $nockBrand, ')
          ..write('fletchingSize: $fletchingSize, ')
          ..write('fletchingAngle: $fletchingAngle, ')
          ..write('hasWrap: $hasWrap, ')
          ..write('wrapColor: $wrapColor, ')
          ..write('purchaseDate: $purchaseDate, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $ArrowsTable extends Arrows with TableInfo<$ArrowsTable, Arrow> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ArrowsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _endIdMeta = const VerificationMeta('endId');
  @override
  late final GeneratedColumn<String> endId = GeneratedColumn<String>(
    'end_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES ends (id)',
    ),
  );
  static const VerificationMeta _faceIndexMeta = const VerificationMeta(
    'faceIndex',
  );
  @override
  late final GeneratedColumn<int> faceIndex = GeneratedColumn<int>(
    'face_index',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _xMeta = const VerificationMeta('x');
  @override
  late final GeneratedColumn<double> x = GeneratedColumn<double>(
    'x',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _yMeta = const VerificationMeta('y');
  @override
  late final GeneratedColumn<double> y = GeneratedColumn<double>(
    'y',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _xMmMeta = const VerificationMeta('xMm');
  @override
  late final GeneratedColumn<double> xMm = GeneratedColumn<double>(
    'x_mm',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _yMmMeta = const VerificationMeta('yMm');
  @override
  late final GeneratedColumn<double> yMm = GeneratedColumn<double>(
    'y_mm',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _scoreMeta = const VerificationMeta('score');
  @override
  late final GeneratedColumn<int> score = GeneratedColumn<int>(
    'score',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _isXMeta = const VerificationMeta('isX');
  @override
  late final GeneratedColumn<bool> isX = GeneratedColumn<bool>(
    'is_x',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_x" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _sequenceMeta = const VerificationMeta(
    'sequence',
  );
  @override
  late final GeneratedColumn<int> sequence = GeneratedColumn<int>(
    'sequence',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _shaftNumberMeta = const VerificationMeta(
    'shaftNumber',
  );
  @override
  late final GeneratedColumn<int> shaftNumber = GeneratedColumn<int>(
    'shaft_number',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _shaftIdMeta = const VerificationMeta(
    'shaftId',
  );
  @override
  late final GeneratedColumn<String> shaftId = GeneratedColumn<String>(
    'shaft_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES shafts (id)',
    ),
  );
  static const VerificationMeta _nockRotationMeta = const VerificationMeta(
    'nockRotation',
  );
  @override
  late final GeneratedColumn<String> nockRotation = GeneratedColumn<String>(
    'nock_rotation',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    endId,
    faceIndex,
    x,
    y,
    xMm,
    yMm,
    score,
    isX,
    sequence,
    shaftNumber,
    shaftId,
    nockRotation,
    createdAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'arrows';
  @override
  VerificationContext validateIntegrity(
    Insertable<Arrow> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('end_id')) {
      context.handle(
        _endIdMeta,
        endId.isAcceptableOrUnknown(data['end_id']!, _endIdMeta),
      );
    } else if (isInserting) {
      context.missing(_endIdMeta);
    }
    if (data.containsKey('face_index')) {
      context.handle(
        _faceIndexMeta,
        faceIndex.isAcceptableOrUnknown(data['face_index']!, _faceIndexMeta),
      );
    }
    if (data.containsKey('x')) {
      context.handle(_xMeta, x.isAcceptableOrUnknown(data['x']!, _xMeta));
    } else if (isInserting) {
      context.missing(_xMeta);
    }
    if (data.containsKey('y')) {
      context.handle(_yMeta, y.isAcceptableOrUnknown(data['y']!, _yMeta));
    } else if (isInserting) {
      context.missing(_yMeta);
    }
    if (data.containsKey('x_mm')) {
      context.handle(
        _xMmMeta,
        xMm.isAcceptableOrUnknown(data['x_mm']!, _xMmMeta),
      );
    }
    if (data.containsKey('y_mm')) {
      context.handle(
        _yMmMeta,
        yMm.isAcceptableOrUnknown(data['y_mm']!, _yMmMeta),
      );
    }
    if (data.containsKey('score')) {
      context.handle(
        _scoreMeta,
        score.isAcceptableOrUnknown(data['score']!, _scoreMeta),
      );
    } else if (isInserting) {
      context.missing(_scoreMeta);
    }
    if (data.containsKey('is_x')) {
      context.handle(
        _isXMeta,
        isX.isAcceptableOrUnknown(data['is_x']!, _isXMeta),
      );
    }
    if (data.containsKey('sequence')) {
      context.handle(
        _sequenceMeta,
        sequence.isAcceptableOrUnknown(data['sequence']!, _sequenceMeta),
      );
    } else if (isInserting) {
      context.missing(_sequenceMeta);
    }
    if (data.containsKey('shaft_number')) {
      context.handle(
        _shaftNumberMeta,
        shaftNumber.isAcceptableOrUnknown(
          data['shaft_number']!,
          _shaftNumberMeta,
        ),
      );
    }
    if (data.containsKey('shaft_id')) {
      context.handle(
        _shaftIdMeta,
        shaftId.isAcceptableOrUnknown(data['shaft_id']!, _shaftIdMeta),
      );
    }
    if (data.containsKey('nock_rotation')) {
      context.handle(
        _nockRotationMeta,
        nockRotation.isAcceptableOrUnknown(
          data['nock_rotation']!,
          _nockRotationMeta,
        ),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  Arrow map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Arrow(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      endId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}end_id'],
      )!,
      faceIndex: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}face_index'],
      )!,
      x: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}x'],
      )!,
      y: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}y'],
      )!,
      xMm: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}x_mm'],
      )!,
      yMm: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}y_mm'],
      )!,
      score: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}score'],
      )!,
      isX: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_x'],
      )!,
      sequence: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sequence'],
      )!,
      shaftNumber: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}shaft_number'],
      ),
      shaftId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}shaft_id'],
      ),
      nockRotation: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}nock_rotation'],
      ),
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
    );
  }

  @override
  $ArrowsTable createAlias(String alias) {
    return $ArrowsTable(attachedDatabase, alias);
  }
}

class Arrow extends DataClass implements Insertable<Arrow> {
  final String id;
  final String endId;
  final int faceIndex;
  final double x;
  final double y;
  final double xMm;
  final double yMm;
  final int score;
  final bool isX;
  final int sequence;
  final int? shaftNumber;
  final String? shaftId;
  final String? nockRotation;
  final DateTime createdAt;
  const Arrow({
    required this.id,
    required this.endId,
    required this.faceIndex,
    required this.x,
    required this.y,
    required this.xMm,
    required this.yMm,
    required this.score,
    required this.isX,
    required this.sequence,
    this.shaftNumber,
    this.shaftId,
    this.nockRotation,
    required this.createdAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['end_id'] = Variable<String>(endId);
    map['face_index'] = Variable<int>(faceIndex);
    map['x'] = Variable<double>(x);
    map['y'] = Variable<double>(y);
    map['x_mm'] = Variable<double>(xMm);
    map['y_mm'] = Variable<double>(yMm);
    map['score'] = Variable<int>(score);
    map['is_x'] = Variable<bool>(isX);
    map['sequence'] = Variable<int>(sequence);
    if (!nullToAbsent || shaftNumber != null) {
      map['shaft_number'] = Variable<int>(shaftNumber);
    }
    if (!nullToAbsent || shaftId != null) {
      map['shaft_id'] = Variable<String>(shaftId);
    }
    if (!nullToAbsent || nockRotation != null) {
      map['nock_rotation'] = Variable<String>(nockRotation);
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    return map;
  }

  ArrowsCompanion toCompanion(bool nullToAbsent) {
    return ArrowsCompanion(
      id: Value(id),
      endId: Value(endId),
      faceIndex: Value(faceIndex),
      x: Value(x),
      y: Value(y),
      xMm: Value(xMm),
      yMm: Value(yMm),
      score: Value(score),
      isX: Value(isX),
      sequence: Value(sequence),
      shaftNumber: shaftNumber == null && nullToAbsent
          ? const Value.absent()
          : Value(shaftNumber),
      shaftId: shaftId == null && nullToAbsent
          ? const Value.absent()
          : Value(shaftId),
      nockRotation: nockRotation == null && nullToAbsent
          ? const Value.absent()
          : Value(nockRotation),
      createdAt: Value(createdAt),
    );
  }

  factory Arrow.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Arrow(
      id: serializer.fromJson<String>(json['id']),
      endId: serializer.fromJson<String>(json['endId']),
      faceIndex: serializer.fromJson<int>(json['faceIndex']),
      x: serializer.fromJson<double>(json['x']),
      y: serializer.fromJson<double>(json['y']),
      xMm: serializer.fromJson<double>(json['xMm']),
      yMm: serializer.fromJson<double>(json['yMm']),
      score: serializer.fromJson<int>(json['score']),
      isX: serializer.fromJson<bool>(json['isX']),
      sequence: serializer.fromJson<int>(json['sequence']),
      shaftNumber: serializer.fromJson<int?>(json['shaftNumber']),
      shaftId: serializer.fromJson<String?>(json['shaftId']),
      nockRotation: serializer.fromJson<String?>(json['nockRotation']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'endId': serializer.toJson<String>(endId),
      'faceIndex': serializer.toJson<int>(faceIndex),
      'x': serializer.toJson<double>(x),
      'y': serializer.toJson<double>(y),
      'xMm': serializer.toJson<double>(xMm),
      'yMm': serializer.toJson<double>(yMm),
      'score': serializer.toJson<int>(score),
      'isX': serializer.toJson<bool>(isX),
      'sequence': serializer.toJson<int>(sequence),
      'shaftNumber': serializer.toJson<int?>(shaftNumber),
      'shaftId': serializer.toJson<String?>(shaftId),
      'nockRotation': serializer.toJson<String?>(nockRotation),
      'createdAt': serializer.toJson<DateTime>(createdAt),
    };
  }

  Arrow copyWith({
    String? id,
    String? endId,
    int? faceIndex,
    double? x,
    double? y,
    double? xMm,
    double? yMm,
    int? score,
    bool? isX,
    int? sequence,
    Value<int?> shaftNumber = const Value.absent(),
    Value<String?> shaftId = const Value.absent(),
    Value<String?> nockRotation = const Value.absent(),
    DateTime? createdAt,
  }) => Arrow(
    id: id ?? this.id,
    endId: endId ?? this.endId,
    faceIndex: faceIndex ?? this.faceIndex,
    x: x ?? this.x,
    y: y ?? this.y,
    xMm: xMm ?? this.xMm,
    yMm: yMm ?? this.yMm,
    score: score ?? this.score,
    isX: isX ?? this.isX,
    sequence: sequence ?? this.sequence,
    shaftNumber: shaftNumber.present ? shaftNumber.value : this.shaftNumber,
    shaftId: shaftId.present ? shaftId.value : this.shaftId,
    nockRotation: nockRotation.present ? nockRotation.value : this.nockRotation,
    createdAt: createdAt ?? this.createdAt,
  );
  Arrow copyWithCompanion(ArrowsCompanion data) {
    return Arrow(
      id: data.id.present ? data.id.value : this.id,
      endId: data.endId.present ? data.endId.value : this.endId,
      faceIndex: data.faceIndex.present ? data.faceIndex.value : this.faceIndex,
      x: data.x.present ? data.x.value : this.x,
      y: data.y.present ? data.y.value : this.y,
      xMm: data.xMm.present ? data.xMm.value : this.xMm,
      yMm: data.yMm.present ? data.yMm.value : this.yMm,
      score: data.score.present ? data.score.value : this.score,
      isX: data.isX.present ? data.isX.value : this.isX,
      sequence: data.sequence.present ? data.sequence.value : this.sequence,
      shaftNumber: data.shaftNumber.present
          ? data.shaftNumber.value
          : this.shaftNumber,
      shaftId: data.shaftId.present ? data.shaftId.value : this.shaftId,
      nockRotation: data.nockRotation.present
          ? data.nockRotation.value
          : this.nockRotation,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Arrow(')
          ..write('id: $id, ')
          ..write('endId: $endId, ')
          ..write('faceIndex: $faceIndex, ')
          ..write('x: $x, ')
          ..write('y: $y, ')
          ..write('xMm: $xMm, ')
          ..write('yMm: $yMm, ')
          ..write('score: $score, ')
          ..write('isX: $isX, ')
          ..write('sequence: $sequence, ')
          ..write('shaftNumber: $shaftNumber, ')
          ..write('shaftId: $shaftId, ')
          ..write('nockRotation: $nockRotation, ')
          ..write('createdAt: $createdAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    endId,
    faceIndex,
    x,
    y,
    xMm,
    yMm,
    score,
    isX,
    sequence,
    shaftNumber,
    shaftId,
    nockRotation,
    createdAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Arrow &&
          other.id == this.id &&
          other.endId == this.endId &&
          other.faceIndex == this.faceIndex &&
          other.x == this.x &&
          other.y == this.y &&
          other.xMm == this.xMm &&
          other.yMm == this.yMm &&
          other.score == this.score &&
          other.isX == this.isX &&
          other.sequence == this.sequence &&
          other.shaftNumber == this.shaftNumber &&
          other.shaftId == this.shaftId &&
          other.nockRotation == this.nockRotation &&
          other.createdAt == this.createdAt);
}

class ArrowsCompanion extends UpdateCompanion<Arrow> {
  final Value<String> id;
  final Value<String> endId;
  final Value<int> faceIndex;
  final Value<double> x;
  final Value<double> y;
  final Value<double> xMm;
  final Value<double> yMm;
  final Value<int> score;
  final Value<bool> isX;
  final Value<int> sequence;
  final Value<int?> shaftNumber;
  final Value<String?> shaftId;
  final Value<String?> nockRotation;
  final Value<DateTime> createdAt;
  final Value<int> rowid;
  const ArrowsCompanion({
    this.id = const Value.absent(),
    this.endId = const Value.absent(),
    this.faceIndex = const Value.absent(),
    this.x = const Value.absent(),
    this.y = const Value.absent(),
    this.xMm = const Value.absent(),
    this.yMm = const Value.absent(),
    this.score = const Value.absent(),
    this.isX = const Value.absent(),
    this.sequence = const Value.absent(),
    this.shaftNumber = const Value.absent(),
    this.shaftId = const Value.absent(),
    this.nockRotation = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  ArrowsCompanion.insert({
    required String id,
    required String endId,
    this.faceIndex = const Value.absent(),
    required double x,
    required double y,
    this.xMm = const Value.absent(),
    this.yMm = const Value.absent(),
    required int score,
    this.isX = const Value.absent(),
    required int sequence,
    this.shaftNumber = const Value.absent(),
    this.shaftId = const Value.absent(),
    this.nockRotation = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       endId = Value(endId),
       x = Value(x),
       y = Value(y),
       score = Value(score),
       sequence = Value(sequence);
  static Insertable<Arrow> custom({
    Expression<String>? id,
    Expression<String>? endId,
    Expression<int>? faceIndex,
    Expression<double>? x,
    Expression<double>? y,
    Expression<double>? xMm,
    Expression<double>? yMm,
    Expression<int>? score,
    Expression<bool>? isX,
    Expression<int>? sequence,
    Expression<int>? shaftNumber,
    Expression<String>? shaftId,
    Expression<String>? nockRotation,
    Expression<DateTime>? createdAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (endId != null) 'end_id': endId,
      if (faceIndex != null) 'face_index': faceIndex,
      if (x != null) 'x': x,
      if (y != null) 'y': y,
      if (xMm != null) 'x_mm': xMm,
      if (yMm != null) 'y_mm': yMm,
      if (score != null) 'score': score,
      if (isX != null) 'is_x': isX,
      if (sequence != null) 'sequence': sequence,
      if (shaftNumber != null) 'shaft_number': shaftNumber,
      if (shaftId != null) 'shaft_id': shaftId,
      if (nockRotation != null) 'nock_rotation': nockRotation,
      if (createdAt != null) 'created_at': createdAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  ArrowsCompanion copyWith({
    Value<String>? id,
    Value<String>? endId,
    Value<int>? faceIndex,
    Value<double>? x,
    Value<double>? y,
    Value<double>? xMm,
    Value<double>? yMm,
    Value<int>? score,
    Value<bool>? isX,
    Value<int>? sequence,
    Value<int?>? shaftNumber,
    Value<String?>? shaftId,
    Value<String?>? nockRotation,
    Value<DateTime>? createdAt,
    Value<int>? rowid,
  }) {
    return ArrowsCompanion(
      id: id ?? this.id,
      endId: endId ?? this.endId,
      faceIndex: faceIndex ?? this.faceIndex,
      x: x ?? this.x,
      y: y ?? this.y,
      xMm: xMm ?? this.xMm,
      yMm: yMm ?? this.yMm,
      score: score ?? this.score,
      isX: isX ?? this.isX,
      sequence: sequence ?? this.sequence,
      shaftNumber: shaftNumber ?? this.shaftNumber,
      shaftId: shaftId ?? this.shaftId,
      nockRotation: nockRotation ?? this.nockRotation,
      createdAt: createdAt ?? this.createdAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (endId.present) {
      map['end_id'] = Variable<String>(endId.value);
    }
    if (faceIndex.present) {
      map['face_index'] = Variable<int>(faceIndex.value);
    }
    if (x.present) {
      map['x'] = Variable<double>(x.value);
    }
    if (y.present) {
      map['y'] = Variable<double>(y.value);
    }
    if (xMm.present) {
      map['x_mm'] = Variable<double>(xMm.value);
    }
    if (yMm.present) {
      map['y_mm'] = Variable<double>(yMm.value);
    }
    if (score.present) {
      map['score'] = Variable<int>(score.value);
    }
    if (isX.present) {
      map['is_x'] = Variable<bool>(isX.value);
    }
    if (sequence.present) {
      map['sequence'] = Variable<int>(sequence.value);
    }
    if (shaftNumber.present) {
      map['shaft_number'] = Variable<int>(shaftNumber.value);
    }
    if (shaftId.present) {
      map['shaft_id'] = Variable<String>(shaftId.value);
    }
    if (nockRotation.present) {
      map['nock_rotation'] = Variable<String>(nockRotation.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ArrowsCompanion(')
          ..write('id: $id, ')
          ..write('endId: $endId, ')
          ..write('faceIndex: $faceIndex, ')
          ..write('x: $x, ')
          ..write('y: $y, ')
          ..write('xMm: $xMm, ')
          ..write('yMm: $yMm, ')
          ..write('score: $score, ')
          ..write('isX: $isX, ')
          ..write('sequence: $sequence, ')
          ..write('shaftNumber: $shaftNumber, ')
          ..write('shaftId: $shaftId, ')
          ..write('nockRotation: $nockRotation, ')
          ..write('createdAt: $createdAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $ImportedScoresTable extends ImportedScores
    with TableInfo<$ImportedScoresTable, ImportedScore> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ImportedScoresTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _dateMeta = const VerificationMeta('date');
  @override
  late final GeneratedColumn<DateTime> date = GeneratedColumn<DateTime>(
    'date',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _roundNameMeta = const VerificationMeta(
    'roundName',
  );
  @override
  late final GeneratedColumn<String> roundName = GeneratedColumn<String>(
    'round_name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _scoreMeta = const VerificationMeta('score');
  @override
  late final GeneratedColumn<int> score = GeneratedColumn<int>(
    'score',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _xCountMeta = const VerificationMeta('xCount');
  @override
  late final GeneratedColumn<int> xCount = GeneratedColumn<int>(
    'x_count',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _locationMeta = const VerificationMeta(
    'location',
  );
  @override
  late final GeneratedColumn<String> location = GeneratedColumn<String>(
    'location',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _notesMeta = const VerificationMeta('notes');
  @override
  late final GeneratedColumn<String> notes = GeneratedColumn<String>(
    'notes',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _sessionTypeMeta = const VerificationMeta(
    'sessionType',
  );
  @override
  late final GeneratedColumn<String> sessionType = GeneratedColumn<String>(
    'session_type',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('competition'),
  );
  static const VerificationMeta _sourceMeta = const VerificationMeta('source');
  @override
  late final GeneratedColumn<String> source = GeneratedColumn<String>(
    'source',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('manual'),
  );
  static const VerificationMeta _importedAtMeta = const VerificationMeta(
    'importedAt',
  );
  @override
  late final GeneratedColumn<DateTime> importedAt = GeneratedColumn<DateTime>(
    'imported_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    date,
    roundName,
    score,
    xCount,
    location,
    notes,
    sessionType,
    source,
    importedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'imported_scores';
  @override
  VerificationContext validateIntegrity(
    Insertable<ImportedScore> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('date')) {
      context.handle(
        _dateMeta,
        date.isAcceptableOrUnknown(data['date']!, _dateMeta),
      );
    } else if (isInserting) {
      context.missing(_dateMeta);
    }
    if (data.containsKey('round_name')) {
      context.handle(
        _roundNameMeta,
        roundName.isAcceptableOrUnknown(data['round_name']!, _roundNameMeta),
      );
    } else if (isInserting) {
      context.missing(_roundNameMeta);
    }
    if (data.containsKey('score')) {
      context.handle(
        _scoreMeta,
        score.isAcceptableOrUnknown(data['score']!, _scoreMeta),
      );
    } else if (isInserting) {
      context.missing(_scoreMeta);
    }
    if (data.containsKey('x_count')) {
      context.handle(
        _xCountMeta,
        xCount.isAcceptableOrUnknown(data['x_count']!, _xCountMeta),
      );
    }
    if (data.containsKey('location')) {
      context.handle(
        _locationMeta,
        location.isAcceptableOrUnknown(data['location']!, _locationMeta),
      );
    }
    if (data.containsKey('notes')) {
      context.handle(
        _notesMeta,
        notes.isAcceptableOrUnknown(data['notes']!, _notesMeta),
      );
    }
    if (data.containsKey('session_type')) {
      context.handle(
        _sessionTypeMeta,
        sessionType.isAcceptableOrUnknown(
          data['session_type']!,
          _sessionTypeMeta,
        ),
      );
    }
    if (data.containsKey('source')) {
      context.handle(
        _sourceMeta,
        source.isAcceptableOrUnknown(data['source']!, _sourceMeta),
      );
    }
    if (data.containsKey('imported_at')) {
      context.handle(
        _importedAtMeta,
        importedAt.isAcceptableOrUnknown(data['imported_at']!, _importedAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  ImportedScore map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ImportedScore(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      date: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}date'],
      )!,
      roundName: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}round_name'],
      )!,
      score: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}score'],
      )!,
      xCount: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}x_count'],
      ),
      location: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}location'],
      ),
      notes: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}notes'],
      ),
      sessionType: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}session_type'],
      )!,
      source: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}source'],
      )!,
      importedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}imported_at'],
      )!,
    );
  }

  @override
  $ImportedScoresTable createAlias(String alias) {
    return $ImportedScoresTable(attachedDatabase, alias);
  }
}

class ImportedScore extends DataClass implements Insertable<ImportedScore> {
  final String id;
  final DateTime date;
  final String roundName;
  final int score;
  final int? xCount;
  final String? location;
  final String? notes;
  final String sessionType;
  final String source;
  final DateTime importedAt;
  const ImportedScore({
    required this.id,
    required this.date,
    required this.roundName,
    required this.score,
    this.xCount,
    this.location,
    this.notes,
    required this.sessionType,
    required this.source,
    required this.importedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['date'] = Variable<DateTime>(date);
    map['round_name'] = Variable<String>(roundName);
    map['score'] = Variable<int>(score);
    if (!nullToAbsent || xCount != null) {
      map['x_count'] = Variable<int>(xCount);
    }
    if (!nullToAbsent || location != null) {
      map['location'] = Variable<String>(location);
    }
    if (!nullToAbsent || notes != null) {
      map['notes'] = Variable<String>(notes);
    }
    map['session_type'] = Variable<String>(sessionType);
    map['source'] = Variable<String>(source);
    map['imported_at'] = Variable<DateTime>(importedAt);
    return map;
  }

  ImportedScoresCompanion toCompanion(bool nullToAbsent) {
    return ImportedScoresCompanion(
      id: Value(id),
      date: Value(date),
      roundName: Value(roundName),
      score: Value(score),
      xCount: xCount == null && nullToAbsent
          ? const Value.absent()
          : Value(xCount),
      location: location == null && nullToAbsent
          ? const Value.absent()
          : Value(location),
      notes: notes == null && nullToAbsent
          ? const Value.absent()
          : Value(notes),
      sessionType: Value(sessionType),
      source: Value(source),
      importedAt: Value(importedAt),
    );
  }

  factory ImportedScore.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ImportedScore(
      id: serializer.fromJson<String>(json['id']),
      date: serializer.fromJson<DateTime>(json['date']),
      roundName: serializer.fromJson<String>(json['roundName']),
      score: serializer.fromJson<int>(json['score']),
      xCount: serializer.fromJson<int?>(json['xCount']),
      location: serializer.fromJson<String?>(json['location']),
      notes: serializer.fromJson<String?>(json['notes']),
      sessionType: serializer.fromJson<String>(json['sessionType']),
      source: serializer.fromJson<String>(json['source']),
      importedAt: serializer.fromJson<DateTime>(json['importedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'date': serializer.toJson<DateTime>(date),
      'roundName': serializer.toJson<String>(roundName),
      'score': serializer.toJson<int>(score),
      'xCount': serializer.toJson<int?>(xCount),
      'location': serializer.toJson<String?>(location),
      'notes': serializer.toJson<String?>(notes),
      'sessionType': serializer.toJson<String>(sessionType),
      'source': serializer.toJson<String>(source),
      'importedAt': serializer.toJson<DateTime>(importedAt),
    };
  }

  ImportedScore copyWith({
    String? id,
    DateTime? date,
    String? roundName,
    int? score,
    Value<int?> xCount = const Value.absent(),
    Value<String?> location = const Value.absent(),
    Value<String?> notes = const Value.absent(),
    String? sessionType,
    String? source,
    DateTime? importedAt,
  }) => ImportedScore(
    id: id ?? this.id,
    date: date ?? this.date,
    roundName: roundName ?? this.roundName,
    score: score ?? this.score,
    xCount: xCount.present ? xCount.value : this.xCount,
    location: location.present ? location.value : this.location,
    notes: notes.present ? notes.value : this.notes,
    sessionType: sessionType ?? this.sessionType,
    source: source ?? this.source,
    importedAt: importedAt ?? this.importedAt,
  );
  ImportedScore copyWithCompanion(ImportedScoresCompanion data) {
    return ImportedScore(
      id: data.id.present ? data.id.value : this.id,
      date: data.date.present ? data.date.value : this.date,
      roundName: data.roundName.present ? data.roundName.value : this.roundName,
      score: data.score.present ? data.score.value : this.score,
      xCount: data.xCount.present ? data.xCount.value : this.xCount,
      location: data.location.present ? data.location.value : this.location,
      notes: data.notes.present ? data.notes.value : this.notes,
      sessionType: data.sessionType.present
          ? data.sessionType.value
          : this.sessionType,
      source: data.source.present ? data.source.value : this.source,
      importedAt: data.importedAt.present
          ? data.importedAt.value
          : this.importedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('ImportedScore(')
          ..write('id: $id, ')
          ..write('date: $date, ')
          ..write('roundName: $roundName, ')
          ..write('score: $score, ')
          ..write('xCount: $xCount, ')
          ..write('location: $location, ')
          ..write('notes: $notes, ')
          ..write('sessionType: $sessionType, ')
          ..write('source: $source, ')
          ..write('importedAt: $importedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    date,
    roundName,
    score,
    xCount,
    location,
    notes,
    sessionType,
    source,
    importedAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ImportedScore &&
          other.id == this.id &&
          other.date == this.date &&
          other.roundName == this.roundName &&
          other.score == this.score &&
          other.xCount == this.xCount &&
          other.location == this.location &&
          other.notes == this.notes &&
          other.sessionType == this.sessionType &&
          other.source == this.source &&
          other.importedAt == this.importedAt);
}

class ImportedScoresCompanion extends UpdateCompanion<ImportedScore> {
  final Value<String> id;
  final Value<DateTime> date;
  final Value<String> roundName;
  final Value<int> score;
  final Value<int?> xCount;
  final Value<String?> location;
  final Value<String?> notes;
  final Value<String> sessionType;
  final Value<String> source;
  final Value<DateTime> importedAt;
  final Value<int> rowid;
  const ImportedScoresCompanion({
    this.id = const Value.absent(),
    this.date = const Value.absent(),
    this.roundName = const Value.absent(),
    this.score = const Value.absent(),
    this.xCount = const Value.absent(),
    this.location = const Value.absent(),
    this.notes = const Value.absent(),
    this.sessionType = const Value.absent(),
    this.source = const Value.absent(),
    this.importedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  ImportedScoresCompanion.insert({
    required String id,
    required DateTime date,
    required String roundName,
    required int score,
    this.xCount = const Value.absent(),
    this.location = const Value.absent(),
    this.notes = const Value.absent(),
    this.sessionType = const Value.absent(),
    this.source = const Value.absent(),
    this.importedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       date = Value(date),
       roundName = Value(roundName),
       score = Value(score);
  static Insertable<ImportedScore> custom({
    Expression<String>? id,
    Expression<DateTime>? date,
    Expression<String>? roundName,
    Expression<int>? score,
    Expression<int>? xCount,
    Expression<String>? location,
    Expression<String>? notes,
    Expression<String>? sessionType,
    Expression<String>? source,
    Expression<DateTime>? importedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (date != null) 'date': date,
      if (roundName != null) 'round_name': roundName,
      if (score != null) 'score': score,
      if (xCount != null) 'x_count': xCount,
      if (location != null) 'location': location,
      if (notes != null) 'notes': notes,
      if (sessionType != null) 'session_type': sessionType,
      if (source != null) 'source': source,
      if (importedAt != null) 'imported_at': importedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  ImportedScoresCompanion copyWith({
    Value<String>? id,
    Value<DateTime>? date,
    Value<String>? roundName,
    Value<int>? score,
    Value<int?>? xCount,
    Value<String?>? location,
    Value<String?>? notes,
    Value<String>? sessionType,
    Value<String>? source,
    Value<DateTime>? importedAt,
    Value<int>? rowid,
  }) {
    return ImportedScoresCompanion(
      id: id ?? this.id,
      date: date ?? this.date,
      roundName: roundName ?? this.roundName,
      score: score ?? this.score,
      xCount: xCount ?? this.xCount,
      location: location ?? this.location,
      notes: notes ?? this.notes,
      sessionType: sessionType ?? this.sessionType,
      source: source ?? this.source,
      importedAt: importedAt ?? this.importedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (date.present) {
      map['date'] = Variable<DateTime>(date.value);
    }
    if (roundName.present) {
      map['round_name'] = Variable<String>(roundName.value);
    }
    if (score.present) {
      map['score'] = Variable<int>(score.value);
    }
    if (xCount.present) {
      map['x_count'] = Variable<int>(xCount.value);
    }
    if (location.present) {
      map['location'] = Variable<String>(location.value);
    }
    if (notes.present) {
      map['notes'] = Variable<String>(notes.value);
    }
    if (sessionType.present) {
      map['session_type'] = Variable<String>(sessionType.value);
    }
    if (source.present) {
      map['source'] = Variable<String>(source.value);
    }
    if (importedAt.present) {
      map['imported_at'] = Variable<DateTime>(importedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ImportedScoresCompanion(')
          ..write('id: $id, ')
          ..write('date: $date, ')
          ..write('roundName: $roundName, ')
          ..write('score: $score, ')
          ..write('xCount: $xCount, ')
          ..write('location: $location, ')
          ..write('notes: $notes, ')
          ..write('sessionType: $sessionType, ')
          ..write('source: $source, ')
          ..write('importedAt: $importedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $UserPreferencesTable extends UserPreferences
    with TableInfo<$UserPreferencesTable, UserPreference> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $UserPreferencesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _keyMeta = const VerificationMeta('key');
  @override
  late final GeneratedColumn<String> key = GeneratedColumn<String>(
    'key',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _valueMeta = const VerificationMeta('value');
  @override
  late final GeneratedColumn<String> value = GeneratedColumn<String>(
    'value',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [key, value];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'user_preferences';
  @override
  VerificationContext validateIntegrity(
    Insertable<UserPreference> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('key')) {
      context.handle(
        _keyMeta,
        key.isAcceptableOrUnknown(data['key']!, _keyMeta),
      );
    } else if (isInserting) {
      context.missing(_keyMeta);
    }
    if (data.containsKey('value')) {
      context.handle(
        _valueMeta,
        value.isAcceptableOrUnknown(data['value']!, _valueMeta),
      );
    } else if (isInserting) {
      context.missing(_valueMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {key};
  @override
  UserPreference map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return UserPreference(
      key: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}key'],
      )!,
      value: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}value'],
      )!,
    );
  }

  @override
  $UserPreferencesTable createAlias(String alias) {
    return $UserPreferencesTable(attachedDatabase, alias);
  }
}

class UserPreference extends DataClass implements Insertable<UserPreference> {
  final String key;
  final String value;
  const UserPreference({required this.key, required this.value});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['key'] = Variable<String>(key);
    map['value'] = Variable<String>(value);
    return map;
  }

  UserPreferencesCompanion toCompanion(bool nullToAbsent) {
    return UserPreferencesCompanion(key: Value(key), value: Value(value));
  }

  factory UserPreference.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return UserPreference(
      key: serializer.fromJson<String>(json['key']),
      value: serializer.fromJson<String>(json['value']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'key': serializer.toJson<String>(key),
      'value': serializer.toJson<String>(value),
    };
  }

  UserPreference copyWith({String? key, String? value}) =>
      UserPreference(key: key ?? this.key, value: value ?? this.value);
  UserPreference copyWithCompanion(UserPreferencesCompanion data) {
    return UserPreference(
      key: data.key.present ? data.key.value : this.key,
      value: data.value.present ? data.value.value : this.value,
    );
  }

  @override
  String toString() {
    return (StringBuffer('UserPreference(')
          ..write('key: $key, ')
          ..write('value: $value')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(key, value);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is UserPreference &&
          other.key == this.key &&
          other.value == this.value);
}

class UserPreferencesCompanion extends UpdateCompanion<UserPreference> {
  final Value<String> key;
  final Value<String> value;
  final Value<int> rowid;
  const UserPreferencesCompanion({
    this.key = const Value.absent(),
    this.value = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  UserPreferencesCompanion.insert({
    required String key,
    required String value,
    this.rowid = const Value.absent(),
  }) : key = Value(key),
       value = Value(value);
  static Insertable<UserPreference> custom({
    Expression<String>? key,
    Expression<String>? value,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (key != null) 'key': key,
      if (value != null) 'value': value,
      if (rowid != null) 'rowid': rowid,
    });
  }

  UserPreferencesCompanion copyWith({
    Value<String>? key,
    Value<String>? value,
    Value<int>? rowid,
  }) {
    return UserPreferencesCompanion(
      key: key ?? this.key,
      value: value ?? this.value,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (key.present) {
      map['key'] = Variable<String>(key.value);
    }
    if (value.present) {
      map['value'] = Variable<String>(value.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('UserPreferencesCompanion(')
          ..write('key: $key, ')
          ..write('value: $value, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $FingerTabsTable extends FingerTabs
    with TableInfo<$FingerTabsTable, FingerTab> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $FingerTabsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _makeMeta = const VerificationMeta('make');
  @override
  late final GeneratedColumn<String> make = GeneratedColumn<String>(
    'make',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _modelMeta = const VerificationMeta('model');
  @override
  late final GeneratedColumn<String> model = GeneratedColumn<String>(
    'model',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _sizeMeta = const VerificationMeta('size');
  @override
  late final GeneratedColumn<String> size = GeneratedColumn<String>(
    'size',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _plateTypeMeta = const VerificationMeta(
    'plateType',
  );
  @override
  late final GeneratedColumn<String> plateType = GeneratedColumn<String>(
    'plate_type',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _fingerSpacerMeta = const VerificationMeta(
    'fingerSpacer',
  );
  @override
  late final GeneratedColumn<String> fingerSpacer = GeneratedColumn<String>(
    'finger_spacer',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _notesMeta = const VerificationMeta('notes');
  @override
  late final GeneratedColumn<String> notes = GeneratedColumn<String>(
    'notes',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _isDefaultMeta = const VerificationMeta(
    'isDefault',
  );
  @override
  late final GeneratedColumn<bool> isDefault = GeneratedColumn<bool>(
    'is_default',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_default" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _deletedAtMeta = const VerificationMeta(
    'deletedAt',
  );
  @override
  late final GeneratedColumn<DateTime> deletedAt = GeneratedColumn<DateTime>(
    'deleted_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    name,
    make,
    model,
    size,
    plateType,
    fingerSpacer,
    notes,
    isDefault,
    createdAt,
    updatedAt,
    deletedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'finger_tabs';
  @override
  VerificationContext validateIntegrity(
    Insertable<FingerTab> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('make')) {
      context.handle(
        _makeMeta,
        make.isAcceptableOrUnknown(data['make']!, _makeMeta),
      );
    }
    if (data.containsKey('model')) {
      context.handle(
        _modelMeta,
        model.isAcceptableOrUnknown(data['model']!, _modelMeta),
      );
    }
    if (data.containsKey('size')) {
      context.handle(
        _sizeMeta,
        size.isAcceptableOrUnknown(data['size']!, _sizeMeta),
      );
    }
    if (data.containsKey('plate_type')) {
      context.handle(
        _plateTypeMeta,
        plateType.isAcceptableOrUnknown(data['plate_type']!, _plateTypeMeta),
      );
    }
    if (data.containsKey('finger_spacer')) {
      context.handle(
        _fingerSpacerMeta,
        fingerSpacer.isAcceptableOrUnknown(
          data['finger_spacer']!,
          _fingerSpacerMeta,
        ),
      );
    }
    if (data.containsKey('notes')) {
      context.handle(
        _notesMeta,
        notes.isAcceptableOrUnknown(data['notes']!, _notesMeta),
      );
    }
    if (data.containsKey('is_default')) {
      context.handle(
        _isDefaultMeta,
        isDefault.isAcceptableOrUnknown(data['is_default']!, _isDefaultMeta),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    }
    if (data.containsKey('deleted_at')) {
      context.handle(
        _deletedAtMeta,
        deletedAt.isAcceptableOrUnknown(data['deleted_at']!, _deletedAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  FingerTab map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return FingerTab(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      make: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}make'],
      ),
      model: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}model'],
      ),
      size: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}size'],
      ),
      plateType: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}plate_type'],
      ),
      fingerSpacer: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}finger_spacer'],
      ),
      notes: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}notes'],
      ),
      isDefault: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_default'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      )!,
      deletedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}deleted_at'],
      ),
    );
  }

  @override
  $FingerTabsTable createAlias(String alias) {
    return $FingerTabsTable(attachedDatabase, alias);
  }
}

class FingerTab extends DataClass implements Insertable<FingerTab> {
  final String id;
  final String name;
  final String? make;
  final String? model;
  final String? size;
  final String? plateType;
  final String? fingerSpacer;
  final String? notes;
  final bool isDefault;
  final DateTime createdAt;
  final DateTime updatedAt;
  final DateTime? deletedAt;
  const FingerTab({
    required this.id,
    required this.name,
    this.make,
    this.model,
    this.size,
    this.plateType,
    this.fingerSpacer,
    this.notes,
    required this.isDefault,
    required this.createdAt,
    required this.updatedAt,
    this.deletedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['name'] = Variable<String>(name);
    if (!nullToAbsent || make != null) {
      map['make'] = Variable<String>(make);
    }
    if (!nullToAbsent || model != null) {
      map['model'] = Variable<String>(model);
    }
    if (!nullToAbsent || size != null) {
      map['size'] = Variable<String>(size);
    }
    if (!nullToAbsent || plateType != null) {
      map['plate_type'] = Variable<String>(plateType);
    }
    if (!nullToAbsent || fingerSpacer != null) {
      map['finger_spacer'] = Variable<String>(fingerSpacer);
    }
    if (!nullToAbsent || notes != null) {
      map['notes'] = Variable<String>(notes);
    }
    map['is_default'] = Variable<bool>(isDefault);
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    if (!nullToAbsent || deletedAt != null) {
      map['deleted_at'] = Variable<DateTime>(deletedAt);
    }
    return map;
  }

  FingerTabsCompanion toCompanion(bool nullToAbsent) {
    return FingerTabsCompanion(
      id: Value(id),
      name: Value(name),
      make: make == null && nullToAbsent ? const Value.absent() : Value(make),
      model: model == null && nullToAbsent
          ? const Value.absent()
          : Value(model),
      size: size == null && nullToAbsent ? const Value.absent() : Value(size),
      plateType: plateType == null && nullToAbsent
          ? const Value.absent()
          : Value(plateType),
      fingerSpacer: fingerSpacer == null && nullToAbsent
          ? const Value.absent()
          : Value(fingerSpacer),
      notes: notes == null && nullToAbsent
          ? const Value.absent()
          : Value(notes),
      isDefault: Value(isDefault),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
      deletedAt: deletedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(deletedAt),
    );
  }

  factory FingerTab.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return FingerTab(
      id: serializer.fromJson<String>(json['id']),
      name: serializer.fromJson<String>(json['name']),
      make: serializer.fromJson<String?>(json['make']),
      model: serializer.fromJson<String?>(json['model']),
      size: serializer.fromJson<String?>(json['size']),
      plateType: serializer.fromJson<String?>(json['plateType']),
      fingerSpacer: serializer.fromJson<String?>(json['fingerSpacer']),
      notes: serializer.fromJson<String?>(json['notes']),
      isDefault: serializer.fromJson<bool>(json['isDefault']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
      deletedAt: serializer.fromJson<DateTime?>(json['deletedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'name': serializer.toJson<String>(name),
      'make': serializer.toJson<String?>(make),
      'model': serializer.toJson<String?>(model),
      'size': serializer.toJson<String?>(size),
      'plateType': serializer.toJson<String?>(plateType),
      'fingerSpacer': serializer.toJson<String?>(fingerSpacer),
      'notes': serializer.toJson<String?>(notes),
      'isDefault': serializer.toJson<bool>(isDefault),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
      'deletedAt': serializer.toJson<DateTime?>(deletedAt),
    };
  }

  FingerTab copyWith({
    String? id,
    String? name,
    Value<String?> make = const Value.absent(),
    Value<String?> model = const Value.absent(),
    Value<String?> size = const Value.absent(),
    Value<String?> plateType = const Value.absent(),
    Value<String?> fingerSpacer = const Value.absent(),
    Value<String?> notes = const Value.absent(),
    bool? isDefault,
    DateTime? createdAt,
    DateTime? updatedAt,
    Value<DateTime?> deletedAt = const Value.absent(),
  }) => FingerTab(
    id: id ?? this.id,
    name: name ?? this.name,
    make: make.present ? make.value : this.make,
    model: model.present ? model.value : this.model,
    size: size.present ? size.value : this.size,
    plateType: plateType.present ? plateType.value : this.plateType,
    fingerSpacer: fingerSpacer.present ? fingerSpacer.value : this.fingerSpacer,
    notes: notes.present ? notes.value : this.notes,
    isDefault: isDefault ?? this.isDefault,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
    deletedAt: deletedAt.present ? deletedAt.value : this.deletedAt,
  );
  FingerTab copyWithCompanion(FingerTabsCompanion data) {
    return FingerTab(
      id: data.id.present ? data.id.value : this.id,
      name: data.name.present ? data.name.value : this.name,
      make: data.make.present ? data.make.value : this.make,
      model: data.model.present ? data.model.value : this.model,
      size: data.size.present ? data.size.value : this.size,
      plateType: data.plateType.present ? data.plateType.value : this.plateType,
      fingerSpacer: data.fingerSpacer.present
          ? data.fingerSpacer.value
          : this.fingerSpacer,
      notes: data.notes.present ? data.notes.value : this.notes,
      isDefault: data.isDefault.present ? data.isDefault.value : this.isDefault,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
      deletedAt: data.deletedAt.present ? data.deletedAt.value : this.deletedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('FingerTab(')
          ..write('id: $id, ')
          ..write('name: $name, ')
          ..write('make: $make, ')
          ..write('model: $model, ')
          ..write('size: $size, ')
          ..write('plateType: $plateType, ')
          ..write('fingerSpacer: $fingerSpacer, ')
          ..write('notes: $notes, ')
          ..write('isDefault: $isDefault, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('deletedAt: $deletedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    name,
    make,
    model,
    size,
    plateType,
    fingerSpacer,
    notes,
    isDefault,
    createdAt,
    updatedAt,
    deletedAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is FingerTab &&
          other.id == this.id &&
          other.name == this.name &&
          other.make == this.make &&
          other.model == this.model &&
          other.size == this.size &&
          other.plateType == this.plateType &&
          other.fingerSpacer == this.fingerSpacer &&
          other.notes == this.notes &&
          other.isDefault == this.isDefault &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt &&
          other.deletedAt == this.deletedAt);
}

class FingerTabsCompanion extends UpdateCompanion<FingerTab> {
  final Value<String> id;
  final Value<String> name;
  final Value<String?> make;
  final Value<String?> model;
  final Value<String?> size;
  final Value<String?> plateType;
  final Value<String?> fingerSpacer;
  final Value<String?> notes;
  final Value<bool> isDefault;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  final Value<DateTime?> deletedAt;
  final Value<int> rowid;
  const FingerTabsCompanion({
    this.id = const Value.absent(),
    this.name = const Value.absent(),
    this.make = const Value.absent(),
    this.model = const Value.absent(),
    this.size = const Value.absent(),
    this.plateType = const Value.absent(),
    this.fingerSpacer = const Value.absent(),
    this.notes = const Value.absent(),
    this.isDefault = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.deletedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  FingerTabsCompanion.insert({
    required String id,
    required String name,
    this.make = const Value.absent(),
    this.model = const Value.absent(),
    this.size = const Value.absent(),
    this.plateType = const Value.absent(),
    this.fingerSpacer = const Value.absent(),
    this.notes = const Value.absent(),
    this.isDefault = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.deletedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       name = Value(name);
  static Insertable<FingerTab> custom({
    Expression<String>? id,
    Expression<String>? name,
    Expression<String>? make,
    Expression<String>? model,
    Expression<String>? size,
    Expression<String>? plateType,
    Expression<String>? fingerSpacer,
    Expression<String>? notes,
    Expression<bool>? isDefault,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
    Expression<DateTime>? deletedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (name != null) 'name': name,
      if (make != null) 'make': make,
      if (model != null) 'model': model,
      if (size != null) 'size': size,
      if (plateType != null) 'plate_type': plateType,
      if (fingerSpacer != null) 'finger_spacer': fingerSpacer,
      if (notes != null) 'notes': notes,
      if (isDefault != null) 'is_default': isDefault,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (deletedAt != null) 'deleted_at': deletedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  FingerTabsCompanion copyWith({
    Value<String>? id,
    Value<String>? name,
    Value<String?>? make,
    Value<String?>? model,
    Value<String?>? size,
    Value<String?>? plateType,
    Value<String?>? fingerSpacer,
    Value<String?>? notes,
    Value<bool>? isDefault,
    Value<DateTime>? createdAt,
    Value<DateTime>? updatedAt,
    Value<DateTime?>? deletedAt,
    Value<int>? rowid,
  }) {
    return FingerTabsCompanion(
      id: id ?? this.id,
      name: name ?? this.name,
      make: make ?? this.make,
      model: model ?? this.model,
      size: size ?? this.size,
      plateType: plateType ?? this.plateType,
      fingerSpacer: fingerSpacer ?? this.fingerSpacer,
      notes: notes ?? this.notes,
      isDefault: isDefault ?? this.isDefault,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      deletedAt: deletedAt ?? this.deletedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (make.present) {
      map['make'] = Variable<String>(make.value);
    }
    if (model.present) {
      map['model'] = Variable<String>(model.value);
    }
    if (size.present) {
      map['size'] = Variable<String>(size.value);
    }
    if (plateType.present) {
      map['plate_type'] = Variable<String>(plateType.value);
    }
    if (fingerSpacer.present) {
      map['finger_spacer'] = Variable<String>(fingerSpacer.value);
    }
    if (notes.present) {
      map['notes'] = Variable<String>(notes.value);
    }
    if (isDefault.present) {
      map['is_default'] = Variable<bool>(isDefault.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (deletedAt.present) {
      map['deleted_at'] = Variable<DateTime>(deletedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('FingerTabsCompanion(')
          ..write('id: $id, ')
          ..write('name: $name, ')
          ..write('make: $make, ')
          ..write('model: $model, ')
          ..write('size: $size, ')
          ..write('plateType: $plateType, ')
          ..write('fingerSpacer: $fingerSpacer, ')
          ..write('notes: $notes, ')
          ..write('isDefault: $isDefault, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('deletedAt: $deletedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $StabilizersTable extends Stabilizers
    with TableInfo<$StabilizersTable, Stabilizer> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $StabilizersTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _bowIdMeta = const VerificationMeta('bowId');
  @override
  late final GeneratedColumn<String> bowId = GeneratedColumn<String>(
    'bow_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES bows (id)',
    ),
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _longRodModelMeta = const VerificationMeta(
    'longRodModel',
  );
  @override
  late final GeneratedColumn<String> longRodModel = GeneratedColumn<String>(
    'long_rod_model',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _longRodLengthMeta = const VerificationMeta(
    'longRodLength',
  );
  @override
  late final GeneratedColumn<double> longRodLength = GeneratedColumn<double>(
    'long_rod_length',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _longRodWeightMeta = const VerificationMeta(
    'longRodWeight',
  );
  @override
  late final GeneratedColumn<double> longRodWeight = GeneratedColumn<double>(
    'long_rod_weight',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _longRodPurchaseDateMeta =
      const VerificationMeta('longRodPurchaseDate');
  @override
  late final GeneratedColumn<DateTime> longRodPurchaseDate =
      GeneratedColumn<DateTime>(
        'long_rod_purchase_date',
        aliasedName,
        true,
        type: DriftSqlType.dateTime,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _sideRodModelMeta = const VerificationMeta(
    'sideRodModel',
  );
  @override
  late final GeneratedColumn<String> sideRodModel = GeneratedColumn<String>(
    'side_rod_model',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _sideRodLengthMeta = const VerificationMeta(
    'sideRodLength',
  );
  @override
  late final GeneratedColumn<double> sideRodLength = GeneratedColumn<double>(
    'side_rod_length',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _sideRodWeightMeta = const VerificationMeta(
    'sideRodWeight',
  );
  @override
  late final GeneratedColumn<double> sideRodWeight = GeneratedColumn<double>(
    'side_rod_weight',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _sideRodPurchaseDateMeta =
      const VerificationMeta('sideRodPurchaseDate');
  @override
  late final GeneratedColumn<DateTime> sideRodPurchaseDate =
      GeneratedColumn<DateTime>(
        'side_rod_purchase_date',
        aliasedName,
        true,
        type: DriftSqlType.dateTime,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _extenderLengthMeta = const VerificationMeta(
    'extenderLength',
  );
  @override
  late final GeneratedColumn<double> extenderLength = GeneratedColumn<double>(
    'extender_length',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _vbarModelMeta = const VerificationMeta(
    'vbarModel',
  );
  @override
  late final GeneratedColumn<String> vbarModel = GeneratedColumn<String>(
    'vbar_model',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _vbarAngleHorizontalMeta =
      const VerificationMeta('vbarAngleHorizontal');
  @override
  late final GeneratedColumn<double> vbarAngleHorizontal =
      GeneratedColumn<double>(
        'vbar_angle_horizontal',
        aliasedName,
        true,
        type: DriftSqlType.double,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _vbarAngleVerticalMeta = const VerificationMeta(
    'vbarAngleVertical',
  );
  @override
  late final GeneratedColumn<double> vbarAngleVertical =
      GeneratedColumn<double>(
        'vbar_angle_vertical',
        aliasedName,
        true,
        type: DriftSqlType.double,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _weightArrangementMeta = const VerificationMeta(
    'weightArrangement',
  );
  @override
  late final GeneratedColumn<String> weightArrangement =
      GeneratedColumn<String>(
        'weight_arrangement',
        aliasedName,
        true,
        type: DriftSqlType.string,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _damperModelMeta = const VerificationMeta(
    'damperModel',
  );
  @override
  late final GeneratedColumn<String> damperModel = GeneratedColumn<String>(
    'damper_model',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _damperPositionsMeta = const VerificationMeta(
    'damperPositions',
  );
  @override
  late final GeneratedColumn<String> damperPositions = GeneratedColumn<String>(
    'damper_positions',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _notesMeta = const VerificationMeta('notes');
  @override
  late final GeneratedColumn<String> notes = GeneratedColumn<String>(
    'notes',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    bowId,
    name,
    longRodModel,
    longRodLength,
    longRodWeight,
    longRodPurchaseDate,
    sideRodModel,
    sideRodLength,
    sideRodWeight,
    sideRodPurchaseDate,
    extenderLength,
    vbarModel,
    vbarAngleHorizontal,
    vbarAngleVertical,
    weightArrangement,
    damperModel,
    damperPositions,
    notes,
    createdAt,
    updatedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'stabilizers';
  @override
  VerificationContext validateIntegrity(
    Insertable<Stabilizer> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('bow_id')) {
      context.handle(
        _bowIdMeta,
        bowId.isAcceptableOrUnknown(data['bow_id']!, _bowIdMeta),
      );
    } else if (isInserting) {
      context.missing(_bowIdMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    }
    if (data.containsKey('long_rod_model')) {
      context.handle(
        _longRodModelMeta,
        longRodModel.isAcceptableOrUnknown(
          data['long_rod_model']!,
          _longRodModelMeta,
        ),
      );
    }
    if (data.containsKey('long_rod_length')) {
      context.handle(
        _longRodLengthMeta,
        longRodLength.isAcceptableOrUnknown(
          data['long_rod_length']!,
          _longRodLengthMeta,
        ),
      );
    }
    if (data.containsKey('long_rod_weight')) {
      context.handle(
        _longRodWeightMeta,
        longRodWeight.isAcceptableOrUnknown(
          data['long_rod_weight']!,
          _longRodWeightMeta,
        ),
      );
    }
    if (data.containsKey('long_rod_purchase_date')) {
      context.handle(
        _longRodPurchaseDateMeta,
        longRodPurchaseDate.isAcceptableOrUnknown(
          data['long_rod_purchase_date']!,
          _longRodPurchaseDateMeta,
        ),
      );
    }
    if (data.containsKey('side_rod_model')) {
      context.handle(
        _sideRodModelMeta,
        sideRodModel.isAcceptableOrUnknown(
          data['side_rod_model']!,
          _sideRodModelMeta,
        ),
      );
    }
    if (data.containsKey('side_rod_length')) {
      context.handle(
        _sideRodLengthMeta,
        sideRodLength.isAcceptableOrUnknown(
          data['side_rod_length']!,
          _sideRodLengthMeta,
        ),
      );
    }
    if (data.containsKey('side_rod_weight')) {
      context.handle(
        _sideRodWeightMeta,
        sideRodWeight.isAcceptableOrUnknown(
          data['side_rod_weight']!,
          _sideRodWeightMeta,
        ),
      );
    }
    if (data.containsKey('side_rod_purchase_date')) {
      context.handle(
        _sideRodPurchaseDateMeta,
        sideRodPurchaseDate.isAcceptableOrUnknown(
          data['side_rod_purchase_date']!,
          _sideRodPurchaseDateMeta,
        ),
      );
    }
    if (data.containsKey('extender_length')) {
      context.handle(
        _extenderLengthMeta,
        extenderLength.isAcceptableOrUnknown(
          data['extender_length']!,
          _extenderLengthMeta,
        ),
      );
    }
    if (data.containsKey('vbar_model')) {
      context.handle(
        _vbarModelMeta,
        vbarModel.isAcceptableOrUnknown(data['vbar_model']!, _vbarModelMeta),
      );
    }
    if (data.containsKey('vbar_angle_horizontal')) {
      context.handle(
        _vbarAngleHorizontalMeta,
        vbarAngleHorizontal.isAcceptableOrUnknown(
          data['vbar_angle_horizontal']!,
          _vbarAngleHorizontalMeta,
        ),
      );
    }
    if (data.containsKey('vbar_angle_vertical')) {
      context.handle(
        _vbarAngleVerticalMeta,
        vbarAngleVertical.isAcceptableOrUnknown(
          data['vbar_angle_vertical']!,
          _vbarAngleVerticalMeta,
        ),
      );
    }
    if (data.containsKey('weight_arrangement')) {
      context.handle(
        _weightArrangementMeta,
        weightArrangement.isAcceptableOrUnknown(
          data['weight_arrangement']!,
          _weightArrangementMeta,
        ),
      );
    }
    if (data.containsKey('damper_model')) {
      context.handle(
        _damperModelMeta,
        damperModel.isAcceptableOrUnknown(
          data['damper_model']!,
          _damperModelMeta,
        ),
      );
    }
    if (data.containsKey('damper_positions')) {
      context.handle(
        _damperPositionsMeta,
        damperPositions.isAcceptableOrUnknown(
          data['damper_positions']!,
          _damperPositionsMeta,
        ),
      );
    }
    if (data.containsKey('notes')) {
      context.handle(
        _notesMeta,
        notes.isAcceptableOrUnknown(data['notes']!, _notesMeta),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  Stabilizer map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Stabilizer(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      bowId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}bow_id'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      ),
      longRodModel: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}long_rod_model'],
      ),
      longRodLength: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}long_rod_length'],
      ),
      longRodWeight: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}long_rod_weight'],
      ),
      longRodPurchaseDate: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}long_rod_purchase_date'],
      ),
      sideRodModel: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}side_rod_model'],
      ),
      sideRodLength: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}side_rod_length'],
      ),
      sideRodWeight: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}side_rod_weight'],
      ),
      sideRodPurchaseDate: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}side_rod_purchase_date'],
      ),
      extenderLength: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}extender_length'],
      ),
      vbarModel: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}vbar_model'],
      ),
      vbarAngleHorizontal: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}vbar_angle_horizontal'],
      ),
      vbarAngleVertical: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}vbar_angle_vertical'],
      ),
      weightArrangement: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}weight_arrangement'],
      ),
      damperModel: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}damper_model'],
      ),
      damperPositions: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}damper_positions'],
      ),
      notes: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}notes'],
      ),
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      )!,
    );
  }

  @override
  $StabilizersTable createAlias(String alias) {
    return $StabilizersTable(attachedDatabase, alias);
  }
}

class Stabilizer extends DataClass implements Insertable<Stabilizer> {
  final String id;
  final String bowId;
  final String? name;
  final String? longRodModel;
  final double? longRodLength;
  final double? longRodWeight;
  final DateTime? longRodPurchaseDate;
  final String? sideRodModel;
  final double? sideRodLength;
  final double? sideRodWeight;
  final DateTime? sideRodPurchaseDate;
  final double? extenderLength;
  final String? vbarModel;
  final double? vbarAngleHorizontal;
  final double? vbarAngleVertical;
  final String? weightArrangement;
  final String? damperModel;
  final String? damperPositions;
  final String? notes;
  final DateTime createdAt;
  final DateTime updatedAt;
  const Stabilizer({
    required this.id,
    required this.bowId,
    this.name,
    this.longRodModel,
    this.longRodLength,
    this.longRodWeight,
    this.longRodPurchaseDate,
    this.sideRodModel,
    this.sideRodLength,
    this.sideRodWeight,
    this.sideRodPurchaseDate,
    this.extenderLength,
    this.vbarModel,
    this.vbarAngleHorizontal,
    this.vbarAngleVertical,
    this.weightArrangement,
    this.damperModel,
    this.damperPositions,
    this.notes,
    required this.createdAt,
    required this.updatedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['bow_id'] = Variable<String>(bowId);
    if (!nullToAbsent || name != null) {
      map['name'] = Variable<String>(name);
    }
    if (!nullToAbsent || longRodModel != null) {
      map['long_rod_model'] = Variable<String>(longRodModel);
    }
    if (!nullToAbsent || longRodLength != null) {
      map['long_rod_length'] = Variable<double>(longRodLength);
    }
    if (!nullToAbsent || longRodWeight != null) {
      map['long_rod_weight'] = Variable<double>(longRodWeight);
    }
    if (!nullToAbsent || longRodPurchaseDate != null) {
      map['long_rod_purchase_date'] = Variable<DateTime>(longRodPurchaseDate);
    }
    if (!nullToAbsent || sideRodModel != null) {
      map['side_rod_model'] = Variable<String>(sideRodModel);
    }
    if (!nullToAbsent || sideRodLength != null) {
      map['side_rod_length'] = Variable<double>(sideRodLength);
    }
    if (!nullToAbsent || sideRodWeight != null) {
      map['side_rod_weight'] = Variable<double>(sideRodWeight);
    }
    if (!nullToAbsent || sideRodPurchaseDate != null) {
      map['side_rod_purchase_date'] = Variable<DateTime>(sideRodPurchaseDate);
    }
    if (!nullToAbsent || extenderLength != null) {
      map['extender_length'] = Variable<double>(extenderLength);
    }
    if (!nullToAbsent || vbarModel != null) {
      map['vbar_model'] = Variable<String>(vbarModel);
    }
    if (!nullToAbsent || vbarAngleHorizontal != null) {
      map['vbar_angle_horizontal'] = Variable<double>(vbarAngleHorizontal);
    }
    if (!nullToAbsent || vbarAngleVertical != null) {
      map['vbar_angle_vertical'] = Variable<double>(vbarAngleVertical);
    }
    if (!nullToAbsent || weightArrangement != null) {
      map['weight_arrangement'] = Variable<String>(weightArrangement);
    }
    if (!nullToAbsent || damperModel != null) {
      map['damper_model'] = Variable<String>(damperModel);
    }
    if (!nullToAbsent || damperPositions != null) {
      map['damper_positions'] = Variable<String>(damperPositions);
    }
    if (!nullToAbsent || notes != null) {
      map['notes'] = Variable<String>(notes);
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    return map;
  }

  StabilizersCompanion toCompanion(bool nullToAbsent) {
    return StabilizersCompanion(
      id: Value(id),
      bowId: Value(bowId),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      longRodModel: longRodModel == null && nullToAbsent
          ? const Value.absent()
          : Value(longRodModel),
      longRodLength: longRodLength == null && nullToAbsent
          ? const Value.absent()
          : Value(longRodLength),
      longRodWeight: longRodWeight == null && nullToAbsent
          ? const Value.absent()
          : Value(longRodWeight),
      longRodPurchaseDate: longRodPurchaseDate == null && nullToAbsent
          ? const Value.absent()
          : Value(longRodPurchaseDate),
      sideRodModel: sideRodModel == null && nullToAbsent
          ? const Value.absent()
          : Value(sideRodModel),
      sideRodLength: sideRodLength == null && nullToAbsent
          ? const Value.absent()
          : Value(sideRodLength),
      sideRodWeight: sideRodWeight == null && nullToAbsent
          ? const Value.absent()
          : Value(sideRodWeight),
      sideRodPurchaseDate: sideRodPurchaseDate == null && nullToAbsent
          ? const Value.absent()
          : Value(sideRodPurchaseDate),
      extenderLength: extenderLength == null && nullToAbsent
          ? const Value.absent()
          : Value(extenderLength),
      vbarModel: vbarModel == null && nullToAbsent
          ? const Value.absent()
          : Value(vbarModel),
      vbarAngleHorizontal: vbarAngleHorizontal == null && nullToAbsent
          ? const Value.absent()
          : Value(vbarAngleHorizontal),
      vbarAngleVertical: vbarAngleVertical == null && nullToAbsent
          ? const Value.absent()
          : Value(vbarAngleVertical),
      weightArrangement: weightArrangement == null && nullToAbsent
          ? const Value.absent()
          : Value(weightArrangement),
      damperModel: damperModel == null && nullToAbsent
          ? const Value.absent()
          : Value(damperModel),
      damperPositions: damperPositions == null && nullToAbsent
          ? const Value.absent()
          : Value(damperPositions),
      notes: notes == null && nullToAbsent
          ? const Value.absent()
          : Value(notes),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory Stabilizer.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Stabilizer(
      id: serializer.fromJson<String>(json['id']),
      bowId: serializer.fromJson<String>(json['bowId']),
      name: serializer.fromJson<String?>(json['name']),
      longRodModel: serializer.fromJson<String?>(json['longRodModel']),
      longRodLength: serializer.fromJson<double?>(json['longRodLength']),
      longRodWeight: serializer.fromJson<double?>(json['longRodWeight']),
      longRodPurchaseDate: serializer.fromJson<DateTime?>(
        json['longRodPurchaseDate'],
      ),
      sideRodModel: serializer.fromJson<String?>(json['sideRodModel']),
      sideRodLength: serializer.fromJson<double?>(json['sideRodLength']),
      sideRodWeight: serializer.fromJson<double?>(json['sideRodWeight']),
      sideRodPurchaseDate: serializer.fromJson<DateTime?>(
        json['sideRodPurchaseDate'],
      ),
      extenderLength: serializer.fromJson<double?>(json['extenderLength']),
      vbarModel: serializer.fromJson<String?>(json['vbarModel']),
      vbarAngleHorizontal: serializer.fromJson<double?>(
        json['vbarAngleHorizontal'],
      ),
      vbarAngleVertical: serializer.fromJson<double?>(
        json['vbarAngleVertical'],
      ),
      weightArrangement: serializer.fromJson<String?>(
        json['weightArrangement'],
      ),
      damperModel: serializer.fromJson<String?>(json['damperModel']),
      damperPositions: serializer.fromJson<String?>(json['damperPositions']),
      notes: serializer.fromJson<String?>(json['notes']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'bowId': serializer.toJson<String>(bowId),
      'name': serializer.toJson<String?>(name),
      'longRodModel': serializer.toJson<String?>(longRodModel),
      'longRodLength': serializer.toJson<double?>(longRodLength),
      'longRodWeight': serializer.toJson<double?>(longRodWeight),
      'longRodPurchaseDate': serializer.toJson<DateTime?>(longRodPurchaseDate),
      'sideRodModel': serializer.toJson<String?>(sideRodModel),
      'sideRodLength': serializer.toJson<double?>(sideRodLength),
      'sideRodWeight': serializer.toJson<double?>(sideRodWeight),
      'sideRodPurchaseDate': serializer.toJson<DateTime?>(sideRodPurchaseDate),
      'extenderLength': serializer.toJson<double?>(extenderLength),
      'vbarModel': serializer.toJson<String?>(vbarModel),
      'vbarAngleHorizontal': serializer.toJson<double?>(vbarAngleHorizontal),
      'vbarAngleVertical': serializer.toJson<double?>(vbarAngleVertical),
      'weightArrangement': serializer.toJson<String?>(weightArrangement),
      'damperModel': serializer.toJson<String?>(damperModel),
      'damperPositions': serializer.toJson<String?>(damperPositions),
      'notes': serializer.toJson<String?>(notes),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
    };
  }

  Stabilizer copyWith({
    String? id,
    String? bowId,
    Value<String?> name = const Value.absent(),
    Value<String?> longRodModel = const Value.absent(),
    Value<double?> longRodLength = const Value.absent(),
    Value<double?> longRodWeight = const Value.absent(),
    Value<DateTime?> longRodPurchaseDate = const Value.absent(),
    Value<String?> sideRodModel = const Value.absent(),
    Value<double?> sideRodLength = const Value.absent(),
    Value<double?> sideRodWeight = const Value.absent(),
    Value<DateTime?> sideRodPurchaseDate = const Value.absent(),
    Value<double?> extenderLength = const Value.absent(),
    Value<String?> vbarModel = const Value.absent(),
    Value<double?> vbarAngleHorizontal = const Value.absent(),
    Value<double?> vbarAngleVertical = const Value.absent(),
    Value<String?> weightArrangement = const Value.absent(),
    Value<String?> damperModel = const Value.absent(),
    Value<String?> damperPositions = const Value.absent(),
    Value<String?> notes = const Value.absent(),
    DateTime? createdAt,
    DateTime? updatedAt,
  }) => Stabilizer(
    id: id ?? this.id,
    bowId: bowId ?? this.bowId,
    name: name.present ? name.value : this.name,
    longRodModel: longRodModel.present ? longRodModel.value : this.longRodModel,
    longRodLength: longRodLength.present
        ? longRodLength.value
        : this.longRodLength,
    longRodWeight: longRodWeight.present
        ? longRodWeight.value
        : this.longRodWeight,
    longRodPurchaseDate: longRodPurchaseDate.present
        ? longRodPurchaseDate.value
        : this.longRodPurchaseDate,
    sideRodModel: sideRodModel.present ? sideRodModel.value : this.sideRodModel,
    sideRodLength: sideRodLength.present
        ? sideRodLength.value
        : this.sideRodLength,
    sideRodWeight: sideRodWeight.present
        ? sideRodWeight.value
        : this.sideRodWeight,
    sideRodPurchaseDate: sideRodPurchaseDate.present
        ? sideRodPurchaseDate.value
        : this.sideRodPurchaseDate,
    extenderLength: extenderLength.present
        ? extenderLength.value
        : this.extenderLength,
    vbarModel: vbarModel.present ? vbarModel.value : this.vbarModel,
    vbarAngleHorizontal: vbarAngleHorizontal.present
        ? vbarAngleHorizontal.value
        : this.vbarAngleHorizontal,
    vbarAngleVertical: vbarAngleVertical.present
        ? vbarAngleVertical.value
        : this.vbarAngleVertical,
    weightArrangement: weightArrangement.present
        ? weightArrangement.value
        : this.weightArrangement,
    damperModel: damperModel.present ? damperModel.value : this.damperModel,
    damperPositions: damperPositions.present
        ? damperPositions.value
        : this.damperPositions,
    notes: notes.present ? notes.value : this.notes,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
  );
  Stabilizer copyWithCompanion(StabilizersCompanion data) {
    return Stabilizer(
      id: data.id.present ? data.id.value : this.id,
      bowId: data.bowId.present ? data.bowId.value : this.bowId,
      name: data.name.present ? data.name.value : this.name,
      longRodModel: data.longRodModel.present
          ? data.longRodModel.value
          : this.longRodModel,
      longRodLength: data.longRodLength.present
          ? data.longRodLength.value
          : this.longRodLength,
      longRodWeight: data.longRodWeight.present
          ? data.longRodWeight.value
          : this.longRodWeight,
      longRodPurchaseDate: data.longRodPurchaseDate.present
          ? data.longRodPurchaseDate.value
          : this.longRodPurchaseDate,
      sideRodModel: data.sideRodModel.present
          ? data.sideRodModel.value
          : this.sideRodModel,
      sideRodLength: data.sideRodLength.present
          ? data.sideRodLength.value
          : this.sideRodLength,
      sideRodWeight: data.sideRodWeight.present
          ? data.sideRodWeight.value
          : this.sideRodWeight,
      sideRodPurchaseDate: data.sideRodPurchaseDate.present
          ? data.sideRodPurchaseDate.value
          : this.sideRodPurchaseDate,
      extenderLength: data.extenderLength.present
          ? data.extenderLength.value
          : this.extenderLength,
      vbarModel: data.vbarModel.present ? data.vbarModel.value : this.vbarModel,
      vbarAngleHorizontal: data.vbarAngleHorizontal.present
          ? data.vbarAngleHorizontal.value
          : this.vbarAngleHorizontal,
      vbarAngleVertical: data.vbarAngleVertical.present
          ? data.vbarAngleVertical.value
          : this.vbarAngleVertical,
      weightArrangement: data.weightArrangement.present
          ? data.weightArrangement.value
          : this.weightArrangement,
      damperModel: data.damperModel.present
          ? data.damperModel.value
          : this.damperModel,
      damperPositions: data.damperPositions.present
          ? data.damperPositions.value
          : this.damperPositions,
      notes: data.notes.present ? data.notes.value : this.notes,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Stabilizer(')
          ..write('id: $id, ')
          ..write('bowId: $bowId, ')
          ..write('name: $name, ')
          ..write('longRodModel: $longRodModel, ')
          ..write('longRodLength: $longRodLength, ')
          ..write('longRodWeight: $longRodWeight, ')
          ..write('longRodPurchaseDate: $longRodPurchaseDate, ')
          ..write('sideRodModel: $sideRodModel, ')
          ..write('sideRodLength: $sideRodLength, ')
          ..write('sideRodWeight: $sideRodWeight, ')
          ..write('sideRodPurchaseDate: $sideRodPurchaseDate, ')
          ..write('extenderLength: $extenderLength, ')
          ..write('vbarModel: $vbarModel, ')
          ..write('vbarAngleHorizontal: $vbarAngleHorizontal, ')
          ..write('vbarAngleVertical: $vbarAngleVertical, ')
          ..write('weightArrangement: $weightArrangement, ')
          ..write('damperModel: $damperModel, ')
          ..write('damperPositions: $damperPositions, ')
          ..write('notes: $notes, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hashAll([
    id,
    bowId,
    name,
    longRodModel,
    longRodLength,
    longRodWeight,
    longRodPurchaseDate,
    sideRodModel,
    sideRodLength,
    sideRodWeight,
    sideRodPurchaseDate,
    extenderLength,
    vbarModel,
    vbarAngleHorizontal,
    vbarAngleVertical,
    weightArrangement,
    damperModel,
    damperPositions,
    notes,
    createdAt,
    updatedAt,
  ]);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Stabilizer &&
          other.id == this.id &&
          other.bowId == this.bowId &&
          other.name == this.name &&
          other.longRodModel == this.longRodModel &&
          other.longRodLength == this.longRodLength &&
          other.longRodWeight == this.longRodWeight &&
          other.longRodPurchaseDate == this.longRodPurchaseDate &&
          other.sideRodModel == this.sideRodModel &&
          other.sideRodLength == this.sideRodLength &&
          other.sideRodWeight == this.sideRodWeight &&
          other.sideRodPurchaseDate == this.sideRodPurchaseDate &&
          other.extenderLength == this.extenderLength &&
          other.vbarModel == this.vbarModel &&
          other.vbarAngleHorizontal == this.vbarAngleHorizontal &&
          other.vbarAngleVertical == this.vbarAngleVertical &&
          other.weightArrangement == this.weightArrangement &&
          other.damperModel == this.damperModel &&
          other.damperPositions == this.damperPositions &&
          other.notes == this.notes &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class StabilizersCompanion extends UpdateCompanion<Stabilizer> {
  final Value<String> id;
  final Value<String> bowId;
  final Value<String?> name;
  final Value<String?> longRodModel;
  final Value<double?> longRodLength;
  final Value<double?> longRodWeight;
  final Value<DateTime?> longRodPurchaseDate;
  final Value<String?> sideRodModel;
  final Value<double?> sideRodLength;
  final Value<double?> sideRodWeight;
  final Value<DateTime?> sideRodPurchaseDate;
  final Value<double?> extenderLength;
  final Value<String?> vbarModel;
  final Value<double?> vbarAngleHorizontal;
  final Value<double?> vbarAngleVertical;
  final Value<String?> weightArrangement;
  final Value<String?> damperModel;
  final Value<String?> damperPositions;
  final Value<String?> notes;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  final Value<int> rowid;
  const StabilizersCompanion({
    this.id = const Value.absent(),
    this.bowId = const Value.absent(),
    this.name = const Value.absent(),
    this.longRodModel = const Value.absent(),
    this.longRodLength = const Value.absent(),
    this.longRodWeight = const Value.absent(),
    this.longRodPurchaseDate = const Value.absent(),
    this.sideRodModel = const Value.absent(),
    this.sideRodLength = const Value.absent(),
    this.sideRodWeight = const Value.absent(),
    this.sideRodPurchaseDate = const Value.absent(),
    this.extenderLength = const Value.absent(),
    this.vbarModel = const Value.absent(),
    this.vbarAngleHorizontal = const Value.absent(),
    this.vbarAngleVertical = const Value.absent(),
    this.weightArrangement = const Value.absent(),
    this.damperModel = const Value.absent(),
    this.damperPositions = const Value.absent(),
    this.notes = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  StabilizersCompanion.insert({
    required String id,
    required String bowId,
    this.name = const Value.absent(),
    this.longRodModel = const Value.absent(),
    this.longRodLength = const Value.absent(),
    this.longRodWeight = const Value.absent(),
    this.longRodPurchaseDate = const Value.absent(),
    this.sideRodModel = const Value.absent(),
    this.sideRodLength = const Value.absent(),
    this.sideRodWeight = const Value.absent(),
    this.sideRodPurchaseDate = const Value.absent(),
    this.extenderLength = const Value.absent(),
    this.vbarModel = const Value.absent(),
    this.vbarAngleHorizontal = const Value.absent(),
    this.vbarAngleVertical = const Value.absent(),
    this.weightArrangement = const Value.absent(),
    this.damperModel = const Value.absent(),
    this.damperPositions = const Value.absent(),
    this.notes = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       bowId = Value(bowId);
  static Insertable<Stabilizer> custom({
    Expression<String>? id,
    Expression<String>? bowId,
    Expression<String>? name,
    Expression<String>? longRodModel,
    Expression<double>? longRodLength,
    Expression<double>? longRodWeight,
    Expression<DateTime>? longRodPurchaseDate,
    Expression<String>? sideRodModel,
    Expression<double>? sideRodLength,
    Expression<double>? sideRodWeight,
    Expression<DateTime>? sideRodPurchaseDate,
    Expression<double>? extenderLength,
    Expression<String>? vbarModel,
    Expression<double>? vbarAngleHorizontal,
    Expression<double>? vbarAngleVertical,
    Expression<String>? weightArrangement,
    Expression<String>? damperModel,
    Expression<String>? damperPositions,
    Expression<String>? notes,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (bowId != null) 'bow_id': bowId,
      if (name != null) 'name': name,
      if (longRodModel != null) 'long_rod_model': longRodModel,
      if (longRodLength != null) 'long_rod_length': longRodLength,
      if (longRodWeight != null) 'long_rod_weight': longRodWeight,
      if (longRodPurchaseDate != null)
        'long_rod_purchase_date': longRodPurchaseDate,
      if (sideRodModel != null) 'side_rod_model': sideRodModel,
      if (sideRodLength != null) 'side_rod_length': sideRodLength,
      if (sideRodWeight != null) 'side_rod_weight': sideRodWeight,
      if (sideRodPurchaseDate != null)
        'side_rod_purchase_date': sideRodPurchaseDate,
      if (extenderLength != null) 'extender_length': extenderLength,
      if (vbarModel != null) 'vbar_model': vbarModel,
      if (vbarAngleHorizontal != null)
        'vbar_angle_horizontal': vbarAngleHorizontal,
      if (vbarAngleVertical != null) 'vbar_angle_vertical': vbarAngleVertical,
      if (weightArrangement != null) 'weight_arrangement': weightArrangement,
      if (damperModel != null) 'damper_model': damperModel,
      if (damperPositions != null) 'damper_positions': damperPositions,
      if (notes != null) 'notes': notes,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  StabilizersCompanion copyWith({
    Value<String>? id,
    Value<String>? bowId,
    Value<String?>? name,
    Value<String?>? longRodModel,
    Value<double?>? longRodLength,
    Value<double?>? longRodWeight,
    Value<DateTime?>? longRodPurchaseDate,
    Value<String?>? sideRodModel,
    Value<double?>? sideRodLength,
    Value<double?>? sideRodWeight,
    Value<DateTime?>? sideRodPurchaseDate,
    Value<double?>? extenderLength,
    Value<String?>? vbarModel,
    Value<double?>? vbarAngleHorizontal,
    Value<double?>? vbarAngleVertical,
    Value<String?>? weightArrangement,
    Value<String?>? damperModel,
    Value<String?>? damperPositions,
    Value<String?>? notes,
    Value<DateTime>? createdAt,
    Value<DateTime>? updatedAt,
    Value<int>? rowid,
  }) {
    return StabilizersCompanion(
      id: id ?? this.id,
      bowId: bowId ?? this.bowId,
      name: name ?? this.name,
      longRodModel: longRodModel ?? this.longRodModel,
      longRodLength: longRodLength ?? this.longRodLength,
      longRodWeight: longRodWeight ?? this.longRodWeight,
      longRodPurchaseDate: longRodPurchaseDate ?? this.longRodPurchaseDate,
      sideRodModel: sideRodModel ?? this.sideRodModel,
      sideRodLength: sideRodLength ?? this.sideRodLength,
      sideRodWeight: sideRodWeight ?? this.sideRodWeight,
      sideRodPurchaseDate: sideRodPurchaseDate ?? this.sideRodPurchaseDate,
      extenderLength: extenderLength ?? this.extenderLength,
      vbarModel: vbarModel ?? this.vbarModel,
      vbarAngleHorizontal: vbarAngleHorizontal ?? this.vbarAngleHorizontal,
      vbarAngleVertical: vbarAngleVertical ?? this.vbarAngleVertical,
      weightArrangement: weightArrangement ?? this.weightArrangement,
      damperModel: damperModel ?? this.damperModel,
      damperPositions: damperPositions ?? this.damperPositions,
      notes: notes ?? this.notes,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (bowId.present) {
      map['bow_id'] = Variable<String>(bowId.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (longRodModel.present) {
      map['long_rod_model'] = Variable<String>(longRodModel.value);
    }
    if (longRodLength.present) {
      map['long_rod_length'] = Variable<double>(longRodLength.value);
    }
    if (longRodWeight.present) {
      map['long_rod_weight'] = Variable<double>(longRodWeight.value);
    }
    if (longRodPurchaseDate.present) {
      map['long_rod_purchase_date'] = Variable<DateTime>(
        longRodPurchaseDate.value,
      );
    }
    if (sideRodModel.present) {
      map['side_rod_model'] = Variable<String>(sideRodModel.value);
    }
    if (sideRodLength.present) {
      map['side_rod_length'] = Variable<double>(sideRodLength.value);
    }
    if (sideRodWeight.present) {
      map['side_rod_weight'] = Variable<double>(sideRodWeight.value);
    }
    if (sideRodPurchaseDate.present) {
      map['side_rod_purchase_date'] = Variable<DateTime>(
        sideRodPurchaseDate.value,
      );
    }
    if (extenderLength.present) {
      map['extender_length'] = Variable<double>(extenderLength.value);
    }
    if (vbarModel.present) {
      map['vbar_model'] = Variable<String>(vbarModel.value);
    }
    if (vbarAngleHorizontal.present) {
      map['vbar_angle_horizontal'] = Variable<double>(
        vbarAngleHorizontal.value,
      );
    }
    if (vbarAngleVertical.present) {
      map['vbar_angle_vertical'] = Variable<double>(vbarAngleVertical.value);
    }
    if (weightArrangement.present) {
      map['weight_arrangement'] = Variable<String>(weightArrangement.value);
    }
    if (damperModel.present) {
      map['damper_model'] = Variable<String>(damperModel.value);
    }
    if (damperPositions.present) {
      map['damper_positions'] = Variable<String>(damperPositions.value);
    }
    if (notes.present) {
      map['notes'] = Variable<String>(notes.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('StabilizersCompanion(')
          ..write('id: $id, ')
          ..write('bowId: $bowId, ')
          ..write('name: $name, ')
          ..write('longRodModel: $longRodModel, ')
          ..write('longRodLength: $longRodLength, ')
          ..write('longRodWeight: $longRodWeight, ')
          ..write('longRodPurchaseDate: $longRodPurchaseDate, ')
          ..write('sideRodModel: $sideRodModel, ')
          ..write('sideRodLength: $sideRodLength, ')
          ..write('sideRodWeight: $sideRodWeight, ')
          ..write('sideRodPurchaseDate: $sideRodPurchaseDate, ')
          ..write('extenderLength: $extenderLength, ')
          ..write('vbarModel: $vbarModel, ')
          ..write('vbarAngleHorizontal: $vbarAngleHorizontal, ')
          ..write('vbarAngleVertical: $vbarAngleVertical, ')
          ..write('weightArrangement: $weightArrangement, ')
          ..write('damperModel: $damperModel, ')
          ..write('damperPositions: $damperPositions, ')
          ..write('notes: $notes, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $BowStringsTable extends BowStrings
    with TableInfo<$BowStringsTable, BowString> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $BowStringsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _bowIdMeta = const VerificationMeta('bowId');
  @override
  late final GeneratedColumn<String> bowId = GeneratedColumn<String>(
    'bow_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES bows (id)',
    ),
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _materialMeta = const VerificationMeta(
    'material',
  );
  @override
  late final GeneratedColumn<String> material = GeneratedColumn<String>(
    'material',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _strandCountMeta = const VerificationMeta(
    'strandCount',
  );
  @override
  late final GeneratedColumn<int> strandCount = GeneratedColumn<int>(
    'strand_count',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _servingMaterialMeta = const VerificationMeta(
    'servingMaterial',
  );
  @override
  late final GeneratedColumn<String> servingMaterial = GeneratedColumn<String>(
    'serving_material',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _stringLengthMeta = const VerificationMeta(
    'stringLength',
  );
  @override
  late final GeneratedColumn<double> stringLength = GeneratedColumn<double>(
    'string_length',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _colorMeta = const VerificationMeta('color');
  @override
  late final GeneratedColumn<String> color = GeneratedColumn<String>(
    'color',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _isActiveMeta = const VerificationMeta(
    'isActive',
  );
  @override
  late final GeneratedColumn<bool> isActive = GeneratedColumn<bool>(
    'is_active',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_active" IN (0, 1))',
    ),
    defaultValue: const Constant(true),
  );
  static const VerificationMeta _purchaseDateMeta = const VerificationMeta(
    'purchaseDate',
  );
  @override
  late final GeneratedColumn<DateTime> purchaseDate = GeneratedColumn<DateTime>(
    'purchase_date',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _retiredAtMeta = const VerificationMeta(
    'retiredAt',
  );
  @override
  late final GeneratedColumn<DateTime> retiredAt = GeneratedColumn<DateTime>(
    'retired_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _notesMeta = const VerificationMeta('notes');
  @override
  late final GeneratedColumn<String> notes = GeneratedColumn<String>(
    'notes',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    bowId,
    name,
    material,
    strandCount,
    servingMaterial,
    stringLength,
    color,
    isActive,
    purchaseDate,
    retiredAt,
    notes,
    createdAt,
    updatedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'bow_strings';
  @override
  VerificationContext validateIntegrity(
    Insertable<BowString> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('bow_id')) {
      context.handle(
        _bowIdMeta,
        bowId.isAcceptableOrUnknown(data['bow_id']!, _bowIdMeta),
      );
    } else if (isInserting) {
      context.missing(_bowIdMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    }
    if (data.containsKey('material')) {
      context.handle(
        _materialMeta,
        material.isAcceptableOrUnknown(data['material']!, _materialMeta),
      );
    }
    if (data.containsKey('strand_count')) {
      context.handle(
        _strandCountMeta,
        strandCount.isAcceptableOrUnknown(
          data['strand_count']!,
          _strandCountMeta,
        ),
      );
    }
    if (data.containsKey('serving_material')) {
      context.handle(
        _servingMaterialMeta,
        servingMaterial.isAcceptableOrUnknown(
          data['serving_material']!,
          _servingMaterialMeta,
        ),
      );
    }
    if (data.containsKey('string_length')) {
      context.handle(
        _stringLengthMeta,
        stringLength.isAcceptableOrUnknown(
          data['string_length']!,
          _stringLengthMeta,
        ),
      );
    }
    if (data.containsKey('color')) {
      context.handle(
        _colorMeta,
        color.isAcceptableOrUnknown(data['color']!, _colorMeta),
      );
    }
    if (data.containsKey('is_active')) {
      context.handle(
        _isActiveMeta,
        isActive.isAcceptableOrUnknown(data['is_active']!, _isActiveMeta),
      );
    }
    if (data.containsKey('purchase_date')) {
      context.handle(
        _purchaseDateMeta,
        purchaseDate.isAcceptableOrUnknown(
          data['purchase_date']!,
          _purchaseDateMeta,
        ),
      );
    }
    if (data.containsKey('retired_at')) {
      context.handle(
        _retiredAtMeta,
        retiredAt.isAcceptableOrUnknown(data['retired_at']!, _retiredAtMeta),
      );
    }
    if (data.containsKey('notes')) {
      context.handle(
        _notesMeta,
        notes.isAcceptableOrUnknown(data['notes']!, _notesMeta),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  BowString map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return BowString(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      bowId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}bow_id'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      ),
      material: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}material'],
      ),
      strandCount: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}strand_count'],
      ),
      servingMaterial: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}serving_material'],
      ),
      stringLength: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}string_length'],
      ),
      color: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}color'],
      ),
      isActive: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_active'],
      )!,
      purchaseDate: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}purchase_date'],
      ),
      retiredAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}retired_at'],
      ),
      notes: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}notes'],
      ),
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      )!,
    );
  }

  @override
  $BowStringsTable createAlias(String alias) {
    return $BowStringsTable(attachedDatabase, alias);
  }
}

class BowString extends DataClass implements Insertable<BowString> {
  final String id;
  final String bowId;
  final String? name;
  final String? material;
  final int? strandCount;
  final String? servingMaterial;
  final double? stringLength;
  final String? color;
  final bool isActive;
  final DateTime? purchaseDate;
  final DateTime? retiredAt;
  final String? notes;
  final DateTime createdAt;
  final DateTime updatedAt;
  const BowString({
    required this.id,
    required this.bowId,
    this.name,
    this.material,
    this.strandCount,
    this.servingMaterial,
    this.stringLength,
    this.color,
    required this.isActive,
    this.purchaseDate,
    this.retiredAt,
    this.notes,
    required this.createdAt,
    required this.updatedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['bow_id'] = Variable<String>(bowId);
    if (!nullToAbsent || name != null) {
      map['name'] = Variable<String>(name);
    }
    if (!nullToAbsent || material != null) {
      map['material'] = Variable<String>(material);
    }
    if (!nullToAbsent || strandCount != null) {
      map['strand_count'] = Variable<int>(strandCount);
    }
    if (!nullToAbsent || servingMaterial != null) {
      map['serving_material'] = Variable<String>(servingMaterial);
    }
    if (!nullToAbsent || stringLength != null) {
      map['string_length'] = Variable<double>(stringLength);
    }
    if (!nullToAbsent || color != null) {
      map['color'] = Variable<String>(color);
    }
    map['is_active'] = Variable<bool>(isActive);
    if (!nullToAbsent || purchaseDate != null) {
      map['purchase_date'] = Variable<DateTime>(purchaseDate);
    }
    if (!nullToAbsent || retiredAt != null) {
      map['retired_at'] = Variable<DateTime>(retiredAt);
    }
    if (!nullToAbsent || notes != null) {
      map['notes'] = Variable<String>(notes);
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    return map;
  }

  BowStringsCompanion toCompanion(bool nullToAbsent) {
    return BowStringsCompanion(
      id: Value(id),
      bowId: Value(bowId),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      material: material == null && nullToAbsent
          ? const Value.absent()
          : Value(material),
      strandCount: strandCount == null && nullToAbsent
          ? const Value.absent()
          : Value(strandCount),
      servingMaterial: servingMaterial == null && nullToAbsent
          ? const Value.absent()
          : Value(servingMaterial),
      stringLength: stringLength == null && nullToAbsent
          ? const Value.absent()
          : Value(stringLength),
      color: color == null && nullToAbsent
          ? const Value.absent()
          : Value(color),
      isActive: Value(isActive),
      purchaseDate: purchaseDate == null && nullToAbsent
          ? const Value.absent()
          : Value(purchaseDate),
      retiredAt: retiredAt == null && nullToAbsent
          ? const Value.absent()
          : Value(retiredAt),
      notes: notes == null && nullToAbsent
          ? const Value.absent()
          : Value(notes),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory BowString.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return BowString(
      id: serializer.fromJson<String>(json['id']),
      bowId: serializer.fromJson<String>(json['bowId']),
      name: serializer.fromJson<String?>(json['name']),
      material: serializer.fromJson<String?>(json['material']),
      strandCount: serializer.fromJson<int?>(json['strandCount']),
      servingMaterial: serializer.fromJson<String?>(json['servingMaterial']),
      stringLength: serializer.fromJson<double?>(json['stringLength']),
      color: serializer.fromJson<String?>(json['color']),
      isActive: serializer.fromJson<bool>(json['isActive']),
      purchaseDate: serializer.fromJson<DateTime?>(json['purchaseDate']),
      retiredAt: serializer.fromJson<DateTime?>(json['retiredAt']),
      notes: serializer.fromJson<String?>(json['notes']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'bowId': serializer.toJson<String>(bowId),
      'name': serializer.toJson<String?>(name),
      'material': serializer.toJson<String?>(material),
      'strandCount': serializer.toJson<int?>(strandCount),
      'servingMaterial': serializer.toJson<String?>(servingMaterial),
      'stringLength': serializer.toJson<double?>(stringLength),
      'color': serializer.toJson<String?>(color),
      'isActive': serializer.toJson<bool>(isActive),
      'purchaseDate': serializer.toJson<DateTime?>(purchaseDate),
      'retiredAt': serializer.toJson<DateTime?>(retiredAt),
      'notes': serializer.toJson<String?>(notes),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
    };
  }

  BowString copyWith({
    String? id,
    String? bowId,
    Value<String?> name = const Value.absent(),
    Value<String?> material = const Value.absent(),
    Value<int?> strandCount = const Value.absent(),
    Value<String?> servingMaterial = const Value.absent(),
    Value<double?> stringLength = const Value.absent(),
    Value<String?> color = const Value.absent(),
    bool? isActive,
    Value<DateTime?> purchaseDate = const Value.absent(),
    Value<DateTime?> retiredAt = const Value.absent(),
    Value<String?> notes = const Value.absent(),
    DateTime? createdAt,
    DateTime? updatedAt,
  }) => BowString(
    id: id ?? this.id,
    bowId: bowId ?? this.bowId,
    name: name.present ? name.value : this.name,
    material: material.present ? material.value : this.material,
    strandCount: strandCount.present ? strandCount.value : this.strandCount,
    servingMaterial: servingMaterial.present
        ? servingMaterial.value
        : this.servingMaterial,
    stringLength: stringLength.present ? stringLength.value : this.stringLength,
    color: color.present ? color.value : this.color,
    isActive: isActive ?? this.isActive,
    purchaseDate: purchaseDate.present ? purchaseDate.value : this.purchaseDate,
    retiredAt: retiredAt.present ? retiredAt.value : this.retiredAt,
    notes: notes.present ? notes.value : this.notes,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
  );
  BowString copyWithCompanion(BowStringsCompanion data) {
    return BowString(
      id: data.id.present ? data.id.value : this.id,
      bowId: data.bowId.present ? data.bowId.value : this.bowId,
      name: data.name.present ? data.name.value : this.name,
      material: data.material.present ? data.material.value : this.material,
      strandCount: data.strandCount.present
          ? data.strandCount.value
          : this.strandCount,
      servingMaterial: data.servingMaterial.present
          ? data.servingMaterial.value
          : this.servingMaterial,
      stringLength: data.stringLength.present
          ? data.stringLength.value
          : this.stringLength,
      color: data.color.present ? data.color.value : this.color,
      isActive: data.isActive.present ? data.isActive.value : this.isActive,
      purchaseDate: data.purchaseDate.present
          ? data.purchaseDate.value
          : this.purchaseDate,
      retiredAt: data.retiredAt.present ? data.retiredAt.value : this.retiredAt,
      notes: data.notes.present ? data.notes.value : this.notes,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('BowString(')
          ..write('id: $id, ')
          ..write('bowId: $bowId, ')
          ..write('name: $name, ')
          ..write('material: $material, ')
          ..write('strandCount: $strandCount, ')
          ..write('servingMaterial: $servingMaterial, ')
          ..write('stringLength: $stringLength, ')
          ..write('color: $color, ')
          ..write('isActive: $isActive, ')
          ..write('purchaseDate: $purchaseDate, ')
          ..write('retiredAt: $retiredAt, ')
          ..write('notes: $notes, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    bowId,
    name,
    material,
    strandCount,
    servingMaterial,
    stringLength,
    color,
    isActive,
    purchaseDate,
    retiredAt,
    notes,
    createdAt,
    updatedAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is BowString &&
          other.id == this.id &&
          other.bowId == this.bowId &&
          other.name == this.name &&
          other.material == this.material &&
          other.strandCount == this.strandCount &&
          other.servingMaterial == this.servingMaterial &&
          other.stringLength == this.stringLength &&
          other.color == this.color &&
          other.isActive == this.isActive &&
          other.purchaseDate == this.purchaseDate &&
          other.retiredAt == this.retiredAt &&
          other.notes == this.notes &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class BowStringsCompanion extends UpdateCompanion<BowString> {
  final Value<String> id;
  final Value<String> bowId;
  final Value<String?> name;
  final Value<String?> material;
  final Value<int?> strandCount;
  final Value<String?> servingMaterial;
  final Value<double?> stringLength;
  final Value<String?> color;
  final Value<bool> isActive;
  final Value<DateTime?> purchaseDate;
  final Value<DateTime?> retiredAt;
  final Value<String?> notes;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  final Value<int> rowid;
  const BowStringsCompanion({
    this.id = const Value.absent(),
    this.bowId = const Value.absent(),
    this.name = const Value.absent(),
    this.material = const Value.absent(),
    this.strandCount = const Value.absent(),
    this.servingMaterial = const Value.absent(),
    this.stringLength = const Value.absent(),
    this.color = const Value.absent(),
    this.isActive = const Value.absent(),
    this.purchaseDate = const Value.absent(),
    this.retiredAt = const Value.absent(),
    this.notes = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  BowStringsCompanion.insert({
    required String id,
    required String bowId,
    this.name = const Value.absent(),
    this.material = const Value.absent(),
    this.strandCount = const Value.absent(),
    this.servingMaterial = const Value.absent(),
    this.stringLength = const Value.absent(),
    this.color = const Value.absent(),
    this.isActive = const Value.absent(),
    this.purchaseDate = const Value.absent(),
    this.retiredAt = const Value.absent(),
    this.notes = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       bowId = Value(bowId);
  static Insertable<BowString> custom({
    Expression<String>? id,
    Expression<String>? bowId,
    Expression<String>? name,
    Expression<String>? material,
    Expression<int>? strandCount,
    Expression<String>? servingMaterial,
    Expression<double>? stringLength,
    Expression<String>? color,
    Expression<bool>? isActive,
    Expression<DateTime>? purchaseDate,
    Expression<DateTime>? retiredAt,
    Expression<String>? notes,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (bowId != null) 'bow_id': bowId,
      if (name != null) 'name': name,
      if (material != null) 'material': material,
      if (strandCount != null) 'strand_count': strandCount,
      if (servingMaterial != null) 'serving_material': servingMaterial,
      if (stringLength != null) 'string_length': stringLength,
      if (color != null) 'color': color,
      if (isActive != null) 'is_active': isActive,
      if (purchaseDate != null) 'purchase_date': purchaseDate,
      if (retiredAt != null) 'retired_at': retiredAt,
      if (notes != null) 'notes': notes,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  BowStringsCompanion copyWith({
    Value<String>? id,
    Value<String>? bowId,
    Value<String?>? name,
    Value<String?>? material,
    Value<int?>? strandCount,
    Value<String?>? servingMaterial,
    Value<double?>? stringLength,
    Value<String?>? color,
    Value<bool>? isActive,
    Value<DateTime?>? purchaseDate,
    Value<DateTime?>? retiredAt,
    Value<String?>? notes,
    Value<DateTime>? createdAt,
    Value<DateTime>? updatedAt,
    Value<int>? rowid,
  }) {
    return BowStringsCompanion(
      id: id ?? this.id,
      bowId: bowId ?? this.bowId,
      name: name ?? this.name,
      material: material ?? this.material,
      strandCount: strandCount ?? this.strandCount,
      servingMaterial: servingMaterial ?? this.servingMaterial,
      stringLength: stringLength ?? this.stringLength,
      color: color ?? this.color,
      isActive: isActive ?? this.isActive,
      purchaseDate: purchaseDate ?? this.purchaseDate,
      retiredAt: retiredAt ?? this.retiredAt,
      notes: notes ?? this.notes,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (bowId.present) {
      map['bow_id'] = Variable<String>(bowId.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (material.present) {
      map['material'] = Variable<String>(material.value);
    }
    if (strandCount.present) {
      map['strand_count'] = Variable<int>(strandCount.value);
    }
    if (servingMaterial.present) {
      map['serving_material'] = Variable<String>(servingMaterial.value);
    }
    if (stringLength.present) {
      map['string_length'] = Variable<double>(stringLength.value);
    }
    if (color.present) {
      map['color'] = Variable<String>(color.value);
    }
    if (isActive.present) {
      map['is_active'] = Variable<bool>(isActive.value);
    }
    if (purchaseDate.present) {
      map['purchase_date'] = Variable<DateTime>(purchaseDate.value);
    }
    if (retiredAt.present) {
      map['retired_at'] = Variable<DateTime>(retiredAt.value);
    }
    if (notes.present) {
      map['notes'] = Variable<String>(notes.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('BowStringsCompanion(')
          ..write('id: $id, ')
          ..write('bowId: $bowId, ')
          ..write('name: $name, ')
          ..write('material: $material, ')
          ..write('strandCount: $strandCount, ')
          ..write('servingMaterial: $servingMaterial, ')
          ..write('stringLength: $stringLength, ')
          ..write('color: $color, ')
          ..write('isActive: $isActive, ')
          ..write('purchaseDate: $purchaseDate, ')
          ..write('retiredAt: $retiredAt, ')
          ..write('notes: $notes, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $VolumeEntriesTable extends VolumeEntries
    with TableInfo<$VolumeEntriesTable, VolumeEntry> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $VolumeEntriesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _dateMeta = const VerificationMeta('date');
  @override
  late final GeneratedColumn<DateTime> date = GeneratedColumn<DateTime>(
    'date',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _arrowCountMeta = const VerificationMeta(
    'arrowCount',
  );
  @override
  late final GeneratedColumn<int> arrowCount = GeneratedColumn<int>(
    'arrow_count',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _titleMeta = const VerificationMeta('title');
  @override
  late final GeneratedColumn<String> title = GeneratedColumn<String>(
    'title',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _notesMeta = const VerificationMeta('notes');
  @override
  late final GeneratedColumn<String> notes = GeneratedColumn<String>(
    'notes',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    date,
    arrowCount,
    title,
    notes,
    createdAt,
    updatedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'volume_entries';
  @override
  VerificationContext validateIntegrity(
    Insertable<VolumeEntry> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('date')) {
      context.handle(
        _dateMeta,
        date.isAcceptableOrUnknown(data['date']!, _dateMeta),
      );
    } else if (isInserting) {
      context.missing(_dateMeta);
    }
    if (data.containsKey('arrow_count')) {
      context.handle(
        _arrowCountMeta,
        arrowCount.isAcceptableOrUnknown(data['arrow_count']!, _arrowCountMeta),
      );
    } else if (isInserting) {
      context.missing(_arrowCountMeta);
    }
    if (data.containsKey('title')) {
      context.handle(
        _titleMeta,
        title.isAcceptableOrUnknown(data['title']!, _titleMeta),
      );
    }
    if (data.containsKey('notes')) {
      context.handle(
        _notesMeta,
        notes.isAcceptableOrUnknown(data['notes']!, _notesMeta),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  VolumeEntry map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return VolumeEntry(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      date: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}date'],
      )!,
      arrowCount: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}arrow_count'],
      )!,
      title: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}title'],
      ),
      notes: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}notes'],
      ),
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      )!,
    );
  }

  @override
  $VolumeEntriesTable createAlias(String alias) {
    return $VolumeEntriesTable(attachedDatabase, alias);
  }
}

class VolumeEntry extends DataClass implements Insertable<VolumeEntry> {
  final String id;
  final DateTime date;
  final int arrowCount;
  final String? title;
  final String? notes;
  final DateTime createdAt;
  final DateTime updatedAt;
  const VolumeEntry({
    required this.id,
    required this.date,
    required this.arrowCount,
    this.title,
    this.notes,
    required this.createdAt,
    required this.updatedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['date'] = Variable<DateTime>(date);
    map['arrow_count'] = Variable<int>(arrowCount);
    if (!nullToAbsent || title != null) {
      map['title'] = Variable<String>(title);
    }
    if (!nullToAbsent || notes != null) {
      map['notes'] = Variable<String>(notes);
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    return map;
  }

  VolumeEntriesCompanion toCompanion(bool nullToAbsent) {
    return VolumeEntriesCompanion(
      id: Value(id),
      date: Value(date),
      arrowCount: Value(arrowCount),
      title: title == null && nullToAbsent
          ? const Value.absent()
          : Value(title),
      notes: notes == null && nullToAbsent
          ? const Value.absent()
          : Value(notes),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory VolumeEntry.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return VolumeEntry(
      id: serializer.fromJson<String>(json['id']),
      date: serializer.fromJson<DateTime>(json['date']),
      arrowCount: serializer.fromJson<int>(json['arrowCount']),
      title: serializer.fromJson<String?>(json['title']),
      notes: serializer.fromJson<String?>(json['notes']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'date': serializer.toJson<DateTime>(date),
      'arrowCount': serializer.toJson<int>(arrowCount),
      'title': serializer.toJson<String?>(title),
      'notes': serializer.toJson<String?>(notes),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
    };
  }

  VolumeEntry copyWith({
    String? id,
    DateTime? date,
    int? arrowCount,
    Value<String?> title = const Value.absent(),
    Value<String?> notes = const Value.absent(),
    DateTime? createdAt,
    DateTime? updatedAt,
  }) => VolumeEntry(
    id: id ?? this.id,
    date: date ?? this.date,
    arrowCount: arrowCount ?? this.arrowCount,
    title: title.present ? title.value : this.title,
    notes: notes.present ? notes.value : this.notes,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
  );
  VolumeEntry copyWithCompanion(VolumeEntriesCompanion data) {
    return VolumeEntry(
      id: data.id.present ? data.id.value : this.id,
      date: data.date.present ? data.date.value : this.date,
      arrowCount: data.arrowCount.present
          ? data.arrowCount.value
          : this.arrowCount,
      title: data.title.present ? data.title.value : this.title,
      notes: data.notes.present ? data.notes.value : this.notes,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('VolumeEntry(')
          ..write('id: $id, ')
          ..write('date: $date, ')
          ..write('arrowCount: $arrowCount, ')
          ..write('title: $title, ')
          ..write('notes: $notes, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(id, date, arrowCount, title, notes, createdAt, updatedAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is VolumeEntry &&
          other.id == this.id &&
          other.date == this.date &&
          other.arrowCount == this.arrowCount &&
          other.title == this.title &&
          other.notes == this.notes &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class VolumeEntriesCompanion extends UpdateCompanion<VolumeEntry> {
  final Value<String> id;
  final Value<DateTime> date;
  final Value<int> arrowCount;
  final Value<String?> title;
  final Value<String?> notes;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  final Value<int> rowid;
  const VolumeEntriesCompanion({
    this.id = const Value.absent(),
    this.date = const Value.absent(),
    this.arrowCount = const Value.absent(),
    this.title = const Value.absent(),
    this.notes = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  VolumeEntriesCompanion.insert({
    required String id,
    required DateTime date,
    required int arrowCount,
    this.title = const Value.absent(),
    this.notes = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       date = Value(date),
       arrowCount = Value(arrowCount);
  static Insertable<VolumeEntry> custom({
    Expression<String>? id,
    Expression<DateTime>? date,
    Expression<int>? arrowCount,
    Expression<String>? title,
    Expression<String>? notes,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (date != null) 'date': date,
      if (arrowCount != null) 'arrow_count': arrowCount,
      if (title != null) 'title': title,
      if (notes != null) 'notes': notes,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  VolumeEntriesCompanion copyWith({
    Value<String>? id,
    Value<DateTime>? date,
    Value<int>? arrowCount,
    Value<String?>? title,
    Value<String?>? notes,
    Value<DateTime>? createdAt,
    Value<DateTime>? updatedAt,
    Value<int>? rowid,
  }) {
    return VolumeEntriesCompanion(
      id: id ?? this.id,
      date: date ?? this.date,
      arrowCount: arrowCount ?? this.arrowCount,
      title: title ?? this.title,
      notes: notes ?? this.notes,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (date.present) {
      map['date'] = Variable<DateTime>(date.value);
    }
    if (arrowCount.present) {
      map['arrow_count'] = Variable<int>(arrowCount.value);
    }
    if (title.present) {
      map['title'] = Variable<String>(title.value);
    }
    if (notes.present) {
      map['notes'] = Variable<String>(notes.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('VolumeEntriesCompanion(')
          ..write('id: $id, ')
          ..write('date: $date, ')
          ..write('arrowCount: $arrowCount, ')
          ..write('title: $title, ')
          ..write('notes: $notes, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $OlyExerciseTypesTable extends OlyExerciseTypes
    with TableInfo<$OlyExerciseTypesTable, OlyExerciseType> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $OlyExerciseTypesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _descriptionMeta = const VerificationMeta(
    'description',
  );
  @override
  late final GeneratedColumn<String> description = GeneratedColumn<String>(
    'description',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _intensityMeta = const VerificationMeta(
    'intensity',
  );
  @override
  late final GeneratedColumn<double> intensity = GeneratedColumn<double>(
    'intensity',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
    defaultValue: const Constant(1.0),
  );
  static const VerificationMeta _categoryMeta = const VerificationMeta(
    'category',
  );
  @override
  late final GeneratedColumn<String> category = GeneratedColumn<String>(
    'category',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('static'),
  );
  static const VerificationMeta _firstIntroducedAtMeta = const VerificationMeta(
    'firstIntroducedAt',
  );
  @override
  late final GeneratedColumn<String> firstIntroducedAt =
      GeneratedColumn<String>(
        'first_introduced_at',
        aliasedName,
        true,
        type: DriftSqlType.string,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _sortOrderMeta = const VerificationMeta(
    'sortOrder',
  );
  @override
  late final GeneratedColumn<int> sortOrder = GeneratedColumn<int>(
    'sort_order',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    name,
    description,
    intensity,
    category,
    firstIntroducedAt,
    sortOrder,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'oly_exercise_types';
  @override
  VerificationContext validateIntegrity(
    Insertable<OlyExerciseType> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('description')) {
      context.handle(
        _descriptionMeta,
        description.isAcceptableOrUnknown(
          data['description']!,
          _descriptionMeta,
        ),
      );
    }
    if (data.containsKey('intensity')) {
      context.handle(
        _intensityMeta,
        intensity.isAcceptableOrUnknown(data['intensity']!, _intensityMeta),
      );
    }
    if (data.containsKey('category')) {
      context.handle(
        _categoryMeta,
        category.isAcceptableOrUnknown(data['category']!, _categoryMeta),
      );
    }
    if (data.containsKey('first_introduced_at')) {
      context.handle(
        _firstIntroducedAtMeta,
        firstIntroducedAt.isAcceptableOrUnknown(
          data['first_introduced_at']!,
          _firstIntroducedAtMeta,
        ),
      );
    }
    if (data.containsKey('sort_order')) {
      context.handle(
        _sortOrderMeta,
        sortOrder.isAcceptableOrUnknown(data['sort_order']!, _sortOrderMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  OlyExerciseType map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return OlyExerciseType(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      description: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}description'],
      ),
      intensity: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}intensity'],
      )!,
      category: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}category'],
      )!,
      firstIntroducedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}first_introduced_at'],
      ),
      sortOrder: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sort_order'],
      )!,
    );
  }

  @override
  $OlyExerciseTypesTable createAlias(String alias) {
    return $OlyExerciseTypesTable(attachedDatabase, alias);
  }
}

class OlyExerciseType extends DataClass implements Insertable<OlyExerciseType> {
  final String id;
  final String name;
  final String? description;
  final double intensity;
  final String category;
  final String? firstIntroducedAt;
  final int sortOrder;
  const OlyExerciseType({
    required this.id,
    required this.name,
    this.description,
    required this.intensity,
    required this.category,
    this.firstIntroducedAt,
    required this.sortOrder,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['name'] = Variable<String>(name);
    if (!nullToAbsent || description != null) {
      map['description'] = Variable<String>(description);
    }
    map['intensity'] = Variable<double>(intensity);
    map['category'] = Variable<String>(category);
    if (!nullToAbsent || firstIntroducedAt != null) {
      map['first_introduced_at'] = Variable<String>(firstIntroducedAt);
    }
    map['sort_order'] = Variable<int>(sortOrder);
    return map;
  }

  OlyExerciseTypesCompanion toCompanion(bool nullToAbsent) {
    return OlyExerciseTypesCompanion(
      id: Value(id),
      name: Value(name),
      description: description == null && nullToAbsent
          ? const Value.absent()
          : Value(description),
      intensity: Value(intensity),
      category: Value(category),
      firstIntroducedAt: firstIntroducedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(firstIntroducedAt),
      sortOrder: Value(sortOrder),
    );
  }

  factory OlyExerciseType.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return OlyExerciseType(
      id: serializer.fromJson<String>(json['id']),
      name: serializer.fromJson<String>(json['name']),
      description: serializer.fromJson<String?>(json['description']),
      intensity: serializer.fromJson<double>(json['intensity']),
      category: serializer.fromJson<String>(json['category']),
      firstIntroducedAt: serializer.fromJson<String?>(
        json['firstIntroducedAt'],
      ),
      sortOrder: serializer.fromJson<int>(json['sortOrder']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'name': serializer.toJson<String>(name),
      'description': serializer.toJson<String?>(description),
      'intensity': serializer.toJson<double>(intensity),
      'category': serializer.toJson<String>(category),
      'firstIntroducedAt': serializer.toJson<String?>(firstIntroducedAt),
      'sortOrder': serializer.toJson<int>(sortOrder),
    };
  }

  OlyExerciseType copyWith({
    String? id,
    String? name,
    Value<String?> description = const Value.absent(),
    double? intensity,
    String? category,
    Value<String?> firstIntroducedAt = const Value.absent(),
    int? sortOrder,
  }) => OlyExerciseType(
    id: id ?? this.id,
    name: name ?? this.name,
    description: description.present ? description.value : this.description,
    intensity: intensity ?? this.intensity,
    category: category ?? this.category,
    firstIntroducedAt: firstIntroducedAt.present
        ? firstIntroducedAt.value
        : this.firstIntroducedAt,
    sortOrder: sortOrder ?? this.sortOrder,
  );
  OlyExerciseType copyWithCompanion(OlyExerciseTypesCompanion data) {
    return OlyExerciseType(
      id: data.id.present ? data.id.value : this.id,
      name: data.name.present ? data.name.value : this.name,
      description: data.description.present
          ? data.description.value
          : this.description,
      intensity: data.intensity.present ? data.intensity.value : this.intensity,
      category: data.category.present ? data.category.value : this.category,
      firstIntroducedAt: data.firstIntroducedAt.present
          ? data.firstIntroducedAt.value
          : this.firstIntroducedAt,
      sortOrder: data.sortOrder.present ? data.sortOrder.value : this.sortOrder,
    );
  }

  @override
  String toString() {
    return (StringBuffer('OlyExerciseType(')
          ..write('id: $id, ')
          ..write('name: $name, ')
          ..write('description: $description, ')
          ..write('intensity: $intensity, ')
          ..write('category: $category, ')
          ..write('firstIntroducedAt: $firstIntroducedAt, ')
          ..write('sortOrder: $sortOrder')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    name,
    description,
    intensity,
    category,
    firstIntroducedAt,
    sortOrder,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is OlyExerciseType &&
          other.id == this.id &&
          other.name == this.name &&
          other.description == this.description &&
          other.intensity == this.intensity &&
          other.category == this.category &&
          other.firstIntroducedAt == this.firstIntroducedAt &&
          other.sortOrder == this.sortOrder);
}

class OlyExerciseTypesCompanion extends UpdateCompanion<OlyExerciseType> {
  final Value<String> id;
  final Value<String> name;
  final Value<String?> description;
  final Value<double> intensity;
  final Value<String> category;
  final Value<String?> firstIntroducedAt;
  final Value<int> sortOrder;
  final Value<int> rowid;
  const OlyExerciseTypesCompanion({
    this.id = const Value.absent(),
    this.name = const Value.absent(),
    this.description = const Value.absent(),
    this.intensity = const Value.absent(),
    this.category = const Value.absent(),
    this.firstIntroducedAt = const Value.absent(),
    this.sortOrder = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  OlyExerciseTypesCompanion.insert({
    required String id,
    required String name,
    this.description = const Value.absent(),
    this.intensity = const Value.absent(),
    this.category = const Value.absent(),
    this.firstIntroducedAt = const Value.absent(),
    this.sortOrder = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       name = Value(name);
  static Insertable<OlyExerciseType> custom({
    Expression<String>? id,
    Expression<String>? name,
    Expression<String>? description,
    Expression<double>? intensity,
    Expression<String>? category,
    Expression<String>? firstIntroducedAt,
    Expression<int>? sortOrder,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (name != null) 'name': name,
      if (description != null) 'description': description,
      if (intensity != null) 'intensity': intensity,
      if (category != null) 'category': category,
      if (firstIntroducedAt != null) 'first_introduced_at': firstIntroducedAt,
      if (sortOrder != null) 'sort_order': sortOrder,
      if (rowid != null) 'rowid': rowid,
    });
  }

  OlyExerciseTypesCompanion copyWith({
    Value<String>? id,
    Value<String>? name,
    Value<String?>? description,
    Value<double>? intensity,
    Value<String>? category,
    Value<String?>? firstIntroducedAt,
    Value<int>? sortOrder,
    Value<int>? rowid,
  }) {
    return OlyExerciseTypesCompanion(
      id: id ?? this.id,
      name: name ?? this.name,
      description: description ?? this.description,
      intensity: intensity ?? this.intensity,
      category: category ?? this.category,
      firstIntroducedAt: firstIntroducedAt ?? this.firstIntroducedAt,
      sortOrder: sortOrder ?? this.sortOrder,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (description.present) {
      map['description'] = Variable<String>(description.value);
    }
    if (intensity.present) {
      map['intensity'] = Variable<double>(intensity.value);
    }
    if (category.present) {
      map['category'] = Variable<String>(category.value);
    }
    if (firstIntroducedAt.present) {
      map['first_introduced_at'] = Variable<String>(firstIntroducedAt.value);
    }
    if (sortOrder.present) {
      map['sort_order'] = Variable<int>(sortOrder.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('OlyExerciseTypesCompanion(')
          ..write('id: $id, ')
          ..write('name: $name, ')
          ..write('description: $description, ')
          ..write('intensity: $intensity, ')
          ..write('category: $category, ')
          ..write('firstIntroducedAt: $firstIntroducedAt, ')
          ..write('sortOrder: $sortOrder, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $OlySessionTemplatesTable extends OlySessionTemplates
    with TableInfo<$OlySessionTemplatesTable, OlySessionTemplate> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $OlySessionTemplatesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _versionMeta = const VerificationMeta(
    'version',
  );
  @override
  late final GeneratedColumn<String> version = GeneratedColumn<String>(
    'version',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _focusMeta = const VerificationMeta('focus');
  @override
  late final GeneratedColumn<String> focus = GeneratedColumn<String>(
    'focus',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _durationMinutesMeta = const VerificationMeta(
    'durationMinutes',
  );
  @override
  late final GeneratedColumn<int> durationMinutes = GeneratedColumn<int>(
    'duration_minutes',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _volumeLoadMeta = const VerificationMeta(
    'volumeLoad',
  );
  @override
  late final GeneratedColumn<int> volumeLoad = GeneratedColumn<int>(
    'volume_load',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _adjustedVolumeLoadMeta =
      const VerificationMeta('adjustedVolumeLoad');
  @override
  late final GeneratedColumn<int> adjustedVolumeLoad = GeneratedColumn<int>(
    'adjusted_volume_load',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _workRatioMeta = const VerificationMeta(
    'workRatio',
  );
  @override
  late final GeneratedColumn<double> workRatio = GeneratedColumn<double>(
    'work_ratio',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _adjustedWorkRatioMeta = const VerificationMeta(
    'adjustedWorkRatio',
  );
  @override
  late final GeneratedColumn<double> adjustedWorkRatio =
      GeneratedColumn<double>(
        'adjusted_work_ratio',
        aliasedName,
        false,
        type: DriftSqlType.double,
        requiredDuringInsert: true,
      );
  static const VerificationMeta _requirementsMeta = const VerificationMeta(
    'requirements',
  );
  @override
  late final GeneratedColumn<String> requirements = GeneratedColumn<String>(
    'requirements',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _equipmentMeta = const VerificationMeta(
    'equipment',
  );
  @override
  late final GeneratedColumn<String> equipment = GeneratedColumn<String>(
    'equipment',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('Bow, elbow sling, stabilisers'),
  );
  static const VerificationMeta _notesMeta = const VerificationMeta('notes');
  @override
  late final GeneratedColumn<String> notes = GeneratedColumn<String>(
    'notes',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _sortOrderMeta = const VerificationMeta(
    'sortOrder',
  );
  @override
  late final GeneratedColumn<int> sortOrder = GeneratedColumn<int>(
    'sort_order',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    version,
    name,
    focus,
    durationMinutes,
    volumeLoad,
    adjustedVolumeLoad,
    workRatio,
    adjustedWorkRatio,
    requirements,
    equipment,
    notes,
    sortOrder,
    createdAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'oly_session_templates';
  @override
  VerificationContext validateIntegrity(
    Insertable<OlySessionTemplate> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('version')) {
      context.handle(
        _versionMeta,
        version.isAcceptableOrUnknown(data['version']!, _versionMeta),
      );
    } else if (isInserting) {
      context.missing(_versionMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('focus')) {
      context.handle(
        _focusMeta,
        focus.isAcceptableOrUnknown(data['focus']!, _focusMeta),
      );
    }
    if (data.containsKey('duration_minutes')) {
      context.handle(
        _durationMinutesMeta,
        durationMinutes.isAcceptableOrUnknown(
          data['duration_minutes']!,
          _durationMinutesMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_durationMinutesMeta);
    }
    if (data.containsKey('volume_load')) {
      context.handle(
        _volumeLoadMeta,
        volumeLoad.isAcceptableOrUnknown(data['volume_load']!, _volumeLoadMeta),
      );
    } else if (isInserting) {
      context.missing(_volumeLoadMeta);
    }
    if (data.containsKey('adjusted_volume_load')) {
      context.handle(
        _adjustedVolumeLoadMeta,
        adjustedVolumeLoad.isAcceptableOrUnknown(
          data['adjusted_volume_load']!,
          _adjustedVolumeLoadMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_adjustedVolumeLoadMeta);
    }
    if (data.containsKey('work_ratio')) {
      context.handle(
        _workRatioMeta,
        workRatio.isAcceptableOrUnknown(data['work_ratio']!, _workRatioMeta),
      );
    } else if (isInserting) {
      context.missing(_workRatioMeta);
    }
    if (data.containsKey('adjusted_work_ratio')) {
      context.handle(
        _adjustedWorkRatioMeta,
        adjustedWorkRatio.isAcceptableOrUnknown(
          data['adjusted_work_ratio']!,
          _adjustedWorkRatioMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_adjustedWorkRatioMeta);
    }
    if (data.containsKey('requirements')) {
      context.handle(
        _requirementsMeta,
        requirements.isAcceptableOrUnknown(
          data['requirements']!,
          _requirementsMeta,
        ),
      );
    }
    if (data.containsKey('equipment')) {
      context.handle(
        _equipmentMeta,
        equipment.isAcceptableOrUnknown(data['equipment']!, _equipmentMeta),
      );
    }
    if (data.containsKey('notes')) {
      context.handle(
        _notesMeta,
        notes.isAcceptableOrUnknown(data['notes']!, _notesMeta),
      );
    }
    if (data.containsKey('sort_order')) {
      context.handle(
        _sortOrderMeta,
        sortOrder.isAcceptableOrUnknown(data['sort_order']!, _sortOrderMeta),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  OlySessionTemplate map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return OlySessionTemplate(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      version: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}version'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      focus: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}focus'],
      ),
      durationMinutes: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}duration_minutes'],
      )!,
      volumeLoad: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}volume_load'],
      )!,
      adjustedVolumeLoad: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}adjusted_volume_load'],
      )!,
      workRatio: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}work_ratio'],
      )!,
      adjustedWorkRatio: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}adjusted_work_ratio'],
      )!,
      requirements: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}requirements'],
      ),
      equipment: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}equipment'],
      )!,
      notes: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}notes'],
      ),
      sortOrder: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sort_order'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
    );
  }

  @override
  $OlySessionTemplatesTable createAlias(String alias) {
    return $OlySessionTemplatesTable(attachedDatabase, alias);
  }
}

class OlySessionTemplate extends DataClass
    implements Insertable<OlySessionTemplate> {
  final String id;
  final String version;
  final String name;
  final String? focus;
  final int durationMinutes;
  final int volumeLoad;
  final int adjustedVolumeLoad;
  final double workRatio;
  final double adjustedWorkRatio;
  final String? requirements;
  final String equipment;
  final String? notes;
  final int sortOrder;
  final DateTime createdAt;
  const OlySessionTemplate({
    required this.id,
    required this.version,
    required this.name,
    this.focus,
    required this.durationMinutes,
    required this.volumeLoad,
    required this.adjustedVolumeLoad,
    required this.workRatio,
    required this.adjustedWorkRatio,
    this.requirements,
    required this.equipment,
    this.notes,
    required this.sortOrder,
    required this.createdAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['version'] = Variable<String>(version);
    map['name'] = Variable<String>(name);
    if (!nullToAbsent || focus != null) {
      map['focus'] = Variable<String>(focus);
    }
    map['duration_minutes'] = Variable<int>(durationMinutes);
    map['volume_load'] = Variable<int>(volumeLoad);
    map['adjusted_volume_load'] = Variable<int>(adjustedVolumeLoad);
    map['work_ratio'] = Variable<double>(workRatio);
    map['adjusted_work_ratio'] = Variable<double>(adjustedWorkRatio);
    if (!nullToAbsent || requirements != null) {
      map['requirements'] = Variable<String>(requirements);
    }
    map['equipment'] = Variable<String>(equipment);
    if (!nullToAbsent || notes != null) {
      map['notes'] = Variable<String>(notes);
    }
    map['sort_order'] = Variable<int>(sortOrder);
    map['created_at'] = Variable<DateTime>(createdAt);
    return map;
  }

  OlySessionTemplatesCompanion toCompanion(bool nullToAbsent) {
    return OlySessionTemplatesCompanion(
      id: Value(id),
      version: Value(version),
      name: Value(name),
      focus: focus == null && nullToAbsent
          ? const Value.absent()
          : Value(focus),
      durationMinutes: Value(durationMinutes),
      volumeLoad: Value(volumeLoad),
      adjustedVolumeLoad: Value(adjustedVolumeLoad),
      workRatio: Value(workRatio),
      adjustedWorkRatio: Value(adjustedWorkRatio),
      requirements: requirements == null && nullToAbsent
          ? const Value.absent()
          : Value(requirements),
      equipment: Value(equipment),
      notes: notes == null && nullToAbsent
          ? const Value.absent()
          : Value(notes),
      sortOrder: Value(sortOrder),
      createdAt: Value(createdAt),
    );
  }

  factory OlySessionTemplate.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return OlySessionTemplate(
      id: serializer.fromJson<String>(json['id']),
      version: serializer.fromJson<String>(json['version']),
      name: serializer.fromJson<String>(json['name']),
      focus: serializer.fromJson<String?>(json['focus']),
      durationMinutes: serializer.fromJson<int>(json['durationMinutes']),
      volumeLoad: serializer.fromJson<int>(json['volumeLoad']),
      adjustedVolumeLoad: serializer.fromJson<int>(json['adjustedVolumeLoad']),
      workRatio: serializer.fromJson<double>(json['workRatio']),
      adjustedWorkRatio: serializer.fromJson<double>(json['adjustedWorkRatio']),
      requirements: serializer.fromJson<String?>(json['requirements']),
      equipment: serializer.fromJson<String>(json['equipment']),
      notes: serializer.fromJson<String?>(json['notes']),
      sortOrder: serializer.fromJson<int>(json['sortOrder']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'version': serializer.toJson<String>(version),
      'name': serializer.toJson<String>(name),
      'focus': serializer.toJson<String?>(focus),
      'durationMinutes': serializer.toJson<int>(durationMinutes),
      'volumeLoad': serializer.toJson<int>(volumeLoad),
      'adjustedVolumeLoad': serializer.toJson<int>(adjustedVolumeLoad),
      'workRatio': serializer.toJson<double>(workRatio),
      'adjustedWorkRatio': serializer.toJson<double>(adjustedWorkRatio),
      'requirements': serializer.toJson<String?>(requirements),
      'equipment': serializer.toJson<String>(equipment),
      'notes': serializer.toJson<String?>(notes),
      'sortOrder': serializer.toJson<int>(sortOrder),
      'createdAt': serializer.toJson<DateTime>(createdAt),
    };
  }

  OlySessionTemplate copyWith({
    String? id,
    String? version,
    String? name,
    Value<String?> focus = const Value.absent(),
    int? durationMinutes,
    int? volumeLoad,
    int? adjustedVolumeLoad,
    double? workRatio,
    double? adjustedWorkRatio,
    Value<String?> requirements = const Value.absent(),
    String? equipment,
    Value<String?> notes = const Value.absent(),
    int? sortOrder,
    DateTime? createdAt,
  }) => OlySessionTemplate(
    id: id ?? this.id,
    version: version ?? this.version,
    name: name ?? this.name,
    focus: focus.present ? focus.value : this.focus,
    durationMinutes: durationMinutes ?? this.durationMinutes,
    volumeLoad: volumeLoad ?? this.volumeLoad,
    adjustedVolumeLoad: adjustedVolumeLoad ?? this.adjustedVolumeLoad,
    workRatio: workRatio ?? this.workRatio,
    adjustedWorkRatio: adjustedWorkRatio ?? this.adjustedWorkRatio,
    requirements: requirements.present ? requirements.value : this.requirements,
    equipment: equipment ?? this.equipment,
    notes: notes.present ? notes.value : this.notes,
    sortOrder: sortOrder ?? this.sortOrder,
    createdAt: createdAt ?? this.createdAt,
  );
  OlySessionTemplate copyWithCompanion(OlySessionTemplatesCompanion data) {
    return OlySessionTemplate(
      id: data.id.present ? data.id.value : this.id,
      version: data.version.present ? data.version.value : this.version,
      name: data.name.present ? data.name.value : this.name,
      focus: data.focus.present ? data.focus.value : this.focus,
      durationMinutes: data.durationMinutes.present
          ? data.durationMinutes.value
          : this.durationMinutes,
      volumeLoad: data.volumeLoad.present
          ? data.volumeLoad.value
          : this.volumeLoad,
      adjustedVolumeLoad: data.adjustedVolumeLoad.present
          ? data.adjustedVolumeLoad.value
          : this.adjustedVolumeLoad,
      workRatio: data.workRatio.present ? data.workRatio.value : this.workRatio,
      adjustedWorkRatio: data.adjustedWorkRatio.present
          ? data.adjustedWorkRatio.value
          : this.adjustedWorkRatio,
      requirements: data.requirements.present
          ? data.requirements.value
          : this.requirements,
      equipment: data.equipment.present ? data.equipment.value : this.equipment,
      notes: data.notes.present ? data.notes.value : this.notes,
      sortOrder: data.sortOrder.present ? data.sortOrder.value : this.sortOrder,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('OlySessionTemplate(')
          ..write('id: $id, ')
          ..write('version: $version, ')
          ..write('name: $name, ')
          ..write('focus: $focus, ')
          ..write('durationMinutes: $durationMinutes, ')
          ..write('volumeLoad: $volumeLoad, ')
          ..write('adjustedVolumeLoad: $adjustedVolumeLoad, ')
          ..write('workRatio: $workRatio, ')
          ..write('adjustedWorkRatio: $adjustedWorkRatio, ')
          ..write('requirements: $requirements, ')
          ..write('equipment: $equipment, ')
          ..write('notes: $notes, ')
          ..write('sortOrder: $sortOrder, ')
          ..write('createdAt: $createdAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    version,
    name,
    focus,
    durationMinutes,
    volumeLoad,
    adjustedVolumeLoad,
    workRatio,
    adjustedWorkRatio,
    requirements,
    equipment,
    notes,
    sortOrder,
    createdAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is OlySessionTemplate &&
          other.id == this.id &&
          other.version == this.version &&
          other.name == this.name &&
          other.focus == this.focus &&
          other.durationMinutes == this.durationMinutes &&
          other.volumeLoad == this.volumeLoad &&
          other.adjustedVolumeLoad == this.adjustedVolumeLoad &&
          other.workRatio == this.workRatio &&
          other.adjustedWorkRatio == this.adjustedWorkRatio &&
          other.requirements == this.requirements &&
          other.equipment == this.equipment &&
          other.notes == this.notes &&
          other.sortOrder == this.sortOrder &&
          other.createdAt == this.createdAt);
}

class OlySessionTemplatesCompanion extends UpdateCompanion<OlySessionTemplate> {
  final Value<String> id;
  final Value<String> version;
  final Value<String> name;
  final Value<String?> focus;
  final Value<int> durationMinutes;
  final Value<int> volumeLoad;
  final Value<int> adjustedVolumeLoad;
  final Value<double> workRatio;
  final Value<double> adjustedWorkRatio;
  final Value<String?> requirements;
  final Value<String> equipment;
  final Value<String?> notes;
  final Value<int> sortOrder;
  final Value<DateTime> createdAt;
  final Value<int> rowid;
  const OlySessionTemplatesCompanion({
    this.id = const Value.absent(),
    this.version = const Value.absent(),
    this.name = const Value.absent(),
    this.focus = const Value.absent(),
    this.durationMinutes = const Value.absent(),
    this.volumeLoad = const Value.absent(),
    this.adjustedVolumeLoad = const Value.absent(),
    this.workRatio = const Value.absent(),
    this.adjustedWorkRatio = const Value.absent(),
    this.requirements = const Value.absent(),
    this.equipment = const Value.absent(),
    this.notes = const Value.absent(),
    this.sortOrder = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  OlySessionTemplatesCompanion.insert({
    required String id,
    required String version,
    required String name,
    this.focus = const Value.absent(),
    required int durationMinutes,
    required int volumeLoad,
    required int adjustedVolumeLoad,
    required double workRatio,
    required double adjustedWorkRatio,
    this.requirements = const Value.absent(),
    this.equipment = const Value.absent(),
    this.notes = const Value.absent(),
    this.sortOrder = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       version = Value(version),
       name = Value(name),
       durationMinutes = Value(durationMinutes),
       volumeLoad = Value(volumeLoad),
       adjustedVolumeLoad = Value(adjustedVolumeLoad),
       workRatio = Value(workRatio),
       adjustedWorkRatio = Value(adjustedWorkRatio);
  static Insertable<OlySessionTemplate> custom({
    Expression<String>? id,
    Expression<String>? version,
    Expression<String>? name,
    Expression<String>? focus,
    Expression<int>? durationMinutes,
    Expression<int>? volumeLoad,
    Expression<int>? adjustedVolumeLoad,
    Expression<double>? workRatio,
    Expression<double>? adjustedWorkRatio,
    Expression<String>? requirements,
    Expression<String>? equipment,
    Expression<String>? notes,
    Expression<int>? sortOrder,
    Expression<DateTime>? createdAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (version != null) 'version': version,
      if (name != null) 'name': name,
      if (focus != null) 'focus': focus,
      if (durationMinutes != null) 'duration_minutes': durationMinutes,
      if (volumeLoad != null) 'volume_load': volumeLoad,
      if (adjustedVolumeLoad != null)
        'adjusted_volume_load': adjustedVolumeLoad,
      if (workRatio != null) 'work_ratio': workRatio,
      if (adjustedWorkRatio != null) 'adjusted_work_ratio': adjustedWorkRatio,
      if (requirements != null) 'requirements': requirements,
      if (equipment != null) 'equipment': equipment,
      if (notes != null) 'notes': notes,
      if (sortOrder != null) 'sort_order': sortOrder,
      if (createdAt != null) 'created_at': createdAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  OlySessionTemplatesCompanion copyWith({
    Value<String>? id,
    Value<String>? version,
    Value<String>? name,
    Value<String?>? focus,
    Value<int>? durationMinutes,
    Value<int>? volumeLoad,
    Value<int>? adjustedVolumeLoad,
    Value<double>? workRatio,
    Value<double>? adjustedWorkRatio,
    Value<String?>? requirements,
    Value<String>? equipment,
    Value<String?>? notes,
    Value<int>? sortOrder,
    Value<DateTime>? createdAt,
    Value<int>? rowid,
  }) {
    return OlySessionTemplatesCompanion(
      id: id ?? this.id,
      version: version ?? this.version,
      name: name ?? this.name,
      focus: focus ?? this.focus,
      durationMinutes: durationMinutes ?? this.durationMinutes,
      volumeLoad: volumeLoad ?? this.volumeLoad,
      adjustedVolumeLoad: adjustedVolumeLoad ?? this.adjustedVolumeLoad,
      workRatio: workRatio ?? this.workRatio,
      adjustedWorkRatio: adjustedWorkRatio ?? this.adjustedWorkRatio,
      requirements: requirements ?? this.requirements,
      equipment: equipment ?? this.equipment,
      notes: notes ?? this.notes,
      sortOrder: sortOrder ?? this.sortOrder,
      createdAt: createdAt ?? this.createdAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (version.present) {
      map['version'] = Variable<String>(version.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (focus.present) {
      map['focus'] = Variable<String>(focus.value);
    }
    if (durationMinutes.present) {
      map['duration_minutes'] = Variable<int>(durationMinutes.value);
    }
    if (volumeLoad.present) {
      map['volume_load'] = Variable<int>(volumeLoad.value);
    }
    if (adjustedVolumeLoad.present) {
      map['adjusted_volume_load'] = Variable<int>(adjustedVolumeLoad.value);
    }
    if (workRatio.present) {
      map['work_ratio'] = Variable<double>(workRatio.value);
    }
    if (adjustedWorkRatio.present) {
      map['adjusted_work_ratio'] = Variable<double>(adjustedWorkRatio.value);
    }
    if (requirements.present) {
      map['requirements'] = Variable<String>(requirements.value);
    }
    if (equipment.present) {
      map['equipment'] = Variable<String>(equipment.value);
    }
    if (notes.present) {
      map['notes'] = Variable<String>(notes.value);
    }
    if (sortOrder.present) {
      map['sort_order'] = Variable<int>(sortOrder.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('OlySessionTemplatesCompanion(')
          ..write('id: $id, ')
          ..write('version: $version, ')
          ..write('name: $name, ')
          ..write('focus: $focus, ')
          ..write('durationMinutes: $durationMinutes, ')
          ..write('volumeLoad: $volumeLoad, ')
          ..write('adjustedVolumeLoad: $adjustedVolumeLoad, ')
          ..write('workRatio: $workRatio, ')
          ..write('adjustedWorkRatio: $adjustedWorkRatio, ')
          ..write('requirements: $requirements, ')
          ..write('equipment: $equipment, ')
          ..write('notes: $notes, ')
          ..write('sortOrder: $sortOrder, ')
          ..write('createdAt: $createdAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $OlySessionExercisesTable extends OlySessionExercises
    with TableInfo<$OlySessionExercisesTable, OlySessionExercise> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $OlySessionExercisesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _sessionTemplateIdMeta = const VerificationMeta(
    'sessionTemplateId',
  );
  @override
  late final GeneratedColumn<String> sessionTemplateId =
      GeneratedColumn<String>(
        'session_template_id',
        aliasedName,
        false,
        type: DriftSqlType.string,
        requiredDuringInsert: true,
        defaultConstraints: GeneratedColumn.constraintIsAlways(
          'REFERENCES oly_session_templates (id)',
        ),
      );
  static const VerificationMeta _exerciseTypeIdMeta = const VerificationMeta(
    'exerciseTypeId',
  );
  @override
  late final GeneratedColumn<String> exerciseTypeId = GeneratedColumn<String>(
    'exercise_type_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES oly_exercise_types (id)',
    ),
  );
  static const VerificationMeta _exerciseOrderMeta = const VerificationMeta(
    'exerciseOrder',
  );
  @override
  late final GeneratedColumn<int> exerciseOrder = GeneratedColumn<int>(
    'exercise_order',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _repsMeta = const VerificationMeta('reps');
  @override
  late final GeneratedColumn<int> reps = GeneratedColumn<int>(
    'reps',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _workSecondsMeta = const VerificationMeta(
    'workSeconds',
  );
  @override
  late final GeneratedColumn<int> workSeconds = GeneratedColumn<int>(
    'work_seconds',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _restSecondsMeta = const VerificationMeta(
    'restSeconds',
  );
  @override
  late final GeneratedColumn<int> restSeconds = GeneratedColumn<int>(
    'rest_seconds',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _detailsMeta = const VerificationMeta(
    'details',
  );
  @override
  late final GeneratedColumn<String> details = GeneratedColumn<String>(
    'details',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _intensityOverrideMeta = const VerificationMeta(
    'intensityOverride',
  );
  @override
  late final GeneratedColumn<double> intensityOverride =
      GeneratedColumn<double>(
        'intensity_override',
        aliasedName,
        true,
        type: DriftSqlType.double,
        requiredDuringInsert: false,
      );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    sessionTemplateId,
    exerciseTypeId,
    exerciseOrder,
    reps,
    workSeconds,
    restSeconds,
    details,
    intensityOverride,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'oly_session_exercises';
  @override
  VerificationContext validateIntegrity(
    Insertable<OlySessionExercise> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('session_template_id')) {
      context.handle(
        _sessionTemplateIdMeta,
        sessionTemplateId.isAcceptableOrUnknown(
          data['session_template_id']!,
          _sessionTemplateIdMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_sessionTemplateIdMeta);
    }
    if (data.containsKey('exercise_type_id')) {
      context.handle(
        _exerciseTypeIdMeta,
        exerciseTypeId.isAcceptableOrUnknown(
          data['exercise_type_id']!,
          _exerciseTypeIdMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_exerciseTypeIdMeta);
    }
    if (data.containsKey('exercise_order')) {
      context.handle(
        _exerciseOrderMeta,
        exerciseOrder.isAcceptableOrUnknown(
          data['exercise_order']!,
          _exerciseOrderMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_exerciseOrderMeta);
    }
    if (data.containsKey('reps')) {
      context.handle(
        _repsMeta,
        reps.isAcceptableOrUnknown(data['reps']!, _repsMeta),
      );
    } else if (isInserting) {
      context.missing(_repsMeta);
    }
    if (data.containsKey('work_seconds')) {
      context.handle(
        _workSecondsMeta,
        workSeconds.isAcceptableOrUnknown(
          data['work_seconds']!,
          _workSecondsMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_workSecondsMeta);
    }
    if (data.containsKey('rest_seconds')) {
      context.handle(
        _restSecondsMeta,
        restSeconds.isAcceptableOrUnknown(
          data['rest_seconds']!,
          _restSecondsMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_restSecondsMeta);
    }
    if (data.containsKey('details')) {
      context.handle(
        _detailsMeta,
        details.isAcceptableOrUnknown(data['details']!, _detailsMeta),
      );
    }
    if (data.containsKey('intensity_override')) {
      context.handle(
        _intensityOverrideMeta,
        intensityOverride.isAcceptableOrUnknown(
          data['intensity_override']!,
          _intensityOverrideMeta,
        ),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  OlySessionExercise map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return OlySessionExercise(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      sessionTemplateId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}session_template_id'],
      )!,
      exerciseTypeId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}exercise_type_id'],
      )!,
      exerciseOrder: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}exercise_order'],
      )!,
      reps: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}reps'],
      )!,
      workSeconds: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}work_seconds'],
      )!,
      restSeconds: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}rest_seconds'],
      )!,
      details: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}details'],
      ),
      intensityOverride: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}intensity_override'],
      ),
    );
  }

  @override
  $OlySessionExercisesTable createAlias(String alias) {
    return $OlySessionExercisesTable(attachedDatabase, alias);
  }
}

class OlySessionExercise extends DataClass
    implements Insertable<OlySessionExercise> {
  final String id;
  final String sessionTemplateId;
  final String exerciseTypeId;
  final int exerciseOrder;
  final int reps;
  final int workSeconds;
  final int restSeconds;
  final String? details;
  final double? intensityOverride;
  const OlySessionExercise({
    required this.id,
    required this.sessionTemplateId,
    required this.exerciseTypeId,
    required this.exerciseOrder,
    required this.reps,
    required this.workSeconds,
    required this.restSeconds,
    this.details,
    this.intensityOverride,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['session_template_id'] = Variable<String>(sessionTemplateId);
    map['exercise_type_id'] = Variable<String>(exerciseTypeId);
    map['exercise_order'] = Variable<int>(exerciseOrder);
    map['reps'] = Variable<int>(reps);
    map['work_seconds'] = Variable<int>(workSeconds);
    map['rest_seconds'] = Variable<int>(restSeconds);
    if (!nullToAbsent || details != null) {
      map['details'] = Variable<String>(details);
    }
    if (!nullToAbsent || intensityOverride != null) {
      map['intensity_override'] = Variable<double>(intensityOverride);
    }
    return map;
  }

  OlySessionExercisesCompanion toCompanion(bool nullToAbsent) {
    return OlySessionExercisesCompanion(
      id: Value(id),
      sessionTemplateId: Value(sessionTemplateId),
      exerciseTypeId: Value(exerciseTypeId),
      exerciseOrder: Value(exerciseOrder),
      reps: Value(reps),
      workSeconds: Value(workSeconds),
      restSeconds: Value(restSeconds),
      details: details == null && nullToAbsent
          ? const Value.absent()
          : Value(details),
      intensityOverride: intensityOverride == null && nullToAbsent
          ? const Value.absent()
          : Value(intensityOverride),
    );
  }

  factory OlySessionExercise.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return OlySessionExercise(
      id: serializer.fromJson<String>(json['id']),
      sessionTemplateId: serializer.fromJson<String>(json['sessionTemplateId']),
      exerciseTypeId: serializer.fromJson<String>(json['exerciseTypeId']),
      exerciseOrder: serializer.fromJson<int>(json['exerciseOrder']),
      reps: serializer.fromJson<int>(json['reps']),
      workSeconds: serializer.fromJson<int>(json['workSeconds']),
      restSeconds: serializer.fromJson<int>(json['restSeconds']),
      details: serializer.fromJson<String?>(json['details']),
      intensityOverride: serializer.fromJson<double?>(
        json['intensityOverride'],
      ),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'sessionTemplateId': serializer.toJson<String>(sessionTemplateId),
      'exerciseTypeId': serializer.toJson<String>(exerciseTypeId),
      'exerciseOrder': serializer.toJson<int>(exerciseOrder),
      'reps': serializer.toJson<int>(reps),
      'workSeconds': serializer.toJson<int>(workSeconds),
      'restSeconds': serializer.toJson<int>(restSeconds),
      'details': serializer.toJson<String?>(details),
      'intensityOverride': serializer.toJson<double?>(intensityOverride),
    };
  }

  OlySessionExercise copyWith({
    String? id,
    String? sessionTemplateId,
    String? exerciseTypeId,
    int? exerciseOrder,
    int? reps,
    int? workSeconds,
    int? restSeconds,
    Value<String?> details = const Value.absent(),
    Value<double?> intensityOverride = const Value.absent(),
  }) => OlySessionExercise(
    id: id ?? this.id,
    sessionTemplateId: sessionTemplateId ?? this.sessionTemplateId,
    exerciseTypeId: exerciseTypeId ?? this.exerciseTypeId,
    exerciseOrder: exerciseOrder ?? this.exerciseOrder,
    reps: reps ?? this.reps,
    workSeconds: workSeconds ?? this.workSeconds,
    restSeconds: restSeconds ?? this.restSeconds,
    details: details.present ? details.value : this.details,
    intensityOverride: intensityOverride.present
        ? intensityOverride.value
        : this.intensityOverride,
  );
  OlySessionExercise copyWithCompanion(OlySessionExercisesCompanion data) {
    return OlySessionExercise(
      id: data.id.present ? data.id.value : this.id,
      sessionTemplateId: data.sessionTemplateId.present
          ? data.sessionTemplateId.value
          : this.sessionTemplateId,
      exerciseTypeId: data.exerciseTypeId.present
          ? data.exerciseTypeId.value
          : this.exerciseTypeId,
      exerciseOrder: data.exerciseOrder.present
          ? data.exerciseOrder.value
          : this.exerciseOrder,
      reps: data.reps.present ? data.reps.value : this.reps,
      workSeconds: data.workSeconds.present
          ? data.workSeconds.value
          : this.workSeconds,
      restSeconds: data.restSeconds.present
          ? data.restSeconds.value
          : this.restSeconds,
      details: data.details.present ? data.details.value : this.details,
      intensityOverride: data.intensityOverride.present
          ? data.intensityOverride.value
          : this.intensityOverride,
    );
  }

  @override
  String toString() {
    return (StringBuffer('OlySessionExercise(')
          ..write('id: $id, ')
          ..write('sessionTemplateId: $sessionTemplateId, ')
          ..write('exerciseTypeId: $exerciseTypeId, ')
          ..write('exerciseOrder: $exerciseOrder, ')
          ..write('reps: $reps, ')
          ..write('workSeconds: $workSeconds, ')
          ..write('restSeconds: $restSeconds, ')
          ..write('details: $details, ')
          ..write('intensityOverride: $intensityOverride')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    sessionTemplateId,
    exerciseTypeId,
    exerciseOrder,
    reps,
    workSeconds,
    restSeconds,
    details,
    intensityOverride,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is OlySessionExercise &&
          other.id == this.id &&
          other.sessionTemplateId == this.sessionTemplateId &&
          other.exerciseTypeId == this.exerciseTypeId &&
          other.exerciseOrder == this.exerciseOrder &&
          other.reps == this.reps &&
          other.workSeconds == this.workSeconds &&
          other.restSeconds == this.restSeconds &&
          other.details == this.details &&
          other.intensityOverride == this.intensityOverride);
}

class OlySessionExercisesCompanion extends UpdateCompanion<OlySessionExercise> {
  final Value<String> id;
  final Value<String> sessionTemplateId;
  final Value<String> exerciseTypeId;
  final Value<int> exerciseOrder;
  final Value<int> reps;
  final Value<int> workSeconds;
  final Value<int> restSeconds;
  final Value<String?> details;
  final Value<double?> intensityOverride;
  final Value<int> rowid;
  const OlySessionExercisesCompanion({
    this.id = const Value.absent(),
    this.sessionTemplateId = const Value.absent(),
    this.exerciseTypeId = const Value.absent(),
    this.exerciseOrder = const Value.absent(),
    this.reps = const Value.absent(),
    this.workSeconds = const Value.absent(),
    this.restSeconds = const Value.absent(),
    this.details = const Value.absent(),
    this.intensityOverride = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  OlySessionExercisesCompanion.insert({
    required String id,
    required String sessionTemplateId,
    required String exerciseTypeId,
    required int exerciseOrder,
    required int reps,
    required int workSeconds,
    required int restSeconds,
    this.details = const Value.absent(),
    this.intensityOverride = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       sessionTemplateId = Value(sessionTemplateId),
       exerciseTypeId = Value(exerciseTypeId),
       exerciseOrder = Value(exerciseOrder),
       reps = Value(reps),
       workSeconds = Value(workSeconds),
       restSeconds = Value(restSeconds);
  static Insertable<OlySessionExercise> custom({
    Expression<String>? id,
    Expression<String>? sessionTemplateId,
    Expression<String>? exerciseTypeId,
    Expression<int>? exerciseOrder,
    Expression<int>? reps,
    Expression<int>? workSeconds,
    Expression<int>? restSeconds,
    Expression<String>? details,
    Expression<double>? intensityOverride,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (sessionTemplateId != null) 'session_template_id': sessionTemplateId,
      if (exerciseTypeId != null) 'exercise_type_id': exerciseTypeId,
      if (exerciseOrder != null) 'exercise_order': exerciseOrder,
      if (reps != null) 'reps': reps,
      if (workSeconds != null) 'work_seconds': workSeconds,
      if (restSeconds != null) 'rest_seconds': restSeconds,
      if (details != null) 'details': details,
      if (intensityOverride != null) 'intensity_override': intensityOverride,
      if (rowid != null) 'rowid': rowid,
    });
  }

  OlySessionExercisesCompanion copyWith({
    Value<String>? id,
    Value<String>? sessionTemplateId,
    Value<String>? exerciseTypeId,
    Value<int>? exerciseOrder,
    Value<int>? reps,
    Value<int>? workSeconds,
    Value<int>? restSeconds,
    Value<String?>? details,
    Value<double?>? intensityOverride,
    Value<int>? rowid,
  }) {
    return OlySessionExercisesCompanion(
      id: id ?? this.id,
      sessionTemplateId: sessionTemplateId ?? this.sessionTemplateId,
      exerciseTypeId: exerciseTypeId ?? this.exerciseTypeId,
      exerciseOrder: exerciseOrder ?? this.exerciseOrder,
      reps: reps ?? this.reps,
      workSeconds: workSeconds ?? this.workSeconds,
      restSeconds: restSeconds ?? this.restSeconds,
      details: details ?? this.details,
      intensityOverride: intensityOverride ?? this.intensityOverride,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (sessionTemplateId.present) {
      map['session_template_id'] = Variable<String>(sessionTemplateId.value);
    }
    if (exerciseTypeId.present) {
      map['exercise_type_id'] = Variable<String>(exerciseTypeId.value);
    }
    if (exerciseOrder.present) {
      map['exercise_order'] = Variable<int>(exerciseOrder.value);
    }
    if (reps.present) {
      map['reps'] = Variable<int>(reps.value);
    }
    if (workSeconds.present) {
      map['work_seconds'] = Variable<int>(workSeconds.value);
    }
    if (restSeconds.present) {
      map['rest_seconds'] = Variable<int>(restSeconds.value);
    }
    if (details.present) {
      map['details'] = Variable<String>(details.value);
    }
    if (intensityOverride.present) {
      map['intensity_override'] = Variable<double>(intensityOverride.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('OlySessionExercisesCompanion(')
          ..write('id: $id, ')
          ..write('sessionTemplateId: $sessionTemplateId, ')
          ..write('exerciseTypeId: $exerciseTypeId, ')
          ..write('exerciseOrder: $exerciseOrder, ')
          ..write('reps: $reps, ')
          ..write('workSeconds: $workSeconds, ')
          ..write('restSeconds: $restSeconds, ')
          ..write('details: $details, ')
          ..write('intensityOverride: $intensityOverride, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $OlyTrainingLogsTable extends OlyTrainingLogs
    with TableInfo<$OlyTrainingLogsTable, OlyTrainingLog> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $OlyTrainingLogsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _sessionTemplateIdMeta = const VerificationMeta(
    'sessionTemplateId',
  );
  @override
  late final GeneratedColumn<String> sessionTemplateId =
      GeneratedColumn<String>(
        'session_template_id',
        aliasedName,
        true,
        type: DriftSqlType.string,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _sessionVersionMeta = const VerificationMeta(
    'sessionVersion',
  );
  @override
  late final GeneratedColumn<String> sessionVersion = GeneratedColumn<String>(
    'session_version',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _sessionNameMeta = const VerificationMeta(
    'sessionName',
  );
  @override
  late final GeneratedColumn<String> sessionName = GeneratedColumn<String>(
    'session_name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _plannedDurationSecondsMeta =
      const VerificationMeta('plannedDurationSeconds');
  @override
  late final GeneratedColumn<int> plannedDurationSeconds = GeneratedColumn<int>(
    'planned_duration_seconds',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _actualDurationSecondsMeta =
      const VerificationMeta('actualDurationSeconds');
  @override
  late final GeneratedColumn<int> actualDurationSeconds = GeneratedColumn<int>(
    'actual_duration_seconds',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _plannedExercisesMeta = const VerificationMeta(
    'plannedExercises',
  );
  @override
  late final GeneratedColumn<int> plannedExercises = GeneratedColumn<int>(
    'planned_exercises',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _completedExercisesMeta =
      const VerificationMeta('completedExercises');
  @override
  late final GeneratedColumn<int> completedExercises = GeneratedColumn<int>(
    'completed_exercises',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _totalHoldSecondsMeta = const VerificationMeta(
    'totalHoldSeconds',
  );
  @override
  late final GeneratedColumn<int> totalHoldSeconds = GeneratedColumn<int>(
    'total_hold_seconds',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _totalRestSecondsMeta = const VerificationMeta(
    'totalRestSeconds',
  );
  @override
  late final GeneratedColumn<int> totalRestSeconds = GeneratedColumn<int>(
    'total_rest_seconds',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _feedbackShakingMeta = const VerificationMeta(
    'feedbackShaking',
  );
  @override
  late final GeneratedColumn<int> feedbackShaking = GeneratedColumn<int>(
    'feedback_shaking',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _feedbackStructureMeta = const VerificationMeta(
    'feedbackStructure',
  );
  @override
  late final GeneratedColumn<int> feedbackStructure = GeneratedColumn<int>(
    'feedback_structure',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _feedbackRestMeta = const VerificationMeta(
    'feedbackRest',
  );
  @override
  late final GeneratedColumn<int> feedbackRest = GeneratedColumn<int>(
    'feedback_rest',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _progressionSuggestionMeta =
      const VerificationMeta('progressionSuggestion');
  @override
  late final GeneratedColumn<String> progressionSuggestion =
      GeneratedColumn<String>(
        'progression_suggestion',
        aliasedName,
        true,
        type: DriftSqlType.string,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _suggestedNextVersionMeta =
      const VerificationMeta('suggestedNextVersion');
  @override
  late final GeneratedColumn<String> suggestedNextVersion =
      GeneratedColumn<String>(
        'suggested_next_version',
        aliasedName,
        true,
        type: DriftSqlType.string,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _notesMeta = const VerificationMeta('notes');
  @override
  late final GeneratedColumn<String> notes = GeneratedColumn<String>(
    'notes',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _startedAtMeta = const VerificationMeta(
    'startedAt',
  );
  @override
  late final GeneratedColumn<DateTime> startedAt = GeneratedColumn<DateTime>(
    'started_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _completedAtMeta = const VerificationMeta(
    'completedAt',
  );
  @override
  late final GeneratedColumn<DateTime> completedAt = GeneratedColumn<DateTime>(
    'completed_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    sessionTemplateId,
    sessionVersion,
    sessionName,
    plannedDurationSeconds,
    actualDurationSeconds,
    plannedExercises,
    completedExercises,
    totalHoldSeconds,
    totalRestSeconds,
    feedbackShaking,
    feedbackStructure,
    feedbackRest,
    progressionSuggestion,
    suggestedNextVersion,
    notes,
    startedAt,
    completedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'oly_training_logs';
  @override
  VerificationContext validateIntegrity(
    Insertable<OlyTrainingLog> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('session_template_id')) {
      context.handle(
        _sessionTemplateIdMeta,
        sessionTemplateId.isAcceptableOrUnknown(
          data['session_template_id']!,
          _sessionTemplateIdMeta,
        ),
      );
    }
    if (data.containsKey('session_version')) {
      context.handle(
        _sessionVersionMeta,
        sessionVersion.isAcceptableOrUnknown(
          data['session_version']!,
          _sessionVersionMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_sessionVersionMeta);
    }
    if (data.containsKey('session_name')) {
      context.handle(
        _sessionNameMeta,
        sessionName.isAcceptableOrUnknown(
          data['session_name']!,
          _sessionNameMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_sessionNameMeta);
    }
    if (data.containsKey('planned_duration_seconds')) {
      context.handle(
        _plannedDurationSecondsMeta,
        plannedDurationSeconds.isAcceptableOrUnknown(
          data['planned_duration_seconds']!,
          _plannedDurationSecondsMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_plannedDurationSecondsMeta);
    }
    if (data.containsKey('actual_duration_seconds')) {
      context.handle(
        _actualDurationSecondsMeta,
        actualDurationSeconds.isAcceptableOrUnknown(
          data['actual_duration_seconds']!,
          _actualDurationSecondsMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_actualDurationSecondsMeta);
    }
    if (data.containsKey('planned_exercises')) {
      context.handle(
        _plannedExercisesMeta,
        plannedExercises.isAcceptableOrUnknown(
          data['planned_exercises']!,
          _plannedExercisesMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_plannedExercisesMeta);
    }
    if (data.containsKey('completed_exercises')) {
      context.handle(
        _completedExercisesMeta,
        completedExercises.isAcceptableOrUnknown(
          data['completed_exercises']!,
          _completedExercisesMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_completedExercisesMeta);
    }
    if (data.containsKey('total_hold_seconds')) {
      context.handle(
        _totalHoldSecondsMeta,
        totalHoldSeconds.isAcceptableOrUnknown(
          data['total_hold_seconds']!,
          _totalHoldSecondsMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_totalHoldSecondsMeta);
    }
    if (data.containsKey('total_rest_seconds')) {
      context.handle(
        _totalRestSecondsMeta,
        totalRestSeconds.isAcceptableOrUnknown(
          data['total_rest_seconds']!,
          _totalRestSecondsMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_totalRestSecondsMeta);
    }
    if (data.containsKey('feedback_shaking')) {
      context.handle(
        _feedbackShakingMeta,
        feedbackShaking.isAcceptableOrUnknown(
          data['feedback_shaking']!,
          _feedbackShakingMeta,
        ),
      );
    }
    if (data.containsKey('feedback_structure')) {
      context.handle(
        _feedbackStructureMeta,
        feedbackStructure.isAcceptableOrUnknown(
          data['feedback_structure']!,
          _feedbackStructureMeta,
        ),
      );
    }
    if (data.containsKey('feedback_rest')) {
      context.handle(
        _feedbackRestMeta,
        feedbackRest.isAcceptableOrUnknown(
          data['feedback_rest']!,
          _feedbackRestMeta,
        ),
      );
    }
    if (data.containsKey('progression_suggestion')) {
      context.handle(
        _progressionSuggestionMeta,
        progressionSuggestion.isAcceptableOrUnknown(
          data['progression_suggestion']!,
          _progressionSuggestionMeta,
        ),
      );
    }
    if (data.containsKey('suggested_next_version')) {
      context.handle(
        _suggestedNextVersionMeta,
        suggestedNextVersion.isAcceptableOrUnknown(
          data['suggested_next_version']!,
          _suggestedNextVersionMeta,
        ),
      );
    }
    if (data.containsKey('notes')) {
      context.handle(
        _notesMeta,
        notes.isAcceptableOrUnknown(data['notes']!, _notesMeta),
      );
    }
    if (data.containsKey('started_at')) {
      context.handle(
        _startedAtMeta,
        startedAt.isAcceptableOrUnknown(data['started_at']!, _startedAtMeta),
      );
    } else if (isInserting) {
      context.missing(_startedAtMeta);
    }
    if (data.containsKey('completed_at')) {
      context.handle(
        _completedAtMeta,
        completedAt.isAcceptableOrUnknown(
          data['completed_at']!,
          _completedAtMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_completedAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  OlyTrainingLog map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return OlyTrainingLog(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      sessionTemplateId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}session_template_id'],
      ),
      sessionVersion: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}session_version'],
      )!,
      sessionName: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}session_name'],
      )!,
      plannedDurationSeconds: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}planned_duration_seconds'],
      )!,
      actualDurationSeconds: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}actual_duration_seconds'],
      )!,
      plannedExercises: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}planned_exercises'],
      )!,
      completedExercises: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}completed_exercises'],
      )!,
      totalHoldSeconds: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}total_hold_seconds'],
      )!,
      totalRestSeconds: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}total_rest_seconds'],
      )!,
      feedbackShaking: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}feedback_shaking'],
      ),
      feedbackStructure: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}feedback_structure'],
      ),
      feedbackRest: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}feedback_rest'],
      ),
      progressionSuggestion: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}progression_suggestion'],
      ),
      suggestedNextVersion: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}suggested_next_version'],
      ),
      notes: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}notes'],
      ),
      startedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}started_at'],
      )!,
      completedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}completed_at'],
      )!,
    );
  }

  @override
  $OlyTrainingLogsTable createAlias(String alias) {
    return $OlyTrainingLogsTable(attachedDatabase, alias);
  }
}

class OlyTrainingLog extends DataClass implements Insertable<OlyTrainingLog> {
  final String id;
  final String? sessionTemplateId;
  final String sessionVersion;
  final String sessionName;
  final int plannedDurationSeconds;
  final int actualDurationSeconds;
  final int plannedExercises;
  final int completedExercises;
  final int totalHoldSeconds;
  final int totalRestSeconds;
  final int? feedbackShaking;
  final int? feedbackStructure;
  final int? feedbackRest;
  final String? progressionSuggestion;
  final String? suggestedNextVersion;
  final String? notes;
  final DateTime startedAt;
  final DateTime completedAt;
  const OlyTrainingLog({
    required this.id,
    this.sessionTemplateId,
    required this.sessionVersion,
    required this.sessionName,
    required this.plannedDurationSeconds,
    required this.actualDurationSeconds,
    required this.plannedExercises,
    required this.completedExercises,
    required this.totalHoldSeconds,
    required this.totalRestSeconds,
    this.feedbackShaking,
    this.feedbackStructure,
    this.feedbackRest,
    this.progressionSuggestion,
    this.suggestedNextVersion,
    this.notes,
    required this.startedAt,
    required this.completedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    if (!nullToAbsent || sessionTemplateId != null) {
      map['session_template_id'] = Variable<String>(sessionTemplateId);
    }
    map['session_version'] = Variable<String>(sessionVersion);
    map['session_name'] = Variable<String>(sessionName);
    map['planned_duration_seconds'] = Variable<int>(plannedDurationSeconds);
    map['actual_duration_seconds'] = Variable<int>(actualDurationSeconds);
    map['planned_exercises'] = Variable<int>(plannedExercises);
    map['completed_exercises'] = Variable<int>(completedExercises);
    map['total_hold_seconds'] = Variable<int>(totalHoldSeconds);
    map['total_rest_seconds'] = Variable<int>(totalRestSeconds);
    if (!nullToAbsent || feedbackShaking != null) {
      map['feedback_shaking'] = Variable<int>(feedbackShaking);
    }
    if (!nullToAbsent || feedbackStructure != null) {
      map['feedback_structure'] = Variable<int>(feedbackStructure);
    }
    if (!nullToAbsent || feedbackRest != null) {
      map['feedback_rest'] = Variable<int>(feedbackRest);
    }
    if (!nullToAbsent || progressionSuggestion != null) {
      map['progression_suggestion'] = Variable<String>(progressionSuggestion);
    }
    if (!nullToAbsent || suggestedNextVersion != null) {
      map['suggested_next_version'] = Variable<String>(suggestedNextVersion);
    }
    if (!nullToAbsent || notes != null) {
      map['notes'] = Variable<String>(notes);
    }
    map['started_at'] = Variable<DateTime>(startedAt);
    map['completed_at'] = Variable<DateTime>(completedAt);
    return map;
  }

  OlyTrainingLogsCompanion toCompanion(bool nullToAbsent) {
    return OlyTrainingLogsCompanion(
      id: Value(id),
      sessionTemplateId: sessionTemplateId == null && nullToAbsent
          ? const Value.absent()
          : Value(sessionTemplateId),
      sessionVersion: Value(sessionVersion),
      sessionName: Value(sessionName),
      plannedDurationSeconds: Value(plannedDurationSeconds),
      actualDurationSeconds: Value(actualDurationSeconds),
      plannedExercises: Value(plannedExercises),
      completedExercises: Value(completedExercises),
      totalHoldSeconds: Value(totalHoldSeconds),
      totalRestSeconds: Value(totalRestSeconds),
      feedbackShaking: feedbackShaking == null && nullToAbsent
          ? const Value.absent()
          : Value(feedbackShaking),
      feedbackStructure: feedbackStructure == null && nullToAbsent
          ? const Value.absent()
          : Value(feedbackStructure),
      feedbackRest: feedbackRest == null && nullToAbsent
          ? const Value.absent()
          : Value(feedbackRest),
      progressionSuggestion: progressionSuggestion == null && nullToAbsent
          ? const Value.absent()
          : Value(progressionSuggestion),
      suggestedNextVersion: suggestedNextVersion == null && nullToAbsent
          ? const Value.absent()
          : Value(suggestedNextVersion),
      notes: notes == null && nullToAbsent
          ? const Value.absent()
          : Value(notes),
      startedAt: Value(startedAt),
      completedAt: Value(completedAt),
    );
  }

  factory OlyTrainingLog.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return OlyTrainingLog(
      id: serializer.fromJson<String>(json['id']),
      sessionTemplateId: serializer.fromJson<String?>(
        json['sessionTemplateId'],
      ),
      sessionVersion: serializer.fromJson<String>(json['sessionVersion']),
      sessionName: serializer.fromJson<String>(json['sessionName']),
      plannedDurationSeconds: serializer.fromJson<int>(
        json['plannedDurationSeconds'],
      ),
      actualDurationSeconds: serializer.fromJson<int>(
        json['actualDurationSeconds'],
      ),
      plannedExercises: serializer.fromJson<int>(json['plannedExercises']),
      completedExercises: serializer.fromJson<int>(json['completedExercises']),
      totalHoldSeconds: serializer.fromJson<int>(json['totalHoldSeconds']),
      totalRestSeconds: serializer.fromJson<int>(json['totalRestSeconds']),
      feedbackShaking: serializer.fromJson<int?>(json['feedbackShaking']),
      feedbackStructure: serializer.fromJson<int?>(json['feedbackStructure']),
      feedbackRest: serializer.fromJson<int?>(json['feedbackRest']),
      progressionSuggestion: serializer.fromJson<String?>(
        json['progressionSuggestion'],
      ),
      suggestedNextVersion: serializer.fromJson<String?>(
        json['suggestedNextVersion'],
      ),
      notes: serializer.fromJson<String?>(json['notes']),
      startedAt: serializer.fromJson<DateTime>(json['startedAt']),
      completedAt: serializer.fromJson<DateTime>(json['completedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'sessionTemplateId': serializer.toJson<String?>(sessionTemplateId),
      'sessionVersion': serializer.toJson<String>(sessionVersion),
      'sessionName': serializer.toJson<String>(sessionName),
      'plannedDurationSeconds': serializer.toJson<int>(plannedDurationSeconds),
      'actualDurationSeconds': serializer.toJson<int>(actualDurationSeconds),
      'plannedExercises': serializer.toJson<int>(plannedExercises),
      'completedExercises': serializer.toJson<int>(completedExercises),
      'totalHoldSeconds': serializer.toJson<int>(totalHoldSeconds),
      'totalRestSeconds': serializer.toJson<int>(totalRestSeconds),
      'feedbackShaking': serializer.toJson<int?>(feedbackShaking),
      'feedbackStructure': serializer.toJson<int?>(feedbackStructure),
      'feedbackRest': serializer.toJson<int?>(feedbackRest),
      'progressionSuggestion': serializer.toJson<String?>(
        progressionSuggestion,
      ),
      'suggestedNextVersion': serializer.toJson<String?>(suggestedNextVersion),
      'notes': serializer.toJson<String?>(notes),
      'startedAt': serializer.toJson<DateTime>(startedAt),
      'completedAt': serializer.toJson<DateTime>(completedAt),
    };
  }

  OlyTrainingLog copyWith({
    String? id,
    Value<String?> sessionTemplateId = const Value.absent(),
    String? sessionVersion,
    String? sessionName,
    int? plannedDurationSeconds,
    int? actualDurationSeconds,
    int? plannedExercises,
    int? completedExercises,
    int? totalHoldSeconds,
    int? totalRestSeconds,
    Value<int?> feedbackShaking = const Value.absent(),
    Value<int?> feedbackStructure = const Value.absent(),
    Value<int?> feedbackRest = const Value.absent(),
    Value<String?> progressionSuggestion = const Value.absent(),
    Value<String?> suggestedNextVersion = const Value.absent(),
    Value<String?> notes = const Value.absent(),
    DateTime? startedAt,
    DateTime? completedAt,
  }) => OlyTrainingLog(
    id: id ?? this.id,
    sessionTemplateId: sessionTemplateId.present
        ? sessionTemplateId.value
        : this.sessionTemplateId,
    sessionVersion: sessionVersion ?? this.sessionVersion,
    sessionName: sessionName ?? this.sessionName,
    plannedDurationSeconds:
        plannedDurationSeconds ?? this.plannedDurationSeconds,
    actualDurationSeconds: actualDurationSeconds ?? this.actualDurationSeconds,
    plannedExercises: plannedExercises ?? this.plannedExercises,
    completedExercises: completedExercises ?? this.completedExercises,
    totalHoldSeconds: totalHoldSeconds ?? this.totalHoldSeconds,
    totalRestSeconds: totalRestSeconds ?? this.totalRestSeconds,
    feedbackShaking: feedbackShaking.present
        ? feedbackShaking.value
        : this.feedbackShaking,
    feedbackStructure: feedbackStructure.present
        ? feedbackStructure.value
        : this.feedbackStructure,
    feedbackRest: feedbackRest.present ? feedbackRest.value : this.feedbackRest,
    progressionSuggestion: progressionSuggestion.present
        ? progressionSuggestion.value
        : this.progressionSuggestion,
    suggestedNextVersion: suggestedNextVersion.present
        ? suggestedNextVersion.value
        : this.suggestedNextVersion,
    notes: notes.present ? notes.value : this.notes,
    startedAt: startedAt ?? this.startedAt,
    completedAt: completedAt ?? this.completedAt,
  );
  OlyTrainingLog copyWithCompanion(OlyTrainingLogsCompanion data) {
    return OlyTrainingLog(
      id: data.id.present ? data.id.value : this.id,
      sessionTemplateId: data.sessionTemplateId.present
          ? data.sessionTemplateId.value
          : this.sessionTemplateId,
      sessionVersion: data.sessionVersion.present
          ? data.sessionVersion.value
          : this.sessionVersion,
      sessionName: data.sessionName.present
          ? data.sessionName.value
          : this.sessionName,
      plannedDurationSeconds: data.plannedDurationSeconds.present
          ? data.plannedDurationSeconds.value
          : this.plannedDurationSeconds,
      actualDurationSeconds: data.actualDurationSeconds.present
          ? data.actualDurationSeconds.value
          : this.actualDurationSeconds,
      plannedExercises: data.plannedExercises.present
          ? data.plannedExercises.value
          : this.plannedExercises,
      completedExercises: data.completedExercises.present
          ? data.completedExercises.value
          : this.completedExercises,
      totalHoldSeconds: data.totalHoldSeconds.present
          ? data.totalHoldSeconds.value
          : this.totalHoldSeconds,
      totalRestSeconds: data.totalRestSeconds.present
          ? data.totalRestSeconds.value
          : this.totalRestSeconds,
      feedbackShaking: data.feedbackShaking.present
          ? data.feedbackShaking.value
          : this.feedbackShaking,
      feedbackStructure: data.feedbackStructure.present
          ? data.feedbackStructure.value
          : this.feedbackStructure,
      feedbackRest: data.feedbackRest.present
          ? data.feedbackRest.value
          : this.feedbackRest,
      progressionSuggestion: data.progressionSuggestion.present
          ? data.progressionSuggestion.value
          : this.progressionSuggestion,
      suggestedNextVersion: data.suggestedNextVersion.present
          ? data.suggestedNextVersion.value
          : this.suggestedNextVersion,
      notes: data.notes.present ? data.notes.value : this.notes,
      startedAt: data.startedAt.present ? data.startedAt.value : this.startedAt,
      completedAt: data.completedAt.present
          ? data.completedAt.value
          : this.completedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('OlyTrainingLog(')
          ..write('id: $id, ')
          ..write('sessionTemplateId: $sessionTemplateId, ')
          ..write('sessionVersion: $sessionVersion, ')
          ..write('sessionName: $sessionName, ')
          ..write('plannedDurationSeconds: $plannedDurationSeconds, ')
          ..write('actualDurationSeconds: $actualDurationSeconds, ')
          ..write('plannedExercises: $plannedExercises, ')
          ..write('completedExercises: $completedExercises, ')
          ..write('totalHoldSeconds: $totalHoldSeconds, ')
          ..write('totalRestSeconds: $totalRestSeconds, ')
          ..write('feedbackShaking: $feedbackShaking, ')
          ..write('feedbackStructure: $feedbackStructure, ')
          ..write('feedbackRest: $feedbackRest, ')
          ..write('progressionSuggestion: $progressionSuggestion, ')
          ..write('suggestedNextVersion: $suggestedNextVersion, ')
          ..write('notes: $notes, ')
          ..write('startedAt: $startedAt, ')
          ..write('completedAt: $completedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    sessionTemplateId,
    sessionVersion,
    sessionName,
    plannedDurationSeconds,
    actualDurationSeconds,
    plannedExercises,
    completedExercises,
    totalHoldSeconds,
    totalRestSeconds,
    feedbackShaking,
    feedbackStructure,
    feedbackRest,
    progressionSuggestion,
    suggestedNextVersion,
    notes,
    startedAt,
    completedAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is OlyTrainingLog &&
          other.id == this.id &&
          other.sessionTemplateId == this.sessionTemplateId &&
          other.sessionVersion == this.sessionVersion &&
          other.sessionName == this.sessionName &&
          other.plannedDurationSeconds == this.plannedDurationSeconds &&
          other.actualDurationSeconds == this.actualDurationSeconds &&
          other.plannedExercises == this.plannedExercises &&
          other.completedExercises == this.completedExercises &&
          other.totalHoldSeconds == this.totalHoldSeconds &&
          other.totalRestSeconds == this.totalRestSeconds &&
          other.feedbackShaking == this.feedbackShaking &&
          other.feedbackStructure == this.feedbackStructure &&
          other.feedbackRest == this.feedbackRest &&
          other.progressionSuggestion == this.progressionSuggestion &&
          other.suggestedNextVersion == this.suggestedNextVersion &&
          other.notes == this.notes &&
          other.startedAt == this.startedAt &&
          other.completedAt == this.completedAt);
}

class OlyTrainingLogsCompanion extends UpdateCompanion<OlyTrainingLog> {
  final Value<String> id;
  final Value<String?> sessionTemplateId;
  final Value<String> sessionVersion;
  final Value<String> sessionName;
  final Value<int> plannedDurationSeconds;
  final Value<int> actualDurationSeconds;
  final Value<int> plannedExercises;
  final Value<int> completedExercises;
  final Value<int> totalHoldSeconds;
  final Value<int> totalRestSeconds;
  final Value<int?> feedbackShaking;
  final Value<int?> feedbackStructure;
  final Value<int?> feedbackRest;
  final Value<String?> progressionSuggestion;
  final Value<String?> suggestedNextVersion;
  final Value<String?> notes;
  final Value<DateTime> startedAt;
  final Value<DateTime> completedAt;
  final Value<int> rowid;
  const OlyTrainingLogsCompanion({
    this.id = const Value.absent(),
    this.sessionTemplateId = const Value.absent(),
    this.sessionVersion = const Value.absent(),
    this.sessionName = const Value.absent(),
    this.plannedDurationSeconds = const Value.absent(),
    this.actualDurationSeconds = const Value.absent(),
    this.plannedExercises = const Value.absent(),
    this.completedExercises = const Value.absent(),
    this.totalHoldSeconds = const Value.absent(),
    this.totalRestSeconds = const Value.absent(),
    this.feedbackShaking = const Value.absent(),
    this.feedbackStructure = const Value.absent(),
    this.feedbackRest = const Value.absent(),
    this.progressionSuggestion = const Value.absent(),
    this.suggestedNextVersion = const Value.absent(),
    this.notes = const Value.absent(),
    this.startedAt = const Value.absent(),
    this.completedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  OlyTrainingLogsCompanion.insert({
    required String id,
    this.sessionTemplateId = const Value.absent(),
    required String sessionVersion,
    required String sessionName,
    required int plannedDurationSeconds,
    required int actualDurationSeconds,
    required int plannedExercises,
    required int completedExercises,
    required int totalHoldSeconds,
    required int totalRestSeconds,
    this.feedbackShaking = const Value.absent(),
    this.feedbackStructure = const Value.absent(),
    this.feedbackRest = const Value.absent(),
    this.progressionSuggestion = const Value.absent(),
    this.suggestedNextVersion = const Value.absent(),
    this.notes = const Value.absent(),
    required DateTime startedAt,
    required DateTime completedAt,
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       sessionVersion = Value(sessionVersion),
       sessionName = Value(sessionName),
       plannedDurationSeconds = Value(plannedDurationSeconds),
       actualDurationSeconds = Value(actualDurationSeconds),
       plannedExercises = Value(plannedExercises),
       completedExercises = Value(completedExercises),
       totalHoldSeconds = Value(totalHoldSeconds),
       totalRestSeconds = Value(totalRestSeconds),
       startedAt = Value(startedAt),
       completedAt = Value(completedAt);
  static Insertable<OlyTrainingLog> custom({
    Expression<String>? id,
    Expression<String>? sessionTemplateId,
    Expression<String>? sessionVersion,
    Expression<String>? sessionName,
    Expression<int>? plannedDurationSeconds,
    Expression<int>? actualDurationSeconds,
    Expression<int>? plannedExercises,
    Expression<int>? completedExercises,
    Expression<int>? totalHoldSeconds,
    Expression<int>? totalRestSeconds,
    Expression<int>? feedbackShaking,
    Expression<int>? feedbackStructure,
    Expression<int>? feedbackRest,
    Expression<String>? progressionSuggestion,
    Expression<String>? suggestedNextVersion,
    Expression<String>? notes,
    Expression<DateTime>? startedAt,
    Expression<DateTime>? completedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (sessionTemplateId != null) 'session_template_id': sessionTemplateId,
      if (sessionVersion != null) 'session_version': sessionVersion,
      if (sessionName != null) 'session_name': sessionName,
      if (plannedDurationSeconds != null)
        'planned_duration_seconds': plannedDurationSeconds,
      if (actualDurationSeconds != null)
        'actual_duration_seconds': actualDurationSeconds,
      if (plannedExercises != null) 'planned_exercises': plannedExercises,
      if (completedExercises != null) 'completed_exercises': completedExercises,
      if (totalHoldSeconds != null) 'total_hold_seconds': totalHoldSeconds,
      if (totalRestSeconds != null) 'total_rest_seconds': totalRestSeconds,
      if (feedbackShaking != null) 'feedback_shaking': feedbackShaking,
      if (feedbackStructure != null) 'feedback_structure': feedbackStructure,
      if (feedbackRest != null) 'feedback_rest': feedbackRest,
      if (progressionSuggestion != null)
        'progression_suggestion': progressionSuggestion,
      if (suggestedNextVersion != null)
        'suggested_next_version': suggestedNextVersion,
      if (notes != null) 'notes': notes,
      if (startedAt != null) 'started_at': startedAt,
      if (completedAt != null) 'completed_at': completedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  OlyTrainingLogsCompanion copyWith({
    Value<String>? id,
    Value<String?>? sessionTemplateId,
    Value<String>? sessionVersion,
    Value<String>? sessionName,
    Value<int>? plannedDurationSeconds,
    Value<int>? actualDurationSeconds,
    Value<int>? plannedExercises,
    Value<int>? completedExercises,
    Value<int>? totalHoldSeconds,
    Value<int>? totalRestSeconds,
    Value<int?>? feedbackShaking,
    Value<int?>? feedbackStructure,
    Value<int?>? feedbackRest,
    Value<String?>? progressionSuggestion,
    Value<String?>? suggestedNextVersion,
    Value<String?>? notes,
    Value<DateTime>? startedAt,
    Value<DateTime>? completedAt,
    Value<int>? rowid,
  }) {
    return OlyTrainingLogsCompanion(
      id: id ?? this.id,
      sessionTemplateId: sessionTemplateId ?? this.sessionTemplateId,
      sessionVersion: sessionVersion ?? this.sessionVersion,
      sessionName: sessionName ?? this.sessionName,
      plannedDurationSeconds:
          plannedDurationSeconds ?? this.plannedDurationSeconds,
      actualDurationSeconds:
          actualDurationSeconds ?? this.actualDurationSeconds,
      plannedExercises: plannedExercises ?? this.plannedExercises,
      completedExercises: completedExercises ?? this.completedExercises,
      totalHoldSeconds: totalHoldSeconds ?? this.totalHoldSeconds,
      totalRestSeconds: totalRestSeconds ?? this.totalRestSeconds,
      feedbackShaking: feedbackShaking ?? this.feedbackShaking,
      feedbackStructure: feedbackStructure ?? this.feedbackStructure,
      feedbackRest: feedbackRest ?? this.feedbackRest,
      progressionSuggestion:
          progressionSuggestion ?? this.progressionSuggestion,
      suggestedNextVersion: suggestedNextVersion ?? this.suggestedNextVersion,
      notes: notes ?? this.notes,
      startedAt: startedAt ?? this.startedAt,
      completedAt: completedAt ?? this.completedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (sessionTemplateId.present) {
      map['session_template_id'] = Variable<String>(sessionTemplateId.value);
    }
    if (sessionVersion.present) {
      map['session_version'] = Variable<String>(sessionVersion.value);
    }
    if (sessionName.present) {
      map['session_name'] = Variable<String>(sessionName.value);
    }
    if (plannedDurationSeconds.present) {
      map['planned_duration_seconds'] = Variable<int>(
        plannedDurationSeconds.value,
      );
    }
    if (actualDurationSeconds.present) {
      map['actual_duration_seconds'] = Variable<int>(
        actualDurationSeconds.value,
      );
    }
    if (plannedExercises.present) {
      map['planned_exercises'] = Variable<int>(plannedExercises.value);
    }
    if (completedExercises.present) {
      map['completed_exercises'] = Variable<int>(completedExercises.value);
    }
    if (totalHoldSeconds.present) {
      map['total_hold_seconds'] = Variable<int>(totalHoldSeconds.value);
    }
    if (totalRestSeconds.present) {
      map['total_rest_seconds'] = Variable<int>(totalRestSeconds.value);
    }
    if (feedbackShaking.present) {
      map['feedback_shaking'] = Variable<int>(feedbackShaking.value);
    }
    if (feedbackStructure.present) {
      map['feedback_structure'] = Variable<int>(feedbackStructure.value);
    }
    if (feedbackRest.present) {
      map['feedback_rest'] = Variable<int>(feedbackRest.value);
    }
    if (progressionSuggestion.present) {
      map['progression_suggestion'] = Variable<String>(
        progressionSuggestion.value,
      );
    }
    if (suggestedNextVersion.present) {
      map['suggested_next_version'] = Variable<String>(
        suggestedNextVersion.value,
      );
    }
    if (notes.present) {
      map['notes'] = Variable<String>(notes.value);
    }
    if (startedAt.present) {
      map['started_at'] = Variable<DateTime>(startedAt.value);
    }
    if (completedAt.present) {
      map['completed_at'] = Variable<DateTime>(completedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('OlyTrainingLogsCompanion(')
          ..write('id: $id, ')
          ..write('sessionTemplateId: $sessionTemplateId, ')
          ..write('sessionVersion: $sessionVersion, ')
          ..write('sessionName: $sessionName, ')
          ..write('plannedDurationSeconds: $plannedDurationSeconds, ')
          ..write('actualDurationSeconds: $actualDurationSeconds, ')
          ..write('plannedExercises: $plannedExercises, ')
          ..write('completedExercises: $completedExercises, ')
          ..write('totalHoldSeconds: $totalHoldSeconds, ')
          ..write('totalRestSeconds: $totalRestSeconds, ')
          ..write('feedbackShaking: $feedbackShaking, ')
          ..write('feedbackStructure: $feedbackStructure, ')
          ..write('feedbackRest: $feedbackRest, ')
          ..write('progressionSuggestion: $progressionSuggestion, ')
          ..write('suggestedNextVersion: $suggestedNextVersion, ')
          ..write('notes: $notes, ')
          ..write('startedAt: $startedAt, ')
          ..write('completedAt: $completedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $UserTrainingProgressTable extends UserTrainingProgress
    with TableInfo<$UserTrainingProgressTable, UserTrainingProgressData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $UserTrainingProgressTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _currentLevelMeta = const VerificationMeta(
    'currentLevel',
  );
  @override
  late final GeneratedColumn<String> currentLevel = GeneratedColumn<String>(
    'current_level',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('1.0'),
  );
  static const VerificationMeta _sessionsAtCurrentLevelMeta =
      const VerificationMeta('sessionsAtCurrentLevel');
  @override
  late final GeneratedColumn<int> sessionsAtCurrentLevel = GeneratedColumn<int>(
    'sessions_at_current_level',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _lastSessionAtMeta = const VerificationMeta(
    'lastSessionAt',
  );
  @override
  late final GeneratedColumn<DateTime> lastSessionAt =
      GeneratedColumn<DateTime>(
        'last_session_at',
        aliasedName,
        true,
        type: DriftSqlType.dateTime,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _lastSessionVersionMeta =
      const VerificationMeta('lastSessionVersion');
  @override
  late final GeneratedColumn<String> lastSessionVersion =
      GeneratedColumn<String>(
        'last_session_version',
        aliasedName,
        true,
        type: DriftSqlType.string,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _totalSessionsCompletedMeta =
      const VerificationMeta('totalSessionsCompleted');
  @override
  late final GeneratedColumn<int> totalSessionsCompleted = GeneratedColumn<int>(
    'total_sessions_completed',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _hasCompletedAssessmentMeta =
      const VerificationMeta('hasCompletedAssessment');
  @override
  late final GeneratedColumn<bool> hasCompletedAssessment =
      GeneratedColumn<bool>(
        'has_completed_assessment',
        aliasedName,
        false,
        type: DriftSqlType.bool,
        requiredDuringInsert: false,
        defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("has_completed_assessment" IN (0, 1))',
        ),
        defaultValue: const Constant(false),
      );
  static const VerificationMeta _assessmentMaxHoldSecondsMeta =
      const VerificationMeta('assessmentMaxHoldSeconds');
  @override
  late final GeneratedColumn<int> assessmentMaxHoldSeconds =
      GeneratedColumn<int>(
        'assessment_max_hold_seconds',
        aliasedName,
        true,
        type: DriftSqlType.int,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _assessmentDateMeta = const VerificationMeta(
    'assessmentDate',
  );
  @override
  late final GeneratedColumn<DateTime> assessmentDate =
      GeneratedColumn<DateTime>(
        'assessment_date',
        aliasedName,
        true,
        type: DriftSqlType.dateTime,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    currentLevel,
    sessionsAtCurrentLevel,
    lastSessionAt,
    lastSessionVersion,
    totalSessionsCompleted,
    hasCompletedAssessment,
    assessmentMaxHoldSeconds,
    assessmentDate,
    createdAt,
    updatedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'user_training_progress';
  @override
  VerificationContext validateIntegrity(
    Insertable<UserTrainingProgressData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('current_level')) {
      context.handle(
        _currentLevelMeta,
        currentLevel.isAcceptableOrUnknown(
          data['current_level']!,
          _currentLevelMeta,
        ),
      );
    }
    if (data.containsKey('sessions_at_current_level')) {
      context.handle(
        _sessionsAtCurrentLevelMeta,
        sessionsAtCurrentLevel.isAcceptableOrUnknown(
          data['sessions_at_current_level']!,
          _sessionsAtCurrentLevelMeta,
        ),
      );
    }
    if (data.containsKey('last_session_at')) {
      context.handle(
        _lastSessionAtMeta,
        lastSessionAt.isAcceptableOrUnknown(
          data['last_session_at']!,
          _lastSessionAtMeta,
        ),
      );
    }
    if (data.containsKey('last_session_version')) {
      context.handle(
        _lastSessionVersionMeta,
        lastSessionVersion.isAcceptableOrUnknown(
          data['last_session_version']!,
          _lastSessionVersionMeta,
        ),
      );
    }
    if (data.containsKey('total_sessions_completed')) {
      context.handle(
        _totalSessionsCompletedMeta,
        totalSessionsCompleted.isAcceptableOrUnknown(
          data['total_sessions_completed']!,
          _totalSessionsCompletedMeta,
        ),
      );
    }
    if (data.containsKey('has_completed_assessment')) {
      context.handle(
        _hasCompletedAssessmentMeta,
        hasCompletedAssessment.isAcceptableOrUnknown(
          data['has_completed_assessment']!,
          _hasCompletedAssessmentMeta,
        ),
      );
    }
    if (data.containsKey('assessment_max_hold_seconds')) {
      context.handle(
        _assessmentMaxHoldSecondsMeta,
        assessmentMaxHoldSeconds.isAcceptableOrUnknown(
          data['assessment_max_hold_seconds']!,
          _assessmentMaxHoldSecondsMeta,
        ),
      );
    }
    if (data.containsKey('assessment_date')) {
      context.handle(
        _assessmentDateMeta,
        assessmentDate.isAcceptableOrUnknown(
          data['assessment_date']!,
          _assessmentDateMeta,
        ),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  UserTrainingProgressData map(
    Map<String, dynamic> data, {
    String? tablePrefix,
  }) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return UserTrainingProgressData(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      currentLevel: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}current_level'],
      )!,
      sessionsAtCurrentLevel: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sessions_at_current_level'],
      )!,
      lastSessionAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}last_session_at'],
      ),
      lastSessionVersion: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}last_session_version'],
      ),
      totalSessionsCompleted: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}total_sessions_completed'],
      )!,
      hasCompletedAssessment: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}has_completed_assessment'],
      )!,
      assessmentMaxHoldSeconds: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}assessment_max_hold_seconds'],
      ),
      assessmentDate: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}assessment_date'],
      ),
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      )!,
    );
  }

  @override
  $UserTrainingProgressTable createAlias(String alias) {
    return $UserTrainingProgressTable(attachedDatabase, alias);
  }
}

class UserTrainingProgressData extends DataClass
    implements Insertable<UserTrainingProgressData> {
  final String id;
  final String currentLevel;
  final int sessionsAtCurrentLevel;
  final DateTime? lastSessionAt;
  final String? lastSessionVersion;
  final int totalSessionsCompleted;
  final bool hasCompletedAssessment;
  final int? assessmentMaxHoldSeconds;
  final DateTime? assessmentDate;
  final DateTime createdAt;
  final DateTime updatedAt;
  const UserTrainingProgressData({
    required this.id,
    required this.currentLevel,
    required this.sessionsAtCurrentLevel,
    this.lastSessionAt,
    this.lastSessionVersion,
    required this.totalSessionsCompleted,
    required this.hasCompletedAssessment,
    this.assessmentMaxHoldSeconds,
    this.assessmentDate,
    required this.createdAt,
    required this.updatedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['current_level'] = Variable<String>(currentLevel);
    map['sessions_at_current_level'] = Variable<int>(sessionsAtCurrentLevel);
    if (!nullToAbsent || lastSessionAt != null) {
      map['last_session_at'] = Variable<DateTime>(lastSessionAt);
    }
    if (!nullToAbsent || lastSessionVersion != null) {
      map['last_session_version'] = Variable<String>(lastSessionVersion);
    }
    map['total_sessions_completed'] = Variable<int>(totalSessionsCompleted);
    map['has_completed_assessment'] = Variable<bool>(hasCompletedAssessment);
    if (!nullToAbsent || assessmentMaxHoldSeconds != null) {
      map['assessment_max_hold_seconds'] = Variable<int>(
        assessmentMaxHoldSeconds,
      );
    }
    if (!nullToAbsent || assessmentDate != null) {
      map['assessment_date'] = Variable<DateTime>(assessmentDate);
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    return map;
  }

  UserTrainingProgressCompanion toCompanion(bool nullToAbsent) {
    return UserTrainingProgressCompanion(
      id: Value(id),
      currentLevel: Value(currentLevel),
      sessionsAtCurrentLevel: Value(sessionsAtCurrentLevel),
      lastSessionAt: lastSessionAt == null && nullToAbsent
          ? const Value.absent()
          : Value(lastSessionAt),
      lastSessionVersion: lastSessionVersion == null && nullToAbsent
          ? const Value.absent()
          : Value(lastSessionVersion),
      totalSessionsCompleted: Value(totalSessionsCompleted),
      hasCompletedAssessment: Value(hasCompletedAssessment),
      assessmentMaxHoldSeconds: assessmentMaxHoldSeconds == null && nullToAbsent
          ? const Value.absent()
          : Value(assessmentMaxHoldSeconds),
      assessmentDate: assessmentDate == null && nullToAbsent
          ? const Value.absent()
          : Value(assessmentDate),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory UserTrainingProgressData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return UserTrainingProgressData(
      id: serializer.fromJson<String>(json['id']),
      currentLevel: serializer.fromJson<String>(json['currentLevel']),
      sessionsAtCurrentLevel: serializer.fromJson<int>(
        json['sessionsAtCurrentLevel'],
      ),
      lastSessionAt: serializer.fromJson<DateTime?>(json['lastSessionAt']),
      lastSessionVersion: serializer.fromJson<String?>(
        json['lastSessionVersion'],
      ),
      totalSessionsCompleted: serializer.fromJson<int>(
        json['totalSessionsCompleted'],
      ),
      hasCompletedAssessment: serializer.fromJson<bool>(
        json['hasCompletedAssessment'],
      ),
      assessmentMaxHoldSeconds: serializer.fromJson<int?>(
        json['assessmentMaxHoldSeconds'],
      ),
      assessmentDate: serializer.fromJson<DateTime?>(json['assessmentDate']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'currentLevel': serializer.toJson<String>(currentLevel),
      'sessionsAtCurrentLevel': serializer.toJson<int>(sessionsAtCurrentLevel),
      'lastSessionAt': serializer.toJson<DateTime?>(lastSessionAt),
      'lastSessionVersion': serializer.toJson<String?>(lastSessionVersion),
      'totalSessionsCompleted': serializer.toJson<int>(totalSessionsCompleted),
      'hasCompletedAssessment': serializer.toJson<bool>(hasCompletedAssessment),
      'assessmentMaxHoldSeconds': serializer.toJson<int?>(
        assessmentMaxHoldSeconds,
      ),
      'assessmentDate': serializer.toJson<DateTime?>(assessmentDate),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
    };
  }

  UserTrainingProgressData copyWith({
    String? id,
    String? currentLevel,
    int? sessionsAtCurrentLevel,
    Value<DateTime?> lastSessionAt = const Value.absent(),
    Value<String?> lastSessionVersion = const Value.absent(),
    int? totalSessionsCompleted,
    bool? hasCompletedAssessment,
    Value<int?> assessmentMaxHoldSeconds = const Value.absent(),
    Value<DateTime?> assessmentDate = const Value.absent(),
    DateTime? createdAt,
    DateTime? updatedAt,
  }) => UserTrainingProgressData(
    id: id ?? this.id,
    currentLevel: currentLevel ?? this.currentLevel,
    sessionsAtCurrentLevel:
        sessionsAtCurrentLevel ?? this.sessionsAtCurrentLevel,
    lastSessionAt: lastSessionAt.present
        ? lastSessionAt.value
        : this.lastSessionAt,
    lastSessionVersion: lastSessionVersion.present
        ? lastSessionVersion.value
        : this.lastSessionVersion,
    totalSessionsCompleted:
        totalSessionsCompleted ?? this.totalSessionsCompleted,
    hasCompletedAssessment:
        hasCompletedAssessment ?? this.hasCompletedAssessment,
    assessmentMaxHoldSeconds: assessmentMaxHoldSeconds.present
        ? assessmentMaxHoldSeconds.value
        : this.assessmentMaxHoldSeconds,
    assessmentDate: assessmentDate.present
        ? assessmentDate.value
        : this.assessmentDate,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
  );
  UserTrainingProgressData copyWithCompanion(
    UserTrainingProgressCompanion data,
  ) {
    return UserTrainingProgressData(
      id: data.id.present ? data.id.value : this.id,
      currentLevel: data.currentLevel.present
          ? data.currentLevel.value
          : this.currentLevel,
      sessionsAtCurrentLevel: data.sessionsAtCurrentLevel.present
          ? data.sessionsAtCurrentLevel.value
          : this.sessionsAtCurrentLevel,
      lastSessionAt: data.lastSessionAt.present
          ? data.lastSessionAt.value
          : this.lastSessionAt,
      lastSessionVersion: data.lastSessionVersion.present
          ? data.lastSessionVersion.value
          : this.lastSessionVersion,
      totalSessionsCompleted: data.totalSessionsCompleted.present
          ? data.totalSessionsCompleted.value
          : this.totalSessionsCompleted,
      hasCompletedAssessment: data.hasCompletedAssessment.present
          ? data.hasCompletedAssessment.value
          : this.hasCompletedAssessment,
      assessmentMaxHoldSeconds: data.assessmentMaxHoldSeconds.present
          ? data.assessmentMaxHoldSeconds.value
          : this.assessmentMaxHoldSeconds,
      assessmentDate: data.assessmentDate.present
          ? data.assessmentDate.value
          : this.assessmentDate,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('UserTrainingProgressData(')
          ..write('id: $id, ')
          ..write('currentLevel: $currentLevel, ')
          ..write('sessionsAtCurrentLevel: $sessionsAtCurrentLevel, ')
          ..write('lastSessionAt: $lastSessionAt, ')
          ..write('lastSessionVersion: $lastSessionVersion, ')
          ..write('totalSessionsCompleted: $totalSessionsCompleted, ')
          ..write('hasCompletedAssessment: $hasCompletedAssessment, ')
          ..write('assessmentMaxHoldSeconds: $assessmentMaxHoldSeconds, ')
          ..write('assessmentDate: $assessmentDate, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    currentLevel,
    sessionsAtCurrentLevel,
    lastSessionAt,
    lastSessionVersion,
    totalSessionsCompleted,
    hasCompletedAssessment,
    assessmentMaxHoldSeconds,
    assessmentDate,
    createdAt,
    updatedAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is UserTrainingProgressData &&
          other.id == this.id &&
          other.currentLevel == this.currentLevel &&
          other.sessionsAtCurrentLevel == this.sessionsAtCurrentLevel &&
          other.lastSessionAt == this.lastSessionAt &&
          other.lastSessionVersion == this.lastSessionVersion &&
          other.totalSessionsCompleted == this.totalSessionsCompleted &&
          other.hasCompletedAssessment == this.hasCompletedAssessment &&
          other.assessmentMaxHoldSeconds == this.assessmentMaxHoldSeconds &&
          other.assessmentDate == this.assessmentDate &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class UserTrainingProgressCompanion
    extends UpdateCompanion<UserTrainingProgressData> {
  final Value<String> id;
  final Value<String> currentLevel;
  final Value<int> sessionsAtCurrentLevel;
  final Value<DateTime?> lastSessionAt;
  final Value<String?> lastSessionVersion;
  final Value<int> totalSessionsCompleted;
  final Value<bool> hasCompletedAssessment;
  final Value<int?> assessmentMaxHoldSeconds;
  final Value<DateTime?> assessmentDate;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  final Value<int> rowid;
  const UserTrainingProgressCompanion({
    this.id = const Value.absent(),
    this.currentLevel = const Value.absent(),
    this.sessionsAtCurrentLevel = const Value.absent(),
    this.lastSessionAt = const Value.absent(),
    this.lastSessionVersion = const Value.absent(),
    this.totalSessionsCompleted = const Value.absent(),
    this.hasCompletedAssessment = const Value.absent(),
    this.assessmentMaxHoldSeconds = const Value.absent(),
    this.assessmentDate = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  UserTrainingProgressCompanion.insert({
    required String id,
    this.currentLevel = const Value.absent(),
    this.sessionsAtCurrentLevel = const Value.absent(),
    this.lastSessionAt = const Value.absent(),
    this.lastSessionVersion = const Value.absent(),
    this.totalSessionsCompleted = const Value.absent(),
    this.hasCompletedAssessment = const Value.absent(),
    this.assessmentMaxHoldSeconds = const Value.absent(),
    this.assessmentDate = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id);
  static Insertable<UserTrainingProgressData> custom({
    Expression<String>? id,
    Expression<String>? currentLevel,
    Expression<int>? sessionsAtCurrentLevel,
    Expression<DateTime>? lastSessionAt,
    Expression<String>? lastSessionVersion,
    Expression<int>? totalSessionsCompleted,
    Expression<bool>? hasCompletedAssessment,
    Expression<int>? assessmentMaxHoldSeconds,
    Expression<DateTime>? assessmentDate,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (currentLevel != null) 'current_level': currentLevel,
      if (sessionsAtCurrentLevel != null)
        'sessions_at_current_level': sessionsAtCurrentLevel,
      if (lastSessionAt != null) 'last_session_at': lastSessionAt,
      if (lastSessionVersion != null)
        'last_session_version': lastSessionVersion,
      if (totalSessionsCompleted != null)
        'total_sessions_completed': totalSessionsCompleted,
      if (hasCompletedAssessment != null)
        'has_completed_assessment': hasCompletedAssessment,
      if (assessmentMaxHoldSeconds != null)
        'assessment_max_hold_seconds': assessmentMaxHoldSeconds,
      if (assessmentDate != null) 'assessment_date': assessmentDate,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  UserTrainingProgressCompanion copyWith({
    Value<String>? id,
    Value<String>? currentLevel,
    Value<int>? sessionsAtCurrentLevel,
    Value<DateTime?>? lastSessionAt,
    Value<String?>? lastSessionVersion,
    Value<int>? totalSessionsCompleted,
    Value<bool>? hasCompletedAssessment,
    Value<int?>? assessmentMaxHoldSeconds,
    Value<DateTime?>? assessmentDate,
    Value<DateTime>? createdAt,
    Value<DateTime>? updatedAt,
    Value<int>? rowid,
  }) {
    return UserTrainingProgressCompanion(
      id: id ?? this.id,
      currentLevel: currentLevel ?? this.currentLevel,
      sessionsAtCurrentLevel:
          sessionsAtCurrentLevel ?? this.sessionsAtCurrentLevel,
      lastSessionAt: lastSessionAt ?? this.lastSessionAt,
      lastSessionVersion: lastSessionVersion ?? this.lastSessionVersion,
      totalSessionsCompleted:
          totalSessionsCompleted ?? this.totalSessionsCompleted,
      hasCompletedAssessment:
          hasCompletedAssessment ?? this.hasCompletedAssessment,
      assessmentMaxHoldSeconds:
          assessmentMaxHoldSeconds ?? this.assessmentMaxHoldSeconds,
      assessmentDate: assessmentDate ?? this.assessmentDate,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (currentLevel.present) {
      map['current_level'] = Variable<String>(currentLevel.value);
    }
    if (sessionsAtCurrentLevel.present) {
      map['sessions_at_current_level'] = Variable<int>(
        sessionsAtCurrentLevel.value,
      );
    }
    if (lastSessionAt.present) {
      map['last_session_at'] = Variable<DateTime>(lastSessionAt.value);
    }
    if (lastSessionVersion.present) {
      map['last_session_version'] = Variable<String>(lastSessionVersion.value);
    }
    if (totalSessionsCompleted.present) {
      map['total_sessions_completed'] = Variable<int>(
        totalSessionsCompleted.value,
      );
    }
    if (hasCompletedAssessment.present) {
      map['has_completed_assessment'] = Variable<bool>(
        hasCompletedAssessment.value,
      );
    }
    if (assessmentMaxHoldSeconds.present) {
      map['assessment_max_hold_seconds'] = Variable<int>(
        assessmentMaxHoldSeconds.value,
      );
    }
    if (assessmentDate.present) {
      map['assessment_date'] = Variable<DateTime>(assessmentDate.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('UserTrainingProgressCompanion(')
          ..write('id: $id, ')
          ..write('currentLevel: $currentLevel, ')
          ..write('sessionsAtCurrentLevel: $sessionsAtCurrentLevel, ')
          ..write('lastSessionAt: $lastSessionAt, ')
          ..write('lastSessionVersion: $lastSessionVersion, ')
          ..write('totalSessionsCompleted: $totalSessionsCompleted, ')
          ..write('hasCompletedAssessment: $hasCompletedAssessment, ')
          ..write('assessmentMaxHoldSeconds: $assessmentMaxHoldSeconds, ')
          ..write('assessmentDate: $assessmentDate, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $BreathTrainingLogsTable extends BreathTrainingLogs
    with TableInfo<$BreathTrainingLogsTable, BreathTrainingLog> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $BreathTrainingLogsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _sessionTypeMeta = const VerificationMeta(
    'sessionType',
  );
  @override
  late final GeneratedColumn<String> sessionType = GeneratedColumn<String>(
    'session_type',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _totalHoldSecondsMeta = const VerificationMeta(
    'totalHoldSeconds',
  );
  @override
  late final GeneratedColumn<int> totalHoldSeconds = GeneratedColumn<int>(
    'total_hold_seconds',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _bestHoldThisSessionMeta =
      const VerificationMeta('bestHoldThisSession');
  @override
  late final GeneratedColumn<int> bestHoldThisSession = GeneratedColumn<int>(
    'best_hold_this_session',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _bestExhaleSecondsMeta = const VerificationMeta(
    'bestExhaleSeconds',
  );
  @override
  late final GeneratedColumn<int> bestExhaleSeconds = GeneratedColumn<int>(
    'best_exhale_seconds',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _roundsMeta = const VerificationMeta('rounds');
  @override
  late final GeneratedColumn<int> rounds = GeneratedColumn<int>(
    'rounds',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _difficultyMeta = const VerificationMeta(
    'difficulty',
  );
  @override
  late final GeneratedColumn<String> difficulty = GeneratedColumn<String>(
    'difficulty',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _durationMinutesMeta = const VerificationMeta(
    'durationMinutes',
  );
  @override
  late final GeneratedColumn<int> durationMinutes = GeneratedColumn<int>(
    'duration_minutes',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _completedAtMeta = const VerificationMeta(
    'completedAt',
  );
  @override
  late final GeneratedColumn<DateTime> completedAt = GeneratedColumn<DateTime>(
    'completed_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    sessionType,
    totalHoldSeconds,
    bestHoldThisSession,
    bestExhaleSeconds,
    rounds,
    difficulty,
    durationMinutes,
    completedAt,
    createdAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'breath_training_logs';
  @override
  VerificationContext validateIntegrity(
    Insertable<BreathTrainingLog> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('session_type')) {
      context.handle(
        _sessionTypeMeta,
        sessionType.isAcceptableOrUnknown(
          data['session_type']!,
          _sessionTypeMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_sessionTypeMeta);
    }
    if (data.containsKey('total_hold_seconds')) {
      context.handle(
        _totalHoldSecondsMeta,
        totalHoldSeconds.isAcceptableOrUnknown(
          data['total_hold_seconds']!,
          _totalHoldSecondsMeta,
        ),
      );
    }
    if (data.containsKey('best_hold_this_session')) {
      context.handle(
        _bestHoldThisSessionMeta,
        bestHoldThisSession.isAcceptableOrUnknown(
          data['best_hold_this_session']!,
          _bestHoldThisSessionMeta,
        ),
      );
    }
    if (data.containsKey('best_exhale_seconds')) {
      context.handle(
        _bestExhaleSecondsMeta,
        bestExhaleSeconds.isAcceptableOrUnknown(
          data['best_exhale_seconds']!,
          _bestExhaleSecondsMeta,
        ),
      );
    }
    if (data.containsKey('rounds')) {
      context.handle(
        _roundsMeta,
        rounds.isAcceptableOrUnknown(data['rounds']!, _roundsMeta),
      );
    }
    if (data.containsKey('difficulty')) {
      context.handle(
        _difficultyMeta,
        difficulty.isAcceptableOrUnknown(data['difficulty']!, _difficultyMeta),
      );
    }
    if (data.containsKey('duration_minutes')) {
      context.handle(
        _durationMinutesMeta,
        durationMinutes.isAcceptableOrUnknown(
          data['duration_minutes']!,
          _durationMinutesMeta,
        ),
      );
    }
    if (data.containsKey('completed_at')) {
      context.handle(
        _completedAtMeta,
        completedAt.isAcceptableOrUnknown(
          data['completed_at']!,
          _completedAtMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_completedAtMeta);
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  BreathTrainingLog map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return BreathTrainingLog(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      sessionType: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}session_type'],
      )!,
      totalHoldSeconds: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}total_hold_seconds'],
      ),
      bestHoldThisSession: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}best_hold_this_session'],
      ),
      bestExhaleSeconds: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}best_exhale_seconds'],
      ),
      rounds: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}rounds'],
      ),
      difficulty: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}difficulty'],
      ),
      durationMinutes: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}duration_minutes'],
      ),
      completedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}completed_at'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
    );
  }

  @override
  $BreathTrainingLogsTable createAlias(String alias) {
    return $BreathTrainingLogsTable(attachedDatabase, alias);
  }
}

class BreathTrainingLog extends DataClass
    implements Insertable<BreathTrainingLog> {
  final String id;
  final String sessionType;
  final int? totalHoldSeconds;
  final int? bestHoldThisSession;
  final int? bestExhaleSeconds;
  final int? rounds;
  final String? difficulty;
  final int? durationMinutes;
  final DateTime completedAt;
  final DateTime createdAt;
  const BreathTrainingLog({
    required this.id,
    required this.sessionType,
    this.totalHoldSeconds,
    this.bestHoldThisSession,
    this.bestExhaleSeconds,
    this.rounds,
    this.difficulty,
    this.durationMinutes,
    required this.completedAt,
    required this.createdAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['session_type'] = Variable<String>(sessionType);
    if (!nullToAbsent || totalHoldSeconds != null) {
      map['total_hold_seconds'] = Variable<int>(totalHoldSeconds);
    }
    if (!nullToAbsent || bestHoldThisSession != null) {
      map['best_hold_this_session'] = Variable<int>(bestHoldThisSession);
    }
    if (!nullToAbsent || bestExhaleSeconds != null) {
      map['best_exhale_seconds'] = Variable<int>(bestExhaleSeconds);
    }
    if (!nullToAbsent || rounds != null) {
      map['rounds'] = Variable<int>(rounds);
    }
    if (!nullToAbsent || difficulty != null) {
      map['difficulty'] = Variable<String>(difficulty);
    }
    if (!nullToAbsent || durationMinutes != null) {
      map['duration_minutes'] = Variable<int>(durationMinutes);
    }
    map['completed_at'] = Variable<DateTime>(completedAt);
    map['created_at'] = Variable<DateTime>(createdAt);
    return map;
  }

  BreathTrainingLogsCompanion toCompanion(bool nullToAbsent) {
    return BreathTrainingLogsCompanion(
      id: Value(id),
      sessionType: Value(sessionType),
      totalHoldSeconds: totalHoldSeconds == null && nullToAbsent
          ? const Value.absent()
          : Value(totalHoldSeconds),
      bestHoldThisSession: bestHoldThisSession == null && nullToAbsent
          ? const Value.absent()
          : Value(bestHoldThisSession),
      bestExhaleSeconds: bestExhaleSeconds == null && nullToAbsent
          ? const Value.absent()
          : Value(bestExhaleSeconds),
      rounds: rounds == null && nullToAbsent
          ? const Value.absent()
          : Value(rounds),
      difficulty: difficulty == null && nullToAbsent
          ? const Value.absent()
          : Value(difficulty),
      durationMinutes: durationMinutes == null && nullToAbsent
          ? const Value.absent()
          : Value(durationMinutes),
      completedAt: Value(completedAt),
      createdAt: Value(createdAt),
    );
  }

  factory BreathTrainingLog.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return BreathTrainingLog(
      id: serializer.fromJson<String>(json['id']),
      sessionType: serializer.fromJson<String>(json['sessionType']),
      totalHoldSeconds: serializer.fromJson<int?>(json['totalHoldSeconds']),
      bestHoldThisSession: serializer.fromJson<int?>(
        json['bestHoldThisSession'],
      ),
      bestExhaleSeconds: serializer.fromJson<int?>(json['bestExhaleSeconds']),
      rounds: serializer.fromJson<int?>(json['rounds']),
      difficulty: serializer.fromJson<String?>(json['difficulty']),
      durationMinutes: serializer.fromJson<int?>(json['durationMinutes']),
      completedAt: serializer.fromJson<DateTime>(json['completedAt']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'sessionType': serializer.toJson<String>(sessionType),
      'totalHoldSeconds': serializer.toJson<int?>(totalHoldSeconds),
      'bestHoldThisSession': serializer.toJson<int?>(bestHoldThisSession),
      'bestExhaleSeconds': serializer.toJson<int?>(bestExhaleSeconds),
      'rounds': serializer.toJson<int?>(rounds),
      'difficulty': serializer.toJson<String?>(difficulty),
      'durationMinutes': serializer.toJson<int?>(durationMinutes),
      'completedAt': serializer.toJson<DateTime>(completedAt),
      'createdAt': serializer.toJson<DateTime>(createdAt),
    };
  }

  BreathTrainingLog copyWith({
    String? id,
    String? sessionType,
    Value<int?> totalHoldSeconds = const Value.absent(),
    Value<int?> bestHoldThisSession = const Value.absent(),
    Value<int?> bestExhaleSeconds = const Value.absent(),
    Value<int?> rounds = const Value.absent(),
    Value<String?> difficulty = const Value.absent(),
    Value<int?> durationMinutes = const Value.absent(),
    DateTime? completedAt,
    DateTime? createdAt,
  }) => BreathTrainingLog(
    id: id ?? this.id,
    sessionType: sessionType ?? this.sessionType,
    totalHoldSeconds: totalHoldSeconds.present
        ? totalHoldSeconds.value
        : this.totalHoldSeconds,
    bestHoldThisSession: bestHoldThisSession.present
        ? bestHoldThisSession.value
        : this.bestHoldThisSession,
    bestExhaleSeconds: bestExhaleSeconds.present
        ? bestExhaleSeconds.value
        : this.bestExhaleSeconds,
    rounds: rounds.present ? rounds.value : this.rounds,
    difficulty: difficulty.present ? difficulty.value : this.difficulty,
    durationMinutes: durationMinutes.present
        ? durationMinutes.value
        : this.durationMinutes,
    completedAt: completedAt ?? this.completedAt,
    createdAt: createdAt ?? this.createdAt,
  );
  BreathTrainingLog copyWithCompanion(BreathTrainingLogsCompanion data) {
    return BreathTrainingLog(
      id: data.id.present ? data.id.value : this.id,
      sessionType: data.sessionType.present
          ? data.sessionType.value
          : this.sessionType,
      totalHoldSeconds: data.totalHoldSeconds.present
          ? data.totalHoldSeconds.value
          : this.totalHoldSeconds,
      bestHoldThisSession: data.bestHoldThisSession.present
          ? data.bestHoldThisSession.value
          : this.bestHoldThisSession,
      bestExhaleSeconds: data.bestExhaleSeconds.present
          ? data.bestExhaleSeconds.value
          : this.bestExhaleSeconds,
      rounds: data.rounds.present ? data.rounds.value : this.rounds,
      difficulty: data.difficulty.present
          ? data.difficulty.value
          : this.difficulty,
      durationMinutes: data.durationMinutes.present
          ? data.durationMinutes.value
          : this.durationMinutes,
      completedAt: data.completedAt.present
          ? data.completedAt.value
          : this.completedAt,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('BreathTrainingLog(')
          ..write('id: $id, ')
          ..write('sessionType: $sessionType, ')
          ..write('totalHoldSeconds: $totalHoldSeconds, ')
          ..write('bestHoldThisSession: $bestHoldThisSession, ')
          ..write('bestExhaleSeconds: $bestExhaleSeconds, ')
          ..write('rounds: $rounds, ')
          ..write('difficulty: $difficulty, ')
          ..write('durationMinutes: $durationMinutes, ')
          ..write('completedAt: $completedAt, ')
          ..write('createdAt: $createdAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    sessionType,
    totalHoldSeconds,
    bestHoldThisSession,
    bestExhaleSeconds,
    rounds,
    difficulty,
    durationMinutes,
    completedAt,
    createdAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is BreathTrainingLog &&
          other.id == this.id &&
          other.sessionType == this.sessionType &&
          other.totalHoldSeconds == this.totalHoldSeconds &&
          other.bestHoldThisSession == this.bestHoldThisSession &&
          other.bestExhaleSeconds == this.bestExhaleSeconds &&
          other.rounds == this.rounds &&
          other.difficulty == this.difficulty &&
          other.durationMinutes == this.durationMinutes &&
          other.completedAt == this.completedAt &&
          other.createdAt == this.createdAt);
}

class BreathTrainingLogsCompanion extends UpdateCompanion<BreathTrainingLog> {
  final Value<String> id;
  final Value<String> sessionType;
  final Value<int?> totalHoldSeconds;
  final Value<int?> bestHoldThisSession;
  final Value<int?> bestExhaleSeconds;
  final Value<int?> rounds;
  final Value<String?> difficulty;
  final Value<int?> durationMinutes;
  final Value<DateTime> completedAt;
  final Value<DateTime> createdAt;
  final Value<int> rowid;
  const BreathTrainingLogsCompanion({
    this.id = const Value.absent(),
    this.sessionType = const Value.absent(),
    this.totalHoldSeconds = const Value.absent(),
    this.bestHoldThisSession = const Value.absent(),
    this.bestExhaleSeconds = const Value.absent(),
    this.rounds = const Value.absent(),
    this.difficulty = const Value.absent(),
    this.durationMinutes = const Value.absent(),
    this.completedAt = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  BreathTrainingLogsCompanion.insert({
    required String id,
    required String sessionType,
    this.totalHoldSeconds = const Value.absent(),
    this.bestHoldThisSession = const Value.absent(),
    this.bestExhaleSeconds = const Value.absent(),
    this.rounds = const Value.absent(),
    this.difficulty = const Value.absent(),
    this.durationMinutes = const Value.absent(),
    required DateTime completedAt,
    this.createdAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       sessionType = Value(sessionType),
       completedAt = Value(completedAt);
  static Insertable<BreathTrainingLog> custom({
    Expression<String>? id,
    Expression<String>? sessionType,
    Expression<int>? totalHoldSeconds,
    Expression<int>? bestHoldThisSession,
    Expression<int>? bestExhaleSeconds,
    Expression<int>? rounds,
    Expression<String>? difficulty,
    Expression<int>? durationMinutes,
    Expression<DateTime>? completedAt,
    Expression<DateTime>? createdAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (sessionType != null) 'session_type': sessionType,
      if (totalHoldSeconds != null) 'total_hold_seconds': totalHoldSeconds,
      if (bestHoldThisSession != null)
        'best_hold_this_session': bestHoldThisSession,
      if (bestExhaleSeconds != null) 'best_exhale_seconds': bestExhaleSeconds,
      if (rounds != null) 'rounds': rounds,
      if (difficulty != null) 'difficulty': difficulty,
      if (durationMinutes != null) 'duration_minutes': durationMinutes,
      if (completedAt != null) 'completed_at': completedAt,
      if (createdAt != null) 'created_at': createdAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  BreathTrainingLogsCompanion copyWith({
    Value<String>? id,
    Value<String>? sessionType,
    Value<int?>? totalHoldSeconds,
    Value<int?>? bestHoldThisSession,
    Value<int?>? bestExhaleSeconds,
    Value<int?>? rounds,
    Value<String?>? difficulty,
    Value<int?>? durationMinutes,
    Value<DateTime>? completedAt,
    Value<DateTime>? createdAt,
    Value<int>? rowid,
  }) {
    return BreathTrainingLogsCompanion(
      id: id ?? this.id,
      sessionType: sessionType ?? this.sessionType,
      totalHoldSeconds: totalHoldSeconds ?? this.totalHoldSeconds,
      bestHoldThisSession: bestHoldThisSession ?? this.bestHoldThisSession,
      bestExhaleSeconds: bestExhaleSeconds ?? this.bestExhaleSeconds,
      rounds: rounds ?? this.rounds,
      difficulty: difficulty ?? this.difficulty,
      durationMinutes: durationMinutes ?? this.durationMinutes,
      completedAt: completedAt ?? this.completedAt,
      createdAt: createdAt ?? this.createdAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (sessionType.present) {
      map['session_type'] = Variable<String>(sessionType.value);
    }
    if (totalHoldSeconds.present) {
      map['total_hold_seconds'] = Variable<int>(totalHoldSeconds.value);
    }
    if (bestHoldThisSession.present) {
      map['best_hold_this_session'] = Variable<int>(bestHoldThisSession.value);
    }
    if (bestExhaleSeconds.present) {
      map['best_exhale_seconds'] = Variable<int>(bestExhaleSeconds.value);
    }
    if (rounds.present) {
      map['rounds'] = Variable<int>(rounds.value);
    }
    if (difficulty.present) {
      map['difficulty'] = Variable<String>(difficulty.value);
    }
    if (durationMinutes.present) {
      map['duration_minutes'] = Variable<int>(durationMinutes.value);
    }
    if (completedAt.present) {
      map['completed_at'] = Variable<DateTime>(completedAt.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('BreathTrainingLogsCompanion(')
          ..write('id: $id, ')
          ..write('sessionType: $sessionType, ')
          ..write('totalHoldSeconds: $totalHoldSeconds, ')
          ..write('bestHoldThisSession: $bestHoldThisSession, ')
          ..write('bestExhaleSeconds: $bestExhaleSeconds, ')
          ..write('rounds: $rounds, ')
          ..write('difficulty: $difficulty, ')
          ..write('durationMinutes: $durationMinutes, ')
          ..write('completedAt: $completedAt, ')
          ..write('createdAt: $createdAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $MilestonesTable extends Milestones
    with TableInfo<$MilestonesTable, Milestone> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $MilestonesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _dateMeta = const VerificationMeta('date');
  @override
  late final GeneratedColumn<DateTime> date = GeneratedColumn<DateTime>(
    'date',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _titleMeta = const VerificationMeta('title');
  @override
  late final GeneratedColumn<String> title = GeneratedColumn<String>(
    'title',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _descriptionMeta = const VerificationMeta(
    'description',
  );
  @override
  late final GeneratedColumn<String> description = GeneratedColumn<String>(
    'description',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _colorMeta = const VerificationMeta('color');
  @override
  late final GeneratedColumn<String> color = GeneratedColumn<String>(
    'color',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('#FFD700'),
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    date,
    title,
    description,
    color,
    createdAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'milestones';
  @override
  VerificationContext validateIntegrity(
    Insertable<Milestone> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('date')) {
      context.handle(
        _dateMeta,
        date.isAcceptableOrUnknown(data['date']!, _dateMeta),
      );
    } else if (isInserting) {
      context.missing(_dateMeta);
    }
    if (data.containsKey('title')) {
      context.handle(
        _titleMeta,
        title.isAcceptableOrUnknown(data['title']!, _titleMeta),
      );
    } else if (isInserting) {
      context.missing(_titleMeta);
    }
    if (data.containsKey('description')) {
      context.handle(
        _descriptionMeta,
        description.isAcceptableOrUnknown(
          data['description']!,
          _descriptionMeta,
        ),
      );
    }
    if (data.containsKey('color')) {
      context.handle(
        _colorMeta,
        color.isAcceptableOrUnknown(data['color']!, _colorMeta),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  Milestone map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Milestone(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      date: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}date'],
      )!,
      title: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}title'],
      )!,
      description: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}description'],
      ),
      color: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}color'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
    );
  }

  @override
  $MilestonesTable createAlias(String alias) {
    return $MilestonesTable(attachedDatabase, alias);
  }
}

class Milestone extends DataClass implements Insertable<Milestone> {
  final String id;
  final DateTime date;
  final String title;
  final String? description;
  final String color;
  final DateTime createdAt;
  const Milestone({
    required this.id,
    required this.date,
    required this.title,
    this.description,
    required this.color,
    required this.createdAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['date'] = Variable<DateTime>(date);
    map['title'] = Variable<String>(title);
    if (!nullToAbsent || description != null) {
      map['description'] = Variable<String>(description);
    }
    map['color'] = Variable<String>(color);
    map['created_at'] = Variable<DateTime>(createdAt);
    return map;
  }

  MilestonesCompanion toCompanion(bool nullToAbsent) {
    return MilestonesCompanion(
      id: Value(id),
      date: Value(date),
      title: Value(title),
      description: description == null && nullToAbsent
          ? const Value.absent()
          : Value(description),
      color: Value(color),
      createdAt: Value(createdAt),
    );
  }

  factory Milestone.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Milestone(
      id: serializer.fromJson<String>(json['id']),
      date: serializer.fromJson<DateTime>(json['date']),
      title: serializer.fromJson<String>(json['title']),
      description: serializer.fromJson<String?>(json['description']),
      color: serializer.fromJson<String>(json['color']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'date': serializer.toJson<DateTime>(date),
      'title': serializer.toJson<String>(title),
      'description': serializer.toJson<String?>(description),
      'color': serializer.toJson<String>(color),
      'createdAt': serializer.toJson<DateTime>(createdAt),
    };
  }

  Milestone copyWith({
    String? id,
    DateTime? date,
    String? title,
    Value<String?> description = const Value.absent(),
    String? color,
    DateTime? createdAt,
  }) => Milestone(
    id: id ?? this.id,
    date: date ?? this.date,
    title: title ?? this.title,
    description: description.present ? description.value : this.description,
    color: color ?? this.color,
    createdAt: createdAt ?? this.createdAt,
  );
  Milestone copyWithCompanion(MilestonesCompanion data) {
    return Milestone(
      id: data.id.present ? data.id.value : this.id,
      date: data.date.present ? data.date.value : this.date,
      title: data.title.present ? data.title.value : this.title,
      description: data.description.present
          ? data.description.value
          : this.description,
      color: data.color.present ? data.color.value : this.color,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Milestone(')
          ..write('id: $id, ')
          ..write('date: $date, ')
          ..write('title: $title, ')
          ..write('description: $description, ')
          ..write('color: $color, ')
          ..write('createdAt: $createdAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(id, date, title, description, color, createdAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Milestone &&
          other.id == this.id &&
          other.date == this.date &&
          other.title == this.title &&
          other.description == this.description &&
          other.color == this.color &&
          other.createdAt == this.createdAt);
}

class MilestonesCompanion extends UpdateCompanion<Milestone> {
  final Value<String> id;
  final Value<DateTime> date;
  final Value<String> title;
  final Value<String?> description;
  final Value<String> color;
  final Value<DateTime> createdAt;
  final Value<int> rowid;
  const MilestonesCompanion({
    this.id = const Value.absent(),
    this.date = const Value.absent(),
    this.title = const Value.absent(),
    this.description = const Value.absent(),
    this.color = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  MilestonesCompanion.insert({
    required String id,
    required DateTime date,
    required String title,
    this.description = const Value.absent(),
    this.color = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       date = Value(date),
       title = Value(title);
  static Insertable<Milestone> custom({
    Expression<String>? id,
    Expression<DateTime>? date,
    Expression<String>? title,
    Expression<String>? description,
    Expression<String>? color,
    Expression<DateTime>? createdAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (date != null) 'date': date,
      if (title != null) 'title': title,
      if (description != null) 'description': description,
      if (color != null) 'color': color,
      if (createdAt != null) 'created_at': createdAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  MilestonesCompanion copyWith({
    Value<String>? id,
    Value<DateTime>? date,
    Value<String>? title,
    Value<String?>? description,
    Value<String>? color,
    Value<DateTime>? createdAt,
    Value<int>? rowid,
  }) {
    return MilestonesCompanion(
      id: id ?? this.id,
      date: date ?? this.date,
      title: title ?? this.title,
      description: description ?? this.description,
      color: color ?? this.color,
      createdAt: createdAt ?? this.createdAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (date.present) {
      map['date'] = Variable<DateTime>(date.value);
    }
    if (title.present) {
      map['title'] = Variable<String>(title.value);
    }
    if (description.present) {
      map['description'] = Variable<String>(description.value);
    }
    if (color.present) {
      map['color'] = Variable<String>(color.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('MilestonesCompanion(')
          ..write('id: $id, ')
          ..write('date: $date, ')
          ..write('title: $title, ')
          ..write('description: $description, ')
          ..write('color: $color, ')
          ..write('createdAt: $createdAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $VolumeImportsTable extends VolumeImports
    with TableInfo<$VolumeImportsTable, VolumeImport> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $VolumeImportsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _rawDataMeta = const VerificationMeta(
    'rawData',
  );
  @override
  late final GeneratedColumn<String> rawData = GeneratedColumn<String>(
    'raw_data',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _columnMappingMeta = const VerificationMeta(
    'columnMapping',
  );
  @override
  late final GeneratedColumn<String> columnMapping = GeneratedColumn<String>(
    'column_mapping',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _rowCountMeta = const VerificationMeta(
    'rowCount',
  );
  @override
  late final GeneratedColumn<int> rowCount = GeneratedColumn<int>(
    'row_count',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _importedCountMeta = const VerificationMeta(
    'importedCount',
  );
  @override
  late final GeneratedColumn<int> importedCount = GeneratedColumn<int>(
    'imported_count',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    name,
    rawData,
    columnMapping,
    rowCount,
    importedCount,
    createdAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'volume_imports';
  @override
  VerificationContext validateIntegrity(
    Insertable<VolumeImport> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('raw_data')) {
      context.handle(
        _rawDataMeta,
        rawData.isAcceptableOrUnknown(data['raw_data']!, _rawDataMeta),
      );
    } else if (isInserting) {
      context.missing(_rawDataMeta);
    }
    if (data.containsKey('column_mapping')) {
      context.handle(
        _columnMappingMeta,
        columnMapping.isAcceptableOrUnknown(
          data['column_mapping']!,
          _columnMappingMeta,
        ),
      );
    }
    if (data.containsKey('row_count')) {
      context.handle(
        _rowCountMeta,
        rowCount.isAcceptableOrUnknown(data['row_count']!, _rowCountMeta),
      );
    } else if (isInserting) {
      context.missing(_rowCountMeta);
    }
    if (data.containsKey('imported_count')) {
      context.handle(
        _importedCountMeta,
        importedCount.isAcceptableOrUnknown(
          data['imported_count']!,
          _importedCountMeta,
        ),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  VolumeImport map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return VolumeImport(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      rawData: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}raw_data'],
      )!,
      columnMapping: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}column_mapping'],
      ),
      rowCount: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}row_count'],
      )!,
      importedCount: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}imported_count'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
    );
  }

  @override
  $VolumeImportsTable createAlias(String alias) {
    return $VolumeImportsTable(attachedDatabase, alias);
  }
}

class VolumeImport extends DataClass implements Insertable<VolumeImport> {
  final String id;
  final String name;
  final String rawData;
  final String? columnMapping;
  final int rowCount;
  final int importedCount;
  final DateTime createdAt;
  const VolumeImport({
    required this.id,
    required this.name,
    required this.rawData,
    this.columnMapping,
    required this.rowCount,
    required this.importedCount,
    required this.createdAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['name'] = Variable<String>(name);
    map['raw_data'] = Variable<String>(rawData);
    if (!nullToAbsent || columnMapping != null) {
      map['column_mapping'] = Variable<String>(columnMapping);
    }
    map['row_count'] = Variable<int>(rowCount);
    map['imported_count'] = Variable<int>(importedCount);
    map['created_at'] = Variable<DateTime>(createdAt);
    return map;
  }

  VolumeImportsCompanion toCompanion(bool nullToAbsent) {
    return VolumeImportsCompanion(
      id: Value(id),
      name: Value(name),
      rawData: Value(rawData),
      columnMapping: columnMapping == null && nullToAbsent
          ? const Value.absent()
          : Value(columnMapping),
      rowCount: Value(rowCount),
      importedCount: Value(importedCount),
      createdAt: Value(createdAt),
    );
  }

  factory VolumeImport.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return VolumeImport(
      id: serializer.fromJson<String>(json['id']),
      name: serializer.fromJson<String>(json['name']),
      rawData: serializer.fromJson<String>(json['rawData']),
      columnMapping: serializer.fromJson<String?>(json['columnMapping']),
      rowCount: serializer.fromJson<int>(json['rowCount']),
      importedCount: serializer.fromJson<int>(json['importedCount']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'name': serializer.toJson<String>(name),
      'rawData': serializer.toJson<String>(rawData),
      'columnMapping': serializer.toJson<String?>(columnMapping),
      'rowCount': serializer.toJson<int>(rowCount),
      'importedCount': serializer.toJson<int>(importedCount),
      'createdAt': serializer.toJson<DateTime>(createdAt),
    };
  }

  VolumeImport copyWith({
    String? id,
    String? name,
    String? rawData,
    Value<String?> columnMapping = const Value.absent(),
    int? rowCount,
    int? importedCount,
    DateTime? createdAt,
  }) => VolumeImport(
    id: id ?? this.id,
    name: name ?? this.name,
    rawData: rawData ?? this.rawData,
    columnMapping: columnMapping.present
        ? columnMapping.value
        : this.columnMapping,
    rowCount: rowCount ?? this.rowCount,
    importedCount: importedCount ?? this.importedCount,
    createdAt: createdAt ?? this.createdAt,
  );
  VolumeImport copyWithCompanion(VolumeImportsCompanion data) {
    return VolumeImport(
      id: data.id.present ? data.id.value : this.id,
      name: data.name.present ? data.name.value : this.name,
      rawData: data.rawData.present ? data.rawData.value : this.rawData,
      columnMapping: data.columnMapping.present
          ? data.columnMapping.value
          : this.columnMapping,
      rowCount: data.rowCount.present ? data.rowCount.value : this.rowCount,
      importedCount: data.importedCount.present
          ? data.importedCount.value
          : this.importedCount,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('VolumeImport(')
          ..write('id: $id, ')
          ..write('name: $name, ')
          ..write('rawData: $rawData, ')
          ..write('columnMapping: $columnMapping, ')
          ..write('rowCount: $rowCount, ')
          ..write('importedCount: $importedCount, ')
          ..write('createdAt: $createdAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    name,
    rawData,
    columnMapping,
    rowCount,
    importedCount,
    createdAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is VolumeImport &&
          other.id == this.id &&
          other.name == this.name &&
          other.rawData == this.rawData &&
          other.columnMapping == this.columnMapping &&
          other.rowCount == this.rowCount &&
          other.importedCount == this.importedCount &&
          other.createdAt == this.createdAt);
}

class VolumeImportsCompanion extends UpdateCompanion<VolumeImport> {
  final Value<String> id;
  final Value<String> name;
  final Value<String> rawData;
  final Value<String?> columnMapping;
  final Value<int> rowCount;
  final Value<int> importedCount;
  final Value<DateTime> createdAt;
  final Value<int> rowid;
  const VolumeImportsCompanion({
    this.id = const Value.absent(),
    this.name = const Value.absent(),
    this.rawData = const Value.absent(),
    this.columnMapping = const Value.absent(),
    this.rowCount = const Value.absent(),
    this.importedCount = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  VolumeImportsCompanion.insert({
    required String id,
    required String name,
    required String rawData,
    this.columnMapping = const Value.absent(),
    required int rowCount,
    this.importedCount = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       name = Value(name),
       rawData = Value(rawData),
       rowCount = Value(rowCount);
  static Insertable<VolumeImport> custom({
    Expression<String>? id,
    Expression<String>? name,
    Expression<String>? rawData,
    Expression<String>? columnMapping,
    Expression<int>? rowCount,
    Expression<int>? importedCount,
    Expression<DateTime>? createdAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (name != null) 'name': name,
      if (rawData != null) 'raw_data': rawData,
      if (columnMapping != null) 'column_mapping': columnMapping,
      if (rowCount != null) 'row_count': rowCount,
      if (importedCount != null) 'imported_count': importedCount,
      if (createdAt != null) 'created_at': createdAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  VolumeImportsCompanion copyWith({
    Value<String>? id,
    Value<String>? name,
    Value<String>? rawData,
    Value<String?>? columnMapping,
    Value<int>? rowCount,
    Value<int>? importedCount,
    Value<DateTime>? createdAt,
    Value<int>? rowid,
  }) {
    return VolumeImportsCompanion(
      id: id ?? this.id,
      name: name ?? this.name,
      rawData: rawData ?? this.rawData,
      columnMapping: columnMapping ?? this.columnMapping,
      rowCount: rowCount ?? this.rowCount,
      importedCount: importedCount ?? this.importedCount,
      createdAt: createdAt ?? this.createdAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (rawData.present) {
      map['raw_data'] = Variable<String>(rawData.value);
    }
    if (columnMapping.present) {
      map['column_mapping'] = Variable<String>(columnMapping.value);
    }
    if (rowCount.present) {
      map['row_count'] = Variable<int>(rowCount.value);
    }
    if (importedCount.present) {
      map['imported_count'] = Variable<int>(importedCount.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('VolumeImportsCompanion(')
          ..write('id: $id, ')
          ..write('name: $name, ')
          ..write('rawData: $rawData, ')
          ..write('columnMapping: $columnMapping, ')
          ..write('rowCount: $rowCount, ')
          ..write('importedCount: $importedCount, ')
          ..write('createdAt: $createdAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $KitSnapshotsTable extends KitSnapshots
    with TableInfo<$KitSnapshotsTable, KitSnapshot> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $KitSnapshotsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _sessionIdMeta = const VerificationMeta(
    'sessionId',
  );
  @override
  late final GeneratedColumn<String> sessionId = GeneratedColumn<String>(
    'session_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _bowIdMeta = const VerificationMeta('bowId');
  @override
  late final GeneratedColumn<String> bowId = GeneratedColumn<String>(
    'bow_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _quiverIdMeta = const VerificationMeta(
    'quiverId',
  );
  @override
  late final GeneratedColumn<String> quiverId = GeneratedColumn<String>(
    'quiver_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _snapshotDateMeta = const VerificationMeta(
    'snapshotDate',
  );
  @override
  late final GeneratedColumn<DateTime> snapshotDate = GeneratedColumn<DateTime>(
    'snapshot_date',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _scoreMeta = const VerificationMeta('score');
  @override
  late final GeneratedColumn<int> score = GeneratedColumn<int>(
    'score',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _maxScoreMeta = const VerificationMeta(
    'maxScore',
  );
  @override
  late final GeneratedColumn<int> maxScore = GeneratedColumn<int>(
    'max_score',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _roundNameMeta = const VerificationMeta(
    'roundName',
  );
  @override
  late final GeneratedColumn<String> roundName = GeneratedColumn<String>(
    'round_name',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _reasonMeta = const VerificationMeta('reason');
  @override
  late final GeneratedColumn<String> reason = GeneratedColumn<String>(
    'reason',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _bowNameMeta = const VerificationMeta(
    'bowName',
  );
  @override
  late final GeneratedColumn<String> bowName = GeneratedColumn<String>(
    'bow_name',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _bowTypeMeta = const VerificationMeta(
    'bowType',
  );
  @override
  late final GeneratedColumn<String> bowType = GeneratedColumn<String>(
    'bow_type',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _bowSettingsMeta = const VerificationMeta(
    'bowSettings',
  );
  @override
  late final GeneratedColumn<String> bowSettings = GeneratedColumn<String>(
    'bow_settings',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _quiverNameMeta = const VerificationMeta(
    'quiverName',
  );
  @override
  late final GeneratedColumn<String> quiverName = GeneratedColumn<String>(
    'quiver_name',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _arrowSettingsMeta = const VerificationMeta(
    'arrowSettings',
  );
  @override
  late final GeneratedColumn<String> arrowSettings = GeneratedColumn<String>(
    'arrow_settings',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _notesMeta = const VerificationMeta('notes');
  @override
  late final GeneratedColumn<String> notes = GeneratedColumn<String>(
    'notes',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    sessionId,
    bowId,
    quiverId,
    snapshotDate,
    score,
    maxScore,
    roundName,
    reason,
    bowName,
    bowType,
    bowSettings,
    quiverName,
    arrowSettings,
    notes,
    createdAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'kit_snapshots';
  @override
  VerificationContext validateIntegrity(
    Insertable<KitSnapshot> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('session_id')) {
      context.handle(
        _sessionIdMeta,
        sessionId.isAcceptableOrUnknown(data['session_id']!, _sessionIdMeta),
      );
    }
    if (data.containsKey('bow_id')) {
      context.handle(
        _bowIdMeta,
        bowId.isAcceptableOrUnknown(data['bow_id']!, _bowIdMeta),
      );
    }
    if (data.containsKey('quiver_id')) {
      context.handle(
        _quiverIdMeta,
        quiverId.isAcceptableOrUnknown(data['quiver_id']!, _quiverIdMeta),
      );
    }
    if (data.containsKey('snapshot_date')) {
      context.handle(
        _snapshotDateMeta,
        snapshotDate.isAcceptableOrUnknown(
          data['snapshot_date']!,
          _snapshotDateMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_snapshotDateMeta);
    }
    if (data.containsKey('score')) {
      context.handle(
        _scoreMeta,
        score.isAcceptableOrUnknown(data['score']!, _scoreMeta),
      );
    }
    if (data.containsKey('max_score')) {
      context.handle(
        _maxScoreMeta,
        maxScore.isAcceptableOrUnknown(data['max_score']!, _maxScoreMeta),
      );
    }
    if (data.containsKey('round_name')) {
      context.handle(
        _roundNameMeta,
        roundName.isAcceptableOrUnknown(data['round_name']!, _roundNameMeta),
      );
    }
    if (data.containsKey('reason')) {
      context.handle(
        _reasonMeta,
        reason.isAcceptableOrUnknown(data['reason']!, _reasonMeta),
      );
    }
    if (data.containsKey('bow_name')) {
      context.handle(
        _bowNameMeta,
        bowName.isAcceptableOrUnknown(data['bow_name']!, _bowNameMeta),
      );
    }
    if (data.containsKey('bow_type')) {
      context.handle(
        _bowTypeMeta,
        bowType.isAcceptableOrUnknown(data['bow_type']!, _bowTypeMeta),
      );
    }
    if (data.containsKey('bow_settings')) {
      context.handle(
        _bowSettingsMeta,
        bowSettings.isAcceptableOrUnknown(
          data['bow_settings']!,
          _bowSettingsMeta,
        ),
      );
    }
    if (data.containsKey('quiver_name')) {
      context.handle(
        _quiverNameMeta,
        quiverName.isAcceptableOrUnknown(data['quiver_name']!, _quiverNameMeta),
      );
    }
    if (data.containsKey('arrow_settings')) {
      context.handle(
        _arrowSettingsMeta,
        arrowSettings.isAcceptableOrUnknown(
          data['arrow_settings']!,
          _arrowSettingsMeta,
        ),
      );
    }
    if (data.containsKey('notes')) {
      context.handle(
        _notesMeta,
        notes.isAcceptableOrUnknown(data['notes']!, _notesMeta),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  KitSnapshot map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return KitSnapshot(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      sessionId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}session_id'],
      ),
      bowId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}bow_id'],
      ),
      quiverId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}quiver_id'],
      ),
      snapshotDate: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}snapshot_date'],
      )!,
      score: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}score'],
      ),
      maxScore: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}max_score'],
      ),
      roundName: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}round_name'],
      ),
      reason: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}reason'],
      ),
      bowName: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}bow_name'],
      ),
      bowType: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}bow_type'],
      ),
      bowSettings: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}bow_settings'],
      ),
      quiverName: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}quiver_name'],
      ),
      arrowSettings: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}arrow_settings'],
      ),
      notes: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}notes'],
      ),
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
    );
  }

  @override
  $KitSnapshotsTable createAlias(String alias) {
    return $KitSnapshotsTable(attachedDatabase, alias);
  }
}

class KitSnapshot extends DataClass implements Insertable<KitSnapshot> {
  final String id;
  final String? sessionId;
  final String? bowId;
  final String? quiverId;
  final DateTime snapshotDate;
  final int? score;
  final int? maxScore;
  final String? roundName;
  final String? reason;
  final String? bowName;
  final String? bowType;
  final String? bowSettings;
  final String? quiverName;
  final String? arrowSettings;
  final String? notes;
  final DateTime createdAt;
  const KitSnapshot({
    required this.id,
    this.sessionId,
    this.bowId,
    this.quiverId,
    required this.snapshotDate,
    this.score,
    this.maxScore,
    this.roundName,
    this.reason,
    this.bowName,
    this.bowType,
    this.bowSettings,
    this.quiverName,
    this.arrowSettings,
    this.notes,
    required this.createdAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    if (!nullToAbsent || sessionId != null) {
      map['session_id'] = Variable<String>(sessionId);
    }
    if (!nullToAbsent || bowId != null) {
      map['bow_id'] = Variable<String>(bowId);
    }
    if (!nullToAbsent || quiverId != null) {
      map['quiver_id'] = Variable<String>(quiverId);
    }
    map['snapshot_date'] = Variable<DateTime>(snapshotDate);
    if (!nullToAbsent || score != null) {
      map['score'] = Variable<int>(score);
    }
    if (!nullToAbsent || maxScore != null) {
      map['max_score'] = Variable<int>(maxScore);
    }
    if (!nullToAbsent || roundName != null) {
      map['round_name'] = Variable<String>(roundName);
    }
    if (!nullToAbsent || reason != null) {
      map['reason'] = Variable<String>(reason);
    }
    if (!nullToAbsent || bowName != null) {
      map['bow_name'] = Variable<String>(bowName);
    }
    if (!nullToAbsent || bowType != null) {
      map['bow_type'] = Variable<String>(bowType);
    }
    if (!nullToAbsent || bowSettings != null) {
      map['bow_settings'] = Variable<String>(bowSettings);
    }
    if (!nullToAbsent || quiverName != null) {
      map['quiver_name'] = Variable<String>(quiverName);
    }
    if (!nullToAbsent || arrowSettings != null) {
      map['arrow_settings'] = Variable<String>(arrowSettings);
    }
    if (!nullToAbsent || notes != null) {
      map['notes'] = Variable<String>(notes);
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    return map;
  }

  KitSnapshotsCompanion toCompanion(bool nullToAbsent) {
    return KitSnapshotsCompanion(
      id: Value(id),
      sessionId: sessionId == null && nullToAbsent
          ? const Value.absent()
          : Value(sessionId),
      bowId: bowId == null && nullToAbsent
          ? const Value.absent()
          : Value(bowId),
      quiverId: quiverId == null && nullToAbsent
          ? const Value.absent()
          : Value(quiverId),
      snapshotDate: Value(snapshotDate),
      score: score == null && nullToAbsent
          ? const Value.absent()
          : Value(score),
      maxScore: maxScore == null && nullToAbsent
          ? const Value.absent()
          : Value(maxScore),
      roundName: roundName == null && nullToAbsent
          ? const Value.absent()
          : Value(roundName),
      reason: reason == null && nullToAbsent
          ? const Value.absent()
          : Value(reason),
      bowName: bowName == null && nullToAbsent
          ? const Value.absent()
          : Value(bowName),
      bowType: bowType == null && nullToAbsent
          ? const Value.absent()
          : Value(bowType),
      bowSettings: bowSettings == null && nullToAbsent
          ? const Value.absent()
          : Value(bowSettings),
      quiverName: quiverName == null && nullToAbsent
          ? const Value.absent()
          : Value(quiverName),
      arrowSettings: arrowSettings == null && nullToAbsent
          ? const Value.absent()
          : Value(arrowSettings),
      notes: notes == null && nullToAbsent
          ? const Value.absent()
          : Value(notes),
      createdAt: Value(createdAt),
    );
  }

  factory KitSnapshot.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return KitSnapshot(
      id: serializer.fromJson<String>(json['id']),
      sessionId: serializer.fromJson<String?>(json['sessionId']),
      bowId: serializer.fromJson<String?>(json['bowId']),
      quiverId: serializer.fromJson<String?>(json['quiverId']),
      snapshotDate: serializer.fromJson<DateTime>(json['snapshotDate']),
      score: serializer.fromJson<int?>(json['score']),
      maxScore: serializer.fromJson<int?>(json['maxScore']),
      roundName: serializer.fromJson<String?>(json['roundName']),
      reason: serializer.fromJson<String?>(json['reason']),
      bowName: serializer.fromJson<String?>(json['bowName']),
      bowType: serializer.fromJson<String?>(json['bowType']),
      bowSettings: serializer.fromJson<String?>(json['bowSettings']),
      quiverName: serializer.fromJson<String?>(json['quiverName']),
      arrowSettings: serializer.fromJson<String?>(json['arrowSettings']),
      notes: serializer.fromJson<String?>(json['notes']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'sessionId': serializer.toJson<String?>(sessionId),
      'bowId': serializer.toJson<String?>(bowId),
      'quiverId': serializer.toJson<String?>(quiverId),
      'snapshotDate': serializer.toJson<DateTime>(snapshotDate),
      'score': serializer.toJson<int?>(score),
      'maxScore': serializer.toJson<int?>(maxScore),
      'roundName': serializer.toJson<String?>(roundName),
      'reason': serializer.toJson<String?>(reason),
      'bowName': serializer.toJson<String?>(bowName),
      'bowType': serializer.toJson<String?>(bowType),
      'bowSettings': serializer.toJson<String?>(bowSettings),
      'quiverName': serializer.toJson<String?>(quiverName),
      'arrowSettings': serializer.toJson<String?>(arrowSettings),
      'notes': serializer.toJson<String?>(notes),
      'createdAt': serializer.toJson<DateTime>(createdAt),
    };
  }

  KitSnapshot copyWith({
    String? id,
    Value<String?> sessionId = const Value.absent(),
    Value<String?> bowId = const Value.absent(),
    Value<String?> quiverId = const Value.absent(),
    DateTime? snapshotDate,
    Value<int?> score = const Value.absent(),
    Value<int?> maxScore = const Value.absent(),
    Value<String?> roundName = const Value.absent(),
    Value<String?> reason = const Value.absent(),
    Value<String?> bowName = const Value.absent(),
    Value<String?> bowType = const Value.absent(),
    Value<String?> bowSettings = const Value.absent(),
    Value<String?> quiverName = const Value.absent(),
    Value<String?> arrowSettings = const Value.absent(),
    Value<String?> notes = const Value.absent(),
    DateTime? createdAt,
  }) => KitSnapshot(
    id: id ?? this.id,
    sessionId: sessionId.present ? sessionId.value : this.sessionId,
    bowId: bowId.present ? bowId.value : this.bowId,
    quiverId: quiverId.present ? quiverId.value : this.quiverId,
    snapshotDate: snapshotDate ?? this.snapshotDate,
    score: score.present ? score.value : this.score,
    maxScore: maxScore.present ? maxScore.value : this.maxScore,
    roundName: roundName.present ? roundName.value : this.roundName,
    reason: reason.present ? reason.value : this.reason,
    bowName: bowName.present ? bowName.value : this.bowName,
    bowType: bowType.present ? bowType.value : this.bowType,
    bowSettings: bowSettings.present ? bowSettings.value : this.bowSettings,
    quiverName: quiverName.present ? quiverName.value : this.quiverName,
    arrowSettings: arrowSettings.present
        ? arrowSettings.value
        : this.arrowSettings,
    notes: notes.present ? notes.value : this.notes,
    createdAt: createdAt ?? this.createdAt,
  );
  KitSnapshot copyWithCompanion(KitSnapshotsCompanion data) {
    return KitSnapshot(
      id: data.id.present ? data.id.value : this.id,
      sessionId: data.sessionId.present ? data.sessionId.value : this.sessionId,
      bowId: data.bowId.present ? data.bowId.value : this.bowId,
      quiverId: data.quiverId.present ? data.quiverId.value : this.quiverId,
      snapshotDate: data.snapshotDate.present
          ? data.snapshotDate.value
          : this.snapshotDate,
      score: data.score.present ? data.score.value : this.score,
      maxScore: data.maxScore.present ? data.maxScore.value : this.maxScore,
      roundName: data.roundName.present ? data.roundName.value : this.roundName,
      reason: data.reason.present ? data.reason.value : this.reason,
      bowName: data.bowName.present ? data.bowName.value : this.bowName,
      bowType: data.bowType.present ? data.bowType.value : this.bowType,
      bowSettings: data.bowSettings.present
          ? data.bowSettings.value
          : this.bowSettings,
      quiverName: data.quiverName.present
          ? data.quiverName.value
          : this.quiverName,
      arrowSettings: data.arrowSettings.present
          ? data.arrowSettings.value
          : this.arrowSettings,
      notes: data.notes.present ? data.notes.value : this.notes,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('KitSnapshot(')
          ..write('id: $id, ')
          ..write('sessionId: $sessionId, ')
          ..write('bowId: $bowId, ')
          ..write('quiverId: $quiverId, ')
          ..write('snapshotDate: $snapshotDate, ')
          ..write('score: $score, ')
          ..write('maxScore: $maxScore, ')
          ..write('roundName: $roundName, ')
          ..write('reason: $reason, ')
          ..write('bowName: $bowName, ')
          ..write('bowType: $bowType, ')
          ..write('bowSettings: $bowSettings, ')
          ..write('quiverName: $quiverName, ')
          ..write('arrowSettings: $arrowSettings, ')
          ..write('notes: $notes, ')
          ..write('createdAt: $createdAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    sessionId,
    bowId,
    quiverId,
    snapshotDate,
    score,
    maxScore,
    roundName,
    reason,
    bowName,
    bowType,
    bowSettings,
    quiverName,
    arrowSettings,
    notes,
    createdAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is KitSnapshot &&
          other.id == this.id &&
          other.sessionId == this.sessionId &&
          other.bowId == this.bowId &&
          other.quiverId == this.quiverId &&
          other.snapshotDate == this.snapshotDate &&
          other.score == this.score &&
          other.maxScore == this.maxScore &&
          other.roundName == this.roundName &&
          other.reason == this.reason &&
          other.bowName == this.bowName &&
          other.bowType == this.bowType &&
          other.bowSettings == this.bowSettings &&
          other.quiverName == this.quiverName &&
          other.arrowSettings == this.arrowSettings &&
          other.notes == this.notes &&
          other.createdAt == this.createdAt);
}

class KitSnapshotsCompanion extends UpdateCompanion<KitSnapshot> {
  final Value<String> id;
  final Value<String?> sessionId;
  final Value<String?> bowId;
  final Value<String?> quiverId;
  final Value<DateTime> snapshotDate;
  final Value<int?> score;
  final Value<int?> maxScore;
  final Value<String?> roundName;
  final Value<String?> reason;
  final Value<String?> bowName;
  final Value<String?> bowType;
  final Value<String?> bowSettings;
  final Value<String?> quiverName;
  final Value<String?> arrowSettings;
  final Value<String?> notes;
  final Value<DateTime> createdAt;
  final Value<int> rowid;
  const KitSnapshotsCompanion({
    this.id = const Value.absent(),
    this.sessionId = const Value.absent(),
    this.bowId = const Value.absent(),
    this.quiverId = const Value.absent(),
    this.snapshotDate = const Value.absent(),
    this.score = const Value.absent(),
    this.maxScore = const Value.absent(),
    this.roundName = const Value.absent(),
    this.reason = const Value.absent(),
    this.bowName = const Value.absent(),
    this.bowType = const Value.absent(),
    this.bowSettings = const Value.absent(),
    this.quiverName = const Value.absent(),
    this.arrowSettings = const Value.absent(),
    this.notes = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  KitSnapshotsCompanion.insert({
    required String id,
    this.sessionId = const Value.absent(),
    this.bowId = const Value.absent(),
    this.quiverId = const Value.absent(),
    required DateTime snapshotDate,
    this.score = const Value.absent(),
    this.maxScore = const Value.absent(),
    this.roundName = const Value.absent(),
    this.reason = const Value.absent(),
    this.bowName = const Value.absent(),
    this.bowType = const Value.absent(),
    this.bowSettings = const Value.absent(),
    this.quiverName = const Value.absent(),
    this.arrowSettings = const Value.absent(),
    this.notes = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       snapshotDate = Value(snapshotDate);
  static Insertable<KitSnapshot> custom({
    Expression<String>? id,
    Expression<String>? sessionId,
    Expression<String>? bowId,
    Expression<String>? quiverId,
    Expression<DateTime>? snapshotDate,
    Expression<int>? score,
    Expression<int>? maxScore,
    Expression<String>? roundName,
    Expression<String>? reason,
    Expression<String>? bowName,
    Expression<String>? bowType,
    Expression<String>? bowSettings,
    Expression<String>? quiverName,
    Expression<String>? arrowSettings,
    Expression<String>? notes,
    Expression<DateTime>? createdAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (sessionId != null) 'session_id': sessionId,
      if (bowId != null) 'bow_id': bowId,
      if (quiverId != null) 'quiver_id': quiverId,
      if (snapshotDate != null) 'snapshot_date': snapshotDate,
      if (score != null) 'score': score,
      if (maxScore != null) 'max_score': maxScore,
      if (roundName != null) 'round_name': roundName,
      if (reason != null) 'reason': reason,
      if (bowName != null) 'bow_name': bowName,
      if (bowType != null) 'bow_type': bowType,
      if (bowSettings != null) 'bow_settings': bowSettings,
      if (quiverName != null) 'quiver_name': quiverName,
      if (arrowSettings != null) 'arrow_settings': arrowSettings,
      if (notes != null) 'notes': notes,
      if (createdAt != null) 'created_at': createdAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  KitSnapshotsCompanion copyWith({
    Value<String>? id,
    Value<String?>? sessionId,
    Value<String?>? bowId,
    Value<String?>? quiverId,
    Value<DateTime>? snapshotDate,
    Value<int?>? score,
    Value<int?>? maxScore,
    Value<String?>? roundName,
    Value<String?>? reason,
    Value<String?>? bowName,
    Value<String?>? bowType,
    Value<String?>? bowSettings,
    Value<String?>? quiverName,
    Value<String?>? arrowSettings,
    Value<String?>? notes,
    Value<DateTime>? createdAt,
    Value<int>? rowid,
  }) {
    return KitSnapshotsCompanion(
      id: id ?? this.id,
      sessionId: sessionId ?? this.sessionId,
      bowId: bowId ?? this.bowId,
      quiverId: quiverId ?? this.quiverId,
      snapshotDate: snapshotDate ?? this.snapshotDate,
      score: score ?? this.score,
      maxScore: maxScore ?? this.maxScore,
      roundName: roundName ?? this.roundName,
      reason: reason ?? this.reason,
      bowName: bowName ?? this.bowName,
      bowType: bowType ?? this.bowType,
      bowSettings: bowSettings ?? this.bowSettings,
      quiverName: quiverName ?? this.quiverName,
      arrowSettings: arrowSettings ?? this.arrowSettings,
      notes: notes ?? this.notes,
      createdAt: createdAt ?? this.createdAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (sessionId.present) {
      map['session_id'] = Variable<String>(sessionId.value);
    }
    if (bowId.present) {
      map['bow_id'] = Variable<String>(bowId.value);
    }
    if (quiverId.present) {
      map['quiver_id'] = Variable<String>(quiverId.value);
    }
    if (snapshotDate.present) {
      map['snapshot_date'] = Variable<DateTime>(snapshotDate.value);
    }
    if (score.present) {
      map['score'] = Variable<int>(score.value);
    }
    if (maxScore.present) {
      map['max_score'] = Variable<int>(maxScore.value);
    }
    if (roundName.present) {
      map['round_name'] = Variable<String>(roundName.value);
    }
    if (reason.present) {
      map['reason'] = Variable<String>(reason.value);
    }
    if (bowName.present) {
      map['bow_name'] = Variable<String>(bowName.value);
    }
    if (bowType.present) {
      map['bow_type'] = Variable<String>(bowType.value);
    }
    if (bowSettings.present) {
      map['bow_settings'] = Variable<String>(bowSettings.value);
    }
    if (quiverName.present) {
      map['quiver_name'] = Variable<String>(quiverName.value);
    }
    if (arrowSettings.present) {
      map['arrow_settings'] = Variable<String>(arrowSettings.value);
    }
    if (notes.present) {
      map['notes'] = Variable<String>(notes.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('KitSnapshotsCompanion(')
          ..write('id: $id, ')
          ..write('sessionId: $sessionId, ')
          ..write('bowId: $bowId, ')
          ..write('quiverId: $quiverId, ')
          ..write('snapshotDate: $snapshotDate, ')
          ..write('score: $score, ')
          ..write('maxScore: $maxScore, ')
          ..write('roundName: $roundName, ')
          ..write('reason: $reason, ')
          ..write('bowName: $bowName, ')
          ..write('bowType: $bowType, ')
          ..write('bowSettings: $bowSettings, ')
          ..write('quiverName: $quiverName, ')
          ..write('arrowSettings: $arrowSettings, ')
          ..write('notes: $notes, ')
          ..write('createdAt: $createdAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $TuningSessionsTable extends TuningSessions
    with TableInfo<$TuningSessionsTable, TuningSession> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $TuningSessionsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _bowIdMeta = const VerificationMeta('bowId');
  @override
  late final GeneratedColumn<String> bowId = GeneratedColumn<String>(
    'bow_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES bows (id)',
    ),
  );
  static const VerificationMeta _dateMeta = const VerificationMeta('date');
  @override
  late final GeneratedColumn<DateTime> date = GeneratedColumn<DateTime>(
    'date',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _bowTypeMeta = const VerificationMeta(
    'bowType',
  );
  @override
  late final GeneratedColumn<String> bowType = GeneratedColumn<String>(
    'bow_type',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _tuningTypeMeta = const VerificationMeta(
    'tuningType',
  );
  @override
  late final GeneratedColumn<String> tuningType = GeneratedColumn<String>(
    'tuning_type',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _resultsMeta = const VerificationMeta(
    'results',
  );
  @override
  late final GeneratedColumn<String> results = GeneratedColumn<String>(
    'results',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _notesMeta = const VerificationMeta('notes');
  @override
  late final GeneratedColumn<String> notes = GeneratedColumn<String>(
    'notes',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    bowId,
    date,
    bowType,
    tuningType,
    results,
    notes,
    createdAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'tuning_sessions';
  @override
  VerificationContext validateIntegrity(
    Insertable<TuningSession> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('bow_id')) {
      context.handle(
        _bowIdMeta,
        bowId.isAcceptableOrUnknown(data['bow_id']!, _bowIdMeta),
      );
    }
    if (data.containsKey('date')) {
      context.handle(
        _dateMeta,
        date.isAcceptableOrUnknown(data['date']!, _dateMeta),
      );
    } else if (isInserting) {
      context.missing(_dateMeta);
    }
    if (data.containsKey('bow_type')) {
      context.handle(
        _bowTypeMeta,
        bowType.isAcceptableOrUnknown(data['bow_type']!, _bowTypeMeta),
      );
    } else if (isInserting) {
      context.missing(_bowTypeMeta);
    }
    if (data.containsKey('tuning_type')) {
      context.handle(
        _tuningTypeMeta,
        tuningType.isAcceptableOrUnknown(data['tuning_type']!, _tuningTypeMeta),
      );
    } else if (isInserting) {
      context.missing(_tuningTypeMeta);
    }
    if (data.containsKey('results')) {
      context.handle(
        _resultsMeta,
        results.isAcceptableOrUnknown(data['results']!, _resultsMeta),
      );
    }
    if (data.containsKey('notes')) {
      context.handle(
        _notesMeta,
        notes.isAcceptableOrUnknown(data['notes']!, _notesMeta),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  TuningSession map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return TuningSession(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      bowId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}bow_id'],
      ),
      date: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}date'],
      )!,
      bowType: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}bow_type'],
      )!,
      tuningType: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}tuning_type'],
      )!,
      results: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}results'],
      ),
      notes: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}notes'],
      ),
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
    );
  }

  @override
  $TuningSessionsTable createAlias(String alias) {
    return $TuningSessionsTable(attachedDatabase, alias);
  }
}

class TuningSession extends DataClass implements Insertable<TuningSession> {
  final String id;
  final String? bowId;
  final DateTime date;
  final String bowType;
  final String tuningType;
  final String? results;
  final String? notes;
  final DateTime createdAt;
  const TuningSession({
    required this.id,
    this.bowId,
    required this.date,
    required this.bowType,
    required this.tuningType,
    this.results,
    this.notes,
    required this.createdAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    if (!nullToAbsent || bowId != null) {
      map['bow_id'] = Variable<String>(bowId);
    }
    map['date'] = Variable<DateTime>(date);
    map['bow_type'] = Variable<String>(bowType);
    map['tuning_type'] = Variable<String>(tuningType);
    if (!nullToAbsent || results != null) {
      map['results'] = Variable<String>(results);
    }
    if (!nullToAbsent || notes != null) {
      map['notes'] = Variable<String>(notes);
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    return map;
  }

  TuningSessionsCompanion toCompanion(bool nullToAbsent) {
    return TuningSessionsCompanion(
      id: Value(id),
      bowId: bowId == null && nullToAbsent
          ? const Value.absent()
          : Value(bowId),
      date: Value(date),
      bowType: Value(bowType),
      tuningType: Value(tuningType),
      results: results == null && nullToAbsent
          ? const Value.absent()
          : Value(results),
      notes: notes == null && nullToAbsent
          ? const Value.absent()
          : Value(notes),
      createdAt: Value(createdAt),
    );
  }

  factory TuningSession.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return TuningSession(
      id: serializer.fromJson<String>(json['id']),
      bowId: serializer.fromJson<String?>(json['bowId']),
      date: serializer.fromJson<DateTime>(json['date']),
      bowType: serializer.fromJson<String>(json['bowType']),
      tuningType: serializer.fromJson<String>(json['tuningType']),
      results: serializer.fromJson<String?>(json['results']),
      notes: serializer.fromJson<String?>(json['notes']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'bowId': serializer.toJson<String?>(bowId),
      'date': serializer.toJson<DateTime>(date),
      'bowType': serializer.toJson<String>(bowType),
      'tuningType': serializer.toJson<String>(tuningType),
      'results': serializer.toJson<String?>(results),
      'notes': serializer.toJson<String?>(notes),
      'createdAt': serializer.toJson<DateTime>(createdAt),
    };
  }

  TuningSession copyWith({
    String? id,
    Value<String?> bowId = const Value.absent(),
    DateTime? date,
    String? bowType,
    String? tuningType,
    Value<String?> results = const Value.absent(),
    Value<String?> notes = const Value.absent(),
    DateTime? createdAt,
  }) => TuningSession(
    id: id ?? this.id,
    bowId: bowId.present ? bowId.value : this.bowId,
    date: date ?? this.date,
    bowType: bowType ?? this.bowType,
    tuningType: tuningType ?? this.tuningType,
    results: results.present ? results.value : this.results,
    notes: notes.present ? notes.value : this.notes,
    createdAt: createdAt ?? this.createdAt,
  );
  TuningSession copyWithCompanion(TuningSessionsCompanion data) {
    return TuningSession(
      id: data.id.present ? data.id.value : this.id,
      bowId: data.bowId.present ? data.bowId.value : this.bowId,
      date: data.date.present ? data.date.value : this.date,
      bowType: data.bowType.present ? data.bowType.value : this.bowType,
      tuningType: data.tuningType.present
          ? data.tuningType.value
          : this.tuningType,
      results: data.results.present ? data.results.value : this.results,
      notes: data.notes.present ? data.notes.value : this.notes,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('TuningSession(')
          ..write('id: $id, ')
          ..write('bowId: $bowId, ')
          ..write('date: $date, ')
          ..write('bowType: $bowType, ')
          ..write('tuningType: $tuningType, ')
          ..write('results: $results, ')
          ..write('notes: $notes, ')
          ..write('createdAt: $createdAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    bowId,
    date,
    bowType,
    tuningType,
    results,
    notes,
    createdAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is TuningSession &&
          other.id == this.id &&
          other.bowId == this.bowId &&
          other.date == this.date &&
          other.bowType == this.bowType &&
          other.tuningType == this.tuningType &&
          other.results == this.results &&
          other.notes == this.notes &&
          other.createdAt == this.createdAt);
}

class TuningSessionsCompanion extends UpdateCompanion<TuningSession> {
  final Value<String> id;
  final Value<String?> bowId;
  final Value<DateTime> date;
  final Value<String> bowType;
  final Value<String> tuningType;
  final Value<String?> results;
  final Value<String?> notes;
  final Value<DateTime> createdAt;
  final Value<int> rowid;
  const TuningSessionsCompanion({
    this.id = const Value.absent(),
    this.bowId = const Value.absent(),
    this.date = const Value.absent(),
    this.bowType = const Value.absent(),
    this.tuningType = const Value.absent(),
    this.results = const Value.absent(),
    this.notes = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  TuningSessionsCompanion.insert({
    required String id,
    this.bowId = const Value.absent(),
    required DateTime date,
    required String bowType,
    required String tuningType,
    this.results = const Value.absent(),
    this.notes = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       date = Value(date),
       bowType = Value(bowType),
       tuningType = Value(tuningType);
  static Insertable<TuningSession> custom({
    Expression<String>? id,
    Expression<String>? bowId,
    Expression<DateTime>? date,
    Expression<String>? bowType,
    Expression<String>? tuningType,
    Expression<String>? results,
    Expression<String>? notes,
    Expression<DateTime>? createdAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (bowId != null) 'bow_id': bowId,
      if (date != null) 'date': date,
      if (bowType != null) 'bow_type': bowType,
      if (tuningType != null) 'tuning_type': tuningType,
      if (results != null) 'results': results,
      if (notes != null) 'notes': notes,
      if (createdAt != null) 'created_at': createdAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  TuningSessionsCompanion copyWith({
    Value<String>? id,
    Value<String?>? bowId,
    Value<DateTime>? date,
    Value<String>? bowType,
    Value<String>? tuningType,
    Value<String?>? results,
    Value<String?>? notes,
    Value<DateTime>? createdAt,
    Value<int>? rowid,
  }) {
    return TuningSessionsCompanion(
      id: id ?? this.id,
      bowId: bowId ?? this.bowId,
      date: date ?? this.date,
      bowType: bowType ?? this.bowType,
      tuningType: tuningType ?? this.tuningType,
      results: results ?? this.results,
      notes: notes ?? this.notes,
      createdAt: createdAt ?? this.createdAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (bowId.present) {
      map['bow_id'] = Variable<String>(bowId.value);
    }
    if (date.present) {
      map['date'] = Variable<DateTime>(date.value);
    }
    if (bowType.present) {
      map['bow_type'] = Variable<String>(bowType.value);
    }
    if (tuningType.present) {
      map['tuning_type'] = Variable<String>(tuningType.value);
    }
    if (results.present) {
      map['results'] = Variable<String>(results.value);
    }
    if (notes.present) {
      map['notes'] = Variable<String>(notes.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('TuningSessionsCompanion(')
          ..write('id: $id, ')
          ..write('bowId: $bowId, ')
          ..write('date: $date, ')
          ..write('bowType: $bowType, ')
          ..write('tuningType: $tuningType, ')
          ..write('results: $results, ')
          ..write('notes: $notes, ')
          ..write('createdAt: $createdAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $SkillLevelsTable extends SkillLevels
    with TableInfo<$SkillLevelsTable, SkillLevel> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $SkillLevelsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _descriptionMeta = const VerificationMeta(
    'description',
  );
  @override
  late final GeneratedColumn<String> description = GeneratedColumn<String>(
    'description',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _currentLevelMeta = const VerificationMeta(
    'currentLevel',
  );
  @override
  late final GeneratedColumn<int> currentLevel = GeneratedColumn<int>(
    'current_level',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(1),
  );
  static const VerificationMeta _currentXpMeta = const VerificationMeta(
    'currentXp',
  );
  @override
  late final GeneratedColumn<int> currentXp = GeneratedColumn<int>(
    'current_xp',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _lastLevelUpAtMeta = const VerificationMeta(
    'lastLevelUpAt',
  );
  @override
  late final GeneratedColumn<DateTime> lastLevelUpAt =
      GeneratedColumn<DateTime>(
        'last_level_up_at',
        aliasedName,
        true,
        type: DriftSqlType.dateTime,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    name,
    description,
    currentLevel,
    currentXp,
    lastLevelUpAt,
    createdAt,
    updatedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'skill_levels';
  @override
  VerificationContext validateIntegrity(
    Insertable<SkillLevel> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('description')) {
      context.handle(
        _descriptionMeta,
        description.isAcceptableOrUnknown(
          data['description']!,
          _descriptionMeta,
        ),
      );
    }
    if (data.containsKey('current_level')) {
      context.handle(
        _currentLevelMeta,
        currentLevel.isAcceptableOrUnknown(
          data['current_level']!,
          _currentLevelMeta,
        ),
      );
    }
    if (data.containsKey('current_xp')) {
      context.handle(
        _currentXpMeta,
        currentXp.isAcceptableOrUnknown(data['current_xp']!, _currentXpMeta),
      );
    }
    if (data.containsKey('last_level_up_at')) {
      context.handle(
        _lastLevelUpAtMeta,
        lastLevelUpAt.isAcceptableOrUnknown(
          data['last_level_up_at']!,
          _lastLevelUpAtMeta,
        ),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  SkillLevel map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return SkillLevel(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      description: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}description'],
      ),
      currentLevel: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}current_level'],
      )!,
      currentXp: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}current_xp'],
      )!,
      lastLevelUpAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}last_level_up_at'],
      ),
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      )!,
    );
  }

  @override
  $SkillLevelsTable createAlias(String alias) {
    return $SkillLevelsTable(attachedDatabase, alias);
  }
}

class SkillLevel extends DataClass implements Insertable<SkillLevel> {
  final String id;
  final String name;
  final String? description;
  final int currentLevel;
  final int currentXp;
  final DateTime? lastLevelUpAt;
  final DateTime createdAt;
  final DateTime updatedAt;
  const SkillLevel({
    required this.id,
    required this.name,
    this.description,
    required this.currentLevel,
    required this.currentXp,
    this.lastLevelUpAt,
    required this.createdAt,
    required this.updatedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['name'] = Variable<String>(name);
    if (!nullToAbsent || description != null) {
      map['description'] = Variable<String>(description);
    }
    map['current_level'] = Variable<int>(currentLevel);
    map['current_xp'] = Variable<int>(currentXp);
    if (!nullToAbsent || lastLevelUpAt != null) {
      map['last_level_up_at'] = Variable<DateTime>(lastLevelUpAt);
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    return map;
  }

  SkillLevelsCompanion toCompanion(bool nullToAbsent) {
    return SkillLevelsCompanion(
      id: Value(id),
      name: Value(name),
      description: description == null && nullToAbsent
          ? const Value.absent()
          : Value(description),
      currentLevel: Value(currentLevel),
      currentXp: Value(currentXp),
      lastLevelUpAt: lastLevelUpAt == null && nullToAbsent
          ? const Value.absent()
          : Value(lastLevelUpAt),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory SkillLevel.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return SkillLevel(
      id: serializer.fromJson<String>(json['id']),
      name: serializer.fromJson<String>(json['name']),
      description: serializer.fromJson<String?>(json['description']),
      currentLevel: serializer.fromJson<int>(json['currentLevel']),
      currentXp: serializer.fromJson<int>(json['currentXp']),
      lastLevelUpAt: serializer.fromJson<DateTime?>(json['lastLevelUpAt']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'name': serializer.toJson<String>(name),
      'description': serializer.toJson<String?>(description),
      'currentLevel': serializer.toJson<int>(currentLevel),
      'currentXp': serializer.toJson<int>(currentXp),
      'lastLevelUpAt': serializer.toJson<DateTime?>(lastLevelUpAt),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
    };
  }

  SkillLevel copyWith({
    String? id,
    String? name,
    Value<String?> description = const Value.absent(),
    int? currentLevel,
    int? currentXp,
    Value<DateTime?> lastLevelUpAt = const Value.absent(),
    DateTime? createdAt,
    DateTime? updatedAt,
  }) => SkillLevel(
    id: id ?? this.id,
    name: name ?? this.name,
    description: description.present ? description.value : this.description,
    currentLevel: currentLevel ?? this.currentLevel,
    currentXp: currentXp ?? this.currentXp,
    lastLevelUpAt: lastLevelUpAt.present
        ? lastLevelUpAt.value
        : this.lastLevelUpAt,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
  );
  SkillLevel copyWithCompanion(SkillLevelsCompanion data) {
    return SkillLevel(
      id: data.id.present ? data.id.value : this.id,
      name: data.name.present ? data.name.value : this.name,
      description: data.description.present
          ? data.description.value
          : this.description,
      currentLevel: data.currentLevel.present
          ? data.currentLevel.value
          : this.currentLevel,
      currentXp: data.currentXp.present ? data.currentXp.value : this.currentXp,
      lastLevelUpAt: data.lastLevelUpAt.present
          ? data.lastLevelUpAt.value
          : this.lastLevelUpAt,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('SkillLevel(')
          ..write('id: $id, ')
          ..write('name: $name, ')
          ..write('description: $description, ')
          ..write('currentLevel: $currentLevel, ')
          ..write('currentXp: $currentXp, ')
          ..write('lastLevelUpAt: $lastLevelUpAt, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    name,
    description,
    currentLevel,
    currentXp,
    lastLevelUpAt,
    createdAt,
    updatedAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is SkillLevel &&
          other.id == this.id &&
          other.name == this.name &&
          other.description == this.description &&
          other.currentLevel == this.currentLevel &&
          other.currentXp == this.currentXp &&
          other.lastLevelUpAt == this.lastLevelUpAt &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class SkillLevelsCompanion extends UpdateCompanion<SkillLevel> {
  final Value<String> id;
  final Value<String> name;
  final Value<String?> description;
  final Value<int> currentLevel;
  final Value<int> currentXp;
  final Value<DateTime?> lastLevelUpAt;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  final Value<int> rowid;
  const SkillLevelsCompanion({
    this.id = const Value.absent(),
    this.name = const Value.absent(),
    this.description = const Value.absent(),
    this.currentLevel = const Value.absent(),
    this.currentXp = const Value.absent(),
    this.lastLevelUpAt = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  SkillLevelsCompanion.insert({
    required String id,
    required String name,
    this.description = const Value.absent(),
    this.currentLevel = const Value.absent(),
    this.currentXp = const Value.absent(),
    this.lastLevelUpAt = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       name = Value(name);
  static Insertable<SkillLevel> custom({
    Expression<String>? id,
    Expression<String>? name,
    Expression<String>? description,
    Expression<int>? currentLevel,
    Expression<int>? currentXp,
    Expression<DateTime>? lastLevelUpAt,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (name != null) 'name': name,
      if (description != null) 'description': description,
      if (currentLevel != null) 'current_level': currentLevel,
      if (currentXp != null) 'current_xp': currentXp,
      if (lastLevelUpAt != null) 'last_level_up_at': lastLevelUpAt,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  SkillLevelsCompanion copyWith({
    Value<String>? id,
    Value<String>? name,
    Value<String?>? description,
    Value<int>? currentLevel,
    Value<int>? currentXp,
    Value<DateTime?>? lastLevelUpAt,
    Value<DateTime>? createdAt,
    Value<DateTime>? updatedAt,
    Value<int>? rowid,
  }) {
    return SkillLevelsCompanion(
      id: id ?? this.id,
      name: name ?? this.name,
      description: description ?? this.description,
      currentLevel: currentLevel ?? this.currentLevel,
      currentXp: currentXp ?? this.currentXp,
      lastLevelUpAt: lastLevelUpAt ?? this.lastLevelUpAt,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (description.present) {
      map['description'] = Variable<String>(description.value);
    }
    if (currentLevel.present) {
      map['current_level'] = Variable<int>(currentLevel.value);
    }
    if (currentXp.present) {
      map['current_xp'] = Variable<int>(currentXp.value);
    }
    if (lastLevelUpAt.present) {
      map['last_level_up_at'] = Variable<DateTime>(lastLevelUpAt.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('SkillLevelsCompanion(')
          ..write('id: $id, ')
          ..write('name: $name, ')
          ..write('description: $description, ')
          ..write('currentLevel: $currentLevel, ')
          ..write('currentXp: $currentXp, ')
          ..write('lastLevelUpAt: $lastLevelUpAt, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $XpHistoryTable extends XpHistory
    with TableInfo<$XpHistoryTable, XpHistoryData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $XpHistoryTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _skillIdMeta = const VerificationMeta(
    'skillId',
  );
  @override
  late final GeneratedColumn<String> skillId = GeneratedColumn<String>(
    'skill_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _xpAmountMeta = const VerificationMeta(
    'xpAmount',
  );
  @override
  late final GeneratedColumn<int> xpAmount = GeneratedColumn<int>(
    'xp_amount',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _sourceMeta = const VerificationMeta('source');
  @override
  late final GeneratedColumn<String> source = GeneratedColumn<String>(
    'source',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _sourceIdMeta = const VerificationMeta(
    'sourceId',
  );
  @override
  late final GeneratedColumn<String> sourceId = GeneratedColumn<String>(
    'source_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _reasonMeta = const VerificationMeta('reason');
  @override
  late final GeneratedColumn<String> reason = GeneratedColumn<String>(
    'reason',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _earnedAtMeta = const VerificationMeta(
    'earnedAt',
  );
  @override
  late final GeneratedColumn<DateTime> earnedAt = GeneratedColumn<DateTime>(
    'earned_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    skillId,
    xpAmount,
    source,
    sourceId,
    reason,
    earnedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'xp_history';
  @override
  VerificationContext validateIntegrity(
    Insertable<XpHistoryData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('skill_id')) {
      context.handle(
        _skillIdMeta,
        skillId.isAcceptableOrUnknown(data['skill_id']!, _skillIdMeta),
      );
    } else if (isInserting) {
      context.missing(_skillIdMeta);
    }
    if (data.containsKey('xp_amount')) {
      context.handle(
        _xpAmountMeta,
        xpAmount.isAcceptableOrUnknown(data['xp_amount']!, _xpAmountMeta),
      );
    } else if (isInserting) {
      context.missing(_xpAmountMeta);
    }
    if (data.containsKey('source')) {
      context.handle(
        _sourceMeta,
        source.isAcceptableOrUnknown(data['source']!, _sourceMeta),
      );
    } else if (isInserting) {
      context.missing(_sourceMeta);
    }
    if (data.containsKey('source_id')) {
      context.handle(
        _sourceIdMeta,
        sourceId.isAcceptableOrUnknown(data['source_id']!, _sourceIdMeta),
      );
    }
    if (data.containsKey('reason')) {
      context.handle(
        _reasonMeta,
        reason.isAcceptableOrUnknown(data['reason']!, _reasonMeta),
      );
    }
    if (data.containsKey('earned_at')) {
      context.handle(
        _earnedAtMeta,
        earnedAt.isAcceptableOrUnknown(data['earned_at']!, _earnedAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  XpHistoryData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return XpHistoryData(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      skillId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}skill_id'],
      )!,
      xpAmount: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}xp_amount'],
      )!,
      source: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}source'],
      )!,
      sourceId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}source_id'],
      ),
      reason: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}reason'],
      ),
      earnedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}earned_at'],
      )!,
    );
  }

  @override
  $XpHistoryTable createAlias(String alias) {
    return $XpHistoryTable(attachedDatabase, alias);
  }
}

class XpHistoryData extends DataClass implements Insertable<XpHistoryData> {
  final String id;
  final String skillId;
  final int xpAmount;
  final String source;
  final String? sourceId;
  final String? reason;
  final DateTime earnedAt;
  const XpHistoryData({
    required this.id,
    required this.skillId,
    required this.xpAmount,
    required this.source,
    this.sourceId,
    this.reason,
    required this.earnedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['skill_id'] = Variable<String>(skillId);
    map['xp_amount'] = Variable<int>(xpAmount);
    map['source'] = Variable<String>(source);
    if (!nullToAbsent || sourceId != null) {
      map['source_id'] = Variable<String>(sourceId);
    }
    if (!nullToAbsent || reason != null) {
      map['reason'] = Variable<String>(reason);
    }
    map['earned_at'] = Variable<DateTime>(earnedAt);
    return map;
  }

  XpHistoryCompanion toCompanion(bool nullToAbsent) {
    return XpHistoryCompanion(
      id: Value(id),
      skillId: Value(skillId),
      xpAmount: Value(xpAmount),
      source: Value(source),
      sourceId: sourceId == null && nullToAbsent
          ? const Value.absent()
          : Value(sourceId),
      reason: reason == null && nullToAbsent
          ? const Value.absent()
          : Value(reason),
      earnedAt: Value(earnedAt),
    );
  }

  factory XpHistoryData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return XpHistoryData(
      id: serializer.fromJson<String>(json['id']),
      skillId: serializer.fromJson<String>(json['skillId']),
      xpAmount: serializer.fromJson<int>(json['xpAmount']),
      source: serializer.fromJson<String>(json['source']),
      sourceId: serializer.fromJson<String?>(json['sourceId']),
      reason: serializer.fromJson<String?>(json['reason']),
      earnedAt: serializer.fromJson<DateTime>(json['earnedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'skillId': serializer.toJson<String>(skillId),
      'xpAmount': serializer.toJson<int>(xpAmount),
      'source': serializer.toJson<String>(source),
      'sourceId': serializer.toJson<String?>(sourceId),
      'reason': serializer.toJson<String?>(reason),
      'earnedAt': serializer.toJson<DateTime>(earnedAt),
    };
  }

  XpHistoryData copyWith({
    String? id,
    String? skillId,
    int? xpAmount,
    String? source,
    Value<String?> sourceId = const Value.absent(),
    Value<String?> reason = const Value.absent(),
    DateTime? earnedAt,
  }) => XpHistoryData(
    id: id ?? this.id,
    skillId: skillId ?? this.skillId,
    xpAmount: xpAmount ?? this.xpAmount,
    source: source ?? this.source,
    sourceId: sourceId.present ? sourceId.value : this.sourceId,
    reason: reason.present ? reason.value : this.reason,
    earnedAt: earnedAt ?? this.earnedAt,
  );
  XpHistoryData copyWithCompanion(XpHistoryCompanion data) {
    return XpHistoryData(
      id: data.id.present ? data.id.value : this.id,
      skillId: data.skillId.present ? data.skillId.value : this.skillId,
      xpAmount: data.xpAmount.present ? data.xpAmount.value : this.xpAmount,
      source: data.source.present ? data.source.value : this.source,
      sourceId: data.sourceId.present ? data.sourceId.value : this.sourceId,
      reason: data.reason.present ? data.reason.value : this.reason,
      earnedAt: data.earnedAt.present ? data.earnedAt.value : this.earnedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('XpHistoryData(')
          ..write('id: $id, ')
          ..write('skillId: $skillId, ')
          ..write('xpAmount: $xpAmount, ')
          ..write('source: $source, ')
          ..write('sourceId: $sourceId, ')
          ..write('reason: $reason, ')
          ..write('earnedAt: $earnedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(id, skillId, xpAmount, source, sourceId, reason, earnedAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is XpHistoryData &&
          other.id == this.id &&
          other.skillId == this.skillId &&
          other.xpAmount == this.xpAmount &&
          other.source == this.source &&
          other.sourceId == this.sourceId &&
          other.reason == this.reason &&
          other.earnedAt == this.earnedAt);
}

class XpHistoryCompanion extends UpdateCompanion<XpHistoryData> {
  final Value<String> id;
  final Value<String> skillId;
  final Value<int> xpAmount;
  final Value<String> source;
  final Value<String?> sourceId;
  final Value<String?> reason;
  final Value<DateTime> earnedAt;
  final Value<int> rowid;
  const XpHistoryCompanion({
    this.id = const Value.absent(),
    this.skillId = const Value.absent(),
    this.xpAmount = const Value.absent(),
    this.source = const Value.absent(),
    this.sourceId = const Value.absent(),
    this.reason = const Value.absent(),
    this.earnedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  XpHistoryCompanion.insert({
    required String id,
    required String skillId,
    required int xpAmount,
    required String source,
    this.sourceId = const Value.absent(),
    this.reason = const Value.absent(),
    this.earnedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       skillId = Value(skillId),
       xpAmount = Value(xpAmount),
       source = Value(source);
  static Insertable<XpHistoryData> custom({
    Expression<String>? id,
    Expression<String>? skillId,
    Expression<int>? xpAmount,
    Expression<String>? source,
    Expression<String>? sourceId,
    Expression<String>? reason,
    Expression<DateTime>? earnedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (skillId != null) 'skill_id': skillId,
      if (xpAmount != null) 'xp_amount': xpAmount,
      if (source != null) 'source': source,
      if (sourceId != null) 'source_id': sourceId,
      if (reason != null) 'reason': reason,
      if (earnedAt != null) 'earned_at': earnedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  XpHistoryCompanion copyWith({
    Value<String>? id,
    Value<String>? skillId,
    Value<int>? xpAmount,
    Value<String>? source,
    Value<String?>? sourceId,
    Value<String?>? reason,
    Value<DateTime>? earnedAt,
    Value<int>? rowid,
  }) {
    return XpHistoryCompanion(
      id: id ?? this.id,
      skillId: skillId ?? this.skillId,
      xpAmount: xpAmount ?? this.xpAmount,
      source: source ?? this.source,
      sourceId: sourceId ?? this.sourceId,
      reason: reason ?? this.reason,
      earnedAt: earnedAt ?? this.earnedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (skillId.present) {
      map['skill_id'] = Variable<String>(skillId.value);
    }
    if (xpAmount.present) {
      map['xp_amount'] = Variable<int>(xpAmount.value);
    }
    if (source.present) {
      map['source'] = Variable<String>(source.value);
    }
    if (sourceId.present) {
      map['source_id'] = Variable<String>(sourceId.value);
    }
    if (reason.present) {
      map['reason'] = Variable<String>(reason.value);
    }
    if (earnedAt.present) {
      map['earned_at'] = Variable<DateTime>(earnedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('XpHistoryCompanion(')
          ..write('id: $id, ')
          ..write('skillId: $skillId, ')
          ..write('xpAmount: $xpAmount, ')
          ..write('source: $source, ')
          ..write('sourceId: $sourceId, ')
          ..write('reason: $reason, ')
          ..write('earnedAt: $earnedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $SightMarksTable extends SightMarks
    with TableInfo<$SightMarksTable, SightMark> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $SightMarksTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _bowIdMeta = const VerificationMeta('bowId');
  @override
  late final GeneratedColumn<String> bowId = GeneratedColumn<String>(
    'bow_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES bows (id)',
    ),
  );
  static const VerificationMeta _distanceMeta = const VerificationMeta(
    'distance',
  );
  @override
  late final GeneratedColumn<double> distance = GeneratedColumn<double>(
    'distance',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _unitMeta = const VerificationMeta('unit');
  @override
  late final GeneratedColumn<String> unit = GeneratedColumn<String>(
    'unit',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('meters'),
  );
  static const VerificationMeta _sightValueMeta = const VerificationMeta(
    'sightValue',
  );
  @override
  late final GeneratedColumn<String> sightValue = GeneratedColumn<String>(
    'sight_value',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _weatherDataMeta = const VerificationMeta(
    'weatherData',
  );
  @override
  late final GeneratedColumn<String> weatherData = GeneratedColumn<String>(
    'weather_data',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _elevationDeltaMeta = const VerificationMeta(
    'elevationDelta',
  );
  @override
  late final GeneratedColumn<double> elevationDelta = GeneratedColumn<double>(
    'elevation_delta',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _slopeAngleMeta = const VerificationMeta(
    'slopeAngle',
  );
  @override
  late final GeneratedColumn<double> slopeAngle = GeneratedColumn<double>(
    'slope_angle',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _sessionIdMeta = const VerificationMeta(
    'sessionId',
  );
  @override
  late final GeneratedColumn<String> sessionId = GeneratedColumn<String>(
    'session_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _endNumberMeta = const VerificationMeta(
    'endNumber',
  );
  @override
  late final GeneratedColumn<int> endNumber = GeneratedColumn<int>(
    'end_number',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _shotCountMeta = const VerificationMeta(
    'shotCount',
  );
  @override
  late final GeneratedColumn<int> shotCount = GeneratedColumn<int>(
    'shot_count',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _confidenceScoreMeta = const VerificationMeta(
    'confidenceScore',
  );
  @override
  late final GeneratedColumn<double> confidenceScore = GeneratedColumn<double>(
    'confidence_score',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _recordedAtMeta = const VerificationMeta(
    'recordedAt',
  );
  @override
  late final GeneratedColumn<DateTime> recordedAt = GeneratedColumn<DateTime>(
    'recorded_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _deletedAtMeta = const VerificationMeta(
    'deletedAt',
  );
  @override
  late final GeneratedColumn<DateTime> deletedAt = GeneratedColumn<DateTime>(
    'deleted_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    bowId,
    distance,
    unit,
    sightValue,
    weatherData,
    elevationDelta,
    slopeAngle,
    sessionId,
    endNumber,
    shotCount,
    confidenceScore,
    recordedAt,
    updatedAt,
    deletedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'sight_marks';
  @override
  VerificationContext validateIntegrity(
    Insertable<SightMark> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('bow_id')) {
      context.handle(
        _bowIdMeta,
        bowId.isAcceptableOrUnknown(data['bow_id']!, _bowIdMeta),
      );
    } else if (isInserting) {
      context.missing(_bowIdMeta);
    }
    if (data.containsKey('distance')) {
      context.handle(
        _distanceMeta,
        distance.isAcceptableOrUnknown(data['distance']!, _distanceMeta),
      );
    } else if (isInserting) {
      context.missing(_distanceMeta);
    }
    if (data.containsKey('unit')) {
      context.handle(
        _unitMeta,
        unit.isAcceptableOrUnknown(data['unit']!, _unitMeta),
      );
    }
    if (data.containsKey('sight_value')) {
      context.handle(
        _sightValueMeta,
        sightValue.isAcceptableOrUnknown(data['sight_value']!, _sightValueMeta),
      );
    } else if (isInserting) {
      context.missing(_sightValueMeta);
    }
    if (data.containsKey('weather_data')) {
      context.handle(
        _weatherDataMeta,
        weatherData.isAcceptableOrUnknown(
          data['weather_data']!,
          _weatherDataMeta,
        ),
      );
    }
    if (data.containsKey('elevation_delta')) {
      context.handle(
        _elevationDeltaMeta,
        elevationDelta.isAcceptableOrUnknown(
          data['elevation_delta']!,
          _elevationDeltaMeta,
        ),
      );
    }
    if (data.containsKey('slope_angle')) {
      context.handle(
        _slopeAngleMeta,
        slopeAngle.isAcceptableOrUnknown(data['slope_angle']!, _slopeAngleMeta),
      );
    }
    if (data.containsKey('session_id')) {
      context.handle(
        _sessionIdMeta,
        sessionId.isAcceptableOrUnknown(data['session_id']!, _sessionIdMeta),
      );
    }
    if (data.containsKey('end_number')) {
      context.handle(
        _endNumberMeta,
        endNumber.isAcceptableOrUnknown(data['end_number']!, _endNumberMeta),
      );
    }
    if (data.containsKey('shot_count')) {
      context.handle(
        _shotCountMeta,
        shotCount.isAcceptableOrUnknown(data['shot_count']!, _shotCountMeta),
      );
    }
    if (data.containsKey('confidence_score')) {
      context.handle(
        _confidenceScoreMeta,
        confidenceScore.isAcceptableOrUnknown(
          data['confidence_score']!,
          _confidenceScoreMeta,
        ),
      );
    }
    if (data.containsKey('recorded_at')) {
      context.handle(
        _recordedAtMeta,
        recordedAt.isAcceptableOrUnknown(data['recorded_at']!, _recordedAtMeta),
      );
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    }
    if (data.containsKey('deleted_at')) {
      context.handle(
        _deletedAtMeta,
        deletedAt.isAcceptableOrUnknown(data['deleted_at']!, _deletedAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  SightMark map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return SightMark(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      bowId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}bow_id'],
      )!,
      distance: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}distance'],
      )!,
      unit: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}unit'],
      )!,
      sightValue: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}sight_value'],
      )!,
      weatherData: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}weather_data'],
      ),
      elevationDelta: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}elevation_delta'],
      ),
      slopeAngle: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}slope_angle'],
      ),
      sessionId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}session_id'],
      ),
      endNumber: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}end_number'],
      ),
      shotCount: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}shot_count'],
      ),
      confidenceScore: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}confidence_score'],
      ),
      recordedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}recorded_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      ),
      deletedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}deleted_at'],
      ),
    );
  }

  @override
  $SightMarksTable createAlias(String alias) {
    return $SightMarksTable(attachedDatabase, alias);
  }
}

class SightMark extends DataClass implements Insertable<SightMark> {
  final String id;
  final String bowId;
  final double distance;
  final String unit;
  final String sightValue;
  final String? weatherData;
  final double? elevationDelta;
  final double? slopeAngle;
  final String? sessionId;
  final int? endNumber;
  final int? shotCount;
  final double? confidenceScore;
  final DateTime recordedAt;
  final DateTime? updatedAt;
  final DateTime? deletedAt;
  const SightMark({
    required this.id,
    required this.bowId,
    required this.distance,
    required this.unit,
    required this.sightValue,
    this.weatherData,
    this.elevationDelta,
    this.slopeAngle,
    this.sessionId,
    this.endNumber,
    this.shotCount,
    this.confidenceScore,
    required this.recordedAt,
    this.updatedAt,
    this.deletedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['bow_id'] = Variable<String>(bowId);
    map['distance'] = Variable<double>(distance);
    map['unit'] = Variable<String>(unit);
    map['sight_value'] = Variable<String>(sightValue);
    if (!nullToAbsent || weatherData != null) {
      map['weather_data'] = Variable<String>(weatherData);
    }
    if (!nullToAbsent || elevationDelta != null) {
      map['elevation_delta'] = Variable<double>(elevationDelta);
    }
    if (!nullToAbsent || slopeAngle != null) {
      map['slope_angle'] = Variable<double>(slopeAngle);
    }
    if (!nullToAbsent || sessionId != null) {
      map['session_id'] = Variable<String>(sessionId);
    }
    if (!nullToAbsent || endNumber != null) {
      map['end_number'] = Variable<int>(endNumber);
    }
    if (!nullToAbsent || shotCount != null) {
      map['shot_count'] = Variable<int>(shotCount);
    }
    if (!nullToAbsent || confidenceScore != null) {
      map['confidence_score'] = Variable<double>(confidenceScore);
    }
    map['recorded_at'] = Variable<DateTime>(recordedAt);
    if (!nullToAbsent || updatedAt != null) {
      map['updated_at'] = Variable<DateTime>(updatedAt);
    }
    if (!nullToAbsent || deletedAt != null) {
      map['deleted_at'] = Variable<DateTime>(deletedAt);
    }
    return map;
  }

  SightMarksCompanion toCompanion(bool nullToAbsent) {
    return SightMarksCompanion(
      id: Value(id),
      bowId: Value(bowId),
      distance: Value(distance),
      unit: Value(unit),
      sightValue: Value(sightValue),
      weatherData: weatherData == null && nullToAbsent
          ? const Value.absent()
          : Value(weatherData),
      elevationDelta: elevationDelta == null && nullToAbsent
          ? const Value.absent()
          : Value(elevationDelta),
      slopeAngle: slopeAngle == null && nullToAbsent
          ? const Value.absent()
          : Value(slopeAngle),
      sessionId: sessionId == null && nullToAbsent
          ? const Value.absent()
          : Value(sessionId),
      endNumber: endNumber == null && nullToAbsent
          ? const Value.absent()
          : Value(endNumber),
      shotCount: shotCount == null && nullToAbsent
          ? const Value.absent()
          : Value(shotCount),
      confidenceScore: confidenceScore == null && nullToAbsent
          ? const Value.absent()
          : Value(confidenceScore),
      recordedAt: Value(recordedAt),
      updatedAt: updatedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(updatedAt),
      deletedAt: deletedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(deletedAt),
    );
  }

  factory SightMark.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return SightMark(
      id: serializer.fromJson<String>(json['id']),
      bowId: serializer.fromJson<String>(json['bowId']),
      distance: serializer.fromJson<double>(json['distance']),
      unit: serializer.fromJson<String>(json['unit']),
      sightValue: serializer.fromJson<String>(json['sightValue']),
      weatherData: serializer.fromJson<String?>(json['weatherData']),
      elevationDelta: serializer.fromJson<double?>(json['elevationDelta']),
      slopeAngle: serializer.fromJson<double?>(json['slopeAngle']),
      sessionId: serializer.fromJson<String?>(json['sessionId']),
      endNumber: serializer.fromJson<int?>(json['endNumber']),
      shotCount: serializer.fromJson<int?>(json['shotCount']),
      confidenceScore: serializer.fromJson<double?>(json['confidenceScore']),
      recordedAt: serializer.fromJson<DateTime>(json['recordedAt']),
      updatedAt: serializer.fromJson<DateTime?>(json['updatedAt']),
      deletedAt: serializer.fromJson<DateTime?>(json['deletedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'bowId': serializer.toJson<String>(bowId),
      'distance': serializer.toJson<double>(distance),
      'unit': serializer.toJson<String>(unit),
      'sightValue': serializer.toJson<String>(sightValue),
      'weatherData': serializer.toJson<String?>(weatherData),
      'elevationDelta': serializer.toJson<double?>(elevationDelta),
      'slopeAngle': serializer.toJson<double?>(slopeAngle),
      'sessionId': serializer.toJson<String?>(sessionId),
      'endNumber': serializer.toJson<int?>(endNumber),
      'shotCount': serializer.toJson<int?>(shotCount),
      'confidenceScore': serializer.toJson<double?>(confidenceScore),
      'recordedAt': serializer.toJson<DateTime>(recordedAt),
      'updatedAt': serializer.toJson<DateTime?>(updatedAt),
      'deletedAt': serializer.toJson<DateTime?>(deletedAt),
    };
  }

  SightMark copyWith({
    String? id,
    String? bowId,
    double? distance,
    String? unit,
    String? sightValue,
    Value<String?> weatherData = const Value.absent(),
    Value<double?> elevationDelta = const Value.absent(),
    Value<double?> slopeAngle = const Value.absent(),
    Value<String?> sessionId = const Value.absent(),
    Value<int?> endNumber = const Value.absent(),
    Value<int?> shotCount = const Value.absent(),
    Value<double?> confidenceScore = const Value.absent(),
    DateTime? recordedAt,
    Value<DateTime?> updatedAt = const Value.absent(),
    Value<DateTime?> deletedAt = const Value.absent(),
  }) => SightMark(
    id: id ?? this.id,
    bowId: bowId ?? this.bowId,
    distance: distance ?? this.distance,
    unit: unit ?? this.unit,
    sightValue: sightValue ?? this.sightValue,
    weatherData: weatherData.present ? weatherData.value : this.weatherData,
    elevationDelta: elevationDelta.present
        ? elevationDelta.value
        : this.elevationDelta,
    slopeAngle: slopeAngle.present ? slopeAngle.value : this.slopeAngle,
    sessionId: sessionId.present ? sessionId.value : this.sessionId,
    endNumber: endNumber.present ? endNumber.value : this.endNumber,
    shotCount: shotCount.present ? shotCount.value : this.shotCount,
    confidenceScore: confidenceScore.present
        ? confidenceScore.value
        : this.confidenceScore,
    recordedAt: recordedAt ?? this.recordedAt,
    updatedAt: updatedAt.present ? updatedAt.value : this.updatedAt,
    deletedAt: deletedAt.present ? deletedAt.value : this.deletedAt,
  );
  SightMark copyWithCompanion(SightMarksCompanion data) {
    return SightMark(
      id: data.id.present ? data.id.value : this.id,
      bowId: data.bowId.present ? data.bowId.value : this.bowId,
      distance: data.distance.present ? data.distance.value : this.distance,
      unit: data.unit.present ? data.unit.value : this.unit,
      sightValue: data.sightValue.present
          ? data.sightValue.value
          : this.sightValue,
      weatherData: data.weatherData.present
          ? data.weatherData.value
          : this.weatherData,
      elevationDelta: data.elevationDelta.present
          ? data.elevationDelta.value
          : this.elevationDelta,
      slopeAngle: data.slopeAngle.present
          ? data.slopeAngle.value
          : this.slopeAngle,
      sessionId: data.sessionId.present ? data.sessionId.value : this.sessionId,
      endNumber: data.endNumber.present ? data.endNumber.value : this.endNumber,
      shotCount: data.shotCount.present ? data.shotCount.value : this.shotCount,
      confidenceScore: data.confidenceScore.present
          ? data.confidenceScore.value
          : this.confidenceScore,
      recordedAt: data.recordedAt.present
          ? data.recordedAt.value
          : this.recordedAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
      deletedAt: data.deletedAt.present ? data.deletedAt.value : this.deletedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('SightMark(')
          ..write('id: $id, ')
          ..write('bowId: $bowId, ')
          ..write('distance: $distance, ')
          ..write('unit: $unit, ')
          ..write('sightValue: $sightValue, ')
          ..write('weatherData: $weatherData, ')
          ..write('elevationDelta: $elevationDelta, ')
          ..write('slopeAngle: $slopeAngle, ')
          ..write('sessionId: $sessionId, ')
          ..write('endNumber: $endNumber, ')
          ..write('shotCount: $shotCount, ')
          ..write('confidenceScore: $confidenceScore, ')
          ..write('recordedAt: $recordedAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('deletedAt: $deletedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    bowId,
    distance,
    unit,
    sightValue,
    weatherData,
    elevationDelta,
    slopeAngle,
    sessionId,
    endNumber,
    shotCount,
    confidenceScore,
    recordedAt,
    updatedAt,
    deletedAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is SightMark &&
          other.id == this.id &&
          other.bowId == this.bowId &&
          other.distance == this.distance &&
          other.unit == this.unit &&
          other.sightValue == this.sightValue &&
          other.weatherData == this.weatherData &&
          other.elevationDelta == this.elevationDelta &&
          other.slopeAngle == this.slopeAngle &&
          other.sessionId == this.sessionId &&
          other.endNumber == this.endNumber &&
          other.shotCount == this.shotCount &&
          other.confidenceScore == this.confidenceScore &&
          other.recordedAt == this.recordedAt &&
          other.updatedAt == this.updatedAt &&
          other.deletedAt == this.deletedAt);
}

class SightMarksCompanion extends UpdateCompanion<SightMark> {
  final Value<String> id;
  final Value<String> bowId;
  final Value<double> distance;
  final Value<String> unit;
  final Value<String> sightValue;
  final Value<String?> weatherData;
  final Value<double?> elevationDelta;
  final Value<double?> slopeAngle;
  final Value<String?> sessionId;
  final Value<int?> endNumber;
  final Value<int?> shotCount;
  final Value<double?> confidenceScore;
  final Value<DateTime> recordedAt;
  final Value<DateTime?> updatedAt;
  final Value<DateTime?> deletedAt;
  final Value<int> rowid;
  const SightMarksCompanion({
    this.id = const Value.absent(),
    this.bowId = const Value.absent(),
    this.distance = const Value.absent(),
    this.unit = const Value.absent(),
    this.sightValue = const Value.absent(),
    this.weatherData = const Value.absent(),
    this.elevationDelta = const Value.absent(),
    this.slopeAngle = const Value.absent(),
    this.sessionId = const Value.absent(),
    this.endNumber = const Value.absent(),
    this.shotCount = const Value.absent(),
    this.confidenceScore = const Value.absent(),
    this.recordedAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.deletedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  SightMarksCompanion.insert({
    required String id,
    required String bowId,
    required double distance,
    this.unit = const Value.absent(),
    required String sightValue,
    this.weatherData = const Value.absent(),
    this.elevationDelta = const Value.absent(),
    this.slopeAngle = const Value.absent(),
    this.sessionId = const Value.absent(),
    this.endNumber = const Value.absent(),
    this.shotCount = const Value.absent(),
    this.confidenceScore = const Value.absent(),
    this.recordedAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.deletedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       bowId = Value(bowId),
       distance = Value(distance),
       sightValue = Value(sightValue);
  static Insertable<SightMark> custom({
    Expression<String>? id,
    Expression<String>? bowId,
    Expression<double>? distance,
    Expression<String>? unit,
    Expression<String>? sightValue,
    Expression<String>? weatherData,
    Expression<double>? elevationDelta,
    Expression<double>? slopeAngle,
    Expression<String>? sessionId,
    Expression<int>? endNumber,
    Expression<int>? shotCount,
    Expression<double>? confidenceScore,
    Expression<DateTime>? recordedAt,
    Expression<DateTime>? updatedAt,
    Expression<DateTime>? deletedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (bowId != null) 'bow_id': bowId,
      if (distance != null) 'distance': distance,
      if (unit != null) 'unit': unit,
      if (sightValue != null) 'sight_value': sightValue,
      if (weatherData != null) 'weather_data': weatherData,
      if (elevationDelta != null) 'elevation_delta': elevationDelta,
      if (slopeAngle != null) 'slope_angle': slopeAngle,
      if (sessionId != null) 'session_id': sessionId,
      if (endNumber != null) 'end_number': endNumber,
      if (shotCount != null) 'shot_count': shotCount,
      if (confidenceScore != null) 'confidence_score': confidenceScore,
      if (recordedAt != null) 'recorded_at': recordedAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (deletedAt != null) 'deleted_at': deletedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  SightMarksCompanion copyWith({
    Value<String>? id,
    Value<String>? bowId,
    Value<double>? distance,
    Value<String>? unit,
    Value<String>? sightValue,
    Value<String?>? weatherData,
    Value<double?>? elevationDelta,
    Value<double?>? slopeAngle,
    Value<String?>? sessionId,
    Value<int?>? endNumber,
    Value<int?>? shotCount,
    Value<double?>? confidenceScore,
    Value<DateTime>? recordedAt,
    Value<DateTime?>? updatedAt,
    Value<DateTime?>? deletedAt,
    Value<int>? rowid,
  }) {
    return SightMarksCompanion(
      id: id ?? this.id,
      bowId: bowId ?? this.bowId,
      distance: distance ?? this.distance,
      unit: unit ?? this.unit,
      sightValue: sightValue ?? this.sightValue,
      weatherData: weatherData ?? this.weatherData,
      elevationDelta: elevationDelta ?? this.elevationDelta,
      slopeAngle: slopeAngle ?? this.slopeAngle,
      sessionId: sessionId ?? this.sessionId,
      endNumber: endNumber ?? this.endNumber,
      shotCount: shotCount ?? this.shotCount,
      confidenceScore: confidenceScore ?? this.confidenceScore,
      recordedAt: recordedAt ?? this.recordedAt,
      updatedAt: updatedAt ?? this.updatedAt,
      deletedAt: deletedAt ?? this.deletedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (bowId.present) {
      map['bow_id'] = Variable<String>(bowId.value);
    }
    if (distance.present) {
      map['distance'] = Variable<double>(distance.value);
    }
    if (unit.present) {
      map['unit'] = Variable<String>(unit.value);
    }
    if (sightValue.present) {
      map['sight_value'] = Variable<String>(sightValue.value);
    }
    if (weatherData.present) {
      map['weather_data'] = Variable<String>(weatherData.value);
    }
    if (elevationDelta.present) {
      map['elevation_delta'] = Variable<double>(elevationDelta.value);
    }
    if (slopeAngle.present) {
      map['slope_angle'] = Variable<double>(slopeAngle.value);
    }
    if (sessionId.present) {
      map['session_id'] = Variable<String>(sessionId.value);
    }
    if (endNumber.present) {
      map['end_number'] = Variable<int>(endNumber.value);
    }
    if (shotCount.present) {
      map['shot_count'] = Variable<int>(shotCount.value);
    }
    if (confidenceScore.present) {
      map['confidence_score'] = Variable<double>(confidenceScore.value);
    }
    if (recordedAt.present) {
      map['recorded_at'] = Variable<DateTime>(recordedAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (deletedAt.present) {
      map['deleted_at'] = Variable<DateTime>(deletedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('SightMarksCompanion(')
          ..write('id: $id, ')
          ..write('bowId: $bowId, ')
          ..write('distance: $distance, ')
          ..write('unit: $unit, ')
          ..write('sightValue: $sightValue, ')
          ..write('weatherData: $weatherData, ')
          ..write('elevationDelta: $elevationDelta, ')
          ..write('slopeAngle: $slopeAngle, ')
          ..write('sessionId: $sessionId, ')
          ..write('endNumber: $endNumber, ')
          ..write('shotCount: $shotCount, ')
          ..write('confidenceScore: $confidenceScore, ')
          ..write('recordedAt: $recordedAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('deletedAt: $deletedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $SightMarkPreferencesTableTable extends SightMarkPreferencesTable
    with
        TableInfo<
          $SightMarkPreferencesTableTable,
          SightMarkPreferencesTableData
        > {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $SightMarkPreferencesTableTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _bowIdMeta = const VerificationMeta('bowId');
  @override
  late final GeneratedColumn<String> bowId = GeneratedColumn<String>(
    'bow_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES bows (id)',
    ),
  );
  static const VerificationMeta _notationStyleMeta = const VerificationMeta(
    'notationStyle',
  );
  @override
  late final GeneratedColumn<String> notationStyle = GeneratedColumn<String>(
    'notation_style',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('decimal'),
  );
  static const VerificationMeta _decimalPlacesMeta = const VerificationMeta(
    'decimalPlaces',
  );
  @override
  late final GeneratedColumn<int> decimalPlaces = GeneratedColumn<int>(
    'decimal_places',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(2),
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [
    bowId,
    notationStyle,
    decimalPlaces,
    createdAt,
    updatedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'sight_mark_preferences_table';
  @override
  VerificationContext validateIntegrity(
    Insertable<SightMarkPreferencesTableData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('bow_id')) {
      context.handle(
        _bowIdMeta,
        bowId.isAcceptableOrUnknown(data['bow_id']!, _bowIdMeta),
      );
    } else if (isInserting) {
      context.missing(_bowIdMeta);
    }
    if (data.containsKey('notation_style')) {
      context.handle(
        _notationStyleMeta,
        notationStyle.isAcceptableOrUnknown(
          data['notation_style']!,
          _notationStyleMeta,
        ),
      );
    }
    if (data.containsKey('decimal_places')) {
      context.handle(
        _decimalPlacesMeta,
        decimalPlaces.isAcceptableOrUnknown(
          data['decimal_places']!,
          _decimalPlacesMeta,
        ),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {bowId};
  @override
  SightMarkPreferencesTableData map(
    Map<String, dynamic> data, {
    String? tablePrefix,
  }) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return SightMarkPreferencesTableData(
      bowId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}bow_id'],
      )!,
      notationStyle: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}notation_style'],
      )!,
      decimalPlaces: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}decimal_places'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      ),
    );
  }

  @override
  $SightMarkPreferencesTableTable createAlias(String alias) {
    return $SightMarkPreferencesTableTable(attachedDatabase, alias);
  }
}

class SightMarkPreferencesTableData extends DataClass
    implements Insertable<SightMarkPreferencesTableData> {
  final String bowId;
  final String notationStyle;
  final int decimalPlaces;
  final DateTime createdAt;
  final DateTime? updatedAt;
  const SightMarkPreferencesTableData({
    required this.bowId,
    required this.notationStyle,
    required this.decimalPlaces,
    required this.createdAt,
    this.updatedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['bow_id'] = Variable<String>(bowId);
    map['notation_style'] = Variable<String>(notationStyle);
    map['decimal_places'] = Variable<int>(decimalPlaces);
    map['created_at'] = Variable<DateTime>(createdAt);
    if (!nullToAbsent || updatedAt != null) {
      map['updated_at'] = Variable<DateTime>(updatedAt);
    }
    return map;
  }

  SightMarkPreferencesTableCompanion toCompanion(bool nullToAbsent) {
    return SightMarkPreferencesTableCompanion(
      bowId: Value(bowId),
      notationStyle: Value(notationStyle),
      decimalPlaces: Value(decimalPlaces),
      createdAt: Value(createdAt),
      updatedAt: updatedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(updatedAt),
    );
  }

  factory SightMarkPreferencesTableData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return SightMarkPreferencesTableData(
      bowId: serializer.fromJson<String>(json['bowId']),
      notationStyle: serializer.fromJson<String>(json['notationStyle']),
      decimalPlaces: serializer.fromJson<int>(json['decimalPlaces']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime?>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'bowId': serializer.toJson<String>(bowId),
      'notationStyle': serializer.toJson<String>(notationStyle),
      'decimalPlaces': serializer.toJson<int>(decimalPlaces),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime?>(updatedAt),
    };
  }

  SightMarkPreferencesTableData copyWith({
    String? bowId,
    String? notationStyle,
    int? decimalPlaces,
    DateTime? createdAt,
    Value<DateTime?> updatedAt = const Value.absent(),
  }) => SightMarkPreferencesTableData(
    bowId: bowId ?? this.bowId,
    notationStyle: notationStyle ?? this.notationStyle,
    decimalPlaces: decimalPlaces ?? this.decimalPlaces,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt.present ? updatedAt.value : this.updatedAt,
  );
  SightMarkPreferencesTableData copyWithCompanion(
    SightMarkPreferencesTableCompanion data,
  ) {
    return SightMarkPreferencesTableData(
      bowId: data.bowId.present ? data.bowId.value : this.bowId,
      notationStyle: data.notationStyle.present
          ? data.notationStyle.value
          : this.notationStyle,
      decimalPlaces: data.decimalPlaces.present
          ? data.decimalPlaces.value
          : this.decimalPlaces,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('SightMarkPreferencesTableData(')
          ..write('bowId: $bowId, ')
          ..write('notationStyle: $notationStyle, ')
          ..write('decimalPlaces: $decimalPlaces, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(bowId, notationStyle, decimalPlaces, createdAt, updatedAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is SightMarkPreferencesTableData &&
          other.bowId == this.bowId &&
          other.notationStyle == this.notationStyle &&
          other.decimalPlaces == this.decimalPlaces &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class SightMarkPreferencesTableCompanion
    extends UpdateCompanion<SightMarkPreferencesTableData> {
  final Value<String> bowId;
  final Value<String> notationStyle;
  final Value<int> decimalPlaces;
  final Value<DateTime> createdAt;
  final Value<DateTime?> updatedAt;
  final Value<int> rowid;
  const SightMarkPreferencesTableCompanion({
    this.bowId = const Value.absent(),
    this.notationStyle = const Value.absent(),
    this.decimalPlaces = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  SightMarkPreferencesTableCompanion.insert({
    required String bowId,
    this.notationStyle = const Value.absent(),
    this.decimalPlaces = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : bowId = Value(bowId);
  static Insertable<SightMarkPreferencesTableData> custom({
    Expression<String>? bowId,
    Expression<String>? notationStyle,
    Expression<int>? decimalPlaces,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (bowId != null) 'bow_id': bowId,
      if (notationStyle != null) 'notation_style': notationStyle,
      if (decimalPlaces != null) 'decimal_places': decimalPlaces,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  SightMarkPreferencesTableCompanion copyWith({
    Value<String>? bowId,
    Value<String>? notationStyle,
    Value<int>? decimalPlaces,
    Value<DateTime>? createdAt,
    Value<DateTime?>? updatedAt,
    Value<int>? rowid,
  }) {
    return SightMarkPreferencesTableCompanion(
      bowId: bowId ?? this.bowId,
      notationStyle: notationStyle ?? this.notationStyle,
      decimalPlaces: decimalPlaces ?? this.decimalPlaces,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (bowId.present) {
      map['bow_id'] = Variable<String>(bowId.value);
    }
    if (notationStyle.present) {
      map['notation_style'] = Variable<String>(notationStyle.value);
    }
    if (decimalPlaces.present) {
      map['decimal_places'] = Variable<int>(decimalPlaces.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('SightMarkPreferencesTableCompanion(')
          ..write('bowId: $bowId, ')
          ..write('notationStyle: $notationStyle, ')
          ..write('decimalPlaces: $decimalPlaces, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $RegisteredTargetsTable extends RegisteredTargets
    with TableInfo<$RegisteredTargetsTable, RegisteredTarget> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $RegisteredTargetsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _targetTypeMeta = const VerificationMeta(
    'targetType',
  );
  @override
  late final GeneratedColumn<String> targetType = GeneratedColumn<String>(
    'target_type',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _imagePathMeta = const VerificationMeta(
    'imagePath',
  );
  @override
  late final GeneratedColumn<String> imagePath = GeneratedColumn<String>(
    'image_path',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _isTripleSpotMeta = const VerificationMeta(
    'isTripleSpot',
  );
  @override
  late final GeneratedColumn<bool> isTripleSpot = GeneratedColumn<bool>(
    'is_triple_spot',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_triple_spot" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    targetType,
    imagePath,
    isTripleSpot,
    createdAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'registered_targets';
  @override
  VerificationContext validateIntegrity(
    Insertable<RegisteredTarget> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('target_type')) {
      context.handle(
        _targetTypeMeta,
        targetType.isAcceptableOrUnknown(data['target_type']!, _targetTypeMeta),
      );
    } else if (isInserting) {
      context.missing(_targetTypeMeta);
    }
    if (data.containsKey('image_path')) {
      context.handle(
        _imagePathMeta,
        imagePath.isAcceptableOrUnknown(data['image_path']!, _imagePathMeta),
      );
    } else if (isInserting) {
      context.missing(_imagePathMeta);
    }
    if (data.containsKey('is_triple_spot')) {
      context.handle(
        _isTripleSpotMeta,
        isTripleSpot.isAcceptableOrUnknown(
          data['is_triple_spot']!,
          _isTripleSpotMeta,
        ),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  RegisteredTarget map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return RegisteredTarget(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      targetType: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}target_type'],
      )!,
      imagePath: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}image_path'],
      )!,
      isTripleSpot: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_triple_spot'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
    );
  }

  @override
  $RegisteredTargetsTable createAlias(String alias) {
    return $RegisteredTargetsTable(attachedDatabase, alias);
  }
}

class RegisteredTarget extends DataClass
    implements Insertable<RegisteredTarget> {
  final String id;
  final String targetType;
  final String imagePath;
  final bool isTripleSpot;
  final DateTime createdAt;
  const RegisteredTarget({
    required this.id,
    required this.targetType,
    required this.imagePath,
    required this.isTripleSpot,
    required this.createdAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['target_type'] = Variable<String>(targetType);
    map['image_path'] = Variable<String>(imagePath);
    map['is_triple_spot'] = Variable<bool>(isTripleSpot);
    map['created_at'] = Variable<DateTime>(createdAt);
    return map;
  }

  RegisteredTargetsCompanion toCompanion(bool nullToAbsent) {
    return RegisteredTargetsCompanion(
      id: Value(id),
      targetType: Value(targetType),
      imagePath: Value(imagePath),
      isTripleSpot: Value(isTripleSpot),
      createdAt: Value(createdAt),
    );
  }

  factory RegisteredTarget.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return RegisteredTarget(
      id: serializer.fromJson<String>(json['id']),
      targetType: serializer.fromJson<String>(json['targetType']),
      imagePath: serializer.fromJson<String>(json['imagePath']),
      isTripleSpot: serializer.fromJson<bool>(json['isTripleSpot']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'targetType': serializer.toJson<String>(targetType),
      'imagePath': serializer.toJson<String>(imagePath),
      'isTripleSpot': serializer.toJson<bool>(isTripleSpot),
      'createdAt': serializer.toJson<DateTime>(createdAt),
    };
  }

  RegisteredTarget copyWith({
    String? id,
    String? targetType,
    String? imagePath,
    bool? isTripleSpot,
    DateTime? createdAt,
  }) => RegisteredTarget(
    id: id ?? this.id,
    targetType: targetType ?? this.targetType,
    imagePath: imagePath ?? this.imagePath,
    isTripleSpot: isTripleSpot ?? this.isTripleSpot,
    createdAt: createdAt ?? this.createdAt,
  );
  RegisteredTarget copyWithCompanion(RegisteredTargetsCompanion data) {
    return RegisteredTarget(
      id: data.id.present ? data.id.value : this.id,
      targetType: data.targetType.present
          ? data.targetType.value
          : this.targetType,
      imagePath: data.imagePath.present ? data.imagePath.value : this.imagePath,
      isTripleSpot: data.isTripleSpot.present
          ? data.isTripleSpot.value
          : this.isTripleSpot,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('RegisteredTarget(')
          ..write('id: $id, ')
          ..write('targetType: $targetType, ')
          ..write('imagePath: $imagePath, ')
          ..write('isTripleSpot: $isTripleSpot, ')
          ..write('createdAt: $createdAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(id, targetType, imagePath, isTripleSpot, createdAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is RegisteredTarget &&
          other.id == this.id &&
          other.targetType == this.targetType &&
          other.imagePath == this.imagePath &&
          other.isTripleSpot == this.isTripleSpot &&
          other.createdAt == this.createdAt);
}

class RegisteredTargetsCompanion extends UpdateCompanion<RegisteredTarget> {
  final Value<String> id;
  final Value<String> targetType;
  final Value<String> imagePath;
  final Value<bool> isTripleSpot;
  final Value<DateTime> createdAt;
  final Value<int> rowid;
  const RegisteredTargetsCompanion({
    this.id = const Value.absent(),
    this.targetType = const Value.absent(),
    this.imagePath = const Value.absent(),
    this.isTripleSpot = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  RegisteredTargetsCompanion.insert({
    required String id,
    required String targetType,
    required String imagePath,
    this.isTripleSpot = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       targetType = Value(targetType),
       imagePath = Value(imagePath);
  static Insertable<RegisteredTarget> custom({
    Expression<String>? id,
    Expression<String>? targetType,
    Expression<String>? imagePath,
    Expression<bool>? isTripleSpot,
    Expression<DateTime>? createdAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (targetType != null) 'target_type': targetType,
      if (imagePath != null) 'image_path': imagePath,
      if (isTripleSpot != null) 'is_triple_spot': isTripleSpot,
      if (createdAt != null) 'created_at': createdAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  RegisteredTargetsCompanion copyWith({
    Value<String>? id,
    Value<String>? targetType,
    Value<String>? imagePath,
    Value<bool>? isTripleSpot,
    Value<DateTime>? createdAt,
    Value<int>? rowid,
  }) {
    return RegisteredTargetsCompanion(
      id: id ?? this.id,
      targetType: targetType ?? this.targetType,
      imagePath: imagePath ?? this.imagePath,
      isTripleSpot: isTripleSpot ?? this.isTripleSpot,
      createdAt: createdAt ?? this.createdAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (targetType.present) {
      map['target_type'] = Variable<String>(targetType.value);
    }
    if (imagePath.present) {
      map['image_path'] = Variable<String>(imagePath.value);
    }
    if (isTripleSpot.present) {
      map['is_triple_spot'] = Variable<bool>(isTripleSpot.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('RegisteredTargetsCompanion(')
          ..write('id: $id, ')
          ..write('targetType: $targetType, ')
          ..write('imagePath: $imagePath, ')
          ..write('isTripleSpot: $isTripleSpot, ')
          ..write('createdAt: $createdAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $AutoPlotUsageTable extends AutoPlotUsage
    with TableInfo<$AutoPlotUsageTable, AutoPlotUsageData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $AutoPlotUsageTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _yearMonthMeta = const VerificationMeta(
    'yearMonth',
  );
  @override
  late final GeneratedColumn<String> yearMonth = GeneratedColumn<String>(
    'year_month',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _scanCountMeta = const VerificationMeta(
    'scanCount',
  );
  @override
  late final GeneratedColumn<int> scanCount = GeneratedColumn<int>(
    'scan_count',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  @override
  List<GeneratedColumn> get $columns => [id, yearMonth, scanCount];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'auto_plot_usage';
  @override
  VerificationContext validateIntegrity(
    Insertable<AutoPlotUsageData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('year_month')) {
      context.handle(
        _yearMonthMeta,
        yearMonth.isAcceptableOrUnknown(data['year_month']!, _yearMonthMeta),
      );
    } else if (isInserting) {
      context.missing(_yearMonthMeta);
    }
    if (data.containsKey('scan_count')) {
      context.handle(
        _scanCountMeta,
        scanCount.isAcceptableOrUnknown(data['scan_count']!, _scanCountMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  AutoPlotUsageData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return AutoPlotUsageData(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      yearMonth: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}year_month'],
      )!,
      scanCount: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}scan_count'],
      )!,
    );
  }

  @override
  $AutoPlotUsageTable createAlias(String alias) {
    return $AutoPlotUsageTable(attachedDatabase, alias);
  }
}

class AutoPlotUsageData extends DataClass
    implements Insertable<AutoPlotUsageData> {
  final String id;
  final String yearMonth;
  final int scanCount;
  const AutoPlotUsageData({
    required this.id,
    required this.yearMonth,
    required this.scanCount,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['year_month'] = Variable<String>(yearMonth);
    map['scan_count'] = Variable<int>(scanCount);
    return map;
  }

  AutoPlotUsageCompanion toCompanion(bool nullToAbsent) {
    return AutoPlotUsageCompanion(
      id: Value(id),
      yearMonth: Value(yearMonth),
      scanCount: Value(scanCount),
    );
  }

  factory AutoPlotUsageData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AutoPlotUsageData(
      id: serializer.fromJson<String>(json['id']),
      yearMonth: serializer.fromJson<String>(json['yearMonth']),
      scanCount: serializer.fromJson<int>(json['scanCount']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'yearMonth': serializer.toJson<String>(yearMonth),
      'scanCount': serializer.toJson<int>(scanCount),
    };
  }

  AutoPlotUsageData copyWith({String? id, String? yearMonth, int? scanCount}) =>
      AutoPlotUsageData(
        id: id ?? this.id,
        yearMonth: yearMonth ?? this.yearMonth,
        scanCount: scanCount ?? this.scanCount,
      );
  AutoPlotUsageData copyWithCompanion(AutoPlotUsageCompanion data) {
    return AutoPlotUsageData(
      id: data.id.present ? data.id.value : this.id,
      yearMonth: data.yearMonth.present ? data.yearMonth.value : this.yearMonth,
      scanCount: data.scanCount.present ? data.scanCount.value : this.scanCount,
    );
  }

  @override
  String toString() {
    return (StringBuffer('AutoPlotUsageData(')
          ..write('id: $id, ')
          ..write('yearMonth: $yearMonth, ')
          ..write('scanCount: $scanCount')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, yearMonth, scanCount);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AutoPlotUsageData &&
          other.id == this.id &&
          other.yearMonth == this.yearMonth &&
          other.scanCount == this.scanCount);
}

class AutoPlotUsageCompanion extends UpdateCompanion<AutoPlotUsageData> {
  final Value<String> id;
  final Value<String> yearMonth;
  final Value<int> scanCount;
  final Value<int> rowid;
  const AutoPlotUsageCompanion({
    this.id = const Value.absent(),
    this.yearMonth = const Value.absent(),
    this.scanCount = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  AutoPlotUsageCompanion.insert({
    required String id,
    required String yearMonth,
    this.scanCount = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       yearMonth = Value(yearMonth);
  static Insertable<AutoPlotUsageData> custom({
    Expression<String>? id,
    Expression<String>? yearMonth,
    Expression<int>? scanCount,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (yearMonth != null) 'year_month': yearMonth,
      if (scanCount != null) 'scan_count': scanCount,
      if (rowid != null) 'rowid': rowid,
    });
  }

  AutoPlotUsageCompanion copyWith({
    Value<String>? id,
    Value<String>? yearMonth,
    Value<int>? scanCount,
    Value<int>? rowid,
  }) {
    return AutoPlotUsageCompanion(
      id: id ?? this.id,
      yearMonth: yearMonth ?? this.yearMonth,
      scanCount: scanCount ?? this.scanCount,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (yearMonth.present) {
      map['year_month'] = Variable<String>(yearMonth.value);
    }
    if (scanCount.present) {
      map['scan_count'] = Variable<int>(scanCount.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AutoPlotUsageCompanion(')
          ..write('id: $id, ')
          ..write('yearMonth: $yearMonth, ')
          ..write('scanCount: $scanCount, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $UserProfilesTable extends UserProfiles
    with TableInfo<$UserProfilesTable, UserProfile> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $UserProfilesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _primaryBowTypeMeta = const VerificationMeta(
    'primaryBowType',
  );
  @override
  late final GeneratedColumn<String> primaryBowType = GeneratedColumn<String>(
    'primary_bow_type',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('recurve'),
  );
  static const VerificationMeta _handednessMeta = const VerificationMeta(
    'handedness',
  );
  @override
  late final GeneratedColumn<String> handedness = GeneratedColumn<String>(
    'handedness',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('right'),
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _clubNameMeta = const VerificationMeta(
    'clubName',
  );
  @override
  late final GeneratedColumn<String> clubName = GeneratedColumn<String>(
    'club_name',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _yearsShootingStartMeta =
      const VerificationMeta('yearsShootingStart');
  @override
  late final GeneratedColumn<int> yearsShootingStart = GeneratedColumn<int>(
    'years_shooting_start',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _shootingFrequencyMeta = const VerificationMeta(
    'shootingFrequency',
  );
  @override
  late final GeneratedColumn<double> shootingFrequency =
      GeneratedColumn<double>(
        'shooting_frequency',
        aliasedName,
        false,
        type: DriftSqlType.double,
        requiredDuringInsert: false,
        defaultValue: const Constant(3.0),
      );
  static const VerificationMeta _competitionLevelsMeta = const VerificationMeta(
    'competitionLevels',
  );
  @override
  late final GeneratedColumn<String> competitionLevels =
      GeneratedColumn<String>(
        'competition_levels',
        aliasedName,
        false,
        type: DriftSqlType.string,
        requiredDuringInsert: false,
        defaultValue: const Constant('[]'),
      );
  static const VerificationMeta _notesMeta = const VerificationMeta('notes');
  @override
  late final GeneratedColumn<String> notes = GeneratedColumn<String>(
    'notes',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    primaryBowType,
    handedness,
    name,
    clubName,
    yearsShootingStart,
    shootingFrequency,
    competitionLevels,
    notes,
    createdAt,
    updatedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'user_profiles';
  @override
  VerificationContext validateIntegrity(
    Insertable<UserProfile> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('primary_bow_type')) {
      context.handle(
        _primaryBowTypeMeta,
        primaryBowType.isAcceptableOrUnknown(
          data['primary_bow_type']!,
          _primaryBowTypeMeta,
        ),
      );
    }
    if (data.containsKey('handedness')) {
      context.handle(
        _handednessMeta,
        handedness.isAcceptableOrUnknown(data['handedness']!, _handednessMeta),
      );
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    }
    if (data.containsKey('club_name')) {
      context.handle(
        _clubNameMeta,
        clubName.isAcceptableOrUnknown(data['club_name']!, _clubNameMeta),
      );
    }
    if (data.containsKey('years_shooting_start')) {
      context.handle(
        _yearsShootingStartMeta,
        yearsShootingStart.isAcceptableOrUnknown(
          data['years_shooting_start']!,
          _yearsShootingStartMeta,
        ),
      );
    }
    if (data.containsKey('shooting_frequency')) {
      context.handle(
        _shootingFrequencyMeta,
        shootingFrequency.isAcceptableOrUnknown(
          data['shooting_frequency']!,
          _shootingFrequencyMeta,
        ),
      );
    }
    if (data.containsKey('competition_levels')) {
      context.handle(
        _competitionLevelsMeta,
        competitionLevels.isAcceptableOrUnknown(
          data['competition_levels']!,
          _competitionLevelsMeta,
        ),
      );
    }
    if (data.containsKey('notes')) {
      context.handle(
        _notesMeta,
        notes.isAcceptableOrUnknown(data['notes']!, _notesMeta),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  UserProfile map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return UserProfile(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      primaryBowType: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}primary_bow_type'],
      )!,
      handedness: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}handedness'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      ),
      clubName: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}club_name'],
      ),
      yearsShootingStart: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}years_shooting_start'],
      ),
      shootingFrequency: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}shooting_frequency'],
      )!,
      competitionLevels: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}competition_levels'],
      )!,
      notes: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}notes'],
      ),
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      )!,
    );
  }

  @override
  $UserProfilesTable createAlias(String alias) {
    return $UserProfilesTable(attachedDatabase, alias);
  }
}

class UserProfile extends DataClass implements Insertable<UserProfile> {
  final String id;
  final String primaryBowType;
  final String handedness;
  final String? name;
  final String? clubName;
  final int? yearsShootingStart;
  final double shootingFrequency;
  final String competitionLevels;
  final String? notes;
  final DateTime createdAt;
  final DateTime updatedAt;
  const UserProfile({
    required this.id,
    required this.primaryBowType,
    required this.handedness,
    this.name,
    this.clubName,
    this.yearsShootingStart,
    required this.shootingFrequency,
    required this.competitionLevels,
    this.notes,
    required this.createdAt,
    required this.updatedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['primary_bow_type'] = Variable<String>(primaryBowType);
    map['handedness'] = Variable<String>(handedness);
    if (!nullToAbsent || name != null) {
      map['name'] = Variable<String>(name);
    }
    if (!nullToAbsent || clubName != null) {
      map['club_name'] = Variable<String>(clubName);
    }
    if (!nullToAbsent || yearsShootingStart != null) {
      map['years_shooting_start'] = Variable<int>(yearsShootingStart);
    }
    map['shooting_frequency'] = Variable<double>(shootingFrequency);
    map['competition_levels'] = Variable<String>(competitionLevels);
    if (!nullToAbsent || notes != null) {
      map['notes'] = Variable<String>(notes);
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    return map;
  }

  UserProfilesCompanion toCompanion(bool nullToAbsent) {
    return UserProfilesCompanion(
      id: Value(id),
      primaryBowType: Value(primaryBowType),
      handedness: Value(handedness),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      clubName: clubName == null && nullToAbsent
          ? const Value.absent()
          : Value(clubName),
      yearsShootingStart: yearsShootingStart == null && nullToAbsent
          ? const Value.absent()
          : Value(yearsShootingStart),
      shootingFrequency: Value(shootingFrequency),
      competitionLevels: Value(competitionLevels),
      notes: notes == null && nullToAbsent
          ? const Value.absent()
          : Value(notes),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory UserProfile.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return UserProfile(
      id: serializer.fromJson<String>(json['id']),
      primaryBowType: serializer.fromJson<String>(json['primaryBowType']),
      handedness: serializer.fromJson<String>(json['handedness']),
      name: serializer.fromJson<String?>(json['name']),
      clubName: serializer.fromJson<String?>(json['clubName']),
      yearsShootingStart: serializer.fromJson<int?>(json['yearsShootingStart']),
      shootingFrequency: serializer.fromJson<double>(json['shootingFrequency']),
      competitionLevels: serializer.fromJson<String>(json['competitionLevels']),
      notes: serializer.fromJson<String?>(json['notes']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'primaryBowType': serializer.toJson<String>(primaryBowType),
      'handedness': serializer.toJson<String>(handedness),
      'name': serializer.toJson<String?>(name),
      'clubName': serializer.toJson<String?>(clubName),
      'yearsShootingStart': serializer.toJson<int?>(yearsShootingStart),
      'shootingFrequency': serializer.toJson<double>(shootingFrequency),
      'competitionLevels': serializer.toJson<String>(competitionLevels),
      'notes': serializer.toJson<String?>(notes),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
    };
  }

  UserProfile copyWith({
    String? id,
    String? primaryBowType,
    String? handedness,
    Value<String?> name = const Value.absent(),
    Value<String?> clubName = const Value.absent(),
    Value<int?> yearsShootingStart = const Value.absent(),
    double? shootingFrequency,
    String? competitionLevels,
    Value<String?> notes = const Value.absent(),
    DateTime? createdAt,
    DateTime? updatedAt,
  }) => UserProfile(
    id: id ?? this.id,
    primaryBowType: primaryBowType ?? this.primaryBowType,
    handedness: handedness ?? this.handedness,
    name: name.present ? name.value : this.name,
    clubName: clubName.present ? clubName.value : this.clubName,
    yearsShootingStart: yearsShootingStart.present
        ? yearsShootingStart.value
        : this.yearsShootingStart,
    shootingFrequency: shootingFrequency ?? this.shootingFrequency,
    competitionLevels: competitionLevels ?? this.competitionLevels,
    notes: notes.present ? notes.value : this.notes,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
  );
  UserProfile copyWithCompanion(UserProfilesCompanion data) {
    return UserProfile(
      id: data.id.present ? data.id.value : this.id,
      primaryBowType: data.primaryBowType.present
          ? data.primaryBowType.value
          : this.primaryBowType,
      handedness: data.handedness.present
          ? data.handedness.value
          : this.handedness,
      name: data.name.present ? data.name.value : this.name,
      clubName: data.clubName.present ? data.clubName.value : this.clubName,
      yearsShootingStart: data.yearsShootingStart.present
          ? data.yearsShootingStart.value
          : this.yearsShootingStart,
      shootingFrequency: data.shootingFrequency.present
          ? data.shootingFrequency.value
          : this.shootingFrequency,
      competitionLevels: data.competitionLevels.present
          ? data.competitionLevels.value
          : this.competitionLevels,
      notes: data.notes.present ? data.notes.value : this.notes,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('UserProfile(')
          ..write('id: $id, ')
          ..write('primaryBowType: $primaryBowType, ')
          ..write('handedness: $handedness, ')
          ..write('name: $name, ')
          ..write('clubName: $clubName, ')
          ..write('yearsShootingStart: $yearsShootingStart, ')
          ..write('shootingFrequency: $shootingFrequency, ')
          ..write('competitionLevels: $competitionLevels, ')
          ..write('notes: $notes, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    primaryBowType,
    handedness,
    name,
    clubName,
    yearsShootingStart,
    shootingFrequency,
    competitionLevels,
    notes,
    createdAt,
    updatedAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is UserProfile &&
          other.id == this.id &&
          other.primaryBowType == this.primaryBowType &&
          other.handedness == this.handedness &&
          other.name == this.name &&
          other.clubName == this.clubName &&
          other.yearsShootingStart == this.yearsShootingStart &&
          other.shootingFrequency == this.shootingFrequency &&
          other.competitionLevels == this.competitionLevels &&
          other.notes == this.notes &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class UserProfilesCompanion extends UpdateCompanion<UserProfile> {
  final Value<String> id;
  final Value<String> primaryBowType;
  final Value<String> handedness;
  final Value<String?> name;
  final Value<String?> clubName;
  final Value<int?> yearsShootingStart;
  final Value<double> shootingFrequency;
  final Value<String> competitionLevels;
  final Value<String?> notes;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  final Value<int> rowid;
  const UserProfilesCompanion({
    this.id = const Value.absent(),
    this.primaryBowType = const Value.absent(),
    this.handedness = const Value.absent(),
    this.name = const Value.absent(),
    this.clubName = const Value.absent(),
    this.yearsShootingStart = const Value.absent(),
    this.shootingFrequency = const Value.absent(),
    this.competitionLevels = const Value.absent(),
    this.notes = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  UserProfilesCompanion.insert({
    required String id,
    this.primaryBowType = const Value.absent(),
    this.handedness = const Value.absent(),
    this.name = const Value.absent(),
    this.clubName = const Value.absent(),
    this.yearsShootingStart = const Value.absent(),
    this.shootingFrequency = const Value.absent(),
    this.competitionLevels = const Value.absent(),
    this.notes = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id);
  static Insertable<UserProfile> custom({
    Expression<String>? id,
    Expression<String>? primaryBowType,
    Expression<String>? handedness,
    Expression<String>? name,
    Expression<String>? clubName,
    Expression<int>? yearsShootingStart,
    Expression<double>? shootingFrequency,
    Expression<String>? competitionLevels,
    Expression<String>? notes,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (primaryBowType != null) 'primary_bow_type': primaryBowType,
      if (handedness != null) 'handedness': handedness,
      if (name != null) 'name': name,
      if (clubName != null) 'club_name': clubName,
      if (yearsShootingStart != null)
        'years_shooting_start': yearsShootingStart,
      if (shootingFrequency != null) 'shooting_frequency': shootingFrequency,
      if (competitionLevels != null) 'competition_levels': competitionLevels,
      if (notes != null) 'notes': notes,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  UserProfilesCompanion copyWith({
    Value<String>? id,
    Value<String>? primaryBowType,
    Value<String>? handedness,
    Value<String?>? name,
    Value<String?>? clubName,
    Value<int?>? yearsShootingStart,
    Value<double>? shootingFrequency,
    Value<String>? competitionLevels,
    Value<String?>? notes,
    Value<DateTime>? createdAt,
    Value<DateTime>? updatedAt,
    Value<int>? rowid,
  }) {
    return UserProfilesCompanion(
      id: id ?? this.id,
      primaryBowType: primaryBowType ?? this.primaryBowType,
      handedness: handedness ?? this.handedness,
      name: name ?? this.name,
      clubName: clubName ?? this.clubName,
      yearsShootingStart: yearsShootingStart ?? this.yearsShootingStart,
      shootingFrequency: shootingFrequency ?? this.shootingFrequency,
      competitionLevels: competitionLevels ?? this.competitionLevels,
      notes: notes ?? this.notes,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (primaryBowType.present) {
      map['primary_bow_type'] = Variable<String>(primaryBowType.value);
    }
    if (handedness.present) {
      map['handedness'] = Variable<String>(handedness.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (clubName.present) {
      map['club_name'] = Variable<String>(clubName.value);
    }
    if (yearsShootingStart.present) {
      map['years_shooting_start'] = Variable<int>(yearsShootingStart.value);
    }
    if (shootingFrequency.present) {
      map['shooting_frequency'] = Variable<double>(shootingFrequency.value);
    }
    if (competitionLevels.present) {
      map['competition_levels'] = Variable<String>(competitionLevels.value);
    }
    if (notes.present) {
      map['notes'] = Variable<String>(notes.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('UserProfilesCompanion(')
          ..write('id: $id, ')
          ..write('primaryBowType: $primaryBowType, ')
          ..write('handedness: $handedness, ')
          ..write('name: $name, ')
          ..write('clubName: $clubName, ')
          ..write('yearsShootingStart: $yearsShootingStart, ')
          ..write('shootingFrequency: $shootingFrequency, ')
          ..write('competitionLevels: $competitionLevels, ')
          ..write('notes: $notes, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $FederationsTable extends Federations
    with TableInfo<$FederationsTable, Federation> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $FederationsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _profileIdMeta = const VerificationMeta(
    'profileId',
  );
  @override
  late final GeneratedColumn<String> profileId = GeneratedColumn<String>(
    'profile_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES user_profiles (id)',
    ),
  );
  static const VerificationMeta _federationNameMeta = const VerificationMeta(
    'federationName',
  );
  @override
  late final GeneratedColumn<String> federationName = GeneratedColumn<String>(
    'federation_name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _membershipNumberMeta = const VerificationMeta(
    'membershipNumber',
  );
  @override
  late final GeneratedColumn<String> membershipNumber = GeneratedColumn<String>(
    'membership_number',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _cardImagePathMeta = const VerificationMeta(
    'cardImagePath',
  );
  @override
  late final GeneratedColumn<String> cardImagePath = GeneratedColumn<String>(
    'card_image_path',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _expiryDateMeta = const VerificationMeta(
    'expiryDate',
  );
  @override
  late final GeneratedColumn<DateTime> expiryDate = GeneratedColumn<DateTime>(
    'expiry_date',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _isPrimaryMeta = const VerificationMeta(
    'isPrimary',
  );
  @override
  late final GeneratedColumn<bool> isPrimary = GeneratedColumn<bool>(
    'is_primary',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_primary" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    profileId,
    federationName,
    membershipNumber,
    cardImagePath,
    expiryDate,
    isPrimary,
    createdAt,
    updatedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'federations';
  @override
  VerificationContext validateIntegrity(
    Insertable<Federation> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('profile_id')) {
      context.handle(
        _profileIdMeta,
        profileId.isAcceptableOrUnknown(data['profile_id']!, _profileIdMeta),
      );
    } else if (isInserting) {
      context.missing(_profileIdMeta);
    }
    if (data.containsKey('federation_name')) {
      context.handle(
        _federationNameMeta,
        federationName.isAcceptableOrUnknown(
          data['federation_name']!,
          _federationNameMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_federationNameMeta);
    }
    if (data.containsKey('membership_number')) {
      context.handle(
        _membershipNumberMeta,
        membershipNumber.isAcceptableOrUnknown(
          data['membership_number']!,
          _membershipNumberMeta,
        ),
      );
    }
    if (data.containsKey('card_image_path')) {
      context.handle(
        _cardImagePathMeta,
        cardImagePath.isAcceptableOrUnknown(
          data['card_image_path']!,
          _cardImagePathMeta,
        ),
      );
    }
    if (data.containsKey('expiry_date')) {
      context.handle(
        _expiryDateMeta,
        expiryDate.isAcceptableOrUnknown(data['expiry_date']!, _expiryDateMeta),
      );
    }
    if (data.containsKey('is_primary')) {
      context.handle(
        _isPrimaryMeta,
        isPrimary.isAcceptableOrUnknown(data['is_primary']!, _isPrimaryMeta),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  Federation map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Federation(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      profileId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}profile_id'],
      )!,
      federationName: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}federation_name'],
      )!,
      membershipNumber: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}membership_number'],
      ),
      cardImagePath: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}card_image_path'],
      ),
      expiryDate: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}expiry_date'],
      ),
      isPrimary: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_primary'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      )!,
    );
  }

  @override
  $FederationsTable createAlias(String alias) {
    return $FederationsTable(attachedDatabase, alias);
  }
}

class Federation extends DataClass implements Insertable<Federation> {
  final String id;
  final String profileId;
  final String federationName;
  final String? membershipNumber;
  final String? cardImagePath;
  final DateTime? expiryDate;
  final bool isPrimary;
  final DateTime createdAt;
  final DateTime updatedAt;
  const Federation({
    required this.id,
    required this.profileId,
    required this.federationName,
    this.membershipNumber,
    this.cardImagePath,
    this.expiryDate,
    required this.isPrimary,
    required this.createdAt,
    required this.updatedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['profile_id'] = Variable<String>(profileId);
    map['federation_name'] = Variable<String>(federationName);
    if (!nullToAbsent || membershipNumber != null) {
      map['membership_number'] = Variable<String>(membershipNumber);
    }
    if (!nullToAbsent || cardImagePath != null) {
      map['card_image_path'] = Variable<String>(cardImagePath);
    }
    if (!nullToAbsent || expiryDate != null) {
      map['expiry_date'] = Variable<DateTime>(expiryDate);
    }
    map['is_primary'] = Variable<bool>(isPrimary);
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    return map;
  }

  FederationsCompanion toCompanion(bool nullToAbsent) {
    return FederationsCompanion(
      id: Value(id),
      profileId: Value(profileId),
      federationName: Value(federationName),
      membershipNumber: membershipNumber == null && nullToAbsent
          ? const Value.absent()
          : Value(membershipNumber),
      cardImagePath: cardImagePath == null && nullToAbsent
          ? const Value.absent()
          : Value(cardImagePath),
      expiryDate: expiryDate == null && nullToAbsent
          ? const Value.absent()
          : Value(expiryDate),
      isPrimary: Value(isPrimary),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory Federation.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Federation(
      id: serializer.fromJson<String>(json['id']),
      profileId: serializer.fromJson<String>(json['profileId']),
      federationName: serializer.fromJson<String>(json['federationName']),
      membershipNumber: serializer.fromJson<String?>(json['membershipNumber']),
      cardImagePath: serializer.fromJson<String?>(json['cardImagePath']),
      expiryDate: serializer.fromJson<DateTime?>(json['expiryDate']),
      isPrimary: serializer.fromJson<bool>(json['isPrimary']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'profileId': serializer.toJson<String>(profileId),
      'federationName': serializer.toJson<String>(federationName),
      'membershipNumber': serializer.toJson<String?>(membershipNumber),
      'cardImagePath': serializer.toJson<String?>(cardImagePath),
      'expiryDate': serializer.toJson<DateTime?>(expiryDate),
      'isPrimary': serializer.toJson<bool>(isPrimary),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
    };
  }

  Federation copyWith({
    String? id,
    String? profileId,
    String? federationName,
    Value<String?> membershipNumber = const Value.absent(),
    Value<String?> cardImagePath = const Value.absent(),
    Value<DateTime?> expiryDate = const Value.absent(),
    bool? isPrimary,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) => Federation(
    id: id ?? this.id,
    profileId: profileId ?? this.profileId,
    federationName: federationName ?? this.federationName,
    membershipNumber: membershipNumber.present
        ? membershipNumber.value
        : this.membershipNumber,
    cardImagePath: cardImagePath.present
        ? cardImagePath.value
        : this.cardImagePath,
    expiryDate: expiryDate.present ? expiryDate.value : this.expiryDate,
    isPrimary: isPrimary ?? this.isPrimary,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
  );
  Federation copyWithCompanion(FederationsCompanion data) {
    return Federation(
      id: data.id.present ? data.id.value : this.id,
      profileId: data.profileId.present ? data.profileId.value : this.profileId,
      federationName: data.federationName.present
          ? data.federationName.value
          : this.federationName,
      membershipNumber: data.membershipNumber.present
          ? data.membershipNumber.value
          : this.membershipNumber,
      cardImagePath: data.cardImagePath.present
          ? data.cardImagePath.value
          : this.cardImagePath,
      expiryDate: data.expiryDate.present
          ? data.expiryDate.value
          : this.expiryDate,
      isPrimary: data.isPrimary.present ? data.isPrimary.value : this.isPrimary,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Federation(')
          ..write('id: $id, ')
          ..write('profileId: $profileId, ')
          ..write('federationName: $federationName, ')
          ..write('membershipNumber: $membershipNumber, ')
          ..write('cardImagePath: $cardImagePath, ')
          ..write('expiryDate: $expiryDate, ')
          ..write('isPrimary: $isPrimary, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    profileId,
    federationName,
    membershipNumber,
    cardImagePath,
    expiryDate,
    isPrimary,
    createdAt,
    updatedAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Federation &&
          other.id == this.id &&
          other.profileId == this.profileId &&
          other.federationName == this.federationName &&
          other.membershipNumber == this.membershipNumber &&
          other.cardImagePath == this.cardImagePath &&
          other.expiryDate == this.expiryDate &&
          other.isPrimary == this.isPrimary &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class FederationsCompanion extends UpdateCompanion<Federation> {
  final Value<String> id;
  final Value<String> profileId;
  final Value<String> federationName;
  final Value<String?> membershipNumber;
  final Value<String?> cardImagePath;
  final Value<DateTime?> expiryDate;
  final Value<bool> isPrimary;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  final Value<int> rowid;
  const FederationsCompanion({
    this.id = const Value.absent(),
    this.profileId = const Value.absent(),
    this.federationName = const Value.absent(),
    this.membershipNumber = const Value.absent(),
    this.cardImagePath = const Value.absent(),
    this.expiryDate = const Value.absent(),
    this.isPrimary = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  FederationsCompanion.insert({
    required String id,
    required String profileId,
    required String federationName,
    this.membershipNumber = const Value.absent(),
    this.cardImagePath = const Value.absent(),
    this.expiryDate = const Value.absent(),
    this.isPrimary = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       profileId = Value(profileId),
       federationName = Value(federationName);
  static Insertable<Federation> custom({
    Expression<String>? id,
    Expression<String>? profileId,
    Expression<String>? federationName,
    Expression<String>? membershipNumber,
    Expression<String>? cardImagePath,
    Expression<DateTime>? expiryDate,
    Expression<bool>? isPrimary,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (profileId != null) 'profile_id': profileId,
      if (federationName != null) 'federation_name': federationName,
      if (membershipNumber != null) 'membership_number': membershipNumber,
      if (cardImagePath != null) 'card_image_path': cardImagePath,
      if (expiryDate != null) 'expiry_date': expiryDate,
      if (isPrimary != null) 'is_primary': isPrimary,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  FederationsCompanion copyWith({
    Value<String>? id,
    Value<String>? profileId,
    Value<String>? federationName,
    Value<String?>? membershipNumber,
    Value<String?>? cardImagePath,
    Value<DateTime?>? expiryDate,
    Value<bool>? isPrimary,
    Value<DateTime>? createdAt,
    Value<DateTime>? updatedAt,
    Value<int>? rowid,
  }) {
    return FederationsCompanion(
      id: id ?? this.id,
      profileId: profileId ?? this.profileId,
      federationName: federationName ?? this.federationName,
      membershipNumber: membershipNumber ?? this.membershipNumber,
      cardImagePath: cardImagePath ?? this.cardImagePath,
      expiryDate: expiryDate ?? this.expiryDate,
      isPrimary: isPrimary ?? this.isPrimary,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (profileId.present) {
      map['profile_id'] = Variable<String>(profileId.value);
    }
    if (federationName.present) {
      map['federation_name'] = Variable<String>(federationName.value);
    }
    if (membershipNumber.present) {
      map['membership_number'] = Variable<String>(membershipNumber.value);
    }
    if (cardImagePath.present) {
      map['card_image_path'] = Variable<String>(cardImagePath.value);
    }
    if (expiryDate.present) {
      map['expiry_date'] = Variable<DateTime>(expiryDate.value);
    }
    if (isPrimary.present) {
      map['is_primary'] = Variable<bool>(isPrimary.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('FederationsCompanion(')
          ..write('id: $id, ')
          ..write('profileId: $profileId, ')
          ..write('federationName: $federationName, ')
          ..write('membershipNumber: $membershipNumber, ')
          ..write('cardImagePath: $cardImagePath, ')
          ..write('expiryDate: $expiryDate, ')
          ..write('isPrimary: $isPrimary, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

abstract class _$AppDatabase extends GeneratedDatabase {
  _$AppDatabase(QueryExecutor e) : super(e);
  $AppDatabaseManager get managers => $AppDatabaseManager(this);
  late final $RoundTypesTable roundTypes = $RoundTypesTable(this);
  late final $BowsTable bows = $BowsTable(this);
  late final $QuiversTable quivers = $QuiversTable(this);
  late final $SessionsTable sessions = $SessionsTable(this);
  late final $EndsTable ends = $EndsTable(this);
  late final $ShaftsTable shafts = $ShaftsTable(this);
  late final $ArrowsTable arrows = $ArrowsTable(this);
  late final $ImportedScoresTable importedScores = $ImportedScoresTable(this);
  late final $UserPreferencesTable userPreferences = $UserPreferencesTable(
    this,
  );
  late final $FingerTabsTable fingerTabs = $FingerTabsTable(this);
  late final $StabilizersTable stabilizers = $StabilizersTable(this);
  late final $BowStringsTable bowStrings = $BowStringsTable(this);
  late final $VolumeEntriesTable volumeEntries = $VolumeEntriesTable(this);
  late final $OlyExerciseTypesTable olyExerciseTypes = $OlyExerciseTypesTable(
    this,
  );
  late final $OlySessionTemplatesTable olySessionTemplates =
      $OlySessionTemplatesTable(this);
  late final $OlySessionExercisesTable olySessionExercises =
      $OlySessionExercisesTable(this);
  late final $OlyTrainingLogsTable olyTrainingLogs = $OlyTrainingLogsTable(
    this,
  );
  late final $UserTrainingProgressTable userTrainingProgress =
      $UserTrainingProgressTable(this);
  late final $BreathTrainingLogsTable breathTrainingLogs =
      $BreathTrainingLogsTable(this);
  late final $MilestonesTable milestones = $MilestonesTable(this);
  late final $VolumeImportsTable volumeImports = $VolumeImportsTable(this);
  late final $KitSnapshotsTable kitSnapshots = $KitSnapshotsTable(this);
  late final $TuningSessionsTable tuningSessions = $TuningSessionsTable(this);
  late final $SkillLevelsTable skillLevels = $SkillLevelsTable(this);
  late final $XpHistoryTable xpHistory = $XpHistoryTable(this);
  late final $SightMarksTable sightMarks = $SightMarksTable(this);
  late final $SightMarkPreferencesTableTable sightMarkPreferencesTable =
      $SightMarkPreferencesTableTable(this);
  late final $RegisteredTargetsTable registeredTargets =
      $RegisteredTargetsTable(this);
  late final $AutoPlotUsageTable autoPlotUsage = $AutoPlotUsageTable(this);
  late final $UserProfilesTable userProfiles = $UserProfilesTable(this);
  late final $FederationsTable federations = $FederationsTable(this);
  @override
  Iterable<TableInfo<Table, Object?>> get allTables =>
      allSchemaEntities.whereType<TableInfo<Table, Object?>>();
  @override
  List<DatabaseSchemaEntity> get allSchemaEntities => [
    roundTypes,
    bows,
    quivers,
    sessions,
    ends,
    shafts,
    arrows,
    importedScores,
    userPreferences,
    fingerTabs,
    stabilizers,
    bowStrings,
    volumeEntries,
    olyExerciseTypes,
    olySessionTemplates,
    olySessionExercises,
    olyTrainingLogs,
    userTrainingProgress,
    breathTrainingLogs,
    milestones,
    volumeImports,
    kitSnapshots,
    tuningSessions,
    skillLevels,
    xpHistory,
    sightMarks,
    sightMarkPreferencesTable,
    registeredTargets,
    autoPlotUsage,
    userProfiles,
    federations,
  ];
}

typedef $$RoundTypesTableCreateCompanionBuilder =
    RoundTypesCompanion Function({
      required String id,
      required String name,
      required String category,
      required int distance,
      required int faceSize,
      required int arrowsPerEnd,
      required int totalEnds,
      required int maxScore,
      required bool isIndoor,
      Value<int> faceCount,
      Value<String> scoringType,
      Value<int> rowid,
    });
typedef $$RoundTypesTableUpdateCompanionBuilder =
    RoundTypesCompanion Function({
      Value<String> id,
      Value<String> name,
      Value<String> category,
      Value<int> distance,
      Value<int> faceSize,
      Value<int> arrowsPerEnd,
      Value<int> totalEnds,
      Value<int> maxScore,
      Value<bool> isIndoor,
      Value<int> faceCount,
      Value<String> scoringType,
      Value<int> rowid,
    });

final class $$RoundTypesTableReferences
    extends BaseReferences<_$AppDatabase, $RoundTypesTable, RoundType> {
  $$RoundTypesTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static MultiTypedResultKey<$SessionsTable, List<Session>> _sessionsRefsTable(
    _$AppDatabase db,
  ) => MultiTypedResultKey.fromTable(
    db.sessions,
    aliasName: $_aliasNameGenerator(db.roundTypes.id, db.sessions.roundTypeId),
  );

  $$SessionsTableProcessedTableManager get sessionsRefs {
    final manager = $$SessionsTableTableManager(
      $_db,
      $_db.sessions,
    ).filter((f) => f.roundTypeId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_sessionsRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$RoundTypesTableFilterComposer
    extends Composer<_$AppDatabase, $RoundTypesTable> {
  $$RoundTypesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get category => $composableBuilder(
    column: $table.category,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get distance => $composableBuilder(
    column: $table.distance,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get faceSize => $composableBuilder(
    column: $table.faceSize,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get arrowsPerEnd => $composableBuilder(
    column: $table.arrowsPerEnd,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get totalEnds => $composableBuilder(
    column: $table.totalEnds,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get maxScore => $composableBuilder(
    column: $table.maxScore,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isIndoor => $composableBuilder(
    column: $table.isIndoor,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get faceCount => $composableBuilder(
    column: $table.faceCount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get scoringType => $composableBuilder(
    column: $table.scoringType,
    builder: (column) => ColumnFilters(column),
  );

  Expression<bool> sessionsRefs(
    Expression<bool> Function($$SessionsTableFilterComposer f) f,
  ) {
    final $$SessionsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.sessions,
      getReferencedColumn: (t) => t.roundTypeId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SessionsTableFilterComposer(
            $db: $db,
            $table: $db.sessions,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$RoundTypesTableOrderingComposer
    extends Composer<_$AppDatabase, $RoundTypesTable> {
  $$RoundTypesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get category => $composableBuilder(
    column: $table.category,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get distance => $composableBuilder(
    column: $table.distance,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get faceSize => $composableBuilder(
    column: $table.faceSize,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get arrowsPerEnd => $composableBuilder(
    column: $table.arrowsPerEnd,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get totalEnds => $composableBuilder(
    column: $table.totalEnds,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get maxScore => $composableBuilder(
    column: $table.maxScore,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isIndoor => $composableBuilder(
    column: $table.isIndoor,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get faceCount => $composableBuilder(
    column: $table.faceCount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get scoringType => $composableBuilder(
    column: $table.scoringType,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$RoundTypesTableAnnotationComposer
    extends Composer<_$AppDatabase, $RoundTypesTable> {
  $$RoundTypesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get category =>
      $composableBuilder(column: $table.category, builder: (column) => column);

  GeneratedColumn<int> get distance =>
      $composableBuilder(column: $table.distance, builder: (column) => column);

  GeneratedColumn<int> get faceSize =>
      $composableBuilder(column: $table.faceSize, builder: (column) => column);

  GeneratedColumn<int> get arrowsPerEnd => $composableBuilder(
    column: $table.arrowsPerEnd,
    builder: (column) => column,
  );

  GeneratedColumn<int> get totalEnds =>
      $composableBuilder(column: $table.totalEnds, builder: (column) => column);

  GeneratedColumn<int> get maxScore =>
      $composableBuilder(column: $table.maxScore, builder: (column) => column);

  GeneratedColumn<bool> get isIndoor =>
      $composableBuilder(column: $table.isIndoor, builder: (column) => column);

  GeneratedColumn<int> get faceCount =>
      $composableBuilder(column: $table.faceCount, builder: (column) => column);

  GeneratedColumn<String> get scoringType => $composableBuilder(
    column: $table.scoringType,
    builder: (column) => column,
  );

  Expression<T> sessionsRefs<T extends Object>(
    Expression<T> Function($$SessionsTableAnnotationComposer a) f,
  ) {
    final $$SessionsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.sessions,
      getReferencedColumn: (t) => t.roundTypeId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SessionsTableAnnotationComposer(
            $db: $db,
            $table: $db.sessions,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$RoundTypesTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $RoundTypesTable,
          RoundType,
          $$RoundTypesTableFilterComposer,
          $$RoundTypesTableOrderingComposer,
          $$RoundTypesTableAnnotationComposer,
          $$RoundTypesTableCreateCompanionBuilder,
          $$RoundTypesTableUpdateCompanionBuilder,
          (RoundType, $$RoundTypesTableReferences),
          RoundType,
          PrefetchHooks Function({bool sessionsRefs})
        > {
  $$RoundTypesTableTableManager(_$AppDatabase db, $RoundTypesTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$RoundTypesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$RoundTypesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$RoundTypesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<String> category = const Value.absent(),
                Value<int> distance = const Value.absent(),
                Value<int> faceSize = const Value.absent(),
                Value<int> arrowsPerEnd = const Value.absent(),
                Value<int> totalEnds = const Value.absent(),
                Value<int> maxScore = const Value.absent(),
                Value<bool> isIndoor = const Value.absent(),
                Value<int> faceCount = const Value.absent(),
                Value<String> scoringType = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => RoundTypesCompanion(
                id: id,
                name: name,
                category: category,
                distance: distance,
                faceSize: faceSize,
                arrowsPerEnd: arrowsPerEnd,
                totalEnds: totalEnds,
                maxScore: maxScore,
                isIndoor: isIndoor,
                faceCount: faceCount,
                scoringType: scoringType,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String name,
                required String category,
                required int distance,
                required int faceSize,
                required int arrowsPerEnd,
                required int totalEnds,
                required int maxScore,
                required bool isIndoor,
                Value<int> faceCount = const Value.absent(),
                Value<String> scoringType = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => RoundTypesCompanion.insert(
                id: id,
                name: name,
                category: category,
                distance: distance,
                faceSize: faceSize,
                arrowsPerEnd: arrowsPerEnd,
                totalEnds: totalEnds,
                maxScore: maxScore,
                isIndoor: isIndoor,
                faceCount: faceCount,
                scoringType: scoringType,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$RoundTypesTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback: ({sessionsRefs = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [if (sessionsRefs) db.sessions],
              addJoins: null,
              getPrefetchedDataCallback: (items) async {
                return [
                  if (sessionsRefs)
                    await $_getPrefetchedData<
                      RoundType,
                      $RoundTypesTable,
                      Session
                    >(
                      currentTable: table,
                      referencedTable: $$RoundTypesTableReferences
                          ._sessionsRefsTable(db),
                      managerFromTypedResult: (p0) =>
                          $$RoundTypesTableReferences(
                            db,
                            table,
                            p0,
                          ).sessionsRefs,
                      referencedItemsForCurrentItem: (item, referencedItems) =>
                          referencedItems.where(
                            (e) => e.roundTypeId == item.id,
                          ),
                      typedResults: items,
                    ),
                ];
              },
            );
          },
        ),
      );
}

typedef $$RoundTypesTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $RoundTypesTable,
      RoundType,
      $$RoundTypesTableFilterComposer,
      $$RoundTypesTableOrderingComposer,
      $$RoundTypesTableAnnotationComposer,
      $$RoundTypesTableCreateCompanionBuilder,
      $$RoundTypesTableUpdateCompanionBuilder,
      (RoundType, $$RoundTypesTableReferences),
      RoundType,
      PrefetchHooks Function({bool sessionsRefs})
    >;
typedef $$BowsTableCreateCompanionBuilder =
    BowsCompanion Function({
      required String id,
      required String name,
      required String bowType,
      Value<String?> settings,
      Value<bool> isDefault,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<DateTime?> deletedAt,
      Value<String?> riserModel,
      Value<DateTime?> riserPurchaseDate,
      Value<String?> limbModel,
      Value<DateTime?> limbPurchaseDate,
      Value<double?> poundage,
      Value<double?> tillerTop,
      Value<double?> tillerBottom,
      Value<double?> braceHeight,
      Value<double?> nockingPointHeight,
      Value<double?> buttonPosition,
      Value<String?> buttonTension,
      Value<double?> clickerPosition,
      Value<double?> eyeToArrowDistance,
      Value<int> rowid,
    });
typedef $$BowsTableUpdateCompanionBuilder =
    BowsCompanion Function({
      Value<String> id,
      Value<String> name,
      Value<String> bowType,
      Value<String?> settings,
      Value<bool> isDefault,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<DateTime?> deletedAt,
      Value<String?> riserModel,
      Value<DateTime?> riserPurchaseDate,
      Value<String?> limbModel,
      Value<DateTime?> limbPurchaseDate,
      Value<double?> poundage,
      Value<double?> tillerTop,
      Value<double?> tillerBottom,
      Value<double?> braceHeight,
      Value<double?> nockingPointHeight,
      Value<double?> buttonPosition,
      Value<String?> buttonTension,
      Value<double?> clickerPosition,
      Value<double?> eyeToArrowDistance,
      Value<int> rowid,
    });

final class $$BowsTableReferences
    extends BaseReferences<_$AppDatabase, $BowsTable, Bow> {
  $$BowsTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static MultiTypedResultKey<$QuiversTable, List<Quiver>> _quiversRefsTable(
    _$AppDatabase db,
  ) => MultiTypedResultKey.fromTable(
    db.quivers,
    aliasName: $_aliasNameGenerator(db.bows.id, db.quivers.bowId),
  );

  $$QuiversTableProcessedTableManager get quiversRefs {
    final manager = $$QuiversTableTableManager(
      $_db,
      $_db.quivers,
    ).filter((f) => f.bowId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_quiversRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$SessionsTable, List<Session>> _sessionsRefsTable(
    _$AppDatabase db,
  ) => MultiTypedResultKey.fromTable(
    db.sessions,
    aliasName: $_aliasNameGenerator(db.bows.id, db.sessions.bowId),
  );

  $$SessionsTableProcessedTableManager get sessionsRefs {
    final manager = $$SessionsTableTableManager(
      $_db,
      $_db.sessions,
    ).filter((f) => f.bowId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_sessionsRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$StabilizersTable, List<Stabilizer>>
  _stabilizersRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.stabilizers,
    aliasName: $_aliasNameGenerator(db.bows.id, db.stabilizers.bowId),
  );

  $$StabilizersTableProcessedTableManager get stabilizersRefs {
    final manager = $$StabilizersTableTableManager(
      $_db,
      $_db.stabilizers,
    ).filter((f) => f.bowId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_stabilizersRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$BowStringsTable, List<BowString>>
  _bowStringsRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.bowStrings,
    aliasName: $_aliasNameGenerator(db.bows.id, db.bowStrings.bowId),
  );

  $$BowStringsTableProcessedTableManager get bowStringsRefs {
    final manager = $$BowStringsTableTableManager(
      $_db,
      $_db.bowStrings,
    ).filter((f) => f.bowId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_bowStringsRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$TuningSessionsTable, List<TuningSession>>
  _tuningSessionsRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.tuningSessions,
    aliasName: $_aliasNameGenerator(db.bows.id, db.tuningSessions.bowId),
  );

  $$TuningSessionsTableProcessedTableManager get tuningSessionsRefs {
    final manager = $$TuningSessionsTableTableManager(
      $_db,
      $_db.tuningSessions,
    ).filter((f) => f.bowId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_tuningSessionsRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$SightMarksTable, List<SightMark>>
  _sightMarksRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.sightMarks,
    aliasName: $_aliasNameGenerator(db.bows.id, db.sightMarks.bowId),
  );

  $$SightMarksTableProcessedTableManager get sightMarksRefs {
    final manager = $$SightMarksTableTableManager(
      $_db,
      $_db.sightMarks,
    ).filter((f) => f.bowId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_sightMarksRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<
    $SightMarkPreferencesTableTable,
    List<SightMarkPreferencesTableData>
  >
  _sightMarkPreferencesTableRefsTable(_$AppDatabase db) =>
      MultiTypedResultKey.fromTable(
        db.sightMarkPreferencesTable,
        aliasName: $_aliasNameGenerator(
          db.bows.id,
          db.sightMarkPreferencesTable.bowId,
        ),
      );

  $$SightMarkPreferencesTableTableProcessedTableManager
  get sightMarkPreferencesTableRefs {
    final manager = $$SightMarkPreferencesTableTableTableManager(
      $_db,
      $_db.sightMarkPreferencesTable,
    ).filter((f) => f.bowId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(
      _sightMarkPreferencesTableRefsTable($_db),
    );
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$BowsTableFilterComposer extends Composer<_$AppDatabase, $BowsTable> {
  $$BowsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get bowType => $composableBuilder(
    column: $table.bowType,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get settings => $composableBuilder(
    column: $table.settings,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isDefault => $composableBuilder(
    column: $table.isDefault,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get deletedAt => $composableBuilder(
    column: $table.deletedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get riserModel => $composableBuilder(
    column: $table.riserModel,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get riserPurchaseDate => $composableBuilder(
    column: $table.riserPurchaseDate,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get limbModel => $composableBuilder(
    column: $table.limbModel,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get limbPurchaseDate => $composableBuilder(
    column: $table.limbPurchaseDate,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get poundage => $composableBuilder(
    column: $table.poundage,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get tillerTop => $composableBuilder(
    column: $table.tillerTop,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get tillerBottom => $composableBuilder(
    column: $table.tillerBottom,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get braceHeight => $composableBuilder(
    column: $table.braceHeight,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get nockingPointHeight => $composableBuilder(
    column: $table.nockingPointHeight,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get buttonPosition => $composableBuilder(
    column: $table.buttonPosition,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get buttonTension => $composableBuilder(
    column: $table.buttonTension,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get clickerPosition => $composableBuilder(
    column: $table.clickerPosition,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get eyeToArrowDistance => $composableBuilder(
    column: $table.eyeToArrowDistance,
    builder: (column) => ColumnFilters(column),
  );

  Expression<bool> quiversRefs(
    Expression<bool> Function($$QuiversTableFilterComposer f) f,
  ) {
    final $$QuiversTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.quivers,
      getReferencedColumn: (t) => t.bowId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$QuiversTableFilterComposer(
            $db: $db,
            $table: $db.quivers,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> sessionsRefs(
    Expression<bool> Function($$SessionsTableFilterComposer f) f,
  ) {
    final $$SessionsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.sessions,
      getReferencedColumn: (t) => t.bowId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SessionsTableFilterComposer(
            $db: $db,
            $table: $db.sessions,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> stabilizersRefs(
    Expression<bool> Function($$StabilizersTableFilterComposer f) f,
  ) {
    final $$StabilizersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.stabilizers,
      getReferencedColumn: (t) => t.bowId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$StabilizersTableFilterComposer(
            $db: $db,
            $table: $db.stabilizers,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> bowStringsRefs(
    Expression<bool> Function($$BowStringsTableFilterComposer f) f,
  ) {
    final $$BowStringsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.bowStrings,
      getReferencedColumn: (t) => t.bowId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$BowStringsTableFilterComposer(
            $db: $db,
            $table: $db.bowStrings,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> tuningSessionsRefs(
    Expression<bool> Function($$TuningSessionsTableFilterComposer f) f,
  ) {
    final $$TuningSessionsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.tuningSessions,
      getReferencedColumn: (t) => t.bowId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$TuningSessionsTableFilterComposer(
            $db: $db,
            $table: $db.tuningSessions,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> sightMarksRefs(
    Expression<bool> Function($$SightMarksTableFilterComposer f) f,
  ) {
    final $$SightMarksTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.sightMarks,
      getReferencedColumn: (t) => t.bowId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SightMarksTableFilterComposer(
            $db: $db,
            $table: $db.sightMarks,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> sightMarkPreferencesTableRefs(
    Expression<bool> Function($$SightMarkPreferencesTableTableFilterComposer f)
    f,
  ) {
    final $$SightMarkPreferencesTableTableFilterComposer composer =
        $composerBuilder(
          composer: this,
          getCurrentColumn: (t) => t.id,
          referencedTable: $db.sightMarkPreferencesTable,
          getReferencedColumn: (t) => t.bowId,
          builder:
              (
                joinBuilder, {
                $addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer,
              }) => $$SightMarkPreferencesTableTableFilterComposer(
                $db: $db,
                $table: $db.sightMarkPreferencesTable,
                $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                joinBuilder: joinBuilder,
                $removeJoinBuilderFromRootComposer:
                    $removeJoinBuilderFromRootComposer,
              ),
        );
    return f(composer);
  }
}

class $$BowsTableOrderingComposer extends Composer<_$AppDatabase, $BowsTable> {
  $$BowsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get bowType => $composableBuilder(
    column: $table.bowType,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get settings => $composableBuilder(
    column: $table.settings,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isDefault => $composableBuilder(
    column: $table.isDefault,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get deletedAt => $composableBuilder(
    column: $table.deletedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get riserModel => $composableBuilder(
    column: $table.riserModel,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get riserPurchaseDate => $composableBuilder(
    column: $table.riserPurchaseDate,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get limbModel => $composableBuilder(
    column: $table.limbModel,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get limbPurchaseDate => $composableBuilder(
    column: $table.limbPurchaseDate,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get poundage => $composableBuilder(
    column: $table.poundage,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get tillerTop => $composableBuilder(
    column: $table.tillerTop,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get tillerBottom => $composableBuilder(
    column: $table.tillerBottom,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get braceHeight => $composableBuilder(
    column: $table.braceHeight,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get nockingPointHeight => $composableBuilder(
    column: $table.nockingPointHeight,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get buttonPosition => $composableBuilder(
    column: $table.buttonPosition,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get buttonTension => $composableBuilder(
    column: $table.buttonTension,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get clickerPosition => $composableBuilder(
    column: $table.clickerPosition,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get eyeToArrowDistance => $composableBuilder(
    column: $table.eyeToArrowDistance,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$BowsTableAnnotationComposer
    extends Composer<_$AppDatabase, $BowsTable> {
  $$BowsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get bowType =>
      $composableBuilder(column: $table.bowType, builder: (column) => column);

  GeneratedColumn<String> get settings =>
      $composableBuilder(column: $table.settings, builder: (column) => column);

  GeneratedColumn<bool> get isDefault =>
      $composableBuilder(column: $table.isDefault, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  GeneratedColumn<DateTime> get deletedAt =>
      $composableBuilder(column: $table.deletedAt, builder: (column) => column);

  GeneratedColumn<String> get riserModel => $composableBuilder(
    column: $table.riserModel,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get riserPurchaseDate => $composableBuilder(
    column: $table.riserPurchaseDate,
    builder: (column) => column,
  );

  GeneratedColumn<String> get limbModel =>
      $composableBuilder(column: $table.limbModel, builder: (column) => column);

  GeneratedColumn<DateTime> get limbPurchaseDate => $composableBuilder(
    column: $table.limbPurchaseDate,
    builder: (column) => column,
  );

  GeneratedColumn<double> get poundage =>
      $composableBuilder(column: $table.poundage, builder: (column) => column);

  GeneratedColumn<double> get tillerTop =>
      $composableBuilder(column: $table.tillerTop, builder: (column) => column);

  GeneratedColumn<double> get tillerBottom => $composableBuilder(
    column: $table.tillerBottom,
    builder: (column) => column,
  );

  GeneratedColumn<double> get braceHeight => $composableBuilder(
    column: $table.braceHeight,
    builder: (column) => column,
  );

  GeneratedColumn<double> get nockingPointHeight => $composableBuilder(
    column: $table.nockingPointHeight,
    builder: (column) => column,
  );

  GeneratedColumn<double> get buttonPosition => $composableBuilder(
    column: $table.buttonPosition,
    builder: (column) => column,
  );

  GeneratedColumn<String> get buttonTension => $composableBuilder(
    column: $table.buttonTension,
    builder: (column) => column,
  );

  GeneratedColumn<double> get clickerPosition => $composableBuilder(
    column: $table.clickerPosition,
    builder: (column) => column,
  );

  GeneratedColumn<double> get eyeToArrowDistance => $composableBuilder(
    column: $table.eyeToArrowDistance,
    builder: (column) => column,
  );

  Expression<T> quiversRefs<T extends Object>(
    Expression<T> Function($$QuiversTableAnnotationComposer a) f,
  ) {
    final $$QuiversTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.quivers,
      getReferencedColumn: (t) => t.bowId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$QuiversTableAnnotationComposer(
            $db: $db,
            $table: $db.quivers,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> sessionsRefs<T extends Object>(
    Expression<T> Function($$SessionsTableAnnotationComposer a) f,
  ) {
    final $$SessionsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.sessions,
      getReferencedColumn: (t) => t.bowId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SessionsTableAnnotationComposer(
            $db: $db,
            $table: $db.sessions,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> stabilizersRefs<T extends Object>(
    Expression<T> Function($$StabilizersTableAnnotationComposer a) f,
  ) {
    final $$StabilizersTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.stabilizers,
      getReferencedColumn: (t) => t.bowId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$StabilizersTableAnnotationComposer(
            $db: $db,
            $table: $db.stabilizers,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> bowStringsRefs<T extends Object>(
    Expression<T> Function($$BowStringsTableAnnotationComposer a) f,
  ) {
    final $$BowStringsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.bowStrings,
      getReferencedColumn: (t) => t.bowId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$BowStringsTableAnnotationComposer(
            $db: $db,
            $table: $db.bowStrings,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> tuningSessionsRefs<T extends Object>(
    Expression<T> Function($$TuningSessionsTableAnnotationComposer a) f,
  ) {
    final $$TuningSessionsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.tuningSessions,
      getReferencedColumn: (t) => t.bowId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$TuningSessionsTableAnnotationComposer(
            $db: $db,
            $table: $db.tuningSessions,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> sightMarksRefs<T extends Object>(
    Expression<T> Function($$SightMarksTableAnnotationComposer a) f,
  ) {
    final $$SightMarksTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.sightMarks,
      getReferencedColumn: (t) => t.bowId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SightMarksTableAnnotationComposer(
            $db: $db,
            $table: $db.sightMarks,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> sightMarkPreferencesTableRefs<T extends Object>(
    Expression<T> Function($$SightMarkPreferencesTableTableAnnotationComposer a)
    f,
  ) {
    final $$SightMarkPreferencesTableTableAnnotationComposer composer =
        $composerBuilder(
          composer: this,
          getCurrentColumn: (t) => t.id,
          referencedTable: $db.sightMarkPreferencesTable,
          getReferencedColumn: (t) => t.bowId,
          builder:
              (
                joinBuilder, {
                $addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer,
              }) => $$SightMarkPreferencesTableTableAnnotationComposer(
                $db: $db,
                $table: $db.sightMarkPreferencesTable,
                $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                joinBuilder: joinBuilder,
                $removeJoinBuilderFromRootComposer:
                    $removeJoinBuilderFromRootComposer,
              ),
        );
    return f(composer);
  }
}

class $$BowsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $BowsTable,
          Bow,
          $$BowsTableFilterComposer,
          $$BowsTableOrderingComposer,
          $$BowsTableAnnotationComposer,
          $$BowsTableCreateCompanionBuilder,
          $$BowsTableUpdateCompanionBuilder,
          (Bow, $$BowsTableReferences),
          Bow,
          PrefetchHooks Function({
            bool quiversRefs,
            bool sessionsRefs,
            bool stabilizersRefs,
            bool bowStringsRefs,
            bool tuningSessionsRefs,
            bool sightMarksRefs,
            bool sightMarkPreferencesTableRefs,
          })
        > {
  $$BowsTableTableManager(_$AppDatabase db, $BowsTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$BowsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$BowsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$BowsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<String> bowType = const Value.absent(),
                Value<String?> settings = const Value.absent(),
                Value<bool> isDefault = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<DateTime?> deletedAt = const Value.absent(),
                Value<String?> riserModel = const Value.absent(),
                Value<DateTime?> riserPurchaseDate = const Value.absent(),
                Value<String?> limbModel = const Value.absent(),
                Value<DateTime?> limbPurchaseDate = const Value.absent(),
                Value<double?> poundage = const Value.absent(),
                Value<double?> tillerTop = const Value.absent(),
                Value<double?> tillerBottom = const Value.absent(),
                Value<double?> braceHeight = const Value.absent(),
                Value<double?> nockingPointHeight = const Value.absent(),
                Value<double?> buttonPosition = const Value.absent(),
                Value<String?> buttonTension = const Value.absent(),
                Value<double?> clickerPosition = const Value.absent(),
                Value<double?> eyeToArrowDistance = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => BowsCompanion(
                id: id,
                name: name,
                bowType: bowType,
                settings: settings,
                isDefault: isDefault,
                createdAt: createdAt,
                updatedAt: updatedAt,
                deletedAt: deletedAt,
                riserModel: riserModel,
                riserPurchaseDate: riserPurchaseDate,
                limbModel: limbModel,
                limbPurchaseDate: limbPurchaseDate,
                poundage: poundage,
                tillerTop: tillerTop,
                tillerBottom: tillerBottom,
                braceHeight: braceHeight,
                nockingPointHeight: nockingPointHeight,
                buttonPosition: buttonPosition,
                buttonTension: buttonTension,
                clickerPosition: clickerPosition,
                eyeToArrowDistance: eyeToArrowDistance,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String name,
                required String bowType,
                Value<String?> settings = const Value.absent(),
                Value<bool> isDefault = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<DateTime?> deletedAt = const Value.absent(),
                Value<String?> riserModel = const Value.absent(),
                Value<DateTime?> riserPurchaseDate = const Value.absent(),
                Value<String?> limbModel = const Value.absent(),
                Value<DateTime?> limbPurchaseDate = const Value.absent(),
                Value<double?> poundage = const Value.absent(),
                Value<double?> tillerTop = const Value.absent(),
                Value<double?> tillerBottom = const Value.absent(),
                Value<double?> braceHeight = const Value.absent(),
                Value<double?> nockingPointHeight = const Value.absent(),
                Value<double?> buttonPosition = const Value.absent(),
                Value<String?> buttonTension = const Value.absent(),
                Value<double?> clickerPosition = const Value.absent(),
                Value<double?> eyeToArrowDistance = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => BowsCompanion.insert(
                id: id,
                name: name,
                bowType: bowType,
                settings: settings,
                isDefault: isDefault,
                createdAt: createdAt,
                updatedAt: updatedAt,
                deletedAt: deletedAt,
                riserModel: riserModel,
                riserPurchaseDate: riserPurchaseDate,
                limbModel: limbModel,
                limbPurchaseDate: limbPurchaseDate,
                poundage: poundage,
                tillerTop: tillerTop,
                tillerBottom: tillerBottom,
                braceHeight: braceHeight,
                nockingPointHeight: nockingPointHeight,
                buttonPosition: buttonPosition,
                buttonTension: buttonTension,
                clickerPosition: clickerPosition,
                eyeToArrowDistance: eyeToArrowDistance,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) =>
                    (e.readTable(table), $$BowsTableReferences(db, table, e)),
              )
              .toList(),
          prefetchHooksCallback:
              ({
                quiversRefs = false,
                sessionsRefs = false,
                stabilizersRefs = false,
                bowStringsRefs = false,
                tuningSessionsRefs = false,
                sightMarksRefs = false,
                sightMarkPreferencesTableRefs = false,
              }) {
                return PrefetchHooks(
                  db: db,
                  explicitlyWatchedTables: [
                    if (quiversRefs) db.quivers,
                    if (sessionsRefs) db.sessions,
                    if (stabilizersRefs) db.stabilizers,
                    if (bowStringsRefs) db.bowStrings,
                    if (tuningSessionsRefs) db.tuningSessions,
                    if (sightMarksRefs) db.sightMarks,
                    if (sightMarkPreferencesTableRefs)
                      db.sightMarkPreferencesTable,
                  ],
                  addJoins: null,
                  getPrefetchedDataCallback: (items) async {
                    return [
                      if (quiversRefs)
                        await $_getPrefetchedData<Bow, $BowsTable, Quiver>(
                          currentTable: table,
                          referencedTable: $$BowsTableReferences
                              ._quiversRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$BowsTableReferences(db, table, p0).quiversRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.bowId == item.id,
                              ),
                          typedResults: items,
                        ),
                      if (sessionsRefs)
                        await $_getPrefetchedData<Bow, $BowsTable, Session>(
                          currentTable: table,
                          referencedTable: $$BowsTableReferences
                              ._sessionsRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$BowsTableReferences(db, table, p0).sessionsRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.bowId == item.id,
                              ),
                          typedResults: items,
                        ),
                      if (stabilizersRefs)
                        await $_getPrefetchedData<Bow, $BowsTable, Stabilizer>(
                          currentTable: table,
                          referencedTable: $$BowsTableReferences
                              ._stabilizersRefsTable(db),
                          managerFromTypedResult: (p0) => $$BowsTableReferences(
                            db,
                            table,
                            p0,
                          ).stabilizersRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.bowId == item.id,
                              ),
                          typedResults: items,
                        ),
                      if (bowStringsRefs)
                        await $_getPrefetchedData<Bow, $BowsTable, BowString>(
                          currentTable: table,
                          referencedTable: $$BowsTableReferences
                              ._bowStringsRefsTable(db),
                          managerFromTypedResult: (p0) => $$BowsTableReferences(
                            db,
                            table,
                            p0,
                          ).bowStringsRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.bowId == item.id,
                              ),
                          typedResults: items,
                        ),
                      if (tuningSessionsRefs)
                        await $_getPrefetchedData<
                          Bow,
                          $BowsTable,
                          TuningSession
                        >(
                          currentTable: table,
                          referencedTable: $$BowsTableReferences
                              ._tuningSessionsRefsTable(db),
                          managerFromTypedResult: (p0) => $$BowsTableReferences(
                            db,
                            table,
                            p0,
                          ).tuningSessionsRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.bowId == item.id,
                              ),
                          typedResults: items,
                        ),
                      if (sightMarksRefs)
                        await $_getPrefetchedData<Bow, $BowsTable, SightMark>(
                          currentTable: table,
                          referencedTable: $$BowsTableReferences
                              ._sightMarksRefsTable(db),
                          managerFromTypedResult: (p0) => $$BowsTableReferences(
                            db,
                            table,
                            p0,
                          ).sightMarksRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.bowId == item.id,
                              ),
                          typedResults: items,
                        ),
                      if (sightMarkPreferencesTableRefs)
                        await $_getPrefetchedData<
                          Bow,
                          $BowsTable,
                          SightMarkPreferencesTableData
                        >(
                          currentTable: table,
                          referencedTable: $$BowsTableReferences
                              ._sightMarkPreferencesTableRefsTable(db),
                          managerFromTypedResult: (p0) => $$BowsTableReferences(
                            db,
                            table,
                            p0,
                          ).sightMarkPreferencesTableRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.bowId == item.id,
                              ),
                          typedResults: items,
                        ),
                    ];
                  },
                );
              },
        ),
      );
}

typedef $$BowsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $BowsTable,
      Bow,
      $$BowsTableFilterComposer,
      $$BowsTableOrderingComposer,
      $$BowsTableAnnotationComposer,
      $$BowsTableCreateCompanionBuilder,
      $$BowsTableUpdateCompanionBuilder,
      (Bow, $$BowsTableReferences),
      Bow,
      PrefetchHooks Function({
        bool quiversRefs,
        bool sessionsRefs,
        bool stabilizersRefs,
        bool bowStringsRefs,
        bool tuningSessionsRefs,
        bool sightMarksRefs,
        bool sightMarkPreferencesTableRefs,
      })
    >;
typedef $$QuiversTableCreateCompanionBuilder =
    QuiversCompanion Function({
      required String id,
      Value<String?> bowId,
      required String name,
      Value<int> shaftCount,
      Value<String?> settings,
      Value<bool> isDefault,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<DateTime?> deletedAt,
      Value<int> rowid,
    });
typedef $$QuiversTableUpdateCompanionBuilder =
    QuiversCompanion Function({
      Value<String> id,
      Value<String?> bowId,
      Value<String> name,
      Value<int> shaftCount,
      Value<String?> settings,
      Value<bool> isDefault,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<DateTime?> deletedAt,
      Value<int> rowid,
    });

final class $$QuiversTableReferences
    extends BaseReferences<_$AppDatabase, $QuiversTable, Quiver> {
  $$QuiversTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $BowsTable _bowIdTable(_$AppDatabase db) =>
      db.bows.createAlias($_aliasNameGenerator(db.quivers.bowId, db.bows.id));

  $$BowsTableProcessedTableManager? get bowId {
    final $_column = $_itemColumn<String>('bow_id');
    if ($_column == null) return null;
    final manager = $$BowsTableTableManager(
      $_db,
      $_db.bows,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_bowIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static MultiTypedResultKey<$SessionsTable, List<Session>> _sessionsRefsTable(
    _$AppDatabase db,
  ) => MultiTypedResultKey.fromTable(
    db.sessions,
    aliasName: $_aliasNameGenerator(db.quivers.id, db.sessions.quiverId),
  );

  $$SessionsTableProcessedTableManager get sessionsRefs {
    final manager = $$SessionsTableTableManager(
      $_db,
      $_db.sessions,
    ).filter((f) => f.quiverId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_sessionsRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$ShaftsTable, List<Shaft>> _shaftsRefsTable(
    _$AppDatabase db,
  ) => MultiTypedResultKey.fromTable(
    db.shafts,
    aliasName: $_aliasNameGenerator(db.quivers.id, db.shafts.quiverId),
  );

  $$ShaftsTableProcessedTableManager get shaftsRefs {
    final manager = $$ShaftsTableTableManager(
      $_db,
      $_db.shafts,
    ).filter((f) => f.quiverId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_shaftsRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$QuiversTableFilterComposer
    extends Composer<_$AppDatabase, $QuiversTable> {
  $$QuiversTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get shaftCount => $composableBuilder(
    column: $table.shaftCount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get settings => $composableBuilder(
    column: $table.settings,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isDefault => $composableBuilder(
    column: $table.isDefault,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get deletedAt => $composableBuilder(
    column: $table.deletedAt,
    builder: (column) => ColumnFilters(column),
  );

  $$BowsTableFilterComposer get bowId {
    final $$BowsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.bowId,
      referencedTable: $db.bows,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$BowsTableFilterComposer(
            $db: $db,
            $table: $db.bows,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<bool> sessionsRefs(
    Expression<bool> Function($$SessionsTableFilterComposer f) f,
  ) {
    final $$SessionsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.sessions,
      getReferencedColumn: (t) => t.quiverId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SessionsTableFilterComposer(
            $db: $db,
            $table: $db.sessions,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> shaftsRefs(
    Expression<bool> Function($$ShaftsTableFilterComposer f) f,
  ) {
    final $$ShaftsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.shafts,
      getReferencedColumn: (t) => t.quiverId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ShaftsTableFilterComposer(
            $db: $db,
            $table: $db.shafts,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$QuiversTableOrderingComposer
    extends Composer<_$AppDatabase, $QuiversTable> {
  $$QuiversTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get shaftCount => $composableBuilder(
    column: $table.shaftCount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get settings => $composableBuilder(
    column: $table.settings,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isDefault => $composableBuilder(
    column: $table.isDefault,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get deletedAt => $composableBuilder(
    column: $table.deletedAt,
    builder: (column) => ColumnOrderings(column),
  );

  $$BowsTableOrderingComposer get bowId {
    final $$BowsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.bowId,
      referencedTable: $db.bows,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$BowsTableOrderingComposer(
            $db: $db,
            $table: $db.bows,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$QuiversTableAnnotationComposer
    extends Composer<_$AppDatabase, $QuiversTable> {
  $$QuiversTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<int> get shaftCount => $composableBuilder(
    column: $table.shaftCount,
    builder: (column) => column,
  );

  GeneratedColumn<String> get settings =>
      $composableBuilder(column: $table.settings, builder: (column) => column);

  GeneratedColumn<bool> get isDefault =>
      $composableBuilder(column: $table.isDefault, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  GeneratedColumn<DateTime> get deletedAt =>
      $composableBuilder(column: $table.deletedAt, builder: (column) => column);

  $$BowsTableAnnotationComposer get bowId {
    final $$BowsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.bowId,
      referencedTable: $db.bows,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$BowsTableAnnotationComposer(
            $db: $db,
            $table: $db.bows,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<T> sessionsRefs<T extends Object>(
    Expression<T> Function($$SessionsTableAnnotationComposer a) f,
  ) {
    final $$SessionsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.sessions,
      getReferencedColumn: (t) => t.quiverId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SessionsTableAnnotationComposer(
            $db: $db,
            $table: $db.sessions,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> shaftsRefs<T extends Object>(
    Expression<T> Function($$ShaftsTableAnnotationComposer a) f,
  ) {
    final $$ShaftsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.shafts,
      getReferencedColumn: (t) => t.quiverId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ShaftsTableAnnotationComposer(
            $db: $db,
            $table: $db.shafts,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$QuiversTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $QuiversTable,
          Quiver,
          $$QuiversTableFilterComposer,
          $$QuiversTableOrderingComposer,
          $$QuiversTableAnnotationComposer,
          $$QuiversTableCreateCompanionBuilder,
          $$QuiversTableUpdateCompanionBuilder,
          (Quiver, $$QuiversTableReferences),
          Quiver,
          PrefetchHooks Function({
            bool bowId,
            bool sessionsRefs,
            bool shaftsRefs,
          })
        > {
  $$QuiversTableTableManager(_$AppDatabase db, $QuiversTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$QuiversTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$QuiversTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$QuiversTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String?> bowId = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<int> shaftCount = const Value.absent(),
                Value<String?> settings = const Value.absent(),
                Value<bool> isDefault = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<DateTime?> deletedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => QuiversCompanion(
                id: id,
                bowId: bowId,
                name: name,
                shaftCount: shaftCount,
                settings: settings,
                isDefault: isDefault,
                createdAt: createdAt,
                updatedAt: updatedAt,
                deletedAt: deletedAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                Value<String?> bowId = const Value.absent(),
                required String name,
                Value<int> shaftCount = const Value.absent(),
                Value<String?> settings = const Value.absent(),
                Value<bool> isDefault = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<DateTime?> deletedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => QuiversCompanion.insert(
                id: id,
                bowId: bowId,
                name: name,
                shaftCount: shaftCount,
                settings: settings,
                isDefault: isDefault,
                createdAt: createdAt,
                updatedAt: updatedAt,
                deletedAt: deletedAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$QuiversTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback:
              ({bowId = false, sessionsRefs = false, shaftsRefs = false}) {
                return PrefetchHooks(
                  db: db,
                  explicitlyWatchedTables: [
                    if (sessionsRefs) db.sessions,
                    if (shaftsRefs) db.shafts,
                  ],
                  addJoins:
                      <
                        T extends TableManagerState<
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic
                        >
                      >(state) {
                        if (bowId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.bowId,
                                    referencedTable: $$QuiversTableReferences
                                        ._bowIdTable(db),
                                    referencedColumn: $$QuiversTableReferences
                                        ._bowIdTable(db)
                                        .id,
                                  )
                                  as T;
                        }

                        return state;
                      },
                  getPrefetchedDataCallback: (items) async {
                    return [
                      if (sessionsRefs)
                        await $_getPrefetchedData<
                          Quiver,
                          $QuiversTable,
                          Session
                        >(
                          currentTable: table,
                          referencedTable: $$QuiversTableReferences
                              ._sessionsRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$QuiversTableReferences(
                                db,
                                table,
                                p0,
                              ).sessionsRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.quiverId == item.id,
                              ),
                          typedResults: items,
                        ),
                      if (shaftsRefs)
                        await $_getPrefetchedData<Quiver, $QuiversTable, Shaft>(
                          currentTable: table,
                          referencedTable: $$QuiversTableReferences
                              ._shaftsRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$QuiversTableReferences(
                                db,
                                table,
                                p0,
                              ).shaftsRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.quiverId == item.id,
                              ),
                          typedResults: items,
                        ),
                    ];
                  },
                );
              },
        ),
      );
}

typedef $$QuiversTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $QuiversTable,
      Quiver,
      $$QuiversTableFilterComposer,
      $$QuiversTableOrderingComposer,
      $$QuiversTableAnnotationComposer,
      $$QuiversTableCreateCompanionBuilder,
      $$QuiversTableUpdateCompanionBuilder,
      (Quiver, $$QuiversTableReferences),
      Quiver,
      PrefetchHooks Function({bool bowId, bool sessionsRefs, bool shaftsRefs})
    >;
typedef $$SessionsTableCreateCompanionBuilder =
    SessionsCompanion Function({
      required String id,
      required String roundTypeId,
      Value<String> sessionType,
      Value<String?> location,
      Value<String?> notes,
      Value<DateTime> startedAt,
      Value<DateTime?> completedAt,
      Value<int> totalScore,
      Value<int> totalXs,
      Value<String?> bowId,
      Value<String?> quiverId,
      Value<bool> shaftTaggingEnabled,
      Value<DateTime?> deletedAt,
      Value<int> rowid,
    });
typedef $$SessionsTableUpdateCompanionBuilder =
    SessionsCompanion Function({
      Value<String> id,
      Value<String> roundTypeId,
      Value<String> sessionType,
      Value<String?> location,
      Value<String?> notes,
      Value<DateTime> startedAt,
      Value<DateTime?> completedAt,
      Value<int> totalScore,
      Value<int> totalXs,
      Value<String?> bowId,
      Value<String?> quiverId,
      Value<bool> shaftTaggingEnabled,
      Value<DateTime?> deletedAt,
      Value<int> rowid,
    });

final class $$SessionsTableReferences
    extends BaseReferences<_$AppDatabase, $SessionsTable, Session> {
  $$SessionsTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $RoundTypesTable _roundTypeIdTable(_$AppDatabase db) =>
      db.roundTypes.createAlias(
        $_aliasNameGenerator(db.sessions.roundTypeId, db.roundTypes.id),
      );

  $$RoundTypesTableProcessedTableManager get roundTypeId {
    final $_column = $_itemColumn<String>('round_type_id')!;

    final manager = $$RoundTypesTableTableManager(
      $_db,
      $_db.roundTypes,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_roundTypeIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $BowsTable _bowIdTable(_$AppDatabase db) =>
      db.bows.createAlias($_aliasNameGenerator(db.sessions.bowId, db.bows.id));

  $$BowsTableProcessedTableManager? get bowId {
    final $_column = $_itemColumn<String>('bow_id');
    if ($_column == null) return null;
    final manager = $$BowsTableTableManager(
      $_db,
      $_db.bows,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_bowIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $QuiversTable _quiverIdTable(_$AppDatabase db) => db.quivers
      .createAlias($_aliasNameGenerator(db.sessions.quiverId, db.quivers.id));

  $$QuiversTableProcessedTableManager? get quiverId {
    final $_column = $_itemColumn<String>('quiver_id');
    if ($_column == null) return null;
    final manager = $$QuiversTableTableManager(
      $_db,
      $_db.quivers,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_quiverIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static MultiTypedResultKey<$EndsTable, List<End>> _endsRefsTable(
    _$AppDatabase db,
  ) => MultiTypedResultKey.fromTable(
    db.ends,
    aliasName: $_aliasNameGenerator(db.sessions.id, db.ends.sessionId),
  );

  $$EndsTableProcessedTableManager get endsRefs {
    final manager = $$EndsTableTableManager(
      $_db,
      $_db.ends,
    ).filter((f) => f.sessionId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_endsRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$SessionsTableFilterComposer
    extends Composer<_$AppDatabase, $SessionsTable> {
  $$SessionsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get sessionType => $composableBuilder(
    column: $table.sessionType,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get location => $composableBuilder(
    column: $table.location,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get startedAt => $composableBuilder(
    column: $table.startedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get completedAt => $composableBuilder(
    column: $table.completedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get totalScore => $composableBuilder(
    column: $table.totalScore,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get totalXs => $composableBuilder(
    column: $table.totalXs,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get shaftTaggingEnabled => $composableBuilder(
    column: $table.shaftTaggingEnabled,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get deletedAt => $composableBuilder(
    column: $table.deletedAt,
    builder: (column) => ColumnFilters(column),
  );

  $$RoundTypesTableFilterComposer get roundTypeId {
    final $$RoundTypesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.roundTypeId,
      referencedTable: $db.roundTypes,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$RoundTypesTableFilterComposer(
            $db: $db,
            $table: $db.roundTypes,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$BowsTableFilterComposer get bowId {
    final $$BowsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.bowId,
      referencedTable: $db.bows,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$BowsTableFilterComposer(
            $db: $db,
            $table: $db.bows,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$QuiversTableFilterComposer get quiverId {
    final $$QuiversTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.quiverId,
      referencedTable: $db.quivers,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$QuiversTableFilterComposer(
            $db: $db,
            $table: $db.quivers,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<bool> endsRefs(
    Expression<bool> Function($$EndsTableFilterComposer f) f,
  ) {
    final $$EndsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.ends,
      getReferencedColumn: (t) => t.sessionId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$EndsTableFilterComposer(
            $db: $db,
            $table: $db.ends,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$SessionsTableOrderingComposer
    extends Composer<_$AppDatabase, $SessionsTable> {
  $$SessionsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get sessionType => $composableBuilder(
    column: $table.sessionType,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get location => $composableBuilder(
    column: $table.location,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get startedAt => $composableBuilder(
    column: $table.startedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get completedAt => $composableBuilder(
    column: $table.completedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get totalScore => $composableBuilder(
    column: $table.totalScore,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get totalXs => $composableBuilder(
    column: $table.totalXs,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get shaftTaggingEnabled => $composableBuilder(
    column: $table.shaftTaggingEnabled,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get deletedAt => $composableBuilder(
    column: $table.deletedAt,
    builder: (column) => ColumnOrderings(column),
  );

  $$RoundTypesTableOrderingComposer get roundTypeId {
    final $$RoundTypesTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.roundTypeId,
      referencedTable: $db.roundTypes,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$RoundTypesTableOrderingComposer(
            $db: $db,
            $table: $db.roundTypes,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$BowsTableOrderingComposer get bowId {
    final $$BowsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.bowId,
      referencedTable: $db.bows,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$BowsTableOrderingComposer(
            $db: $db,
            $table: $db.bows,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$QuiversTableOrderingComposer get quiverId {
    final $$QuiversTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.quiverId,
      referencedTable: $db.quivers,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$QuiversTableOrderingComposer(
            $db: $db,
            $table: $db.quivers,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$SessionsTableAnnotationComposer
    extends Composer<_$AppDatabase, $SessionsTable> {
  $$SessionsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get sessionType => $composableBuilder(
    column: $table.sessionType,
    builder: (column) => column,
  );

  GeneratedColumn<String> get location =>
      $composableBuilder(column: $table.location, builder: (column) => column);

  GeneratedColumn<String> get notes =>
      $composableBuilder(column: $table.notes, builder: (column) => column);

  GeneratedColumn<DateTime> get startedAt =>
      $composableBuilder(column: $table.startedAt, builder: (column) => column);

  GeneratedColumn<DateTime> get completedAt => $composableBuilder(
    column: $table.completedAt,
    builder: (column) => column,
  );

  GeneratedColumn<int> get totalScore => $composableBuilder(
    column: $table.totalScore,
    builder: (column) => column,
  );

  GeneratedColumn<int> get totalXs =>
      $composableBuilder(column: $table.totalXs, builder: (column) => column);

  GeneratedColumn<bool> get shaftTaggingEnabled => $composableBuilder(
    column: $table.shaftTaggingEnabled,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get deletedAt =>
      $composableBuilder(column: $table.deletedAt, builder: (column) => column);

  $$RoundTypesTableAnnotationComposer get roundTypeId {
    final $$RoundTypesTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.roundTypeId,
      referencedTable: $db.roundTypes,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$RoundTypesTableAnnotationComposer(
            $db: $db,
            $table: $db.roundTypes,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$BowsTableAnnotationComposer get bowId {
    final $$BowsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.bowId,
      referencedTable: $db.bows,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$BowsTableAnnotationComposer(
            $db: $db,
            $table: $db.bows,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$QuiversTableAnnotationComposer get quiverId {
    final $$QuiversTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.quiverId,
      referencedTable: $db.quivers,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$QuiversTableAnnotationComposer(
            $db: $db,
            $table: $db.quivers,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<T> endsRefs<T extends Object>(
    Expression<T> Function($$EndsTableAnnotationComposer a) f,
  ) {
    final $$EndsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.ends,
      getReferencedColumn: (t) => t.sessionId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$EndsTableAnnotationComposer(
            $db: $db,
            $table: $db.ends,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$SessionsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $SessionsTable,
          Session,
          $$SessionsTableFilterComposer,
          $$SessionsTableOrderingComposer,
          $$SessionsTableAnnotationComposer,
          $$SessionsTableCreateCompanionBuilder,
          $$SessionsTableUpdateCompanionBuilder,
          (Session, $$SessionsTableReferences),
          Session,
          PrefetchHooks Function({
            bool roundTypeId,
            bool bowId,
            bool quiverId,
            bool endsRefs,
          })
        > {
  $$SessionsTableTableManager(_$AppDatabase db, $SessionsTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$SessionsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$SessionsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$SessionsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> roundTypeId = const Value.absent(),
                Value<String> sessionType = const Value.absent(),
                Value<String?> location = const Value.absent(),
                Value<String?> notes = const Value.absent(),
                Value<DateTime> startedAt = const Value.absent(),
                Value<DateTime?> completedAt = const Value.absent(),
                Value<int> totalScore = const Value.absent(),
                Value<int> totalXs = const Value.absent(),
                Value<String?> bowId = const Value.absent(),
                Value<String?> quiverId = const Value.absent(),
                Value<bool> shaftTaggingEnabled = const Value.absent(),
                Value<DateTime?> deletedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => SessionsCompanion(
                id: id,
                roundTypeId: roundTypeId,
                sessionType: sessionType,
                location: location,
                notes: notes,
                startedAt: startedAt,
                completedAt: completedAt,
                totalScore: totalScore,
                totalXs: totalXs,
                bowId: bowId,
                quiverId: quiverId,
                shaftTaggingEnabled: shaftTaggingEnabled,
                deletedAt: deletedAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String roundTypeId,
                Value<String> sessionType = const Value.absent(),
                Value<String?> location = const Value.absent(),
                Value<String?> notes = const Value.absent(),
                Value<DateTime> startedAt = const Value.absent(),
                Value<DateTime?> completedAt = const Value.absent(),
                Value<int> totalScore = const Value.absent(),
                Value<int> totalXs = const Value.absent(),
                Value<String?> bowId = const Value.absent(),
                Value<String?> quiverId = const Value.absent(),
                Value<bool> shaftTaggingEnabled = const Value.absent(),
                Value<DateTime?> deletedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => SessionsCompanion.insert(
                id: id,
                roundTypeId: roundTypeId,
                sessionType: sessionType,
                location: location,
                notes: notes,
                startedAt: startedAt,
                completedAt: completedAt,
                totalScore: totalScore,
                totalXs: totalXs,
                bowId: bowId,
                quiverId: quiverId,
                shaftTaggingEnabled: shaftTaggingEnabled,
                deletedAt: deletedAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$SessionsTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback:
              ({
                roundTypeId = false,
                bowId = false,
                quiverId = false,
                endsRefs = false,
              }) {
                return PrefetchHooks(
                  db: db,
                  explicitlyWatchedTables: [if (endsRefs) db.ends],
                  addJoins:
                      <
                        T extends TableManagerState<
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic
                        >
                      >(state) {
                        if (roundTypeId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.roundTypeId,
                                    referencedTable: $$SessionsTableReferences
                                        ._roundTypeIdTable(db),
                                    referencedColumn: $$SessionsTableReferences
                                        ._roundTypeIdTable(db)
                                        .id,
                                  )
                                  as T;
                        }
                        if (bowId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.bowId,
                                    referencedTable: $$SessionsTableReferences
                                        ._bowIdTable(db),
                                    referencedColumn: $$SessionsTableReferences
                                        ._bowIdTable(db)
                                        .id,
                                  )
                                  as T;
                        }
                        if (quiverId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.quiverId,
                                    referencedTable: $$SessionsTableReferences
                                        ._quiverIdTable(db),
                                    referencedColumn: $$SessionsTableReferences
                                        ._quiverIdTable(db)
                                        .id,
                                  )
                                  as T;
                        }

                        return state;
                      },
                  getPrefetchedDataCallback: (items) async {
                    return [
                      if (endsRefs)
                        await $_getPrefetchedData<Session, $SessionsTable, End>(
                          currentTable: table,
                          referencedTable: $$SessionsTableReferences
                              ._endsRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$SessionsTableReferences(db, table, p0).endsRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.sessionId == item.id,
                              ),
                          typedResults: items,
                        ),
                    ];
                  },
                );
              },
        ),
      );
}

typedef $$SessionsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $SessionsTable,
      Session,
      $$SessionsTableFilterComposer,
      $$SessionsTableOrderingComposer,
      $$SessionsTableAnnotationComposer,
      $$SessionsTableCreateCompanionBuilder,
      $$SessionsTableUpdateCompanionBuilder,
      (Session, $$SessionsTableReferences),
      Session,
      PrefetchHooks Function({
        bool roundTypeId,
        bool bowId,
        bool quiverId,
        bool endsRefs,
      })
    >;
typedef $$EndsTableCreateCompanionBuilder =
    EndsCompanion Function({
      required String id,
      required String sessionId,
      required int endNumber,
      Value<int> endScore,
      Value<int> endXs,
      Value<String> status,
      Value<DateTime?> committedAt,
      Value<DateTime> createdAt,
      Value<int> rowid,
    });
typedef $$EndsTableUpdateCompanionBuilder =
    EndsCompanion Function({
      Value<String> id,
      Value<String> sessionId,
      Value<int> endNumber,
      Value<int> endScore,
      Value<int> endXs,
      Value<String> status,
      Value<DateTime?> committedAt,
      Value<DateTime> createdAt,
      Value<int> rowid,
    });

final class $$EndsTableReferences
    extends BaseReferences<_$AppDatabase, $EndsTable, End> {
  $$EndsTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $SessionsTable _sessionIdTable(_$AppDatabase db) => db.sessions
      .createAlias($_aliasNameGenerator(db.ends.sessionId, db.sessions.id));

  $$SessionsTableProcessedTableManager get sessionId {
    final $_column = $_itemColumn<String>('session_id')!;

    final manager = $$SessionsTableTableManager(
      $_db,
      $_db.sessions,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_sessionIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static MultiTypedResultKey<$ArrowsTable, List<Arrow>> _arrowsRefsTable(
    _$AppDatabase db,
  ) => MultiTypedResultKey.fromTable(
    db.arrows,
    aliasName: $_aliasNameGenerator(db.ends.id, db.arrows.endId),
  );

  $$ArrowsTableProcessedTableManager get arrowsRefs {
    final manager = $$ArrowsTableTableManager(
      $_db,
      $_db.arrows,
    ).filter((f) => f.endId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_arrowsRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$EndsTableFilterComposer extends Composer<_$AppDatabase, $EndsTable> {
  $$EndsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get endNumber => $composableBuilder(
    column: $table.endNumber,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get endScore => $composableBuilder(
    column: $table.endScore,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get endXs => $composableBuilder(
    column: $table.endXs,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get status => $composableBuilder(
    column: $table.status,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get committedAt => $composableBuilder(
    column: $table.committedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  $$SessionsTableFilterComposer get sessionId {
    final $$SessionsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.sessionId,
      referencedTable: $db.sessions,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SessionsTableFilterComposer(
            $db: $db,
            $table: $db.sessions,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<bool> arrowsRefs(
    Expression<bool> Function($$ArrowsTableFilterComposer f) f,
  ) {
    final $$ArrowsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.arrows,
      getReferencedColumn: (t) => t.endId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ArrowsTableFilterComposer(
            $db: $db,
            $table: $db.arrows,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$EndsTableOrderingComposer extends Composer<_$AppDatabase, $EndsTable> {
  $$EndsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get endNumber => $composableBuilder(
    column: $table.endNumber,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get endScore => $composableBuilder(
    column: $table.endScore,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get endXs => $composableBuilder(
    column: $table.endXs,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get status => $composableBuilder(
    column: $table.status,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get committedAt => $composableBuilder(
    column: $table.committedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  $$SessionsTableOrderingComposer get sessionId {
    final $$SessionsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.sessionId,
      referencedTable: $db.sessions,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SessionsTableOrderingComposer(
            $db: $db,
            $table: $db.sessions,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$EndsTableAnnotationComposer
    extends Composer<_$AppDatabase, $EndsTable> {
  $$EndsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<int> get endNumber =>
      $composableBuilder(column: $table.endNumber, builder: (column) => column);

  GeneratedColumn<int> get endScore =>
      $composableBuilder(column: $table.endScore, builder: (column) => column);

  GeneratedColumn<int> get endXs =>
      $composableBuilder(column: $table.endXs, builder: (column) => column);

  GeneratedColumn<String> get status =>
      $composableBuilder(column: $table.status, builder: (column) => column);

  GeneratedColumn<DateTime> get committedAt => $composableBuilder(
    column: $table.committedAt,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  $$SessionsTableAnnotationComposer get sessionId {
    final $$SessionsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.sessionId,
      referencedTable: $db.sessions,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SessionsTableAnnotationComposer(
            $db: $db,
            $table: $db.sessions,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<T> arrowsRefs<T extends Object>(
    Expression<T> Function($$ArrowsTableAnnotationComposer a) f,
  ) {
    final $$ArrowsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.arrows,
      getReferencedColumn: (t) => t.endId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ArrowsTableAnnotationComposer(
            $db: $db,
            $table: $db.arrows,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$EndsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $EndsTable,
          End,
          $$EndsTableFilterComposer,
          $$EndsTableOrderingComposer,
          $$EndsTableAnnotationComposer,
          $$EndsTableCreateCompanionBuilder,
          $$EndsTableUpdateCompanionBuilder,
          (End, $$EndsTableReferences),
          End,
          PrefetchHooks Function({bool sessionId, bool arrowsRefs})
        > {
  $$EndsTableTableManager(_$AppDatabase db, $EndsTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$EndsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$EndsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$EndsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> sessionId = const Value.absent(),
                Value<int> endNumber = const Value.absent(),
                Value<int> endScore = const Value.absent(),
                Value<int> endXs = const Value.absent(),
                Value<String> status = const Value.absent(),
                Value<DateTime?> committedAt = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => EndsCompanion(
                id: id,
                sessionId: sessionId,
                endNumber: endNumber,
                endScore: endScore,
                endXs: endXs,
                status: status,
                committedAt: committedAt,
                createdAt: createdAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String sessionId,
                required int endNumber,
                Value<int> endScore = const Value.absent(),
                Value<int> endXs = const Value.absent(),
                Value<String> status = const Value.absent(),
                Value<DateTime?> committedAt = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => EndsCompanion.insert(
                id: id,
                sessionId: sessionId,
                endNumber: endNumber,
                endScore: endScore,
                endXs: endXs,
                status: status,
                committedAt: committedAt,
                createdAt: createdAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) =>
                    (e.readTable(table), $$EndsTableReferences(db, table, e)),
              )
              .toList(),
          prefetchHooksCallback: ({sessionId = false, arrowsRefs = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [if (arrowsRefs) db.arrows],
              addJoins:
                  <
                    T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic
                    >
                  >(state) {
                    if (sessionId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.sessionId,
                                referencedTable: $$EndsTableReferences
                                    ._sessionIdTable(db),
                                referencedColumn: $$EndsTableReferences
                                    ._sessionIdTable(db)
                                    .id,
                              )
                              as T;
                    }

                    return state;
                  },
              getPrefetchedDataCallback: (items) async {
                return [
                  if (arrowsRefs)
                    await $_getPrefetchedData<End, $EndsTable, Arrow>(
                      currentTable: table,
                      referencedTable: $$EndsTableReferences._arrowsRefsTable(
                        db,
                      ),
                      managerFromTypedResult: (p0) =>
                          $$EndsTableReferences(db, table, p0).arrowsRefs,
                      referencedItemsForCurrentItem: (item, referencedItems) =>
                          referencedItems.where((e) => e.endId == item.id),
                      typedResults: items,
                    ),
                ];
              },
            );
          },
        ),
      );
}

typedef $$EndsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $EndsTable,
      End,
      $$EndsTableFilterComposer,
      $$EndsTableOrderingComposer,
      $$EndsTableAnnotationComposer,
      $$EndsTableCreateCompanionBuilder,
      $$EndsTableUpdateCompanionBuilder,
      (End, $$EndsTableReferences),
      End,
      PrefetchHooks Function({bool sessionId, bool arrowsRefs})
    >;
typedef $$ShaftsTableCreateCompanionBuilder =
    ShaftsCompanion Function({
      required String id,
      required String quiverId,
      required int number,
      Value<String?> diameter,
      Value<int?> spine,
      Value<double?> lengthInches,
      Value<int?> pointWeight,
      Value<String?> fletchingType,
      Value<String?> fletchingColor,
      Value<String?> nockColor,
      Value<String?> notes,
      Value<DateTime> createdAt,
      Value<DateTime?> retiredAt,
      Value<double?> totalWeight,
      Value<String?> pointType,
      Value<String?> nockBrand,
      Value<String?> fletchingSize,
      Value<double?> fletchingAngle,
      Value<bool?> hasWrap,
      Value<String?> wrapColor,
      Value<DateTime?> purchaseDate,
      Value<int> rowid,
    });
typedef $$ShaftsTableUpdateCompanionBuilder =
    ShaftsCompanion Function({
      Value<String> id,
      Value<String> quiverId,
      Value<int> number,
      Value<String?> diameter,
      Value<int?> spine,
      Value<double?> lengthInches,
      Value<int?> pointWeight,
      Value<String?> fletchingType,
      Value<String?> fletchingColor,
      Value<String?> nockColor,
      Value<String?> notes,
      Value<DateTime> createdAt,
      Value<DateTime?> retiredAt,
      Value<double?> totalWeight,
      Value<String?> pointType,
      Value<String?> nockBrand,
      Value<String?> fletchingSize,
      Value<double?> fletchingAngle,
      Value<bool?> hasWrap,
      Value<String?> wrapColor,
      Value<DateTime?> purchaseDate,
      Value<int> rowid,
    });

final class $$ShaftsTableReferences
    extends BaseReferences<_$AppDatabase, $ShaftsTable, Shaft> {
  $$ShaftsTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $QuiversTable _quiverIdTable(_$AppDatabase db) => db.quivers
      .createAlias($_aliasNameGenerator(db.shafts.quiverId, db.quivers.id));

  $$QuiversTableProcessedTableManager get quiverId {
    final $_column = $_itemColumn<String>('quiver_id')!;

    final manager = $$QuiversTableTableManager(
      $_db,
      $_db.quivers,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_quiverIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static MultiTypedResultKey<$ArrowsTable, List<Arrow>> _arrowsRefsTable(
    _$AppDatabase db,
  ) => MultiTypedResultKey.fromTable(
    db.arrows,
    aliasName: $_aliasNameGenerator(db.shafts.id, db.arrows.shaftId),
  );

  $$ArrowsTableProcessedTableManager get arrowsRefs {
    final manager = $$ArrowsTableTableManager(
      $_db,
      $_db.arrows,
    ).filter((f) => f.shaftId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_arrowsRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$ShaftsTableFilterComposer
    extends Composer<_$AppDatabase, $ShaftsTable> {
  $$ShaftsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get number => $composableBuilder(
    column: $table.number,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get diameter => $composableBuilder(
    column: $table.diameter,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get spine => $composableBuilder(
    column: $table.spine,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get lengthInches => $composableBuilder(
    column: $table.lengthInches,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get pointWeight => $composableBuilder(
    column: $table.pointWeight,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get fletchingType => $composableBuilder(
    column: $table.fletchingType,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get fletchingColor => $composableBuilder(
    column: $table.fletchingColor,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get nockColor => $composableBuilder(
    column: $table.nockColor,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get retiredAt => $composableBuilder(
    column: $table.retiredAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get totalWeight => $composableBuilder(
    column: $table.totalWeight,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get pointType => $composableBuilder(
    column: $table.pointType,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get nockBrand => $composableBuilder(
    column: $table.nockBrand,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get fletchingSize => $composableBuilder(
    column: $table.fletchingSize,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get fletchingAngle => $composableBuilder(
    column: $table.fletchingAngle,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get hasWrap => $composableBuilder(
    column: $table.hasWrap,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get wrapColor => $composableBuilder(
    column: $table.wrapColor,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get purchaseDate => $composableBuilder(
    column: $table.purchaseDate,
    builder: (column) => ColumnFilters(column),
  );

  $$QuiversTableFilterComposer get quiverId {
    final $$QuiversTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.quiverId,
      referencedTable: $db.quivers,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$QuiversTableFilterComposer(
            $db: $db,
            $table: $db.quivers,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<bool> arrowsRefs(
    Expression<bool> Function($$ArrowsTableFilterComposer f) f,
  ) {
    final $$ArrowsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.arrows,
      getReferencedColumn: (t) => t.shaftId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ArrowsTableFilterComposer(
            $db: $db,
            $table: $db.arrows,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$ShaftsTableOrderingComposer
    extends Composer<_$AppDatabase, $ShaftsTable> {
  $$ShaftsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get number => $composableBuilder(
    column: $table.number,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get diameter => $composableBuilder(
    column: $table.diameter,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get spine => $composableBuilder(
    column: $table.spine,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get lengthInches => $composableBuilder(
    column: $table.lengthInches,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get pointWeight => $composableBuilder(
    column: $table.pointWeight,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get fletchingType => $composableBuilder(
    column: $table.fletchingType,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get fletchingColor => $composableBuilder(
    column: $table.fletchingColor,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get nockColor => $composableBuilder(
    column: $table.nockColor,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get retiredAt => $composableBuilder(
    column: $table.retiredAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get totalWeight => $composableBuilder(
    column: $table.totalWeight,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get pointType => $composableBuilder(
    column: $table.pointType,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get nockBrand => $composableBuilder(
    column: $table.nockBrand,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get fletchingSize => $composableBuilder(
    column: $table.fletchingSize,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get fletchingAngle => $composableBuilder(
    column: $table.fletchingAngle,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get hasWrap => $composableBuilder(
    column: $table.hasWrap,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get wrapColor => $composableBuilder(
    column: $table.wrapColor,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get purchaseDate => $composableBuilder(
    column: $table.purchaseDate,
    builder: (column) => ColumnOrderings(column),
  );

  $$QuiversTableOrderingComposer get quiverId {
    final $$QuiversTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.quiverId,
      referencedTable: $db.quivers,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$QuiversTableOrderingComposer(
            $db: $db,
            $table: $db.quivers,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$ShaftsTableAnnotationComposer
    extends Composer<_$AppDatabase, $ShaftsTable> {
  $$ShaftsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<int> get number =>
      $composableBuilder(column: $table.number, builder: (column) => column);

  GeneratedColumn<String> get diameter =>
      $composableBuilder(column: $table.diameter, builder: (column) => column);

  GeneratedColumn<int> get spine =>
      $composableBuilder(column: $table.spine, builder: (column) => column);

  GeneratedColumn<double> get lengthInches => $composableBuilder(
    column: $table.lengthInches,
    builder: (column) => column,
  );

  GeneratedColumn<int> get pointWeight => $composableBuilder(
    column: $table.pointWeight,
    builder: (column) => column,
  );

  GeneratedColumn<String> get fletchingType => $composableBuilder(
    column: $table.fletchingType,
    builder: (column) => column,
  );

  GeneratedColumn<String> get fletchingColor => $composableBuilder(
    column: $table.fletchingColor,
    builder: (column) => column,
  );

  GeneratedColumn<String> get nockColor =>
      $composableBuilder(column: $table.nockColor, builder: (column) => column);

  GeneratedColumn<String> get notes =>
      $composableBuilder(column: $table.notes, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get retiredAt =>
      $composableBuilder(column: $table.retiredAt, builder: (column) => column);

  GeneratedColumn<double> get totalWeight => $composableBuilder(
    column: $table.totalWeight,
    builder: (column) => column,
  );

  GeneratedColumn<String> get pointType =>
      $composableBuilder(column: $table.pointType, builder: (column) => column);

  GeneratedColumn<String> get nockBrand =>
      $composableBuilder(column: $table.nockBrand, builder: (column) => column);

  GeneratedColumn<String> get fletchingSize => $composableBuilder(
    column: $table.fletchingSize,
    builder: (column) => column,
  );

  GeneratedColumn<double> get fletchingAngle => $composableBuilder(
    column: $table.fletchingAngle,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get hasWrap =>
      $composableBuilder(column: $table.hasWrap, builder: (column) => column);

  GeneratedColumn<String> get wrapColor =>
      $composableBuilder(column: $table.wrapColor, builder: (column) => column);

  GeneratedColumn<DateTime> get purchaseDate => $composableBuilder(
    column: $table.purchaseDate,
    builder: (column) => column,
  );

  $$QuiversTableAnnotationComposer get quiverId {
    final $$QuiversTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.quiverId,
      referencedTable: $db.quivers,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$QuiversTableAnnotationComposer(
            $db: $db,
            $table: $db.quivers,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<T> arrowsRefs<T extends Object>(
    Expression<T> Function($$ArrowsTableAnnotationComposer a) f,
  ) {
    final $$ArrowsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.arrows,
      getReferencedColumn: (t) => t.shaftId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ArrowsTableAnnotationComposer(
            $db: $db,
            $table: $db.arrows,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$ShaftsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $ShaftsTable,
          Shaft,
          $$ShaftsTableFilterComposer,
          $$ShaftsTableOrderingComposer,
          $$ShaftsTableAnnotationComposer,
          $$ShaftsTableCreateCompanionBuilder,
          $$ShaftsTableUpdateCompanionBuilder,
          (Shaft, $$ShaftsTableReferences),
          Shaft,
          PrefetchHooks Function({bool quiverId, bool arrowsRefs})
        > {
  $$ShaftsTableTableManager(_$AppDatabase db, $ShaftsTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$ShaftsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$ShaftsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$ShaftsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> quiverId = const Value.absent(),
                Value<int> number = const Value.absent(),
                Value<String?> diameter = const Value.absent(),
                Value<int?> spine = const Value.absent(),
                Value<double?> lengthInches = const Value.absent(),
                Value<int?> pointWeight = const Value.absent(),
                Value<String?> fletchingType = const Value.absent(),
                Value<String?> fletchingColor = const Value.absent(),
                Value<String?> nockColor = const Value.absent(),
                Value<String?> notes = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime?> retiredAt = const Value.absent(),
                Value<double?> totalWeight = const Value.absent(),
                Value<String?> pointType = const Value.absent(),
                Value<String?> nockBrand = const Value.absent(),
                Value<String?> fletchingSize = const Value.absent(),
                Value<double?> fletchingAngle = const Value.absent(),
                Value<bool?> hasWrap = const Value.absent(),
                Value<String?> wrapColor = const Value.absent(),
                Value<DateTime?> purchaseDate = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => ShaftsCompanion(
                id: id,
                quiverId: quiverId,
                number: number,
                diameter: diameter,
                spine: spine,
                lengthInches: lengthInches,
                pointWeight: pointWeight,
                fletchingType: fletchingType,
                fletchingColor: fletchingColor,
                nockColor: nockColor,
                notes: notes,
                createdAt: createdAt,
                retiredAt: retiredAt,
                totalWeight: totalWeight,
                pointType: pointType,
                nockBrand: nockBrand,
                fletchingSize: fletchingSize,
                fletchingAngle: fletchingAngle,
                hasWrap: hasWrap,
                wrapColor: wrapColor,
                purchaseDate: purchaseDate,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String quiverId,
                required int number,
                Value<String?> diameter = const Value.absent(),
                Value<int?> spine = const Value.absent(),
                Value<double?> lengthInches = const Value.absent(),
                Value<int?> pointWeight = const Value.absent(),
                Value<String?> fletchingType = const Value.absent(),
                Value<String?> fletchingColor = const Value.absent(),
                Value<String?> nockColor = const Value.absent(),
                Value<String?> notes = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime?> retiredAt = const Value.absent(),
                Value<double?> totalWeight = const Value.absent(),
                Value<String?> pointType = const Value.absent(),
                Value<String?> nockBrand = const Value.absent(),
                Value<String?> fletchingSize = const Value.absent(),
                Value<double?> fletchingAngle = const Value.absent(),
                Value<bool?> hasWrap = const Value.absent(),
                Value<String?> wrapColor = const Value.absent(),
                Value<DateTime?> purchaseDate = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => ShaftsCompanion.insert(
                id: id,
                quiverId: quiverId,
                number: number,
                diameter: diameter,
                spine: spine,
                lengthInches: lengthInches,
                pointWeight: pointWeight,
                fletchingType: fletchingType,
                fletchingColor: fletchingColor,
                nockColor: nockColor,
                notes: notes,
                createdAt: createdAt,
                retiredAt: retiredAt,
                totalWeight: totalWeight,
                pointType: pointType,
                nockBrand: nockBrand,
                fletchingSize: fletchingSize,
                fletchingAngle: fletchingAngle,
                hasWrap: hasWrap,
                wrapColor: wrapColor,
                purchaseDate: purchaseDate,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) =>
                    (e.readTable(table), $$ShaftsTableReferences(db, table, e)),
              )
              .toList(),
          prefetchHooksCallback: ({quiverId = false, arrowsRefs = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [if (arrowsRefs) db.arrows],
              addJoins:
                  <
                    T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic
                    >
                  >(state) {
                    if (quiverId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.quiverId,
                                referencedTable: $$ShaftsTableReferences
                                    ._quiverIdTable(db),
                                referencedColumn: $$ShaftsTableReferences
                                    ._quiverIdTable(db)
                                    .id,
                              )
                              as T;
                    }

                    return state;
                  },
              getPrefetchedDataCallback: (items) async {
                return [
                  if (arrowsRefs)
                    await $_getPrefetchedData<Shaft, $ShaftsTable, Arrow>(
                      currentTable: table,
                      referencedTable: $$ShaftsTableReferences._arrowsRefsTable(
                        db,
                      ),
                      managerFromTypedResult: (p0) =>
                          $$ShaftsTableReferences(db, table, p0).arrowsRefs,
                      referencedItemsForCurrentItem: (item, referencedItems) =>
                          referencedItems.where((e) => e.shaftId == item.id),
                      typedResults: items,
                    ),
                ];
              },
            );
          },
        ),
      );
}

typedef $$ShaftsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $ShaftsTable,
      Shaft,
      $$ShaftsTableFilterComposer,
      $$ShaftsTableOrderingComposer,
      $$ShaftsTableAnnotationComposer,
      $$ShaftsTableCreateCompanionBuilder,
      $$ShaftsTableUpdateCompanionBuilder,
      (Shaft, $$ShaftsTableReferences),
      Shaft,
      PrefetchHooks Function({bool quiverId, bool arrowsRefs})
    >;
typedef $$ArrowsTableCreateCompanionBuilder =
    ArrowsCompanion Function({
      required String id,
      required String endId,
      Value<int> faceIndex,
      required double x,
      required double y,
      Value<double> xMm,
      Value<double> yMm,
      required int score,
      Value<bool> isX,
      required int sequence,
      Value<int?> shaftNumber,
      Value<String?> shaftId,
      Value<String?> nockRotation,
      Value<DateTime> createdAt,
      Value<int> rowid,
    });
typedef $$ArrowsTableUpdateCompanionBuilder =
    ArrowsCompanion Function({
      Value<String> id,
      Value<String> endId,
      Value<int> faceIndex,
      Value<double> x,
      Value<double> y,
      Value<double> xMm,
      Value<double> yMm,
      Value<int> score,
      Value<bool> isX,
      Value<int> sequence,
      Value<int?> shaftNumber,
      Value<String?> shaftId,
      Value<String?> nockRotation,
      Value<DateTime> createdAt,
      Value<int> rowid,
    });

final class $$ArrowsTableReferences
    extends BaseReferences<_$AppDatabase, $ArrowsTable, Arrow> {
  $$ArrowsTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $EndsTable _endIdTable(_$AppDatabase db) =>
      db.ends.createAlias($_aliasNameGenerator(db.arrows.endId, db.ends.id));

  $$EndsTableProcessedTableManager get endId {
    final $_column = $_itemColumn<String>('end_id')!;

    final manager = $$EndsTableTableManager(
      $_db,
      $_db.ends,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_endIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $ShaftsTable _shaftIdTable(_$AppDatabase db) => db.shafts.createAlias(
    $_aliasNameGenerator(db.arrows.shaftId, db.shafts.id),
  );

  $$ShaftsTableProcessedTableManager? get shaftId {
    final $_column = $_itemColumn<String>('shaft_id');
    if ($_column == null) return null;
    final manager = $$ShaftsTableTableManager(
      $_db,
      $_db.shafts,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_shaftIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$ArrowsTableFilterComposer
    extends Composer<_$AppDatabase, $ArrowsTable> {
  $$ArrowsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get faceIndex => $composableBuilder(
    column: $table.faceIndex,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get x => $composableBuilder(
    column: $table.x,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get y => $composableBuilder(
    column: $table.y,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get xMm => $composableBuilder(
    column: $table.xMm,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get yMm => $composableBuilder(
    column: $table.yMm,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get score => $composableBuilder(
    column: $table.score,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isX => $composableBuilder(
    column: $table.isX,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get sequence => $composableBuilder(
    column: $table.sequence,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get shaftNumber => $composableBuilder(
    column: $table.shaftNumber,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get nockRotation => $composableBuilder(
    column: $table.nockRotation,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  $$EndsTableFilterComposer get endId {
    final $$EndsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.endId,
      referencedTable: $db.ends,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$EndsTableFilterComposer(
            $db: $db,
            $table: $db.ends,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$ShaftsTableFilterComposer get shaftId {
    final $$ShaftsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.shaftId,
      referencedTable: $db.shafts,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ShaftsTableFilterComposer(
            $db: $db,
            $table: $db.shafts,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$ArrowsTableOrderingComposer
    extends Composer<_$AppDatabase, $ArrowsTable> {
  $$ArrowsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get faceIndex => $composableBuilder(
    column: $table.faceIndex,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get x => $composableBuilder(
    column: $table.x,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get y => $composableBuilder(
    column: $table.y,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get xMm => $composableBuilder(
    column: $table.xMm,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get yMm => $composableBuilder(
    column: $table.yMm,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get score => $composableBuilder(
    column: $table.score,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isX => $composableBuilder(
    column: $table.isX,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get sequence => $composableBuilder(
    column: $table.sequence,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get shaftNumber => $composableBuilder(
    column: $table.shaftNumber,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get nockRotation => $composableBuilder(
    column: $table.nockRotation,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  $$EndsTableOrderingComposer get endId {
    final $$EndsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.endId,
      referencedTable: $db.ends,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$EndsTableOrderingComposer(
            $db: $db,
            $table: $db.ends,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$ShaftsTableOrderingComposer get shaftId {
    final $$ShaftsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.shaftId,
      referencedTable: $db.shafts,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ShaftsTableOrderingComposer(
            $db: $db,
            $table: $db.shafts,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$ArrowsTableAnnotationComposer
    extends Composer<_$AppDatabase, $ArrowsTable> {
  $$ArrowsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<int> get faceIndex =>
      $composableBuilder(column: $table.faceIndex, builder: (column) => column);

  GeneratedColumn<double> get x =>
      $composableBuilder(column: $table.x, builder: (column) => column);

  GeneratedColumn<double> get y =>
      $composableBuilder(column: $table.y, builder: (column) => column);

  GeneratedColumn<double> get xMm =>
      $composableBuilder(column: $table.xMm, builder: (column) => column);

  GeneratedColumn<double> get yMm =>
      $composableBuilder(column: $table.yMm, builder: (column) => column);

  GeneratedColumn<int> get score =>
      $composableBuilder(column: $table.score, builder: (column) => column);

  GeneratedColumn<bool> get isX =>
      $composableBuilder(column: $table.isX, builder: (column) => column);

  GeneratedColumn<int> get sequence =>
      $composableBuilder(column: $table.sequence, builder: (column) => column);

  GeneratedColumn<int> get shaftNumber => $composableBuilder(
    column: $table.shaftNumber,
    builder: (column) => column,
  );

  GeneratedColumn<String> get nockRotation => $composableBuilder(
    column: $table.nockRotation,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  $$EndsTableAnnotationComposer get endId {
    final $$EndsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.endId,
      referencedTable: $db.ends,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$EndsTableAnnotationComposer(
            $db: $db,
            $table: $db.ends,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$ShaftsTableAnnotationComposer get shaftId {
    final $$ShaftsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.shaftId,
      referencedTable: $db.shafts,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ShaftsTableAnnotationComposer(
            $db: $db,
            $table: $db.shafts,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$ArrowsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $ArrowsTable,
          Arrow,
          $$ArrowsTableFilterComposer,
          $$ArrowsTableOrderingComposer,
          $$ArrowsTableAnnotationComposer,
          $$ArrowsTableCreateCompanionBuilder,
          $$ArrowsTableUpdateCompanionBuilder,
          (Arrow, $$ArrowsTableReferences),
          Arrow,
          PrefetchHooks Function({bool endId, bool shaftId})
        > {
  $$ArrowsTableTableManager(_$AppDatabase db, $ArrowsTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$ArrowsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$ArrowsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$ArrowsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> endId = const Value.absent(),
                Value<int> faceIndex = const Value.absent(),
                Value<double> x = const Value.absent(),
                Value<double> y = const Value.absent(),
                Value<double> xMm = const Value.absent(),
                Value<double> yMm = const Value.absent(),
                Value<int> score = const Value.absent(),
                Value<bool> isX = const Value.absent(),
                Value<int> sequence = const Value.absent(),
                Value<int?> shaftNumber = const Value.absent(),
                Value<String?> shaftId = const Value.absent(),
                Value<String?> nockRotation = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => ArrowsCompanion(
                id: id,
                endId: endId,
                faceIndex: faceIndex,
                x: x,
                y: y,
                xMm: xMm,
                yMm: yMm,
                score: score,
                isX: isX,
                sequence: sequence,
                shaftNumber: shaftNumber,
                shaftId: shaftId,
                nockRotation: nockRotation,
                createdAt: createdAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String endId,
                Value<int> faceIndex = const Value.absent(),
                required double x,
                required double y,
                Value<double> xMm = const Value.absent(),
                Value<double> yMm = const Value.absent(),
                required int score,
                Value<bool> isX = const Value.absent(),
                required int sequence,
                Value<int?> shaftNumber = const Value.absent(),
                Value<String?> shaftId = const Value.absent(),
                Value<String?> nockRotation = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => ArrowsCompanion.insert(
                id: id,
                endId: endId,
                faceIndex: faceIndex,
                x: x,
                y: y,
                xMm: xMm,
                yMm: yMm,
                score: score,
                isX: isX,
                sequence: sequence,
                shaftNumber: shaftNumber,
                shaftId: shaftId,
                nockRotation: nockRotation,
                createdAt: createdAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) =>
                    (e.readTable(table), $$ArrowsTableReferences(db, table, e)),
              )
              .toList(),
          prefetchHooksCallback: ({endId = false, shaftId = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins:
                  <
                    T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic
                    >
                  >(state) {
                    if (endId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.endId,
                                referencedTable: $$ArrowsTableReferences
                                    ._endIdTable(db),
                                referencedColumn: $$ArrowsTableReferences
                                    ._endIdTable(db)
                                    .id,
                              )
                              as T;
                    }
                    if (shaftId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.shaftId,
                                referencedTable: $$ArrowsTableReferences
                                    ._shaftIdTable(db),
                                referencedColumn: $$ArrowsTableReferences
                                    ._shaftIdTable(db)
                                    .id,
                              )
                              as T;
                    }

                    return state;
                  },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ),
      );
}

typedef $$ArrowsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $ArrowsTable,
      Arrow,
      $$ArrowsTableFilterComposer,
      $$ArrowsTableOrderingComposer,
      $$ArrowsTableAnnotationComposer,
      $$ArrowsTableCreateCompanionBuilder,
      $$ArrowsTableUpdateCompanionBuilder,
      (Arrow, $$ArrowsTableReferences),
      Arrow,
      PrefetchHooks Function({bool endId, bool shaftId})
    >;
typedef $$ImportedScoresTableCreateCompanionBuilder =
    ImportedScoresCompanion Function({
      required String id,
      required DateTime date,
      required String roundName,
      required int score,
      Value<int?> xCount,
      Value<String?> location,
      Value<String?> notes,
      Value<String> sessionType,
      Value<String> source,
      Value<DateTime> importedAt,
      Value<int> rowid,
    });
typedef $$ImportedScoresTableUpdateCompanionBuilder =
    ImportedScoresCompanion Function({
      Value<String> id,
      Value<DateTime> date,
      Value<String> roundName,
      Value<int> score,
      Value<int?> xCount,
      Value<String?> location,
      Value<String?> notes,
      Value<String> sessionType,
      Value<String> source,
      Value<DateTime> importedAt,
      Value<int> rowid,
    });

class $$ImportedScoresTableFilterComposer
    extends Composer<_$AppDatabase, $ImportedScoresTable> {
  $$ImportedScoresTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get date => $composableBuilder(
    column: $table.date,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get roundName => $composableBuilder(
    column: $table.roundName,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get score => $composableBuilder(
    column: $table.score,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get xCount => $composableBuilder(
    column: $table.xCount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get location => $composableBuilder(
    column: $table.location,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get sessionType => $composableBuilder(
    column: $table.sessionType,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get source => $composableBuilder(
    column: $table.source,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get importedAt => $composableBuilder(
    column: $table.importedAt,
    builder: (column) => ColumnFilters(column),
  );
}

class $$ImportedScoresTableOrderingComposer
    extends Composer<_$AppDatabase, $ImportedScoresTable> {
  $$ImportedScoresTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get date => $composableBuilder(
    column: $table.date,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get roundName => $composableBuilder(
    column: $table.roundName,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get score => $composableBuilder(
    column: $table.score,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get xCount => $composableBuilder(
    column: $table.xCount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get location => $composableBuilder(
    column: $table.location,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get sessionType => $composableBuilder(
    column: $table.sessionType,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get source => $composableBuilder(
    column: $table.source,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get importedAt => $composableBuilder(
    column: $table.importedAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$ImportedScoresTableAnnotationComposer
    extends Composer<_$AppDatabase, $ImportedScoresTable> {
  $$ImportedScoresTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<DateTime> get date =>
      $composableBuilder(column: $table.date, builder: (column) => column);

  GeneratedColumn<String> get roundName =>
      $composableBuilder(column: $table.roundName, builder: (column) => column);

  GeneratedColumn<int> get score =>
      $composableBuilder(column: $table.score, builder: (column) => column);

  GeneratedColumn<int> get xCount =>
      $composableBuilder(column: $table.xCount, builder: (column) => column);

  GeneratedColumn<String> get location =>
      $composableBuilder(column: $table.location, builder: (column) => column);

  GeneratedColumn<String> get notes =>
      $composableBuilder(column: $table.notes, builder: (column) => column);

  GeneratedColumn<String> get sessionType => $composableBuilder(
    column: $table.sessionType,
    builder: (column) => column,
  );

  GeneratedColumn<String> get source =>
      $composableBuilder(column: $table.source, builder: (column) => column);

  GeneratedColumn<DateTime> get importedAt => $composableBuilder(
    column: $table.importedAt,
    builder: (column) => column,
  );
}

class $$ImportedScoresTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $ImportedScoresTable,
          ImportedScore,
          $$ImportedScoresTableFilterComposer,
          $$ImportedScoresTableOrderingComposer,
          $$ImportedScoresTableAnnotationComposer,
          $$ImportedScoresTableCreateCompanionBuilder,
          $$ImportedScoresTableUpdateCompanionBuilder,
          (
            ImportedScore,
            BaseReferences<_$AppDatabase, $ImportedScoresTable, ImportedScore>,
          ),
          ImportedScore,
          PrefetchHooks Function()
        > {
  $$ImportedScoresTableTableManager(
    _$AppDatabase db,
    $ImportedScoresTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$ImportedScoresTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$ImportedScoresTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$ImportedScoresTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<DateTime> date = const Value.absent(),
                Value<String> roundName = const Value.absent(),
                Value<int> score = const Value.absent(),
                Value<int?> xCount = const Value.absent(),
                Value<String?> location = const Value.absent(),
                Value<String?> notes = const Value.absent(),
                Value<String> sessionType = const Value.absent(),
                Value<String> source = const Value.absent(),
                Value<DateTime> importedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => ImportedScoresCompanion(
                id: id,
                date: date,
                roundName: roundName,
                score: score,
                xCount: xCount,
                location: location,
                notes: notes,
                sessionType: sessionType,
                source: source,
                importedAt: importedAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required DateTime date,
                required String roundName,
                required int score,
                Value<int?> xCount = const Value.absent(),
                Value<String?> location = const Value.absent(),
                Value<String?> notes = const Value.absent(),
                Value<String> sessionType = const Value.absent(),
                Value<String> source = const Value.absent(),
                Value<DateTime> importedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => ImportedScoresCompanion.insert(
                id: id,
                date: date,
                roundName: roundName,
                score: score,
                xCount: xCount,
                location: location,
                notes: notes,
                sessionType: sessionType,
                source: source,
                importedAt: importedAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$ImportedScoresTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $ImportedScoresTable,
      ImportedScore,
      $$ImportedScoresTableFilterComposer,
      $$ImportedScoresTableOrderingComposer,
      $$ImportedScoresTableAnnotationComposer,
      $$ImportedScoresTableCreateCompanionBuilder,
      $$ImportedScoresTableUpdateCompanionBuilder,
      (
        ImportedScore,
        BaseReferences<_$AppDatabase, $ImportedScoresTable, ImportedScore>,
      ),
      ImportedScore,
      PrefetchHooks Function()
    >;
typedef $$UserPreferencesTableCreateCompanionBuilder =
    UserPreferencesCompanion Function({
      required String key,
      required String value,
      Value<int> rowid,
    });
typedef $$UserPreferencesTableUpdateCompanionBuilder =
    UserPreferencesCompanion Function({
      Value<String> key,
      Value<String> value,
      Value<int> rowid,
    });

class $$UserPreferencesTableFilterComposer
    extends Composer<_$AppDatabase, $UserPreferencesTable> {
  $$UserPreferencesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get key => $composableBuilder(
    column: $table.key,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get value => $composableBuilder(
    column: $table.value,
    builder: (column) => ColumnFilters(column),
  );
}

class $$UserPreferencesTableOrderingComposer
    extends Composer<_$AppDatabase, $UserPreferencesTable> {
  $$UserPreferencesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get key => $composableBuilder(
    column: $table.key,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get value => $composableBuilder(
    column: $table.value,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$UserPreferencesTableAnnotationComposer
    extends Composer<_$AppDatabase, $UserPreferencesTable> {
  $$UserPreferencesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get key =>
      $composableBuilder(column: $table.key, builder: (column) => column);

  GeneratedColumn<String> get value =>
      $composableBuilder(column: $table.value, builder: (column) => column);
}

class $$UserPreferencesTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $UserPreferencesTable,
          UserPreference,
          $$UserPreferencesTableFilterComposer,
          $$UserPreferencesTableOrderingComposer,
          $$UserPreferencesTableAnnotationComposer,
          $$UserPreferencesTableCreateCompanionBuilder,
          $$UserPreferencesTableUpdateCompanionBuilder,
          (
            UserPreference,
            BaseReferences<
              _$AppDatabase,
              $UserPreferencesTable,
              UserPreference
            >,
          ),
          UserPreference,
          PrefetchHooks Function()
        > {
  $$UserPreferencesTableTableManager(
    _$AppDatabase db,
    $UserPreferencesTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$UserPreferencesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$UserPreferencesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$UserPreferencesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> key = const Value.absent(),
                Value<String> value = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => UserPreferencesCompanion(
                key: key,
                value: value,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String key,
                required String value,
                Value<int> rowid = const Value.absent(),
              }) => UserPreferencesCompanion.insert(
                key: key,
                value: value,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$UserPreferencesTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $UserPreferencesTable,
      UserPreference,
      $$UserPreferencesTableFilterComposer,
      $$UserPreferencesTableOrderingComposer,
      $$UserPreferencesTableAnnotationComposer,
      $$UserPreferencesTableCreateCompanionBuilder,
      $$UserPreferencesTableUpdateCompanionBuilder,
      (
        UserPreference,
        BaseReferences<_$AppDatabase, $UserPreferencesTable, UserPreference>,
      ),
      UserPreference,
      PrefetchHooks Function()
    >;
typedef $$FingerTabsTableCreateCompanionBuilder =
    FingerTabsCompanion Function({
      required String id,
      required String name,
      Value<String?> make,
      Value<String?> model,
      Value<String?> size,
      Value<String?> plateType,
      Value<String?> fingerSpacer,
      Value<String?> notes,
      Value<bool> isDefault,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<DateTime?> deletedAt,
      Value<int> rowid,
    });
typedef $$FingerTabsTableUpdateCompanionBuilder =
    FingerTabsCompanion Function({
      Value<String> id,
      Value<String> name,
      Value<String?> make,
      Value<String?> model,
      Value<String?> size,
      Value<String?> plateType,
      Value<String?> fingerSpacer,
      Value<String?> notes,
      Value<bool> isDefault,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<DateTime?> deletedAt,
      Value<int> rowid,
    });

class $$FingerTabsTableFilterComposer
    extends Composer<_$AppDatabase, $FingerTabsTable> {
  $$FingerTabsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get make => $composableBuilder(
    column: $table.make,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get model => $composableBuilder(
    column: $table.model,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get size => $composableBuilder(
    column: $table.size,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get plateType => $composableBuilder(
    column: $table.plateType,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get fingerSpacer => $composableBuilder(
    column: $table.fingerSpacer,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isDefault => $composableBuilder(
    column: $table.isDefault,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get deletedAt => $composableBuilder(
    column: $table.deletedAt,
    builder: (column) => ColumnFilters(column),
  );
}

class $$FingerTabsTableOrderingComposer
    extends Composer<_$AppDatabase, $FingerTabsTable> {
  $$FingerTabsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get make => $composableBuilder(
    column: $table.make,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get model => $composableBuilder(
    column: $table.model,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get size => $composableBuilder(
    column: $table.size,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get plateType => $composableBuilder(
    column: $table.plateType,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get fingerSpacer => $composableBuilder(
    column: $table.fingerSpacer,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isDefault => $composableBuilder(
    column: $table.isDefault,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get deletedAt => $composableBuilder(
    column: $table.deletedAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$FingerTabsTableAnnotationComposer
    extends Composer<_$AppDatabase, $FingerTabsTable> {
  $$FingerTabsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get make =>
      $composableBuilder(column: $table.make, builder: (column) => column);

  GeneratedColumn<String> get model =>
      $composableBuilder(column: $table.model, builder: (column) => column);

  GeneratedColumn<String> get size =>
      $composableBuilder(column: $table.size, builder: (column) => column);

  GeneratedColumn<String> get plateType =>
      $composableBuilder(column: $table.plateType, builder: (column) => column);

  GeneratedColumn<String> get fingerSpacer => $composableBuilder(
    column: $table.fingerSpacer,
    builder: (column) => column,
  );

  GeneratedColumn<String> get notes =>
      $composableBuilder(column: $table.notes, builder: (column) => column);

  GeneratedColumn<bool> get isDefault =>
      $composableBuilder(column: $table.isDefault, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  GeneratedColumn<DateTime> get deletedAt =>
      $composableBuilder(column: $table.deletedAt, builder: (column) => column);
}

class $$FingerTabsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $FingerTabsTable,
          FingerTab,
          $$FingerTabsTableFilterComposer,
          $$FingerTabsTableOrderingComposer,
          $$FingerTabsTableAnnotationComposer,
          $$FingerTabsTableCreateCompanionBuilder,
          $$FingerTabsTableUpdateCompanionBuilder,
          (
            FingerTab,
            BaseReferences<_$AppDatabase, $FingerTabsTable, FingerTab>,
          ),
          FingerTab,
          PrefetchHooks Function()
        > {
  $$FingerTabsTableTableManager(_$AppDatabase db, $FingerTabsTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$FingerTabsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$FingerTabsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$FingerTabsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<String?> make = const Value.absent(),
                Value<String?> model = const Value.absent(),
                Value<String?> size = const Value.absent(),
                Value<String?> plateType = const Value.absent(),
                Value<String?> fingerSpacer = const Value.absent(),
                Value<String?> notes = const Value.absent(),
                Value<bool> isDefault = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<DateTime?> deletedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => FingerTabsCompanion(
                id: id,
                name: name,
                make: make,
                model: model,
                size: size,
                plateType: plateType,
                fingerSpacer: fingerSpacer,
                notes: notes,
                isDefault: isDefault,
                createdAt: createdAt,
                updatedAt: updatedAt,
                deletedAt: deletedAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String name,
                Value<String?> make = const Value.absent(),
                Value<String?> model = const Value.absent(),
                Value<String?> size = const Value.absent(),
                Value<String?> plateType = const Value.absent(),
                Value<String?> fingerSpacer = const Value.absent(),
                Value<String?> notes = const Value.absent(),
                Value<bool> isDefault = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<DateTime?> deletedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => FingerTabsCompanion.insert(
                id: id,
                name: name,
                make: make,
                model: model,
                size: size,
                plateType: plateType,
                fingerSpacer: fingerSpacer,
                notes: notes,
                isDefault: isDefault,
                createdAt: createdAt,
                updatedAt: updatedAt,
                deletedAt: deletedAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$FingerTabsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $FingerTabsTable,
      FingerTab,
      $$FingerTabsTableFilterComposer,
      $$FingerTabsTableOrderingComposer,
      $$FingerTabsTableAnnotationComposer,
      $$FingerTabsTableCreateCompanionBuilder,
      $$FingerTabsTableUpdateCompanionBuilder,
      (FingerTab, BaseReferences<_$AppDatabase, $FingerTabsTable, FingerTab>),
      FingerTab,
      PrefetchHooks Function()
    >;
typedef $$StabilizersTableCreateCompanionBuilder =
    StabilizersCompanion Function({
      required String id,
      required String bowId,
      Value<String?> name,
      Value<String?> longRodModel,
      Value<double?> longRodLength,
      Value<double?> longRodWeight,
      Value<DateTime?> longRodPurchaseDate,
      Value<String?> sideRodModel,
      Value<double?> sideRodLength,
      Value<double?> sideRodWeight,
      Value<DateTime?> sideRodPurchaseDate,
      Value<double?> extenderLength,
      Value<String?> vbarModel,
      Value<double?> vbarAngleHorizontal,
      Value<double?> vbarAngleVertical,
      Value<String?> weightArrangement,
      Value<String?> damperModel,
      Value<String?> damperPositions,
      Value<String?> notes,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<int> rowid,
    });
typedef $$StabilizersTableUpdateCompanionBuilder =
    StabilizersCompanion Function({
      Value<String> id,
      Value<String> bowId,
      Value<String?> name,
      Value<String?> longRodModel,
      Value<double?> longRodLength,
      Value<double?> longRodWeight,
      Value<DateTime?> longRodPurchaseDate,
      Value<String?> sideRodModel,
      Value<double?> sideRodLength,
      Value<double?> sideRodWeight,
      Value<DateTime?> sideRodPurchaseDate,
      Value<double?> extenderLength,
      Value<String?> vbarModel,
      Value<double?> vbarAngleHorizontal,
      Value<double?> vbarAngleVertical,
      Value<String?> weightArrangement,
      Value<String?> damperModel,
      Value<String?> damperPositions,
      Value<String?> notes,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<int> rowid,
    });

final class $$StabilizersTableReferences
    extends BaseReferences<_$AppDatabase, $StabilizersTable, Stabilizer> {
  $$StabilizersTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $BowsTable _bowIdTable(_$AppDatabase db) => db.bows.createAlias(
    $_aliasNameGenerator(db.stabilizers.bowId, db.bows.id),
  );

  $$BowsTableProcessedTableManager get bowId {
    final $_column = $_itemColumn<String>('bow_id')!;

    final manager = $$BowsTableTableManager(
      $_db,
      $_db.bows,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_bowIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$StabilizersTableFilterComposer
    extends Composer<_$AppDatabase, $StabilizersTable> {
  $$StabilizersTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get longRodModel => $composableBuilder(
    column: $table.longRodModel,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get longRodLength => $composableBuilder(
    column: $table.longRodLength,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get longRodWeight => $composableBuilder(
    column: $table.longRodWeight,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get longRodPurchaseDate => $composableBuilder(
    column: $table.longRodPurchaseDate,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get sideRodModel => $composableBuilder(
    column: $table.sideRodModel,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get sideRodLength => $composableBuilder(
    column: $table.sideRodLength,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get sideRodWeight => $composableBuilder(
    column: $table.sideRodWeight,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get sideRodPurchaseDate => $composableBuilder(
    column: $table.sideRodPurchaseDate,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get extenderLength => $composableBuilder(
    column: $table.extenderLength,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get vbarModel => $composableBuilder(
    column: $table.vbarModel,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get vbarAngleHorizontal => $composableBuilder(
    column: $table.vbarAngleHorizontal,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get vbarAngleVertical => $composableBuilder(
    column: $table.vbarAngleVertical,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get weightArrangement => $composableBuilder(
    column: $table.weightArrangement,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get damperModel => $composableBuilder(
    column: $table.damperModel,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get damperPositions => $composableBuilder(
    column: $table.damperPositions,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );

  $$BowsTableFilterComposer get bowId {
    final $$BowsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.bowId,
      referencedTable: $db.bows,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$BowsTableFilterComposer(
            $db: $db,
            $table: $db.bows,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$StabilizersTableOrderingComposer
    extends Composer<_$AppDatabase, $StabilizersTable> {
  $$StabilizersTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get longRodModel => $composableBuilder(
    column: $table.longRodModel,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get longRodLength => $composableBuilder(
    column: $table.longRodLength,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get longRodWeight => $composableBuilder(
    column: $table.longRodWeight,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get longRodPurchaseDate => $composableBuilder(
    column: $table.longRodPurchaseDate,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get sideRodModel => $composableBuilder(
    column: $table.sideRodModel,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get sideRodLength => $composableBuilder(
    column: $table.sideRodLength,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get sideRodWeight => $composableBuilder(
    column: $table.sideRodWeight,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get sideRodPurchaseDate => $composableBuilder(
    column: $table.sideRodPurchaseDate,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get extenderLength => $composableBuilder(
    column: $table.extenderLength,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get vbarModel => $composableBuilder(
    column: $table.vbarModel,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get vbarAngleHorizontal => $composableBuilder(
    column: $table.vbarAngleHorizontal,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get vbarAngleVertical => $composableBuilder(
    column: $table.vbarAngleVertical,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get weightArrangement => $composableBuilder(
    column: $table.weightArrangement,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get damperModel => $composableBuilder(
    column: $table.damperModel,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get damperPositions => $composableBuilder(
    column: $table.damperPositions,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  $$BowsTableOrderingComposer get bowId {
    final $$BowsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.bowId,
      referencedTable: $db.bows,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$BowsTableOrderingComposer(
            $db: $db,
            $table: $db.bows,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$StabilizersTableAnnotationComposer
    extends Composer<_$AppDatabase, $StabilizersTable> {
  $$StabilizersTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get longRodModel => $composableBuilder(
    column: $table.longRodModel,
    builder: (column) => column,
  );

  GeneratedColumn<double> get longRodLength => $composableBuilder(
    column: $table.longRodLength,
    builder: (column) => column,
  );

  GeneratedColumn<double> get longRodWeight => $composableBuilder(
    column: $table.longRodWeight,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get longRodPurchaseDate => $composableBuilder(
    column: $table.longRodPurchaseDate,
    builder: (column) => column,
  );

  GeneratedColumn<String> get sideRodModel => $composableBuilder(
    column: $table.sideRodModel,
    builder: (column) => column,
  );

  GeneratedColumn<double> get sideRodLength => $composableBuilder(
    column: $table.sideRodLength,
    builder: (column) => column,
  );

  GeneratedColumn<double> get sideRodWeight => $composableBuilder(
    column: $table.sideRodWeight,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get sideRodPurchaseDate => $composableBuilder(
    column: $table.sideRodPurchaseDate,
    builder: (column) => column,
  );

  GeneratedColumn<double> get extenderLength => $composableBuilder(
    column: $table.extenderLength,
    builder: (column) => column,
  );

  GeneratedColumn<String> get vbarModel =>
      $composableBuilder(column: $table.vbarModel, builder: (column) => column);

  GeneratedColumn<double> get vbarAngleHorizontal => $composableBuilder(
    column: $table.vbarAngleHorizontal,
    builder: (column) => column,
  );

  GeneratedColumn<double> get vbarAngleVertical => $composableBuilder(
    column: $table.vbarAngleVertical,
    builder: (column) => column,
  );

  GeneratedColumn<String> get weightArrangement => $composableBuilder(
    column: $table.weightArrangement,
    builder: (column) => column,
  );

  GeneratedColumn<String> get damperModel => $composableBuilder(
    column: $table.damperModel,
    builder: (column) => column,
  );

  GeneratedColumn<String> get damperPositions => $composableBuilder(
    column: $table.damperPositions,
    builder: (column) => column,
  );

  GeneratedColumn<String> get notes =>
      $composableBuilder(column: $table.notes, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  $$BowsTableAnnotationComposer get bowId {
    final $$BowsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.bowId,
      referencedTable: $db.bows,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$BowsTableAnnotationComposer(
            $db: $db,
            $table: $db.bows,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$StabilizersTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $StabilizersTable,
          Stabilizer,
          $$StabilizersTableFilterComposer,
          $$StabilizersTableOrderingComposer,
          $$StabilizersTableAnnotationComposer,
          $$StabilizersTableCreateCompanionBuilder,
          $$StabilizersTableUpdateCompanionBuilder,
          (Stabilizer, $$StabilizersTableReferences),
          Stabilizer,
          PrefetchHooks Function({bool bowId})
        > {
  $$StabilizersTableTableManager(_$AppDatabase db, $StabilizersTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$StabilizersTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$StabilizersTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$StabilizersTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> bowId = const Value.absent(),
                Value<String?> name = const Value.absent(),
                Value<String?> longRodModel = const Value.absent(),
                Value<double?> longRodLength = const Value.absent(),
                Value<double?> longRodWeight = const Value.absent(),
                Value<DateTime?> longRodPurchaseDate = const Value.absent(),
                Value<String?> sideRodModel = const Value.absent(),
                Value<double?> sideRodLength = const Value.absent(),
                Value<double?> sideRodWeight = const Value.absent(),
                Value<DateTime?> sideRodPurchaseDate = const Value.absent(),
                Value<double?> extenderLength = const Value.absent(),
                Value<String?> vbarModel = const Value.absent(),
                Value<double?> vbarAngleHorizontal = const Value.absent(),
                Value<double?> vbarAngleVertical = const Value.absent(),
                Value<String?> weightArrangement = const Value.absent(),
                Value<String?> damperModel = const Value.absent(),
                Value<String?> damperPositions = const Value.absent(),
                Value<String?> notes = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => StabilizersCompanion(
                id: id,
                bowId: bowId,
                name: name,
                longRodModel: longRodModel,
                longRodLength: longRodLength,
                longRodWeight: longRodWeight,
                longRodPurchaseDate: longRodPurchaseDate,
                sideRodModel: sideRodModel,
                sideRodLength: sideRodLength,
                sideRodWeight: sideRodWeight,
                sideRodPurchaseDate: sideRodPurchaseDate,
                extenderLength: extenderLength,
                vbarModel: vbarModel,
                vbarAngleHorizontal: vbarAngleHorizontal,
                vbarAngleVertical: vbarAngleVertical,
                weightArrangement: weightArrangement,
                damperModel: damperModel,
                damperPositions: damperPositions,
                notes: notes,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String bowId,
                Value<String?> name = const Value.absent(),
                Value<String?> longRodModel = const Value.absent(),
                Value<double?> longRodLength = const Value.absent(),
                Value<double?> longRodWeight = const Value.absent(),
                Value<DateTime?> longRodPurchaseDate = const Value.absent(),
                Value<String?> sideRodModel = const Value.absent(),
                Value<double?> sideRodLength = const Value.absent(),
                Value<double?> sideRodWeight = const Value.absent(),
                Value<DateTime?> sideRodPurchaseDate = const Value.absent(),
                Value<double?> extenderLength = const Value.absent(),
                Value<String?> vbarModel = const Value.absent(),
                Value<double?> vbarAngleHorizontal = const Value.absent(),
                Value<double?> vbarAngleVertical = const Value.absent(),
                Value<String?> weightArrangement = const Value.absent(),
                Value<String?> damperModel = const Value.absent(),
                Value<String?> damperPositions = const Value.absent(),
                Value<String?> notes = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => StabilizersCompanion.insert(
                id: id,
                bowId: bowId,
                name: name,
                longRodModel: longRodModel,
                longRodLength: longRodLength,
                longRodWeight: longRodWeight,
                longRodPurchaseDate: longRodPurchaseDate,
                sideRodModel: sideRodModel,
                sideRodLength: sideRodLength,
                sideRodWeight: sideRodWeight,
                sideRodPurchaseDate: sideRodPurchaseDate,
                extenderLength: extenderLength,
                vbarModel: vbarModel,
                vbarAngleHorizontal: vbarAngleHorizontal,
                vbarAngleVertical: vbarAngleVertical,
                weightArrangement: weightArrangement,
                damperModel: damperModel,
                damperPositions: damperPositions,
                notes: notes,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$StabilizersTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback: ({bowId = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins:
                  <
                    T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic
                    >
                  >(state) {
                    if (bowId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.bowId,
                                referencedTable: $$StabilizersTableReferences
                                    ._bowIdTable(db),
                                referencedColumn: $$StabilizersTableReferences
                                    ._bowIdTable(db)
                                    .id,
                              )
                              as T;
                    }

                    return state;
                  },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ),
      );
}

typedef $$StabilizersTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $StabilizersTable,
      Stabilizer,
      $$StabilizersTableFilterComposer,
      $$StabilizersTableOrderingComposer,
      $$StabilizersTableAnnotationComposer,
      $$StabilizersTableCreateCompanionBuilder,
      $$StabilizersTableUpdateCompanionBuilder,
      (Stabilizer, $$StabilizersTableReferences),
      Stabilizer,
      PrefetchHooks Function({bool bowId})
    >;
typedef $$BowStringsTableCreateCompanionBuilder =
    BowStringsCompanion Function({
      required String id,
      required String bowId,
      Value<String?> name,
      Value<String?> material,
      Value<int?> strandCount,
      Value<String?> servingMaterial,
      Value<double?> stringLength,
      Value<String?> color,
      Value<bool> isActive,
      Value<DateTime?> purchaseDate,
      Value<DateTime?> retiredAt,
      Value<String?> notes,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<int> rowid,
    });
typedef $$BowStringsTableUpdateCompanionBuilder =
    BowStringsCompanion Function({
      Value<String> id,
      Value<String> bowId,
      Value<String?> name,
      Value<String?> material,
      Value<int?> strandCount,
      Value<String?> servingMaterial,
      Value<double?> stringLength,
      Value<String?> color,
      Value<bool> isActive,
      Value<DateTime?> purchaseDate,
      Value<DateTime?> retiredAt,
      Value<String?> notes,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<int> rowid,
    });

final class $$BowStringsTableReferences
    extends BaseReferences<_$AppDatabase, $BowStringsTable, BowString> {
  $$BowStringsTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $BowsTable _bowIdTable(_$AppDatabase db) => db.bows.createAlias(
    $_aliasNameGenerator(db.bowStrings.bowId, db.bows.id),
  );

  $$BowsTableProcessedTableManager get bowId {
    final $_column = $_itemColumn<String>('bow_id')!;

    final manager = $$BowsTableTableManager(
      $_db,
      $_db.bows,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_bowIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$BowStringsTableFilterComposer
    extends Composer<_$AppDatabase, $BowStringsTable> {
  $$BowStringsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get material => $composableBuilder(
    column: $table.material,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get strandCount => $composableBuilder(
    column: $table.strandCount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get servingMaterial => $composableBuilder(
    column: $table.servingMaterial,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get stringLength => $composableBuilder(
    column: $table.stringLength,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get color => $composableBuilder(
    column: $table.color,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isActive => $composableBuilder(
    column: $table.isActive,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get purchaseDate => $composableBuilder(
    column: $table.purchaseDate,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get retiredAt => $composableBuilder(
    column: $table.retiredAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );

  $$BowsTableFilterComposer get bowId {
    final $$BowsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.bowId,
      referencedTable: $db.bows,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$BowsTableFilterComposer(
            $db: $db,
            $table: $db.bows,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$BowStringsTableOrderingComposer
    extends Composer<_$AppDatabase, $BowStringsTable> {
  $$BowStringsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get material => $composableBuilder(
    column: $table.material,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get strandCount => $composableBuilder(
    column: $table.strandCount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get servingMaterial => $composableBuilder(
    column: $table.servingMaterial,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get stringLength => $composableBuilder(
    column: $table.stringLength,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get color => $composableBuilder(
    column: $table.color,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isActive => $composableBuilder(
    column: $table.isActive,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get purchaseDate => $composableBuilder(
    column: $table.purchaseDate,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get retiredAt => $composableBuilder(
    column: $table.retiredAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  $$BowsTableOrderingComposer get bowId {
    final $$BowsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.bowId,
      referencedTable: $db.bows,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$BowsTableOrderingComposer(
            $db: $db,
            $table: $db.bows,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$BowStringsTableAnnotationComposer
    extends Composer<_$AppDatabase, $BowStringsTable> {
  $$BowStringsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get material =>
      $composableBuilder(column: $table.material, builder: (column) => column);

  GeneratedColumn<int> get strandCount => $composableBuilder(
    column: $table.strandCount,
    builder: (column) => column,
  );

  GeneratedColumn<String> get servingMaterial => $composableBuilder(
    column: $table.servingMaterial,
    builder: (column) => column,
  );

  GeneratedColumn<double> get stringLength => $composableBuilder(
    column: $table.stringLength,
    builder: (column) => column,
  );

  GeneratedColumn<String> get color =>
      $composableBuilder(column: $table.color, builder: (column) => column);

  GeneratedColumn<bool> get isActive =>
      $composableBuilder(column: $table.isActive, builder: (column) => column);

  GeneratedColumn<DateTime> get purchaseDate => $composableBuilder(
    column: $table.purchaseDate,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get retiredAt =>
      $composableBuilder(column: $table.retiredAt, builder: (column) => column);

  GeneratedColumn<String> get notes =>
      $composableBuilder(column: $table.notes, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  $$BowsTableAnnotationComposer get bowId {
    final $$BowsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.bowId,
      referencedTable: $db.bows,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$BowsTableAnnotationComposer(
            $db: $db,
            $table: $db.bows,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$BowStringsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $BowStringsTable,
          BowString,
          $$BowStringsTableFilterComposer,
          $$BowStringsTableOrderingComposer,
          $$BowStringsTableAnnotationComposer,
          $$BowStringsTableCreateCompanionBuilder,
          $$BowStringsTableUpdateCompanionBuilder,
          (BowString, $$BowStringsTableReferences),
          BowString,
          PrefetchHooks Function({bool bowId})
        > {
  $$BowStringsTableTableManager(_$AppDatabase db, $BowStringsTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$BowStringsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$BowStringsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$BowStringsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> bowId = const Value.absent(),
                Value<String?> name = const Value.absent(),
                Value<String?> material = const Value.absent(),
                Value<int?> strandCount = const Value.absent(),
                Value<String?> servingMaterial = const Value.absent(),
                Value<double?> stringLength = const Value.absent(),
                Value<String?> color = const Value.absent(),
                Value<bool> isActive = const Value.absent(),
                Value<DateTime?> purchaseDate = const Value.absent(),
                Value<DateTime?> retiredAt = const Value.absent(),
                Value<String?> notes = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => BowStringsCompanion(
                id: id,
                bowId: bowId,
                name: name,
                material: material,
                strandCount: strandCount,
                servingMaterial: servingMaterial,
                stringLength: stringLength,
                color: color,
                isActive: isActive,
                purchaseDate: purchaseDate,
                retiredAt: retiredAt,
                notes: notes,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String bowId,
                Value<String?> name = const Value.absent(),
                Value<String?> material = const Value.absent(),
                Value<int?> strandCount = const Value.absent(),
                Value<String?> servingMaterial = const Value.absent(),
                Value<double?> stringLength = const Value.absent(),
                Value<String?> color = const Value.absent(),
                Value<bool> isActive = const Value.absent(),
                Value<DateTime?> purchaseDate = const Value.absent(),
                Value<DateTime?> retiredAt = const Value.absent(),
                Value<String?> notes = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => BowStringsCompanion.insert(
                id: id,
                bowId: bowId,
                name: name,
                material: material,
                strandCount: strandCount,
                servingMaterial: servingMaterial,
                stringLength: stringLength,
                color: color,
                isActive: isActive,
                purchaseDate: purchaseDate,
                retiredAt: retiredAt,
                notes: notes,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$BowStringsTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback: ({bowId = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins:
                  <
                    T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic
                    >
                  >(state) {
                    if (bowId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.bowId,
                                referencedTable: $$BowStringsTableReferences
                                    ._bowIdTable(db),
                                referencedColumn: $$BowStringsTableReferences
                                    ._bowIdTable(db)
                                    .id,
                              )
                              as T;
                    }

                    return state;
                  },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ),
      );
}

typedef $$BowStringsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $BowStringsTable,
      BowString,
      $$BowStringsTableFilterComposer,
      $$BowStringsTableOrderingComposer,
      $$BowStringsTableAnnotationComposer,
      $$BowStringsTableCreateCompanionBuilder,
      $$BowStringsTableUpdateCompanionBuilder,
      (BowString, $$BowStringsTableReferences),
      BowString,
      PrefetchHooks Function({bool bowId})
    >;
typedef $$VolumeEntriesTableCreateCompanionBuilder =
    VolumeEntriesCompanion Function({
      required String id,
      required DateTime date,
      required int arrowCount,
      Value<String?> title,
      Value<String?> notes,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<int> rowid,
    });
typedef $$VolumeEntriesTableUpdateCompanionBuilder =
    VolumeEntriesCompanion Function({
      Value<String> id,
      Value<DateTime> date,
      Value<int> arrowCount,
      Value<String?> title,
      Value<String?> notes,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<int> rowid,
    });

class $$VolumeEntriesTableFilterComposer
    extends Composer<_$AppDatabase, $VolumeEntriesTable> {
  $$VolumeEntriesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get date => $composableBuilder(
    column: $table.date,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get arrowCount => $composableBuilder(
    column: $table.arrowCount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get title => $composableBuilder(
    column: $table.title,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );
}

class $$VolumeEntriesTableOrderingComposer
    extends Composer<_$AppDatabase, $VolumeEntriesTable> {
  $$VolumeEntriesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get date => $composableBuilder(
    column: $table.date,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get arrowCount => $composableBuilder(
    column: $table.arrowCount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get title => $composableBuilder(
    column: $table.title,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$VolumeEntriesTableAnnotationComposer
    extends Composer<_$AppDatabase, $VolumeEntriesTable> {
  $$VolumeEntriesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<DateTime> get date =>
      $composableBuilder(column: $table.date, builder: (column) => column);

  GeneratedColumn<int> get arrowCount => $composableBuilder(
    column: $table.arrowCount,
    builder: (column) => column,
  );

  GeneratedColumn<String> get title =>
      $composableBuilder(column: $table.title, builder: (column) => column);

  GeneratedColumn<String> get notes =>
      $composableBuilder(column: $table.notes, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);
}

class $$VolumeEntriesTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $VolumeEntriesTable,
          VolumeEntry,
          $$VolumeEntriesTableFilterComposer,
          $$VolumeEntriesTableOrderingComposer,
          $$VolumeEntriesTableAnnotationComposer,
          $$VolumeEntriesTableCreateCompanionBuilder,
          $$VolumeEntriesTableUpdateCompanionBuilder,
          (
            VolumeEntry,
            BaseReferences<_$AppDatabase, $VolumeEntriesTable, VolumeEntry>,
          ),
          VolumeEntry,
          PrefetchHooks Function()
        > {
  $$VolumeEntriesTableTableManager(_$AppDatabase db, $VolumeEntriesTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$VolumeEntriesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$VolumeEntriesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$VolumeEntriesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<DateTime> date = const Value.absent(),
                Value<int> arrowCount = const Value.absent(),
                Value<String?> title = const Value.absent(),
                Value<String?> notes = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => VolumeEntriesCompanion(
                id: id,
                date: date,
                arrowCount: arrowCount,
                title: title,
                notes: notes,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required DateTime date,
                required int arrowCount,
                Value<String?> title = const Value.absent(),
                Value<String?> notes = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => VolumeEntriesCompanion.insert(
                id: id,
                date: date,
                arrowCount: arrowCount,
                title: title,
                notes: notes,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$VolumeEntriesTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $VolumeEntriesTable,
      VolumeEntry,
      $$VolumeEntriesTableFilterComposer,
      $$VolumeEntriesTableOrderingComposer,
      $$VolumeEntriesTableAnnotationComposer,
      $$VolumeEntriesTableCreateCompanionBuilder,
      $$VolumeEntriesTableUpdateCompanionBuilder,
      (
        VolumeEntry,
        BaseReferences<_$AppDatabase, $VolumeEntriesTable, VolumeEntry>,
      ),
      VolumeEntry,
      PrefetchHooks Function()
    >;
typedef $$OlyExerciseTypesTableCreateCompanionBuilder =
    OlyExerciseTypesCompanion Function({
      required String id,
      required String name,
      Value<String?> description,
      Value<double> intensity,
      Value<String> category,
      Value<String?> firstIntroducedAt,
      Value<int> sortOrder,
      Value<int> rowid,
    });
typedef $$OlyExerciseTypesTableUpdateCompanionBuilder =
    OlyExerciseTypesCompanion Function({
      Value<String> id,
      Value<String> name,
      Value<String?> description,
      Value<double> intensity,
      Value<String> category,
      Value<String?> firstIntroducedAt,
      Value<int> sortOrder,
      Value<int> rowid,
    });

final class $$OlyExerciseTypesTableReferences
    extends
        BaseReferences<_$AppDatabase, $OlyExerciseTypesTable, OlyExerciseType> {
  $$OlyExerciseTypesTableReferences(
    super.$_db,
    super.$_table,
    super.$_typedResult,
  );

  static MultiTypedResultKey<
    $OlySessionExercisesTable,
    List<OlySessionExercise>
  >
  _olySessionExercisesRefsTable(_$AppDatabase db) =>
      MultiTypedResultKey.fromTable(
        db.olySessionExercises,
        aliasName: $_aliasNameGenerator(
          db.olyExerciseTypes.id,
          db.olySessionExercises.exerciseTypeId,
        ),
      );

  $$OlySessionExercisesTableProcessedTableManager get olySessionExercisesRefs {
    final manager = $$OlySessionExercisesTableTableManager(
      $_db,
      $_db.olySessionExercises,
    ).filter((f) => f.exerciseTypeId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(
      _olySessionExercisesRefsTable($_db),
    );
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$OlyExerciseTypesTableFilterComposer
    extends Composer<_$AppDatabase, $OlyExerciseTypesTable> {
  $$OlyExerciseTypesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get description => $composableBuilder(
    column: $table.description,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get intensity => $composableBuilder(
    column: $table.intensity,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get category => $composableBuilder(
    column: $table.category,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get firstIntroducedAt => $composableBuilder(
    column: $table.firstIntroducedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get sortOrder => $composableBuilder(
    column: $table.sortOrder,
    builder: (column) => ColumnFilters(column),
  );

  Expression<bool> olySessionExercisesRefs(
    Expression<bool> Function($$OlySessionExercisesTableFilterComposer f) f,
  ) {
    final $$OlySessionExercisesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.olySessionExercises,
      getReferencedColumn: (t) => t.exerciseTypeId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$OlySessionExercisesTableFilterComposer(
            $db: $db,
            $table: $db.olySessionExercises,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$OlyExerciseTypesTableOrderingComposer
    extends Composer<_$AppDatabase, $OlyExerciseTypesTable> {
  $$OlyExerciseTypesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get description => $composableBuilder(
    column: $table.description,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get intensity => $composableBuilder(
    column: $table.intensity,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get category => $composableBuilder(
    column: $table.category,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get firstIntroducedAt => $composableBuilder(
    column: $table.firstIntroducedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get sortOrder => $composableBuilder(
    column: $table.sortOrder,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$OlyExerciseTypesTableAnnotationComposer
    extends Composer<_$AppDatabase, $OlyExerciseTypesTable> {
  $$OlyExerciseTypesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get description => $composableBuilder(
    column: $table.description,
    builder: (column) => column,
  );

  GeneratedColumn<double> get intensity =>
      $composableBuilder(column: $table.intensity, builder: (column) => column);

  GeneratedColumn<String> get category =>
      $composableBuilder(column: $table.category, builder: (column) => column);

  GeneratedColumn<String> get firstIntroducedAt => $composableBuilder(
    column: $table.firstIntroducedAt,
    builder: (column) => column,
  );

  GeneratedColumn<int> get sortOrder =>
      $composableBuilder(column: $table.sortOrder, builder: (column) => column);

  Expression<T> olySessionExercisesRefs<T extends Object>(
    Expression<T> Function($$OlySessionExercisesTableAnnotationComposer a) f,
  ) {
    final $$OlySessionExercisesTableAnnotationComposer composer =
        $composerBuilder(
          composer: this,
          getCurrentColumn: (t) => t.id,
          referencedTable: $db.olySessionExercises,
          getReferencedColumn: (t) => t.exerciseTypeId,
          builder:
              (
                joinBuilder, {
                $addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer,
              }) => $$OlySessionExercisesTableAnnotationComposer(
                $db: $db,
                $table: $db.olySessionExercises,
                $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                joinBuilder: joinBuilder,
                $removeJoinBuilderFromRootComposer:
                    $removeJoinBuilderFromRootComposer,
              ),
        );
    return f(composer);
  }
}

class $$OlyExerciseTypesTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $OlyExerciseTypesTable,
          OlyExerciseType,
          $$OlyExerciseTypesTableFilterComposer,
          $$OlyExerciseTypesTableOrderingComposer,
          $$OlyExerciseTypesTableAnnotationComposer,
          $$OlyExerciseTypesTableCreateCompanionBuilder,
          $$OlyExerciseTypesTableUpdateCompanionBuilder,
          (OlyExerciseType, $$OlyExerciseTypesTableReferences),
          OlyExerciseType,
          PrefetchHooks Function({bool olySessionExercisesRefs})
        > {
  $$OlyExerciseTypesTableTableManager(
    _$AppDatabase db,
    $OlyExerciseTypesTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$OlyExerciseTypesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$OlyExerciseTypesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$OlyExerciseTypesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<String?> description = const Value.absent(),
                Value<double> intensity = const Value.absent(),
                Value<String> category = const Value.absent(),
                Value<String?> firstIntroducedAt = const Value.absent(),
                Value<int> sortOrder = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => OlyExerciseTypesCompanion(
                id: id,
                name: name,
                description: description,
                intensity: intensity,
                category: category,
                firstIntroducedAt: firstIntroducedAt,
                sortOrder: sortOrder,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String name,
                Value<String?> description = const Value.absent(),
                Value<double> intensity = const Value.absent(),
                Value<String> category = const Value.absent(),
                Value<String?> firstIntroducedAt = const Value.absent(),
                Value<int> sortOrder = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => OlyExerciseTypesCompanion.insert(
                id: id,
                name: name,
                description: description,
                intensity: intensity,
                category: category,
                firstIntroducedAt: firstIntroducedAt,
                sortOrder: sortOrder,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$OlyExerciseTypesTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback: ({olySessionExercisesRefs = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [
                if (olySessionExercisesRefs) db.olySessionExercises,
              ],
              addJoins: null,
              getPrefetchedDataCallback: (items) async {
                return [
                  if (olySessionExercisesRefs)
                    await $_getPrefetchedData<
                      OlyExerciseType,
                      $OlyExerciseTypesTable,
                      OlySessionExercise
                    >(
                      currentTable: table,
                      referencedTable: $$OlyExerciseTypesTableReferences
                          ._olySessionExercisesRefsTable(db),
                      managerFromTypedResult: (p0) =>
                          $$OlyExerciseTypesTableReferences(
                            db,
                            table,
                            p0,
                          ).olySessionExercisesRefs,
                      referencedItemsForCurrentItem: (item, referencedItems) =>
                          referencedItems.where(
                            (e) => e.exerciseTypeId == item.id,
                          ),
                      typedResults: items,
                    ),
                ];
              },
            );
          },
        ),
      );
}

typedef $$OlyExerciseTypesTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $OlyExerciseTypesTable,
      OlyExerciseType,
      $$OlyExerciseTypesTableFilterComposer,
      $$OlyExerciseTypesTableOrderingComposer,
      $$OlyExerciseTypesTableAnnotationComposer,
      $$OlyExerciseTypesTableCreateCompanionBuilder,
      $$OlyExerciseTypesTableUpdateCompanionBuilder,
      (OlyExerciseType, $$OlyExerciseTypesTableReferences),
      OlyExerciseType,
      PrefetchHooks Function({bool olySessionExercisesRefs})
    >;
typedef $$OlySessionTemplatesTableCreateCompanionBuilder =
    OlySessionTemplatesCompanion Function({
      required String id,
      required String version,
      required String name,
      Value<String?> focus,
      required int durationMinutes,
      required int volumeLoad,
      required int adjustedVolumeLoad,
      required double workRatio,
      required double adjustedWorkRatio,
      Value<String?> requirements,
      Value<String> equipment,
      Value<String?> notes,
      Value<int> sortOrder,
      Value<DateTime> createdAt,
      Value<int> rowid,
    });
typedef $$OlySessionTemplatesTableUpdateCompanionBuilder =
    OlySessionTemplatesCompanion Function({
      Value<String> id,
      Value<String> version,
      Value<String> name,
      Value<String?> focus,
      Value<int> durationMinutes,
      Value<int> volumeLoad,
      Value<int> adjustedVolumeLoad,
      Value<double> workRatio,
      Value<double> adjustedWorkRatio,
      Value<String?> requirements,
      Value<String> equipment,
      Value<String?> notes,
      Value<int> sortOrder,
      Value<DateTime> createdAt,
      Value<int> rowid,
    });

final class $$OlySessionTemplatesTableReferences
    extends
        BaseReferences<
          _$AppDatabase,
          $OlySessionTemplatesTable,
          OlySessionTemplate
        > {
  $$OlySessionTemplatesTableReferences(
    super.$_db,
    super.$_table,
    super.$_typedResult,
  );

  static MultiTypedResultKey<
    $OlySessionExercisesTable,
    List<OlySessionExercise>
  >
  _olySessionExercisesRefsTable(_$AppDatabase db) =>
      MultiTypedResultKey.fromTable(
        db.olySessionExercises,
        aliasName: $_aliasNameGenerator(
          db.olySessionTemplates.id,
          db.olySessionExercises.sessionTemplateId,
        ),
      );

  $$OlySessionExercisesTableProcessedTableManager get olySessionExercisesRefs {
    final manager =
        $$OlySessionExercisesTableTableManager(
          $_db,
          $_db.olySessionExercises,
        ).filter(
          (f) => f.sessionTemplateId.id.sqlEquals($_itemColumn<String>('id')!),
        );

    final cache = $_typedResult.readTableOrNull(
      _olySessionExercisesRefsTable($_db),
    );
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$OlySessionTemplatesTableFilterComposer
    extends Composer<_$AppDatabase, $OlySessionTemplatesTable> {
  $$OlySessionTemplatesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get version => $composableBuilder(
    column: $table.version,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get focus => $composableBuilder(
    column: $table.focus,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get durationMinutes => $composableBuilder(
    column: $table.durationMinutes,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get volumeLoad => $composableBuilder(
    column: $table.volumeLoad,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get adjustedVolumeLoad => $composableBuilder(
    column: $table.adjustedVolumeLoad,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get workRatio => $composableBuilder(
    column: $table.workRatio,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get adjustedWorkRatio => $composableBuilder(
    column: $table.adjustedWorkRatio,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get requirements => $composableBuilder(
    column: $table.requirements,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get equipment => $composableBuilder(
    column: $table.equipment,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get sortOrder => $composableBuilder(
    column: $table.sortOrder,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  Expression<bool> olySessionExercisesRefs(
    Expression<bool> Function($$OlySessionExercisesTableFilterComposer f) f,
  ) {
    final $$OlySessionExercisesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.olySessionExercises,
      getReferencedColumn: (t) => t.sessionTemplateId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$OlySessionExercisesTableFilterComposer(
            $db: $db,
            $table: $db.olySessionExercises,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$OlySessionTemplatesTableOrderingComposer
    extends Composer<_$AppDatabase, $OlySessionTemplatesTable> {
  $$OlySessionTemplatesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get version => $composableBuilder(
    column: $table.version,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get focus => $composableBuilder(
    column: $table.focus,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get durationMinutes => $composableBuilder(
    column: $table.durationMinutes,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get volumeLoad => $composableBuilder(
    column: $table.volumeLoad,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get adjustedVolumeLoad => $composableBuilder(
    column: $table.adjustedVolumeLoad,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get workRatio => $composableBuilder(
    column: $table.workRatio,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get adjustedWorkRatio => $composableBuilder(
    column: $table.adjustedWorkRatio,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get requirements => $composableBuilder(
    column: $table.requirements,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get equipment => $composableBuilder(
    column: $table.equipment,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get sortOrder => $composableBuilder(
    column: $table.sortOrder,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$OlySessionTemplatesTableAnnotationComposer
    extends Composer<_$AppDatabase, $OlySessionTemplatesTable> {
  $$OlySessionTemplatesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get version =>
      $composableBuilder(column: $table.version, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get focus =>
      $composableBuilder(column: $table.focus, builder: (column) => column);

  GeneratedColumn<int> get durationMinutes => $composableBuilder(
    column: $table.durationMinutes,
    builder: (column) => column,
  );

  GeneratedColumn<int> get volumeLoad => $composableBuilder(
    column: $table.volumeLoad,
    builder: (column) => column,
  );

  GeneratedColumn<int> get adjustedVolumeLoad => $composableBuilder(
    column: $table.adjustedVolumeLoad,
    builder: (column) => column,
  );

  GeneratedColumn<double> get workRatio =>
      $composableBuilder(column: $table.workRatio, builder: (column) => column);

  GeneratedColumn<double> get adjustedWorkRatio => $composableBuilder(
    column: $table.adjustedWorkRatio,
    builder: (column) => column,
  );

  GeneratedColumn<String> get requirements => $composableBuilder(
    column: $table.requirements,
    builder: (column) => column,
  );

  GeneratedColumn<String> get equipment =>
      $composableBuilder(column: $table.equipment, builder: (column) => column);

  GeneratedColumn<String> get notes =>
      $composableBuilder(column: $table.notes, builder: (column) => column);

  GeneratedColumn<int> get sortOrder =>
      $composableBuilder(column: $table.sortOrder, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  Expression<T> olySessionExercisesRefs<T extends Object>(
    Expression<T> Function($$OlySessionExercisesTableAnnotationComposer a) f,
  ) {
    final $$OlySessionExercisesTableAnnotationComposer composer =
        $composerBuilder(
          composer: this,
          getCurrentColumn: (t) => t.id,
          referencedTable: $db.olySessionExercises,
          getReferencedColumn: (t) => t.sessionTemplateId,
          builder:
              (
                joinBuilder, {
                $addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer,
              }) => $$OlySessionExercisesTableAnnotationComposer(
                $db: $db,
                $table: $db.olySessionExercises,
                $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                joinBuilder: joinBuilder,
                $removeJoinBuilderFromRootComposer:
                    $removeJoinBuilderFromRootComposer,
              ),
        );
    return f(composer);
  }
}

class $$OlySessionTemplatesTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $OlySessionTemplatesTable,
          OlySessionTemplate,
          $$OlySessionTemplatesTableFilterComposer,
          $$OlySessionTemplatesTableOrderingComposer,
          $$OlySessionTemplatesTableAnnotationComposer,
          $$OlySessionTemplatesTableCreateCompanionBuilder,
          $$OlySessionTemplatesTableUpdateCompanionBuilder,
          (OlySessionTemplate, $$OlySessionTemplatesTableReferences),
          OlySessionTemplate,
          PrefetchHooks Function({bool olySessionExercisesRefs})
        > {
  $$OlySessionTemplatesTableTableManager(
    _$AppDatabase db,
    $OlySessionTemplatesTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$OlySessionTemplatesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$OlySessionTemplatesTableOrderingComposer(
                $db: db,
                $table: table,
              ),
          createComputedFieldComposer: () =>
              $$OlySessionTemplatesTableAnnotationComposer(
                $db: db,
                $table: table,
              ),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> version = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<String?> focus = const Value.absent(),
                Value<int> durationMinutes = const Value.absent(),
                Value<int> volumeLoad = const Value.absent(),
                Value<int> adjustedVolumeLoad = const Value.absent(),
                Value<double> workRatio = const Value.absent(),
                Value<double> adjustedWorkRatio = const Value.absent(),
                Value<String?> requirements = const Value.absent(),
                Value<String> equipment = const Value.absent(),
                Value<String?> notes = const Value.absent(),
                Value<int> sortOrder = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => OlySessionTemplatesCompanion(
                id: id,
                version: version,
                name: name,
                focus: focus,
                durationMinutes: durationMinutes,
                volumeLoad: volumeLoad,
                adjustedVolumeLoad: adjustedVolumeLoad,
                workRatio: workRatio,
                adjustedWorkRatio: adjustedWorkRatio,
                requirements: requirements,
                equipment: equipment,
                notes: notes,
                sortOrder: sortOrder,
                createdAt: createdAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String version,
                required String name,
                Value<String?> focus = const Value.absent(),
                required int durationMinutes,
                required int volumeLoad,
                required int adjustedVolumeLoad,
                required double workRatio,
                required double adjustedWorkRatio,
                Value<String?> requirements = const Value.absent(),
                Value<String> equipment = const Value.absent(),
                Value<String?> notes = const Value.absent(),
                Value<int> sortOrder = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => OlySessionTemplatesCompanion.insert(
                id: id,
                version: version,
                name: name,
                focus: focus,
                durationMinutes: durationMinutes,
                volumeLoad: volumeLoad,
                adjustedVolumeLoad: adjustedVolumeLoad,
                workRatio: workRatio,
                adjustedWorkRatio: adjustedWorkRatio,
                requirements: requirements,
                equipment: equipment,
                notes: notes,
                sortOrder: sortOrder,
                createdAt: createdAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$OlySessionTemplatesTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback: ({olySessionExercisesRefs = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [
                if (olySessionExercisesRefs) db.olySessionExercises,
              ],
              addJoins: null,
              getPrefetchedDataCallback: (items) async {
                return [
                  if (olySessionExercisesRefs)
                    await $_getPrefetchedData<
                      OlySessionTemplate,
                      $OlySessionTemplatesTable,
                      OlySessionExercise
                    >(
                      currentTable: table,
                      referencedTable: $$OlySessionTemplatesTableReferences
                          ._olySessionExercisesRefsTable(db),
                      managerFromTypedResult: (p0) =>
                          $$OlySessionTemplatesTableReferences(
                            db,
                            table,
                            p0,
                          ).olySessionExercisesRefs,
                      referencedItemsForCurrentItem: (item, referencedItems) =>
                          referencedItems.where(
                            (e) => e.sessionTemplateId == item.id,
                          ),
                      typedResults: items,
                    ),
                ];
              },
            );
          },
        ),
      );
}

typedef $$OlySessionTemplatesTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $OlySessionTemplatesTable,
      OlySessionTemplate,
      $$OlySessionTemplatesTableFilterComposer,
      $$OlySessionTemplatesTableOrderingComposer,
      $$OlySessionTemplatesTableAnnotationComposer,
      $$OlySessionTemplatesTableCreateCompanionBuilder,
      $$OlySessionTemplatesTableUpdateCompanionBuilder,
      (OlySessionTemplate, $$OlySessionTemplatesTableReferences),
      OlySessionTemplate,
      PrefetchHooks Function({bool olySessionExercisesRefs})
    >;
typedef $$OlySessionExercisesTableCreateCompanionBuilder =
    OlySessionExercisesCompanion Function({
      required String id,
      required String sessionTemplateId,
      required String exerciseTypeId,
      required int exerciseOrder,
      required int reps,
      required int workSeconds,
      required int restSeconds,
      Value<String?> details,
      Value<double?> intensityOverride,
      Value<int> rowid,
    });
typedef $$OlySessionExercisesTableUpdateCompanionBuilder =
    OlySessionExercisesCompanion Function({
      Value<String> id,
      Value<String> sessionTemplateId,
      Value<String> exerciseTypeId,
      Value<int> exerciseOrder,
      Value<int> reps,
      Value<int> workSeconds,
      Value<int> restSeconds,
      Value<String?> details,
      Value<double?> intensityOverride,
      Value<int> rowid,
    });

final class $$OlySessionExercisesTableReferences
    extends
        BaseReferences<
          _$AppDatabase,
          $OlySessionExercisesTable,
          OlySessionExercise
        > {
  $$OlySessionExercisesTableReferences(
    super.$_db,
    super.$_table,
    super.$_typedResult,
  );

  static $OlySessionTemplatesTable _sessionTemplateIdTable(_$AppDatabase db) =>
      db.olySessionTemplates.createAlias(
        $_aliasNameGenerator(
          db.olySessionExercises.sessionTemplateId,
          db.olySessionTemplates.id,
        ),
      );

  $$OlySessionTemplatesTableProcessedTableManager get sessionTemplateId {
    final $_column = $_itemColumn<String>('session_template_id')!;

    final manager = $$OlySessionTemplatesTableTableManager(
      $_db,
      $_db.olySessionTemplates,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_sessionTemplateIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $OlyExerciseTypesTable _exerciseTypeIdTable(_$AppDatabase db) =>
      db.olyExerciseTypes.createAlias(
        $_aliasNameGenerator(
          db.olySessionExercises.exerciseTypeId,
          db.olyExerciseTypes.id,
        ),
      );

  $$OlyExerciseTypesTableProcessedTableManager get exerciseTypeId {
    final $_column = $_itemColumn<String>('exercise_type_id')!;

    final manager = $$OlyExerciseTypesTableTableManager(
      $_db,
      $_db.olyExerciseTypes,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_exerciseTypeIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$OlySessionExercisesTableFilterComposer
    extends Composer<_$AppDatabase, $OlySessionExercisesTable> {
  $$OlySessionExercisesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get exerciseOrder => $composableBuilder(
    column: $table.exerciseOrder,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get reps => $composableBuilder(
    column: $table.reps,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get workSeconds => $composableBuilder(
    column: $table.workSeconds,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get restSeconds => $composableBuilder(
    column: $table.restSeconds,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get details => $composableBuilder(
    column: $table.details,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get intensityOverride => $composableBuilder(
    column: $table.intensityOverride,
    builder: (column) => ColumnFilters(column),
  );

  $$OlySessionTemplatesTableFilterComposer get sessionTemplateId {
    final $$OlySessionTemplatesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.sessionTemplateId,
      referencedTable: $db.olySessionTemplates,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$OlySessionTemplatesTableFilterComposer(
            $db: $db,
            $table: $db.olySessionTemplates,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$OlyExerciseTypesTableFilterComposer get exerciseTypeId {
    final $$OlyExerciseTypesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.exerciseTypeId,
      referencedTable: $db.olyExerciseTypes,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$OlyExerciseTypesTableFilterComposer(
            $db: $db,
            $table: $db.olyExerciseTypes,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$OlySessionExercisesTableOrderingComposer
    extends Composer<_$AppDatabase, $OlySessionExercisesTable> {
  $$OlySessionExercisesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get exerciseOrder => $composableBuilder(
    column: $table.exerciseOrder,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get reps => $composableBuilder(
    column: $table.reps,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get workSeconds => $composableBuilder(
    column: $table.workSeconds,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get restSeconds => $composableBuilder(
    column: $table.restSeconds,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get details => $composableBuilder(
    column: $table.details,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get intensityOverride => $composableBuilder(
    column: $table.intensityOverride,
    builder: (column) => ColumnOrderings(column),
  );

  $$OlySessionTemplatesTableOrderingComposer get sessionTemplateId {
    final $$OlySessionTemplatesTableOrderingComposer composer =
        $composerBuilder(
          composer: this,
          getCurrentColumn: (t) => t.sessionTemplateId,
          referencedTable: $db.olySessionTemplates,
          getReferencedColumn: (t) => t.id,
          builder:
              (
                joinBuilder, {
                $addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer,
              }) => $$OlySessionTemplatesTableOrderingComposer(
                $db: $db,
                $table: $db.olySessionTemplates,
                $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                joinBuilder: joinBuilder,
                $removeJoinBuilderFromRootComposer:
                    $removeJoinBuilderFromRootComposer,
              ),
        );
    return composer;
  }

  $$OlyExerciseTypesTableOrderingComposer get exerciseTypeId {
    final $$OlyExerciseTypesTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.exerciseTypeId,
      referencedTable: $db.olyExerciseTypes,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$OlyExerciseTypesTableOrderingComposer(
            $db: $db,
            $table: $db.olyExerciseTypes,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$OlySessionExercisesTableAnnotationComposer
    extends Composer<_$AppDatabase, $OlySessionExercisesTable> {
  $$OlySessionExercisesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<int> get exerciseOrder => $composableBuilder(
    column: $table.exerciseOrder,
    builder: (column) => column,
  );

  GeneratedColumn<int> get reps =>
      $composableBuilder(column: $table.reps, builder: (column) => column);

  GeneratedColumn<int> get workSeconds => $composableBuilder(
    column: $table.workSeconds,
    builder: (column) => column,
  );

  GeneratedColumn<int> get restSeconds => $composableBuilder(
    column: $table.restSeconds,
    builder: (column) => column,
  );

  GeneratedColumn<String> get details =>
      $composableBuilder(column: $table.details, builder: (column) => column);

  GeneratedColumn<double> get intensityOverride => $composableBuilder(
    column: $table.intensityOverride,
    builder: (column) => column,
  );

  $$OlySessionTemplatesTableAnnotationComposer get sessionTemplateId {
    final $$OlySessionTemplatesTableAnnotationComposer composer =
        $composerBuilder(
          composer: this,
          getCurrentColumn: (t) => t.sessionTemplateId,
          referencedTable: $db.olySessionTemplates,
          getReferencedColumn: (t) => t.id,
          builder:
              (
                joinBuilder, {
                $addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer,
              }) => $$OlySessionTemplatesTableAnnotationComposer(
                $db: $db,
                $table: $db.olySessionTemplates,
                $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                joinBuilder: joinBuilder,
                $removeJoinBuilderFromRootComposer:
                    $removeJoinBuilderFromRootComposer,
              ),
        );
    return composer;
  }

  $$OlyExerciseTypesTableAnnotationComposer get exerciseTypeId {
    final $$OlyExerciseTypesTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.exerciseTypeId,
      referencedTable: $db.olyExerciseTypes,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$OlyExerciseTypesTableAnnotationComposer(
            $db: $db,
            $table: $db.olyExerciseTypes,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$OlySessionExercisesTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $OlySessionExercisesTable,
          OlySessionExercise,
          $$OlySessionExercisesTableFilterComposer,
          $$OlySessionExercisesTableOrderingComposer,
          $$OlySessionExercisesTableAnnotationComposer,
          $$OlySessionExercisesTableCreateCompanionBuilder,
          $$OlySessionExercisesTableUpdateCompanionBuilder,
          (OlySessionExercise, $$OlySessionExercisesTableReferences),
          OlySessionExercise,
          PrefetchHooks Function({bool sessionTemplateId, bool exerciseTypeId})
        > {
  $$OlySessionExercisesTableTableManager(
    _$AppDatabase db,
    $OlySessionExercisesTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$OlySessionExercisesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$OlySessionExercisesTableOrderingComposer(
                $db: db,
                $table: table,
              ),
          createComputedFieldComposer: () =>
              $$OlySessionExercisesTableAnnotationComposer(
                $db: db,
                $table: table,
              ),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> sessionTemplateId = const Value.absent(),
                Value<String> exerciseTypeId = const Value.absent(),
                Value<int> exerciseOrder = const Value.absent(),
                Value<int> reps = const Value.absent(),
                Value<int> workSeconds = const Value.absent(),
                Value<int> restSeconds = const Value.absent(),
                Value<String?> details = const Value.absent(),
                Value<double?> intensityOverride = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => OlySessionExercisesCompanion(
                id: id,
                sessionTemplateId: sessionTemplateId,
                exerciseTypeId: exerciseTypeId,
                exerciseOrder: exerciseOrder,
                reps: reps,
                workSeconds: workSeconds,
                restSeconds: restSeconds,
                details: details,
                intensityOverride: intensityOverride,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String sessionTemplateId,
                required String exerciseTypeId,
                required int exerciseOrder,
                required int reps,
                required int workSeconds,
                required int restSeconds,
                Value<String?> details = const Value.absent(),
                Value<double?> intensityOverride = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => OlySessionExercisesCompanion.insert(
                id: id,
                sessionTemplateId: sessionTemplateId,
                exerciseTypeId: exerciseTypeId,
                exerciseOrder: exerciseOrder,
                reps: reps,
                workSeconds: workSeconds,
                restSeconds: restSeconds,
                details: details,
                intensityOverride: intensityOverride,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$OlySessionExercisesTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback:
              ({sessionTemplateId = false, exerciseTypeId = false}) {
                return PrefetchHooks(
                  db: db,
                  explicitlyWatchedTables: [],
                  addJoins:
                      <
                        T extends TableManagerState<
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic
                        >
                      >(state) {
                        if (sessionTemplateId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.sessionTemplateId,
                                    referencedTable:
                                        $$OlySessionExercisesTableReferences
                                            ._sessionTemplateIdTable(db),
                                    referencedColumn:
                                        $$OlySessionExercisesTableReferences
                                            ._sessionTemplateIdTable(db)
                                            .id,
                                  )
                                  as T;
                        }
                        if (exerciseTypeId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.exerciseTypeId,
                                    referencedTable:
                                        $$OlySessionExercisesTableReferences
                                            ._exerciseTypeIdTable(db),
                                    referencedColumn:
                                        $$OlySessionExercisesTableReferences
                                            ._exerciseTypeIdTable(db)
                                            .id,
                                  )
                                  as T;
                        }

                        return state;
                      },
                  getPrefetchedDataCallback: (items) async {
                    return [];
                  },
                );
              },
        ),
      );
}

typedef $$OlySessionExercisesTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $OlySessionExercisesTable,
      OlySessionExercise,
      $$OlySessionExercisesTableFilterComposer,
      $$OlySessionExercisesTableOrderingComposer,
      $$OlySessionExercisesTableAnnotationComposer,
      $$OlySessionExercisesTableCreateCompanionBuilder,
      $$OlySessionExercisesTableUpdateCompanionBuilder,
      (OlySessionExercise, $$OlySessionExercisesTableReferences),
      OlySessionExercise,
      PrefetchHooks Function({bool sessionTemplateId, bool exerciseTypeId})
    >;
typedef $$OlyTrainingLogsTableCreateCompanionBuilder =
    OlyTrainingLogsCompanion Function({
      required String id,
      Value<String?> sessionTemplateId,
      required String sessionVersion,
      required String sessionName,
      required int plannedDurationSeconds,
      required int actualDurationSeconds,
      required int plannedExercises,
      required int completedExercises,
      required int totalHoldSeconds,
      required int totalRestSeconds,
      Value<int?> feedbackShaking,
      Value<int?> feedbackStructure,
      Value<int?> feedbackRest,
      Value<String?> progressionSuggestion,
      Value<String?> suggestedNextVersion,
      Value<String?> notes,
      required DateTime startedAt,
      required DateTime completedAt,
      Value<int> rowid,
    });
typedef $$OlyTrainingLogsTableUpdateCompanionBuilder =
    OlyTrainingLogsCompanion Function({
      Value<String> id,
      Value<String?> sessionTemplateId,
      Value<String> sessionVersion,
      Value<String> sessionName,
      Value<int> plannedDurationSeconds,
      Value<int> actualDurationSeconds,
      Value<int> plannedExercises,
      Value<int> completedExercises,
      Value<int> totalHoldSeconds,
      Value<int> totalRestSeconds,
      Value<int?> feedbackShaking,
      Value<int?> feedbackStructure,
      Value<int?> feedbackRest,
      Value<String?> progressionSuggestion,
      Value<String?> suggestedNextVersion,
      Value<String?> notes,
      Value<DateTime> startedAt,
      Value<DateTime> completedAt,
      Value<int> rowid,
    });

class $$OlyTrainingLogsTableFilterComposer
    extends Composer<_$AppDatabase, $OlyTrainingLogsTable> {
  $$OlyTrainingLogsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get sessionTemplateId => $composableBuilder(
    column: $table.sessionTemplateId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get sessionVersion => $composableBuilder(
    column: $table.sessionVersion,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get sessionName => $composableBuilder(
    column: $table.sessionName,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get plannedDurationSeconds => $composableBuilder(
    column: $table.plannedDurationSeconds,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get actualDurationSeconds => $composableBuilder(
    column: $table.actualDurationSeconds,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get plannedExercises => $composableBuilder(
    column: $table.plannedExercises,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get completedExercises => $composableBuilder(
    column: $table.completedExercises,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get totalHoldSeconds => $composableBuilder(
    column: $table.totalHoldSeconds,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get totalRestSeconds => $composableBuilder(
    column: $table.totalRestSeconds,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get feedbackShaking => $composableBuilder(
    column: $table.feedbackShaking,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get feedbackStructure => $composableBuilder(
    column: $table.feedbackStructure,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get feedbackRest => $composableBuilder(
    column: $table.feedbackRest,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get progressionSuggestion => $composableBuilder(
    column: $table.progressionSuggestion,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get suggestedNextVersion => $composableBuilder(
    column: $table.suggestedNextVersion,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get startedAt => $composableBuilder(
    column: $table.startedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get completedAt => $composableBuilder(
    column: $table.completedAt,
    builder: (column) => ColumnFilters(column),
  );
}

class $$OlyTrainingLogsTableOrderingComposer
    extends Composer<_$AppDatabase, $OlyTrainingLogsTable> {
  $$OlyTrainingLogsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get sessionTemplateId => $composableBuilder(
    column: $table.sessionTemplateId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get sessionVersion => $composableBuilder(
    column: $table.sessionVersion,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get sessionName => $composableBuilder(
    column: $table.sessionName,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get plannedDurationSeconds => $composableBuilder(
    column: $table.plannedDurationSeconds,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get actualDurationSeconds => $composableBuilder(
    column: $table.actualDurationSeconds,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get plannedExercises => $composableBuilder(
    column: $table.plannedExercises,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get completedExercises => $composableBuilder(
    column: $table.completedExercises,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get totalHoldSeconds => $composableBuilder(
    column: $table.totalHoldSeconds,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get totalRestSeconds => $composableBuilder(
    column: $table.totalRestSeconds,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get feedbackShaking => $composableBuilder(
    column: $table.feedbackShaking,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get feedbackStructure => $composableBuilder(
    column: $table.feedbackStructure,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get feedbackRest => $composableBuilder(
    column: $table.feedbackRest,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get progressionSuggestion => $composableBuilder(
    column: $table.progressionSuggestion,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get suggestedNextVersion => $composableBuilder(
    column: $table.suggestedNextVersion,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get startedAt => $composableBuilder(
    column: $table.startedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get completedAt => $composableBuilder(
    column: $table.completedAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$OlyTrainingLogsTableAnnotationComposer
    extends Composer<_$AppDatabase, $OlyTrainingLogsTable> {
  $$OlyTrainingLogsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get sessionTemplateId => $composableBuilder(
    column: $table.sessionTemplateId,
    builder: (column) => column,
  );

  GeneratedColumn<String> get sessionVersion => $composableBuilder(
    column: $table.sessionVersion,
    builder: (column) => column,
  );

  GeneratedColumn<String> get sessionName => $composableBuilder(
    column: $table.sessionName,
    builder: (column) => column,
  );

  GeneratedColumn<int> get plannedDurationSeconds => $composableBuilder(
    column: $table.plannedDurationSeconds,
    builder: (column) => column,
  );

  GeneratedColumn<int> get actualDurationSeconds => $composableBuilder(
    column: $table.actualDurationSeconds,
    builder: (column) => column,
  );

  GeneratedColumn<int> get plannedExercises => $composableBuilder(
    column: $table.plannedExercises,
    builder: (column) => column,
  );

  GeneratedColumn<int> get completedExercises => $composableBuilder(
    column: $table.completedExercises,
    builder: (column) => column,
  );

  GeneratedColumn<int> get totalHoldSeconds => $composableBuilder(
    column: $table.totalHoldSeconds,
    builder: (column) => column,
  );

  GeneratedColumn<int> get totalRestSeconds => $composableBuilder(
    column: $table.totalRestSeconds,
    builder: (column) => column,
  );

  GeneratedColumn<int> get feedbackShaking => $composableBuilder(
    column: $table.feedbackShaking,
    builder: (column) => column,
  );

  GeneratedColumn<int> get feedbackStructure => $composableBuilder(
    column: $table.feedbackStructure,
    builder: (column) => column,
  );

  GeneratedColumn<int> get feedbackRest => $composableBuilder(
    column: $table.feedbackRest,
    builder: (column) => column,
  );

  GeneratedColumn<String> get progressionSuggestion => $composableBuilder(
    column: $table.progressionSuggestion,
    builder: (column) => column,
  );

  GeneratedColumn<String> get suggestedNextVersion => $composableBuilder(
    column: $table.suggestedNextVersion,
    builder: (column) => column,
  );

  GeneratedColumn<String> get notes =>
      $composableBuilder(column: $table.notes, builder: (column) => column);

  GeneratedColumn<DateTime> get startedAt =>
      $composableBuilder(column: $table.startedAt, builder: (column) => column);

  GeneratedColumn<DateTime> get completedAt => $composableBuilder(
    column: $table.completedAt,
    builder: (column) => column,
  );
}

class $$OlyTrainingLogsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $OlyTrainingLogsTable,
          OlyTrainingLog,
          $$OlyTrainingLogsTableFilterComposer,
          $$OlyTrainingLogsTableOrderingComposer,
          $$OlyTrainingLogsTableAnnotationComposer,
          $$OlyTrainingLogsTableCreateCompanionBuilder,
          $$OlyTrainingLogsTableUpdateCompanionBuilder,
          (
            OlyTrainingLog,
            BaseReferences<
              _$AppDatabase,
              $OlyTrainingLogsTable,
              OlyTrainingLog
            >,
          ),
          OlyTrainingLog,
          PrefetchHooks Function()
        > {
  $$OlyTrainingLogsTableTableManager(
    _$AppDatabase db,
    $OlyTrainingLogsTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$OlyTrainingLogsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$OlyTrainingLogsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$OlyTrainingLogsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String?> sessionTemplateId = const Value.absent(),
                Value<String> sessionVersion = const Value.absent(),
                Value<String> sessionName = const Value.absent(),
                Value<int> plannedDurationSeconds = const Value.absent(),
                Value<int> actualDurationSeconds = const Value.absent(),
                Value<int> plannedExercises = const Value.absent(),
                Value<int> completedExercises = const Value.absent(),
                Value<int> totalHoldSeconds = const Value.absent(),
                Value<int> totalRestSeconds = const Value.absent(),
                Value<int?> feedbackShaking = const Value.absent(),
                Value<int?> feedbackStructure = const Value.absent(),
                Value<int?> feedbackRest = const Value.absent(),
                Value<String?> progressionSuggestion = const Value.absent(),
                Value<String?> suggestedNextVersion = const Value.absent(),
                Value<String?> notes = const Value.absent(),
                Value<DateTime> startedAt = const Value.absent(),
                Value<DateTime> completedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => OlyTrainingLogsCompanion(
                id: id,
                sessionTemplateId: sessionTemplateId,
                sessionVersion: sessionVersion,
                sessionName: sessionName,
                plannedDurationSeconds: plannedDurationSeconds,
                actualDurationSeconds: actualDurationSeconds,
                plannedExercises: plannedExercises,
                completedExercises: completedExercises,
                totalHoldSeconds: totalHoldSeconds,
                totalRestSeconds: totalRestSeconds,
                feedbackShaking: feedbackShaking,
                feedbackStructure: feedbackStructure,
                feedbackRest: feedbackRest,
                progressionSuggestion: progressionSuggestion,
                suggestedNextVersion: suggestedNextVersion,
                notes: notes,
                startedAt: startedAt,
                completedAt: completedAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                Value<String?> sessionTemplateId = const Value.absent(),
                required String sessionVersion,
                required String sessionName,
                required int plannedDurationSeconds,
                required int actualDurationSeconds,
                required int plannedExercises,
                required int completedExercises,
                required int totalHoldSeconds,
                required int totalRestSeconds,
                Value<int?> feedbackShaking = const Value.absent(),
                Value<int?> feedbackStructure = const Value.absent(),
                Value<int?> feedbackRest = const Value.absent(),
                Value<String?> progressionSuggestion = const Value.absent(),
                Value<String?> suggestedNextVersion = const Value.absent(),
                Value<String?> notes = const Value.absent(),
                required DateTime startedAt,
                required DateTime completedAt,
                Value<int> rowid = const Value.absent(),
              }) => OlyTrainingLogsCompanion.insert(
                id: id,
                sessionTemplateId: sessionTemplateId,
                sessionVersion: sessionVersion,
                sessionName: sessionName,
                plannedDurationSeconds: plannedDurationSeconds,
                actualDurationSeconds: actualDurationSeconds,
                plannedExercises: plannedExercises,
                completedExercises: completedExercises,
                totalHoldSeconds: totalHoldSeconds,
                totalRestSeconds: totalRestSeconds,
                feedbackShaking: feedbackShaking,
                feedbackStructure: feedbackStructure,
                feedbackRest: feedbackRest,
                progressionSuggestion: progressionSuggestion,
                suggestedNextVersion: suggestedNextVersion,
                notes: notes,
                startedAt: startedAt,
                completedAt: completedAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$OlyTrainingLogsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $OlyTrainingLogsTable,
      OlyTrainingLog,
      $$OlyTrainingLogsTableFilterComposer,
      $$OlyTrainingLogsTableOrderingComposer,
      $$OlyTrainingLogsTableAnnotationComposer,
      $$OlyTrainingLogsTableCreateCompanionBuilder,
      $$OlyTrainingLogsTableUpdateCompanionBuilder,
      (
        OlyTrainingLog,
        BaseReferences<_$AppDatabase, $OlyTrainingLogsTable, OlyTrainingLog>,
      ),
      OlyTrainingLog,
      PrefetchHooks Function()
    >;
typedef $$UserTrainingProgressTableCreateCompanionBuilder =
    UserTrainingProgressCompanion Function({
      required String id,
      Value<String> currentLevel,
      Value<int> sessionsAtCurrentLevel,
      Value<DateTime?> lastSessionAt,
      Value<String?> lastSessionVersion,
      Value<int> totalSessionsCompleted,
      Value<bool> hasCompletedAssessment,
      Value<int?> assessmentMaxHoldSeconds,
      Value<DateTime?> assessmentDate,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<int> rowid,
    });
typedef $$UserTrainingProgressTableUpdateCompanionBuilder =
    UserTrainingProgressCompanion Function({
      Value<String> id,
      Value<String> currentLevel,
      Value<int> sessionsAtCurrentLevel,
      Value<DateTime?> lastSessionAt,
      Value<String?> lastSessionVersion,
      Value<int> totalSessionsCompleted,
      Value<bool> hasCompletedAssessment,
      Value<int?> assessmentMaxHoldSeconds,
      Value<DateTime?> assessmentDate,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<int> rowid,
    });

class $$UserTrainingProgressTableFilterComposer
    extends Composer<_$AppDatabase, $UserTrainingProgressTable> {
  $$UserTrainingProgressTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get currentLevel => $composableBuilder(
    column: $table.currentLevel,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get sessionsAtCurrentLevel => $composableBuilder(
    column: $table.sessionsAtCurrentLevel,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get lastSessionAt => $composableBuilder(
    column: $table.lastSessionAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get lastSessionVersion => $composableBuilder(
    column: $table.lastSessionVersion,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get totalSessionsCompleted => $composableBuilder(
    column: $table.totalSessionsCompleted,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get hasCompletedAssessment => $composableBuilder(
    column: $table.hasCompletedAssessment,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get assessmentMaxHoldSeconds => $composableBuilder(
    column: $table.assessmentMaxHoldSeconds,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get assessmentDate => $composableBuilder(
    column: $table.assessmentDate,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );
}

class $$UserTrainingProgressTableOrderingComposer
    extends Composer<_$AppDatabase, $UserTrainingProgressTable> {
  $$UserTrainingProgressTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get currentLevel => $composableBuilder(
    column: $table.currentLevel,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get sessionsAtCurrentLevel => $composableBuilder(
    column: $table.sessionsAtCurrentLevel,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get lastSessionAt => $composableBuilder(
    column: $table.lastSessionAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get lastSessionVersion => $composableBuilder(
    column: $table.lastSessionVersion,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get totalSessionsCompleted => $composableBuilder(
    column: $table.totalSessionsCompleted,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get hasCompletedAssessment => $composableBuilder(
    column: $table.hasCompletedAssessment,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get assessmentMaxHoldSeconds => $composableBuilder(
    column: $table.assessmentMaxHoldSeconds,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get assessmentDate => $composableBuilder(
    column: $table.assessmentDate,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$UserTrainingProgressTableAnnotationComposer
    extends Composer<_$AppDatabase, $UserTrainingProgressTable> {
  $$UserTrainingProgressTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get currentLevel => $composableBuilder(
    column: $table.currentLevel,
    builder: (column) => column,
  );

  GeneratedColumn<int> get sessionsAtCurrentLevel => $composableBuilder(
    column: $table.sessionsAtCurrentLevel,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get lastSessionAt => $composableBuilder(
    column: $table.lastSessionAt,
    builder: (column) => column,
  );

  GeneratedColumn<String> get lastSessionVersion => $composableBuilder(
    column: $table.lastSessionVersion,
    builder: (column) => column,
  );

  GeneratedColumn<int> get totalSessionsCompleted => $composableBuilder(
    column: $table.totalSessionsCompleted,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get hasCompletedAssessment => $composableBuilder(
    column: $table.hasCompletedAssessment,
    builder: (column) => column,
  );

  GeneratedColumn<int> get assessmentMaxHoldSeconds => $composableBuilder(
    column: $table.assessmentMaxHoldSeconds,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get assessmentDate => $composableBuilder(
    column: $table.assessmentDate,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);
}

class $$UserTrainingProgressTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $UserTrainingProgressTable,
          UserTrainingProgressData,
          $$UserTrainingProgressTableFilterComposer,
          $$UserTrainingProgressTableOrderingComposer,
          $$UserTrainingProgressTableAnnotationComposer,
          $$UserTrainingProgressTableCreateCompanionBuilder,
          $$UserTrainingProgressTableUpdateCompanionBuilder,
          (
            UserTrainingProgressData,
            BaseReferences<
              _$AppDatabase,
              $UserTrainingProgressTable,
              UserTrainingProgressData
            >,
          ),
          UserTrainingProgressData,
          PrefetchHooks Function()
        > {
  $$UserTrainingProgressTableTableManager(
    _$AppDatabase db,
    $UserTrainingProgressTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$UserTrainingProgressTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$UserTrainingProgressTableOrderingComposer(
                $db: db,
                $table: table,
              ),
          createComputedFieldComposer: () =>
              $$UserTrainingProgressTableAnnotationComposer(
                $db: db,
                $table: table,
              ),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> currentLevel = const Value.absent(),
                Value<int> sessionsAtCurrentLevel = const Value.absent(),
                Value<DateTime?> lastSessionAt = const Value.absent(),
                Value<String?> lastSessionVersion = const Value.absent(),
                Value<int> totalSessionsCompleted = const Value.absent(),
                Value<bool> hasCompletedAssessment = const Value.absent(),
                Value<int?> assessmentMaxHoldSeconds = const Value.absent(),
                Value<DateTime?> assessmentDate = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => UserTrainingProgressCompanion(
                id: id,
                currentLevel: currentLevel,
                sessionsAtCurrentLevel: sessionsAtCurrentLevel,
                lastSessionAt: lastSessionAt,
                lastSessionVersion: lastSessionVersion,
                totalSessionsCompleted: totalSessionsCompleted,
                hasCompletedAssessment: hasCompletedAssessment,
                assessmentMaxHoldSeconds: assessmentMaxHoldSeconds,
                assessmentDate: assessmentDate,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                Value<String> currentLevel = const Value.absent(),
                Value<int> sessionsAtCurrentLevel = const Value.absent(),
                Value<DateTime?> lastSessionAt = const Value.absent(),
                Value<String?> lastSessionVersion = const Value.absent(),
                Value<int> totalSessionsCompleted = const Value.absent(),
                Value<bool> hasCompletedAssessment = const Value.absent(),
                Value<int?> assessmentMaxHoldSeconds = const Value.absent(),
                Value<DateTime?> assessmentDate = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => UserTrainingProgressCompanion.insert(
                id: id,
                currentLevel: currentLevel,
                sessionsAtCurrentLevel: sessionsAtCurrentLevel,
                lastSessionAt: lastSessionAt,
                lastSessionVersion: lastSessionVersion,
                totalSessionsCompleted: totalSessionsCompleted,
                hasCompletedAssessment: hasCompletedAssessment,
                assessmentMaxHoldSeconds: assessmentMaxHoldSeconds,
                assessmentDate: assessmentDate,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$UserTrainingProgressTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $UserTrainingProgressTable,
      UserTrainingProgressData,
      $$UserTrainingProgressTableFilterComposer,
      $$UserTrainingProgressTableOrderingComposer,
      $$UserTrainingProgressTableAnnotationComposer,
      $$UserTrainingProgressTableCreateCompanionBuilder,
      $$UserTrainingProgressTableUpdateCompanionBuilder,
      (
        UserTrainingProgressData,
        BaseReferences<
          _$AppDatabase,
          $UserTrainingProgressTable,
          UserTrainingProgressData
        >,
      ),
      UserTrainingProgressData,
      PrefetchHooks Function()
    >;
typedef $$BreathTrainingLogsTableCreateCompanionBuilder =
    BreathTrainingLogsCompanion Function({
      required String id,
      required String sessionType,
      Value<int?> totalHoldSeconds,
      Value<int?> bestHoldThisSession,
      Value<int?> bestExhaleSeconds,
      Value<int?> rounds,
      Value<String?> difficulty,
      Value<int?> durationMinutes,
      required DateTime completedAt,
      Value<DateTime> createdAt,
      Value<int> rowid,
    });
typedef $$BreathTrainingLogsTableUpdateCompanionBuilder =
    BreathTrainingLogsCompanion Function({
      Value<String> id,
      Value<String> sessionType,
      Value<int?> totalHoldSeconds,
      Value<int?> bestHoldThisSession,
      Value<int?> bestExhaleSeconds,
      Value<int?> rounds,
      Value<String?> difficulty,
      Value<int?> durationMinutes,
      Value<DateTime> completedAt,
      Value<DateTime> createdAt,
      Value<int> rowid,
    });

class $$BreathTrainingLogsTableFilterComposer
    extends Composer<_$AppDatabase, $BreathTrainingLogsTable> {
  $$BreathTrainingLogsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get sessionType => $composableBuilder(
    column: $table.sessionType,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get totalHoldSeconds => $composableBuilder(
    column: $table.totalHoldSeconds,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get bestHoldThisSession => $composableBuilder(
    column: $table.bestHoldThisSession,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get bestExhaleSeconds => $composableBuilder(
    column: $table.bestExhaleSeconds,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get rounds => $composableBuilder(
    column: $table.rounds,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get difficulty => $composableBuilder(
    column: $table.difficulty,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get durationMinutes => $composableBuilder(
    column: $table.durationMinutes,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get completedAt => $composableBuilder(
    column: $table.completedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );
}

class $$BreathTrainingLogsTableOrderingComposer
    extends Composer<_$AppDatabase, $BreathTrainingLogsTable> {
  $$BreathTrainingLogsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get sessionType => $composableBuilder(
    column: $table.sessionType,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get totalHoldSeconds => $composableBuilder(
    column: $table.totalHoldSeconds,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get bestHoldThisSession => $composableBuilder(
    column: $table.bestHoldThisSession,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get bestExhaleSeconds => $composableBuilder(
    column: $table.bestExhaleSeconds,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get rounds => $composableBuilder(
    column: $table.rounds,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get difficulty => $composableBuilder(
    column: $table.difficulty,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get durationMinutes => $composableBuilder(
    column: $table.durationMinutes,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get completedAt => $composableBuilder(
    column: $table.completedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$BreathTrainingLogsTableAnnotationComposer
    extends Composer<_$AppDatabase, $BreathTrainingLogsTable> {
  $$BreathTrainingLogsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get sessionType => $composableBuilder(
    column: $table.sessionType,
    builder: (column) => column,
  );

  GeneratedColumn<int> get totalHoldSeconds => $composableBuilder(
    column: $table.totalHoldSeconds,
    builder: (column) => column,
  );

  GeneratedColumn<int> get bestHoldThisSession => $composableBuilder(
    column: $table.bestHoldThisSession,
    builder: (column) => column,
  );

  GeneratedColumn<int> get bestExhaleSeconds => $composableBuilder(
    column: $table.bestExhaleSeconds,
    builder: (column) => column,
  );

  GeneratedColumn<int> get rounds =>
      $composableBuilder(column: $table.rounds, builder: (column) => column);

  GeneratedColumn<String> get difficulty => $composableBuilder(
    column: $table.difficulty,
    builder: (column) => column,
  );

  GeneratedColumn<int> get durationMinutes => $composableBuilder(
    column: $table.durationMinutes,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get completedAt => $composableBuilder(
    column: $table.completedAt,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);
}

class $$BreathTrainingLogsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $BreathTrainingLogsTable,
          BreathTrainingLog,
          $$BreathTrainingLogsTableFilterComposer,
          $$BreathTrainingLogsTableOrderingComposer,
          $$BreathTrainingLogsTableAnnotationComposer,
          $$BreathTrainingLogsTableCreateCompanionBuilder,
          $$BreathTrainingLogsTableUpdateCompanionBuilder,
          (
            BreathTrainingLog,
            BaseReferences<
              _$AppDatabase,
              $BreathTrainingLogsTable,
              BreathTrainingLog
            >,
          ),
          BreathTrainingLog,
          PrefetchHooks Function()
        > {
  $$BreathTrainingLogsTableTableManager(
    _$AppDatabase db,
    $BreathTrainingLogsTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$BreathTrainingLogsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$BreathTrainingLogsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$BreathTrainingLogsTableAnnotationComposer(
                $db: db,
                $table: table,
              ),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> sessionType = const Value.absent(),
                Value<int?> totalHoldSeconds = const Value.absent(),
                Value<int?> bestHoldThisSession = const Value.absent(),
                Value<int?> bestExhaleSeconds = const Value.absent(),
                Value<int?> rounds = const Value.absent(),
                Value<String?> difficulty = const Value.absent(),
                Value<int?> durationMinutes = const Value.absent(),
                Value<DateTime> completedAt = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => BreathTrainingLogsCompanion(
                id: id,
                sessionType: sessionType,
                totalHoldSeconds: totalHoldSeconds,
                bestHoldThisSession: bestHoldThisSession,
                bestExhaleSeconds: bestExhaleSeconds,
                rounds: rounds,
                difficulty: difficulty,
                durationMinutes: durationMinutes,
                completedAt: completedAt,
                createdAt: createdAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String sessionType,
                Value<int?> totalHoldSeconds = const Value.absent(),
                Value<int?> bestHoldThisSession = const Value.absent(),
                Value<int?> bestExhaleSeconds = const Value.absent(),
                Value<int?> rounds = const Value.absent(),
                Value<String?> difficulty = const Value.absent(),
                Value<int?> durationMinutes = const Value.absent(),
                required DateTime completedAt,
                Value<DateTime> createdAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => BreathTrainingLogsCompanion.insert(
                id: id,
                sessionType: sessionType,
                totalHoldSeconds: totalHoldSeconds,
                bestHoldThisSession: bestHoldThisSession,
                bestExhaleSeconds: bestExhaleSeconds,
                rounds: rounds,
                difficulty: difficulty,
                durationMinutes: durationMinutes,
                completedAt: completedAt,
                createdAt: createdAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$BreathTrainingLogsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $BreathTrainingLogsTable,
      BreathTrainingLog,
      $$BreathTrainingLogsTableFilterComposer,
      $$BreathTrainingLogsTableOrderingComposer,
      $$BreathTrainingLogsTableAnnotationComposer,
      $$BreathTrainingLogsTableCreateCompanionBuilder,
      $$BreathTrainingLogsTableUpdateCompanionBuilder,
      (
        BreathTrainingLog,
        BaseReferences<
          _$AppDatabase,
          $BreathTrainingLogsTable,
          BreathTrainingLog
        >,
      ),
      BreathTrainingLog,
      PrefetchHooks Function()
    >;
typedef $$MilestonesTableCreateCompanionBuilder =
    MilestonesCompanion Function({
      required String id,
      required DateTime date,
      required String title,
      Value<String?> description,
      Value<String> color,
      Value<DateTime> createdAt,
      Value<int> rowid,
    });
typedef $$MilestonesTableUpdateCompanionBuilder =
    MilestonesCompanion Function({
      Value<String> id,
      Value<DateTime> date,
      Value<String> title,
      Value<String?> description,
      Value<String> color,
      Value<DateTime> createdAt,
      Value<int> rowid,
    });

class $$MilestonesTableFilterComposer
    extends Composer<_$AppDatabase, $MilestonesTable> {
  $$MilestonesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get date => $composableBuilder(
    column: $table.date,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get title => $composableBuilder(
    column: $table.title,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get description => $composableBuilder(
    column: $table.description,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get color => $composableBuilder(
    column: $table.color,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );
}

class $$MilestonesTableOrderingComposer
    extends Composer<_$AppDatabase, $MilestonesTable> {
  $$MilestonesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get date => $composableBuilder(
    column: $table.date,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get title => $composableBuilder(
    column: $table.title,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get description => $composableBuilder(
    column: $table.description,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get color => $composableBuilder(
    column: $table.color,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$MilestonesTableAnnotationComposer
    extends Composer<_$AppDatabase, $MilestonesTable> {
  $$MilestonesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<DateTime> get date =>
      $composableBuilder(column: $table.date, builder: (column) => column);

  GeneratedColumn<String> get title =>
      $composableBuilder(column: $table.title, builder: (column) => column);

  GeneratedColumn<String> get description => $composableBuilder(
    column: $table.description,
    builder: (column) => column,
  );

  GeneratedColumn<String> get color =>
      $composableBuilder(column: $table.color, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);
}

class $$MilestonesTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $MilestonesTable,
          Milestone,
          $$MilestonesTableFilterComposer,
          $$MilestonesTableOrderingComposer,
          $$MilestonesTableAnnotationComposer,
          $$MilestonesTableCreateCompanionBuilder,
          $$MilestonesTableUpdateCompanionBuilder,
          (
            Milestone,
            BaseReferences<_$AppDatabase, $MilestonesTable, Milestone>,
          ),
          Milestone,
          PrefetchHooks Function()
        > {
  $$MilestonesTableTableManager(_$AppDatabase db, $MilestonesTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$MilestonesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$MilestonesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$MilestonesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<DateTime> date = const Value.absent(),
                Value<String> title = const Value.absent(),
                Value<String?> description = const Value.absent(),
                Value<String> color = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => MilestonesCompanion(
                id: id,
                date: date,
                title: title,
                description: description,
                color: color,
                createdAt: createdAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required DateTime date,
                required String title,
                Value<String?> description = const Value.absent(),
                Value<String> color = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => MilestonesCompanion.insert(
                id: id,
                date: date,
                title: title,
                description: description,
                color: color,
                createdAt: createdAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$MilestonesTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $MilestonesTable,
      Milestone,
      $$MilestonesTableFilterComposer,
      $$MilestonesTableOrderingComposer,
      $$MilestonesTableAnnotationComposer,
      $$MilestonesTableCreateCompanionBuilder,
      $$MilestonesTableUpdateCompanionBuilder,
      (Milestone, BaseReferences<_$AppDatabase, $MilestonesTable, Milestone>),
      Milestone,
      PrefetchHooks Function()
    >;
typedef $$VolumeImportsTableCreateCompanionBuilder =
    VolumeImportsCompanion Function({
      required String id,
      required String name,
      required String rawData,
      Value<String?> columnMapping,
      required int rowCount,
      Value<int> importedCount,
      Value<DateTime> createdAt,
      Value<int> rowid,
    });
typedef $$VolumeImportsTableUpdateCompanionBuilder =
    VolumeImportsCompanion Function({
      Value<String> id,
      Value<String> name,
      Value<String> rawData,
      Value<String?> columnMapping,
      Value<int> rowCount,
      Value<int> importedCount,
      Value<DateTime> createdAt,
      Value<int> rowid,
    });

class $$VolumeImportsTableFilterComposer
    extends Composer<_$AppDatabase, $VolumeImportsTable> {
  $$VolumeImportsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get rawData => $composableBuilder(
    column: $table.rawData,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get columnMapping => $composableBuilder(
    column: $table.columnMapping,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get rowCount => $composableBuilder(
    column: $table.rowCount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get importedCount => $composableBuilder(
    column: $table.importedCount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );
}

class $$VolumeImportsTableOrderingComposer
    extends Composer<_$AppDatabase, $VolumeImportsTable> {
  $$VolumeImportsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get rawData => $composableBuilder(
    column: $table.rawData,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get columnMapping => $composableBuilder(
    column: $table.columnMapping,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get rowCount => $composableBuilder(
    column: $table.rowCount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get importedCount => $composableBuilder(
    column: $table.importedCount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$VolumeImportsTableAnnotationComposer
    extends Composer<_$AppDatabase, $VolumeImportsTable> {
  $$VolumeImportsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get rawData =>
      $composableBuilder(column: $table.rawData, builder: (column) => column);

  GeneratedColumn<String> get columnMapping => $composableBuilder(
    column: $table.columnMapping,
    builder: (column) => column,
  );

  GeneratedColumn<int> get rowCount =>
      $composableBuilder(column: $table.rowCount, builder: (column) => column);

  GeneratedColumn<int> get importedCount => $composableBuilder(
    column: $table.importedCount,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);
}

class $$VolumeImportsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $VolumeImportsTable,
          VolumeImport,
          $$VolumeImportsTableFilterComposer,
          $$VolumeImportsTableOrderingComposer,
          $$VolumeImportsTableAnnotationComposer,
          $$VolumeImportsTableCreateCompanionBuilder,
          $$VolumeImportsTableUpdateCompanionBuilder,
          (
            VolumeImport,
            BaseReferences<_$AppDatabase, $VolumeImportsTable, VolumeImport>,
          ),
          VolumeImport,
          PrefetchHooks Function()
        > {
  $$VolumeImportsTableTableManager(_$AppDatabase db, $VolumeImportsTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$VolumeImportsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$VolumeImportsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$VolumeImportsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<String> rawData = const Value.absent(),
                Value<String?> columnMapping = const Value.absent(),
                Value<int> rowCount = const Value.absent(),
                Value<int> importedCount = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => VolumeImportsCompanion(
                id: id,
                name: name,
                rawData: rawData,
                columnMapping: columnMapping,
                rowCount: rowCount,
                importedCount: importedCount,
                createdAt: createdAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String name,
                required String rawData,
                Value<String?> columnMapping = const Value.absent(),
                required int rowCount,
                Value<int> importedCount = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => VolumeImportsCompanion.insert(
                id: id,
                name: name,
                rawData: rawData,
                columnMapping: columnMapping,
                rowCount: rowCount,
                importedCount: importedCount,
                createdAt: createdAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$VolumeImportsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $VolumeImportsTable,
      VolumeImport,
      $$VolumeImportsTableFilterComposer,
      $$VolumeImportsTableOrderingComposer,
      $$VolumeImportsTableAnnotationComposer,
      $$VolumeImportsTableCreateCompanionBuilder,
      $$VolumeImportsTableUpdateCompanionBuilder,
      (
        VolumeImport,
        BaseReferences<_$AppDatabase, $VolumeImportsTable, VolumeImport>,
      ),
      VolumeImport,
      PrefetchHooks Function()
    >;
typedef $$KitSnapshotsTableCreateCompanionBuilder =
    KitSnapshotsCompanion Function({
      required String id,
      Value<String?> sessionId,
      Value<String?> bowId,
      Value<String?> quiverId,
      required DateTime snapshotDate,
      Value<int?> score,
      Value<int?> maxScore,
      Value<String?> roundName,
      Value<String?> reason,
      Value<String?> bowName,
      Value<String?> bowType,
      Value<String?> bowSettings,
      Value<String?> quiverName,
      Value<String?> arrowSettings,
      Value<String?> notes,
      Value<DateTime> createdAt,
      Value<int> rowid,
    });
typedef $$KitSnapshotsTableUpdateCompanionBuilder =
    KitSnapshotsCompanion Function({
      Value<String> id,
      Value<String?> sessionId,
      Value<String?> bowId,
      Value<String?> quiverId,
      Value<DateTime> snapshotDate,
      Value<int?> score,
      Value<int?> maxScore,
      Value<String?> roundName,
      Value<String?> reason,
      Value<String?> bowName,
      Value<String?> bowType,
      Value<String?> bowSettings,
      Value<String?> quiverName,
      Value<String?> arrowSettings,
      Value<String?> notes,
      Value<DateTime> createdAt,
      Value<int> rowid,
    });

class $$KitSnapshotsTableFilterComposer
    extends Composer<_$AppDatabase, $KitSnapshotsTable> {
  $$KitSnapshotsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get sessionId => $composableBuilder(
    column: $table.sessionId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get bowId => $composableBuilder(
    column: $table.bowId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get quiverId => $composableBuilder(
    column: $table.quiverId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get snapshotDate => $composableBuilder(
    column: $table.snapshotDate,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get score => $composableBuilder(
    column: $table.score,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get maxScore => $composableBuilder(
    column: $table.maxScore,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get roundName => $composableBuilder(
    column: $table.roundName,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get reason => $composableBuilder(
    column: $table.reason,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get bowName => $composableBuilder(
    column: $table.bowName,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get bowType => $composableBuilder(
    column: $table.bowType,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get bowSettings => $composableBuilder(
    column: $table.bowSettings,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get quiverName => $composableBuilder(
    column: $table.quiverName,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get arrowSettings => $composableBuilder(
    column: $table.arrowSettings,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );
}

class $$KitSnapshotsTableOrderingComposer
    extends Composer<_$AppDatabase, $KitSnapshotsTable> {
  $$KitSnapshotsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get sessionId => $composableBuilder(
    column: $table.sessionId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get bowId => $composableBuilder(
    column: $table.bowId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get quiverId => $composableBuilder(
    column: $table.quiverId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get snapshotDate => $composableBuilder(
    column: $table.snapshotDate,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get score => $composableBuilder(
    column: $table.score,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get maxScore => $composableBuilder(
    column: $table.maxScore,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get roundName => $composableBuilder(
    column: $table.roundName,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get reason => $composableBuilder(
    column: $table.reason,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get bowName => $composableBuilder(
    column: $table.bowName,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get bowType => $composableBuilder(
    column: $table.bowType,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get bowSettings => $composableBuilder(
    column: $table.bowSettings,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get quiverName => $composableBuilder(
    column: $table.quiverName,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get arrowSettings => $composableBuilder(
    column: $table.arrowSettings,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$KitSnapshotsTableAnnotationComposer
    extends Composer<_$AppDatabase, $KitSnapshotsTable> {
  $$KitSnapshotsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get sessionId =>
      $composableBuilder(column: $table.sessionId, builder: (column) => column);

  GeneratedColumn<String> get bowId =>
      $composableBuilder(column: $table.bowId, builder: (column) => column);

  GeneratedColumn<String> get quiverId =>
      $composableBuilder(column: $table.quiverId, builder: (column) => column);

  GeneratedColumn<DateTime> get snapshotDate => $composableBuilder(
    column: $table.snapshotDate,
    builder: (column) => column,
  );

  GeneratedColumn<int> get score =>
      $composableBuilder(column: $table.score, builder: (column) => column);

  GeneratedColumn<int> get maxScore =>
      $composableBuilder(column: $table.maxScore, builder: (column) => column);

  GeneratedColumn<String> get roundName =>
      $composableBuilder(column: $table.roundName, builder: (column) => column);

  GeneratedColumn<String> get reason =>
      $composableBuilder(column: $table.reason, builder: (column) => column);

  GeneratedColumn<String> get bowName =>
      $composableBuilder(column: $table.bowName, builder: (column) => column);

  GeneratedColumn<String> get bowType =>
      $composableBuilder(column: $table.bowType, builder: (column) => column);

  GeneratedColumn<String> get bowSettings => $composableBuilder(
    column: $table.bowSettings,
    builder: (column) => column,
  );

  GeneratedColumn<String> get quiverName => $composableBuilder(
    column: $table.quiverName,
    builder: (column) => column,
  );

  GeneratedColumn<String> get arrowSettings => $composableBuilder(
    column: $table.arrowSettings,
    builder: (column) => column,
  );

  GeneratedColumn<String> get notes =>
      $composableBuilder(column: $table.notes, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);
}

class $$KitSnapshotsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $KitSnapshotsTable,
          KitSnapshot,
          $$KitSnapshotsTableFilterComposer,
          $$KitSnapshotsTableOrderingComposer,
          $$KitSnapshotsTableAnnotationComposer,
          $$KitSnapshotsTableCreateCompanionBuilder,
          $$KitSnapshotsTableUpdateCompanionBuilder,
          (
            KitSnapshot,
            BaseReferences<_$AppDatabase, $KitSnapshotsTable, KitSnapshot>,
          ),
          KitSnapshot,
          PrefetchHooks Function()
        > {
  $$KitSnapshotsTableTableManager(_$AppDatabase db, $KitSnapshotsTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$KitSnapshotsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$KitSnapshotsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$KitSnapshotsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String?> sessionId = const Value.absent(),
                Value<String?> bowId = const Value.absent(),
                Value<String?> quiverId = const Value.absent(),
                Value<DateTime> snapshotDate = const Value.absent(),
                Value<int?> score = const Value.absent(),
                Value<int?> maxScore = const Value.absent(),
                Value<String?> roundName = const Value.absent(),
                Value<String?> reason = const Value.absent(),
                Value<String?> bowName = const Value.absent(),
                Value<String?> bowType = const Value.absent(),
                Value<String?> bowSettings = const Value.absent(),
                Value<String?> quiverName = const Value.absent(),
                Value<String?> arrowSettings = const Value.absent(),
                Value<String?> notes = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => KitSnapshotsCompanion(
                id: id,
                sessionId: sessionId,
                bowId: bowId,
                quiverId: quiverId,
                snapshotDate: snapshotDate,
                score: score,
                maxScore: maxScore,
                roundName: roundName,
                reason: reason,
                bowName: bowName,
                bowType: bowType,
                bowSettings: bowSettings,
                quiverName: quiverName,
                arrowSettings: arrowSettings,
                notes: notes,
                createdAt: createdAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                Value<String?> sessionId = const Value.absent(),
                Value<String?> bowId = const Value.absent(),
                Value<String?> quiverId = const Value.absent(),
                required DateTime snapshotDate,
                Value<int?> score = const Value.absent(),
                Value<int?> maxScore = const Value.absent(),
                Value<String?> roundName = const Value.absent(),
                Value<String?> reason = const Value.absent(),
                Value<String?> bowName = const Value.absent(),
                Value<String?> bowType = const Value.absent(),
                Value<String?> bowSettings = const Value.absent(),
                Value<String?> quiverName = const Value.absent(),
                Value<String?> arrowSettings = const Value.absent(),
                Value<String?> notes = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => KitSnapshotsCompanion.insert(
                id: id,
                sessionId: sessionId,
                bowId: bowId,
                quiverId: quiverId,
                snapshotDate: snapshotDate,
                score: score,
                maxScore: maxScore,
                roundName: roundName,
                reason: reason,
                bowName: bowName,
                bowType: bowType,
                bowSettings: bowSettings,
                quiverName: quiverName,
                arrowSettings: arrowSettings,
                notes: notes,
                createdAt: createdAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$KitSnapshotsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $KitSnapshotsTable,
      KitSnapshot,
      $$KitSnapshotsTableFilterComposer,
      $$KitSnapshotsTableOrderingComposer,
      $$KitSnapshotsTableAnnotationComposer,
      $$KitSnapshotsTableCreateCompanionBuilder,
      $$KitSnapshotsTableUpdateCompanionBuilder,
      (
        KitSnapshot,
        BaseReferences<_$AppDatabase, $KitSnapshotsTable, KitSnapshot>,
      ),
      KitSnapshot,
      PrefetchHooks Function()
    >;
typedef $$TuningSessionsTableCreateCompanionBuilder =
    TuningSessionsCompanion Function({
      required String id,
      Value<String?> bowId,
      required DateTime date,
      required String bowType,
      required String tuningType,
      Value<String?> results,
      Value<String?> notes,
      Value<DateTime> createdAt,
      Value<int> rowid,
    });
typedef $$TuningSessionsTableUpdateCompanionBuilder =
    TuningSessionsCompanion Function({
      Value<String> id,
      Value<String?> bowId,
      Value<DateTime> date,
      Value<String> bowType,
      Value<String> tuningType,
      Value<String?> results,
      Value<String?> notes,
      Value<DateTime> createdAt,
      Value<int> rowid,
    });

final class $$TuningSessionsTableReferences
    extends BaseReferences<_$AppDatabase, $TuningSessionsTable, TuningSession> {
  $$TuningSessionsTableReferences(
    super.$_db,
    super.$_table,
    super.$_typedResult,
  );

  static $BowsTable _bowIdTable(_$AppDatabase db) => db.bows.createAlias(
    $_aliasNameGenerator(db.tuningSessions.bowId, db.bows.id),
  );

  $$BowsTableProcessedTableManager? get bowId {
    final $_column = $_itemColumn<String>('bow_id');
    if ($_column == null) return null;
    final manager = $$BowsTableTableManager(
      $_db,
      $_db.bows,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_bowIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$TuningSessionsTableFilterComposer
    extends Composer<_$AppDatabase, $TuningSessionsTable> {
  $$TuningSessionsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get date => $composableBuilder(
    column: $table.date,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get bowType => $composableBuilder(
    column: $table.bowType,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get tuningType => $composableBuilder(
    column: $table.tuningType,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get results => $composableBuilder(
    column: $table.results,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  $$BowsTableFilterComposer get bowId {
    final $$BowsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.bowId,
      referencedTable: $db.bows,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$BowsTableFilterComposer(
            $db: $db,
            $table: $db.bows,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$TuningSessionsTableOrderingComposer
    extends Composer<_$AppDatabase, $TuningSessionsTable> {
  $$TuningSessionsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get date => $composableBuilder(
    column: $table.date,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get bowType => $composableBuilder(
    column: $table.bowType,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get tuningType => $composableBuilder(
    column: $table.tuningType,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get results => $composableBuilder(
    column: $table.results,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  $$BowsTableOrderingComposer get bowId {
    final $$BowsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.bowId,
      referencedTable: $db.bows,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$BowsTableOrderingComposer(
            $db: $db,
            $table: $db.bows,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$TuningSessionsTableAnnotationComposer
    extends Composer<_$AppDatabase, $TuningSessionsTable> {
  $$TuningSessionsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<DateTime> get date =>
      $composableBuilder(column: $table.date, builder: (column) => column);

  GeneratedColumn<String> get bowType =>
      $composableBuilder(column: $table.bowType, builder: (column) => column);

  GeneratedColumn<String> get tuningType => $composableBuilder(
    column: $table.tuningType,
    builder: (column) => column,
  );

  GeneratedColumn<String> get results =>
      $composableBuilder(column: $table.results, builder: (column) => column);

  GeneratedColumn<String> get notes =>
      $composableBuilder(column: $table.notes, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  $$BowsTableAnnotationComposer get bowId {
    final $$BowsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.bowId,
      referencedTable: $db.bows,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$BowsTableAnnotationComposer(
            $db: $db,
            $table: $db.bows,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$TuningSessionsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $TuningSessionsTable,
          TuningSession,
          $$TuningSessionsTableFilterComposer,
          $$TuningSessionsTableOrderingComposer,
          $$TuningSessionsTableAnnotationComposer,
          $$TuningSessionsTableCreateCompanionBuilder,
          $$TuningSessionsTableUpdateCompanionBuilder,
          (TuningSession, $$TuningSessionsTableReferences),
          TuningSession,
          PrefetchHooks Function({bool bowId})
        > {
  $$TuningSessionsTableTableManager(
    _$AppDatabase db,
    $TuningSessionsTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$TuningSessionsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$TuningSessionsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$TuningSessionsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String?> bowId = const Value.absent(),
                Value<DateTime> date = const Value.absent(),
                Value<String> bowType = const Value.absent(),
                Value<String> tuningType = const Value.absent(),
                Value<String?> results = const Value.absent(),
                Value<String?> notes = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => TuningSessionsCompanion(
                id: id,
                bowId: bowId,
                date: date,
                bowType: bowType,
                tuningType: tuningType,
                results: results,
                notes: notes,
                createdAt: createdAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                Value<String?> bowId = const Value.absent(),
                required DateTime date,
                required String bowType,
                required String tuningType,
                Value<String?> results = const Value.absent(),
                Value<String?> notes = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => TuningSessionsCompanion.insert(
                id: id,
                bowId: bowId,
                date: date,
                bowType: bowType,
                tuningType: tuningType,
                results: results,
                notes: notes,
                createdAt: createdAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$TuningSessionsTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback: ({bowId = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins:
                  <
                    T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic
                    >
                  >(state) {
                    if (bowId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.bowId,
                                referencedTable: $$TuningSessionsTableReferences
                                    ._bowIdTable(db),
                                referencedColumn:
                                    $$TuningSessionsTableReferences
                                        ._bowIdTable(db)
                                        .id,
                              )
                              as T;
                    }

                    return state;
                  },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ),
      );
}

typedef $$TuningSessionsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $TuningSessionsTable,
      TuningSession,
      $$TuningSessionsTableFilterComposer,
      $$TuningSessionsTableOrderingComposer,
      $$TuningSessionsTableAnnotationComposer,
      $$TuningSessionsTableCreateCompanionBuilder,
      $$TuningSessionsTableUpdateCompanionBuilder,
      (TuningSession, $$TuningSessionsTableReferences),
      TuningSession,
      PrefetchHooks Function({bool bowId})
    >;
typedef $$SkillLevelsTableCreateCompanionBuilder =
    SkillLevelsCompanion Function({
      required String id,
      required String name,
      Value<String?> description,
      Value<int> currentLevel,
      Value<int> currentXp,
      Value<DateTime?> lastLevelUpAt,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<int> rowid,
    });
typedef $$SkillLevelsTableUpdateCompanionBuilder =
    SkillLevelsCompanion Function({
      Value<String> id,
      Value<String> name,
      Value<String?> description,
      Value<int> currentLevel,
      Value<int> currentXp,
      Value<DateTime?> lastLevelUpAt,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<int> rowid,
    });

class $$SkillLevelsTableFilterComposer
    extends Composer<_$AppDatabase, $SkillLevelsTable> {
  $$SkillLevelsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get description => $composableBuilder(
    column: $table.description,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get currentLevel => $composableBuilder(
    column: $table.currentLevel,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get currentXp => $composableBuilder(
    column: $table.currentXp,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get lastLevelUpAt => $composableBuilder(
    column: $table.lastLevelUpAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );
}

class $$SkillLevelsTableOrderingComposer
    extends Composer<_$AppDatabase, $SkillLevelsTable> {
  $$SkillLevelsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get description => $composableBuilder(
    column: $table.description,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get currentLevel => $composableBuilder(
    column: $table.currentLevel,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get currentXp => $composableBuilder(
    column: $table.currentXp,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get lastLevelUpAt => $composableBuilder(
    column: $table.lastLevelUpAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$SkillLevelsTableAnnotationComposer
    extends Composer<_$AppDatabase, $SkillLevelsTable> {
  $$SkillLevelsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get description => $composableBuilder(
    column: $table.description,
    builder: (column) => column,
  );

  GeneratedColumn<int> get currentLevel => $composableBuilder(
    column: $table.currentLevel,
    builder: (column) => column,
  );

  GeneratedColumn<int> get currentXp =>
      $composableBuilder(column: $table.currentXp, builder: (column) => column);

  GeneratedColumn<DateTime> get lastLevelUpAt => $composableBuilder(
    column: $table.lastLevelUpAt,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);
}

class $$SkillLevelsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $SkillLevelsTable,
          SkillLevel,
          $$SkillLevelsTableFilterComposer,
          $$SkillLevelsTableOrderingComposer,
          $$SkillLevelsTableAnnotationComposer,
          $$SkillLevelsTableCreateCompanionBuilder,
          $$SkillLevelsTableUpdateCompanionBuilder,
          (
            SkillLevel,
            BaseReferences<_$AppDatabase, $SkillLevelsTable, SkillLevel>,
          ),
          SkillLevel,
          PrefetchHooks Function()
        > {
  $$SkillLevelsTableTableManager(_$AppDatabase db, $SkillLevelsTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$SkillLevelsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$SkillLevelsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$SkillLevelsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<String?> description = const Value.absent(),
                Value<int> currentLevel = const Value.absent(),
                Value<int> currentXp = const Value.absent(),
                Value<DateTime?> lastLevelUpAt = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => SkillLevelsCompanion(
                id: id,
                name: name,
                description: description,
                currentLevel: currentLevel,
                currentXp: currentXp,
                lastLevelUpAt: lastLevelUpAt,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String name,
                Value<String?> description = const Value.absent(),
                Value<int> currentLevel = const Value.absent(),
                Value<int> currentXp = const Value.absent(),
                Value<DateTime?> lastLevelUpAt = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => SkillLevelsCompanion.insert(
                id: id,
                name: name,
                description: description,
                currentLevel: currentLevel,
                currentXp: currentXp,
                lastLevelUpAt: lastLevelUpAt,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$SkillLevelsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $SkillLevelsTable,
      SkillLevel,
      $$SkillLevelsTableFilterComposer,
      $$SkillLevelsTableOrderingComposer,
      $$SkillLevelsTableAnnotationComposer,
      $$SkillLevelsTableCreateCompanionBuilder,
      $$SkillLevelsTableUpdateCompanionBuilder,
      (
        SkillLevel,
        BaseReferences<_$AppDatabase, $SkillLevelsTable, SkillLevel>,
      ),
      SkillLevel,
      PrefetchHooks Function()
    >;
typedef $$XpHistoryTableCreateCompanionBuilder =
    XpHistoryCompanion Function({
      required String id,
      required String skillId,
      required int xpAmount,
      required String source,
      Value<String?> sourceId,
      Value<String?> reason,
      Value<DateTime> earnedAt,
      Value<int> rowid,
    });
typedef $$XpHistoryTableUpdateCompanionBuilder =
    XpHistoryCompanion Function({
      Value<String> id,
      Value<String> skillId,
      Value<int> xpAmount,
      Value<String> source,
      Value<String?> sourceId,
      Value<String?> reason,
      Value<DateTime> earnedAt,
      Value<int> rowid,
    });

class $$XpHistoryTableFilterComposer
    extends Composer<_$AppDatabase, $XpHistoryTable> {
  $$XpHistoryTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get skillId => $composableBuilder(
    column: $table.skillId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get xpAmount => $composableBuilder(
    column: $table.xpAmount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get source => $composableBuilder(
    column: $table.source,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get sourceId => $composableBuilder(
    column: $table.sourceId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get reason => $composableBuilder(
    column: $table.reason,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get earnedAt => $composableBuilder(
    column: $table.earnedAt,
    builder: (column) => ColumnFilters(column),
  );
}

class $$XpHistoryTableOrderingComposer
    extends Composer<_$AppDatabase, $XpHistoryTable> {
  $$XpHistoryTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get skillId => $composableBuilder(
    column: $table.skillId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get xpAmount => $composableBuilder(
    column: $table.xpAmount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get source => $composableBuilder(
    column: $table.source,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get sourceId => $composableBuilder(
    column: $table.sourceId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get reason => $composableBuilder(
    column: $table.reason,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get earnedAt => $composableBuilder(
    column: $table.earnedAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$XpHistoryTableAnnotationComposer
    extends Composer<_$AppDatabase, $XpHistoryTable> {
  $$XpHistoryTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get skillId =>
      $composableBuilder(column: $table.skillId, builder: (column) => column);

  GeneratedColumn<int> get xpAmount =>
      $composableBuilder(column: $table.xpAmount, builder: (column) => column);

  GeneratedColumn<String> get source =>
      $composableBuilder(column: $table.source, builder: (column) => column);

  GeneratedColumn<String> get sourceId =>
      $composableBuilder(column: $table.sourceId, builder: (column) => column);

  GeneratedColumn<String> get reason =>
      $composableBuilder(column: $table.reason, builder: (column) => column);

  GeneratedColumn<DateTime> get earnedAt =>
      $composableBuilder(column: $table.earnedAt, builder: (column) => column);
}

class $$XpHistoryTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $XpHistoryTable,
          XpHistoryData,
          $$XpHistoryTableFilterComposer,
          $$XpHistoryTableOrderingComposer,
          $$XpHistoryTableAnnotationComposer,
          $$XpHistoryTableCreateCompanionBuilder,
          $$XpHistoryTableUpdateCompanionBuilder,
          (
            XpHistoryData,
            BaseReferences<_$AppDatabase, $XpHistoryTable, XpHistoryData>,
          ),
          XpHistoryData,
          PrefetchHooks Function()
        > {
  $$XpHistoryTableTableManager(_$AppDatabase db, $XpHistoryTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$XpHistoryTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$XpHistoryTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$XpHistoryTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> skillId = const Value.absent(),
                Value<int> xpAmount = const Value.absent(),
                Value<String> source = const Value.absent(),
                Value<String?> sourceId = const Value.absent(),
                Value<String?> reason = const Value.absent(),
                Value<DateTime> earnedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => XpHistoryCompanion(
                id: id,
                skillId: skillId,
                xpAmount: xpAmount,
                source: source,
                sourceId: sourceId,
                reason: reason,
                earnedAt: earnedAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String skillId,
                required int xpAmount,
                required String source,
                Value<String?> sourceId = const Value.absent(),
                Value<String?> reason = const Value.absent(),
                Value<DateTime> earnedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => XpHistoryCompanion.insert(
                id: id,
                skillId: skillId,
                xpAmount: xpAmount,
                source: source,
                sourceId: sourceId,
                reason: reason,
                earnedAt: earnedAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$XpHistoryTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $XpHistoryTable,
      XpHistoryData,
      $$XpHistoryTableFilterComposer,
      $$XpHistoryTableOrderingComposer,
      $$XpHistoryTableAnnotationComposer,
      $$XpHistoryTableCreateCompanionBuilder,
      $$XpHistoryTableUpdateCompanionBuilder,
      (
        XpHistoryData,
        BaseReferences<_$AppDatabase, $XpHistoryTable, XpHistoryData>,
      ),
      XpHistoryData,
      PrefetchHooks Function()
    >;
typedef $$SightMarksTableCreateCompanionBuilder =
    SightMarksCompanion Function({
      required String id,
      required String bowId,
      required double distance,
      Value<String> unit,
      required String sightValue,
      Value<String?> weatherData,
      Value<double?> elevationDelta,
      Value<double?> slopeAngle,
      Value<String?> sessionId,
      Value<int?> endNumber,
      Value<int?> shotCount,
      Value<double?> confidenceScore,
      Value<DateTime> recordedAt,
      Value<DateTime?> updatedAt,
      Value<DateTime?> deletedAt,
      Value<int> rowid,
    });
typedef $$SightMarksTableUpdateCompanionBuilder =
    SightMarksCompanion Function({
      Value<String> id,
      Value<String> bowId,
      Value<double> distance,
      Value<String> unit,
      Value<String> sightValue,
      Value<String?> weatherData,
      Value<double?> elevationDelta,
      Value<double?> slopeAngle,
      Value<String?> sessionId,
      Value<int?> endNumber,
      Value<int?> shotCount,
      Value<double?> confidenceScore,
      Value<DateTime> recordedAt,
      Value<DateTime?> updatedAt,
      Value<DateTime?> deletedAt,
      Value<int> rowid,
    });

final class $$SightMarksTableReferences
    extends BaseReferences<_$AppDatabase, $SightMarksTable, SightMark> {
  $$SightMarksTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $BowsTable _bowIdTable(_$AppDatabase db) => db.bows.createAlias(
    $_aliasNameGenerator(db.sightMarks.bowId, db.bows.id),
  );

  $$BowsTableProcessedTableManager get bowId {
    final $_column = $_itemColumn<String>('bow_id')!;

    final manager = $$BowsTableTableManager(
      $_db,
      $_db.bows,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_bowIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$SightMarksTableFilterComposer
    extends Composer<_$AppDatabase, $SightMarksTable> {
  $$SightMarksTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get distance => $composableBuilder(
    column: $table.distance,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get unit => $composableBuilder(
    column: $table.unit,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get sightValue => $composableBuilder(
    column: $table.sightValue,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get weatherData => $composableBuilder(
    column: $table.weatherData,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get elevationDelta => $composableBuilder(
    column: $table.elevationDelta,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get slopeAngle => $composableBuilder(
    column: $table.slopeAngle,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get sessionId => $composableBuilder(
    column: $table.sessionId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get endNumber => $composableBuilder(
    column: $table.endNumber,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get shotCount => $composableBuilder(
    column: $table.shotCount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get confidenceScore => $composableBuilder(
    column: $table.confidenceScore,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get recordedAt => $composableBuilder(
    column: $table.recordedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get deletedAt => $composableBuilder(
    column: $table.deletedAt,
    builder: (column) => ColumnFilters(column),
  );

  $$BowsTableFilterComposer get bowId {
    final $$BowsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.bowId,
      referencedTable: $db.bows,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$BowsTableFilterComposer(
            $db: $db,
            $table: $db.bows,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$SightMarksTableOrderingComposer
    extends Composer<_$AppDatabase, $SightMarksTable> {
  $$SightMarksTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get distance => $composableBuilder(
    column: $table.distance,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get unit => $composableBuilder(
    column: $table.unit,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get sightValue => $composableBuilder(
    column: $table.sightValue,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get weatherData => $composableBuilder(
    column: $table.weatherData,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get elevationDelta => $composableBuilder(
    column: $table.elevationDelta,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get slopeAngle => $composableBuilder(
    column: $table.slopeAngle,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get sessionId => $composableBuilder(
    column: $table.sessionId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get endNumber => $composableBuilder(
    column: $table.endNumber,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get shotCount => $composableBuilder(
    column: $table.shotCount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get confidenceScore => $composableBuilder(
    column: $table.confidenceScore,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get recordedAt => $composableBuilder(
    column: $table.recordedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get deletedAt => $composableBuilder(
    column: $table.deletedAt,
    builder: (column) => ColumnOrderings(column),
  );

  $$BowsTableOrderingComposer get bowId {
    final $$BowsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.bowId,
      referencedTable: $db.bows,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$BowsTableOrderingComposer(
            $db: $db,
            $table: $db.bows,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$SightMarksTableAnnotationComposer
    extends Composer<_$AppDatabase, $SightMarksTable> {
  $$SightMarksTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<double> get distance =>
      $composableBuilder(column: $table.distance, builder: (column) => column);

  GeneratedColumn<String> get unit =>
      $composableBuilder(column: $table.unit, builder: (column) => column);

  GeneratedColumn<String> get sightValue => $composableBuilder(
    column: $table.sightValue,
    builder: (column) => column,
  );

  GeneratedColumn<String> get weatherData => $composableBuilder(
    column: $table.weatherData,
    builder: (column) => column,
  );

  GeneratedColumn<double> get elevationDelta => $composableBuilder(
    column: $table.elevationDelta,
    builder: (column) => column,
  );

  GeneratedColumn<double> get slopeAngle => $composableBuilder(
    column: $table.slopeAngle,
    builder: (column) => column,
  );

  GeneratedColumn<String> get sessionId =>
      $composableBuilder(column: $table.sessionId, builder: (column) => column);

  GeneratedColumn<int> get endNumber =>
      $composableBuilder(column: $table.endNumber, builder: (column) => column);

  GeneratedColumn<int> get shotCount =>
      $composableBuilder(column: $table.shotCount, builder: (column) => column);

  GeneratedColumn<double> get confidenceScore => $composableBuilder(
    column: $table.confidenceScore,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get recordedAt => $composableBuilder(
    column: $table.recordedAt,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  GeneratedColumn<DateTime> get deletedAt =>
      $composableBuilder(column: $table.deletedAt, builder: (column) => column);

  $$BowsTableAnnotationComposer get bowId {
    final $$BowsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.bowId,
      referencedTable: $db.bows,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$BowsTableAnnotationComposer(
            $db: $db,
            $table: $db.bows,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$SightMarksTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $SightMarksTable,
          SightMark,
          $$SightMarksTableFilterComposer,
          $$SightMarksTableOrderingComposer,
          $$SightMarksTableAnnotationComposer,
          $$SightMarksTableCreateCompanionBuilder,
          $$SightMarksTableUpdateCompanionBuilder,
          (SightMark, $$SightMarksTableReferences),
          SightMark,
          PrefetchHooks Function({bool bowId})
        > {
  $$SightMarksTableTableManager(_$AppDatabase db, $SightMarksTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$SightMarksTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$SightMarksTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$SightMarksTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> bowId = const Value.absent(),
                Value<double> distance = const Value.absent(),
                Value<String> unit = const Value.absent(),
                Value<String> sightValue = const Value.absent(),
                Value<String?> weatherData = const Value.absent(),
                Value<double?> elevationDelta = const Value.absent(),
                Value<double?> slopeAngle = const Value.absent(),
                Value<String?> sessionId = const Value.absent(),
                Value<int?> endNumber = const Value.absent(),
                Value<int?> shotCount = const Value.absent(),
                Value<double?> confidenceScore = const Value.absent(),
                Value<DateTime> recordedAt = const Value.absent(),
                Value<DateTime?> updatedAt = const Value.absent(),
                Value<DateTime?> deletedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => SightMarksCompanion(
                id: id,
                bowId: bowId,
                distance: distance,
                unit: unit,
                sightValue: sightValue,
                weatherData: weatherData,
                elevationDelta: elevationDelta,
                slopeAngle: slopeAngle,
                sessionId: sessionId,
                endNumber: endNumber,
                shotCount: shotCount,
                confidenceScore: confidenceScore,
                recordedAt: recordedAt,
                updatedAt: updatedAt,
                deletedAt: deletedAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String bowId,
                required double distance,
                Value<String> unit = const Value.absent(),
                required String sightValue,
                Value<String?> weatherData = const Value.absent(),
                Value<double?> elevationDelta = const Value.absent(),
                Value<double?> slopeAngle = const Value.absent(),
                Value<String?> sessionId = const Value.absent(),
                Value<int?> endNumber = const Value.absent(),
                Value<int?> shotCount = const Value.absent(),
                Value<double?> confidenceScore = const Value.absent(),
                Value<DateTime> recordedAt = const Value.absent(),
                Value<DateTime?> updatedAt = const Value.absent(),
                Value<DateTime?> deletedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => SightMarksCompanion.insert(
                id: id,
                bowId: bowId,
                distance: distance,
                unit: unit,
                sightValue: sightValue,
                weatherData: weatherData,
                elevationDelta: elevationDelta,
                slopeAngle: slopeAngle,
                sessionId: sessionId,
                endNumber: endNumber,
                shotCount: shotCount,
                confidenceScore: confidenceScore,
                recordedAt: recordedAt,
                updatedAt: updatedAt,
                deletedAt: deletedAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$SightMarksTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback: ({bowId = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins:
                  <
                    T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic
                    >
                  >(state) {
                    if (bowId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.bowId,
                                referencedTable: $$SightMarksTableReferences
                                    ._bowIdTable(db),
                                referencedColumn: $$SightMarksTableReferences
                                    ._bowIdTable(db)
                                    .id,
                              )
                              as T;
                    }

                    return state;
                  },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ),
      );
}

typedef $$SightMarksTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $SightMarksTable,
      SightMark,
      $$SightMarksTableFilterComposer,
      $$SightMarksTableOrderingComposer,
      $$SightMarksTableAnnotationComposer,
      $$SightMarksTableCreateCompanionBuilder,
      $$SightMarksTableUpdateCompanionBuilder,
      (SightMark, $$SightMarksTableReferences),
      SightMark,
      PrefetchHooks Function({bool bowId})
    >;
typedef $$SightMarkPreferencesTableTableCreateCompanionBuilder =
    SightMarkPreferencesTableCompanion Function({
      required String bowId,
      Value<String> notationStyle,
      Value<int> decimalPlaces,
      Value<DateTime> createdAt,
      Value<DateTime?> updatedAt,
      Value<int> rowid,
    });
typedef $$SightMarkPreferencesTableTableUpdateCompanionBuilder =
    SightMarkPreferencesTableCompanion Function({
      Value<String> bowId,
      Value<String> notationStyle,
      Value<int> decimalPlaces,
      Value<DateTime> createdAt,
      Value<DateTime?> updatedAt,
      Value<int> rowid,
    });

final class $$SightMarkPreferencesTableTableReferences
    extends
        BaseReferences<
          _$AppDatabase,
          $SightMarkPreferencesTableTable,
          SightMarkPreferencesTableData
        > {
  $$SightMarkPreferencesTableTableReferences(
    super.$_db,
    super.$_table,
    super.$_typedResult,
  );

  static $BowsTable _bowIdTable(_$AppDatabase db) => db.bows.createAlias(
    $_aliasNameGenerator(db.sightMarkPreferencesTable.bowId, db.bows.id),
  );

  $$BowsTableProcessedTableManager get bowId {
    final $_column = $_itemColumn<String>('bow_id')!;

    final manager = $$BowsTableTableManager(
      $_db,
      $_db.bows,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_bowIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$SightMarkPreferencesTableTableFilterComposer
    extends Composer<_$AppDatabase, $SightMarkPreferencesTableTable> {
  $$SightMarkPreferencesTableTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get notationStyle => $composableBuilder(
    column: $table.notationStyle,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get decimalPlaces => $composableBuilder(
    column: $table.decimalPlaces,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );

  $$BowsTableFilterComposer get bowId {
    final $$BowsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.bowId,
      referencedTable: $db.bows,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$BowsTableFilterComposer(
            $db: $db,
            $table: $db.bows,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$SightMarkPreferencesTableTableOrderingComposer
    extends Composer<_$AppDatabase, $SightMarkPreferencesTableTable> {
  $$SightMarkPreferencesTableTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get notationStyle => $composableBuilder(
    column: $table.notationStyle,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get decimalPlaces => $composableBuilder(
    column: $table.decimalPlaces,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  $$BowsTableOrderingComposer get bowId {
    final $$BowsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.bowId,
      referencedTable: $db.bows,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$BowsTableOrderingComposer(
            $db: $db,
            $table: $db.bows,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$SightMarkPreferencesTableTableAnnotationComposer
    extends Composer<_$AppDatabase, $SightMarkPreferencesTableTable> {
  $$SightMarkPreferencesTableTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get notationStyle => $composableBuilder(
    column: $table.notationStyle,
    builder: (column) => column,
  );

  GeneratedColumn<int> get decimalPlaces => $composableBuilder(
    column: $table.decimalPlaces,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  $$BowsTableAnnotationComposer get bowId {
    final $$BowsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.bowId,
      referencedTable: $db.bows,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$BowsTableAnnotationComposer(
            $db: $db,
            $table: $db.bows,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$SightMarkPreferencesTableTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $SightMarkPreferencesTableTable,
          SightMarkPreferencesTableData,
          $$SightMarkPreferencesTableTableFilterComposer,
          $$SightMarkPreferencesTableTableOrderingComposer,
          $$SightMarkPreferencesTableTableAnnotationComposer,
          $$SightMarkPreferencesTableTableCreateCompanionBuilder,
          $$SightMarkPreferencesTableTableUpdateCompanionBuilder,
          (
            SightMarkPreferencesTableData,
            $$SightMarkPreferencesTableTableReferences,
          ),
          SightMarkPreferencesTableData,
          PrefetchHooks Function({bool bowId})
        > {
  $$SightMarkPreferencesTableTableTableManager(
    _$AppDatabase db,
    $SightMarkPreferencesTableTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$SightMarkPreferencesTableTableFilterComposer(
                $db: db,
                $table: table,
              ),
          createOrderingComposer: () =>
              $$SightMarkPreferencesTableTableOrderingComposer(
                $db: db,
                $table: table,
              ),
          createComputedFieldComposer: () =>
              $$SightMarkPreferencesTableTableAnnotationComposer(
                $db: db,
                $table: table,
              ),
          updateCompanionCallback:
              ({
                Value<String> bowId = const Value.absent(),
                Value<String> notationStyle = const Value.absent(),
                Value<int> decimalPlaces = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime?> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => SightMarkPreferencesTableCompanion(
                bowId: bowId,
                notationStyle: notationStyle,
                decimalPlaces: decimalPlaces,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String bowId,
                Value<String> notationStyle = const Value.absent(),
                Value<int> decimalPlaces = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime?> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => SightMarkPreferencesTableCompanion.insert(
                bowId: bowId,
                notationStyle: notationStyle,
                decimalPlaces: decimalPlaces,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$SightMarkPreferencesTableTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback: ({bowId = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins:
                  <
                    T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic
                    >
                  >(state) {
                    if (bowId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.bowId,
                                referencedTable:
                                    $$SightMarkPreferencesTableTableReferences
                                        ._bowIdTable(db),
                                referencedColumn:
                                    $$SightMarkPreferencesTableTableReferences
                                        ._bowIdTable(db)
                                        .id,
                              )
                              as T;
                    }

                    return state;
                  },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ),
      );
}

typedef $$SightMarkPreferencesTableTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $SightMarkPreferencesTableTable,
      SightMarkPreferencesTableData,
      $$SightMarkPreferencesTableTableFilterComposer,
      $$SightMarkPreferencesTableTableOrderingComposer,
      $$SightMarkPreferencesTableTableAnnotationComposer,
      $$SightMarkPreferencesTableTableCreateCompanionBuilder,
      $$SightMarkPreferencesTableTableUpdateCompanionBuilder,
      (
        SightMarkPreferencesTableData,
        $$SightMarkPreferencesTableTableReferences,
      ),
      SightMarkPreferencesTableData,
      PrefetchHooks Function({bool bowId})
    >;
typedef $$RegisteredTargetsTableCreateCompanionBuilder =
    RegisteredTargetsCompanion Function({
      required String id,
      required String targetType,
      required String imagePath,
      Value<bool> isTripleSpot,
      Value<DateTime> createdAt,
      Value<int> rowid,
    });
typedef $$RegisteredTargetsTableUpdateCompanionBuilder =
    RegisteredTargetsCompanion Function({
      Value<String> id,
      Value<String> targetType,
      Value<String> imagePath,
      Value<bool> isTripleSpot,
      Value<DateTime> createdAt,
      Value<int> rowid,
    });

class $$RegisteredTargetsTableFilterComposer
    extends Composer<_$AppDatabase, $RegisteredTargetsTable> {
  $$RegisteredTargetsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get targetType => $composableBuilder(
    column: $table.targetType,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get imagePath => $composableBuilder(
    column: $table.imagePath,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isTripleSpot => $composableBuilder(
    column: $table.isTripleSpot,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );
}

class $$RegisteredTargetsTableOrderingComposer
    extends Composer<_$AppDatabase, $RegisteredTargetsTable> {
  $$RegisteredTargetsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get targetType => $composableBuilder(
    column: $table.targetType,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get imagePath => $composableBuilder(
    column: $table.imagePath,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isTripleSpot => $composableBuilder(
    column: $table.isTripleSpot,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$RegisteredTargetsTableAnnotationComposer
    extends Composer<_$AppDatabase, $RegisteredTargetsTable> {
  $$RegisteredTargetsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get targetType => $composableBuilder(
    column: $table.targetType,
    builder: (column) => column,
  );

  GeneratedColumn<String> get imagePath =>
      $composableBuilder(column: $table.imagePath, builder: (column) => column);

  GeneratedColumn<bool> get isTripleSpot => $composableBuilder(
    column: $table.isTripleSpot,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);
}

class $$RegisteredTargetsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $RegisteredTargetsTable,
          RegisteredTarget,
          $$RegisteredTargetsTableFilterComposer,
          $$RegisteredTargetsTableOrderingComposer,
          $$RegisteredTargetsTableAnnotationComposer,
          $$RegisteredTargetsTableCreateCompanionBuilder,
          $$RegisteredTargetsTableUpdateCompanionBuilder,
          (
            RegisteredTarget,
            BaseReferences<
              _$AppDatabase,
              $RegisteredTargetsTable,
              RegisteredTarget
            >,
          ),
          RegisteredTarget,
          PrefetchHooks Function()
        > {
  $$RegisteredTargetsTableTableManager(
    _$AppDatabase db,
    $RegisteredTargetsTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$RegisteredTargetsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$RegisteredTargetsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$RegisteredTargetsTableAnnotationComposer(
                $db: db,
                $table: table,
              ),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> targetType = const Value.absent(),
                Value<String> imagePath = const Value.absent(),
                Value<bool> isTripleSpot = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => RegisteredTargetsCompanion(
                id: id,
                targetType: targetType,
                imagePath: imagePath,
                isTripleSpot: isTripleSpot,
                createdAt: createdAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String targetType,
                required String imagePath,
                Value<bool> isTripleSpot = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => RegisteredTargetsCompanion.insert(
                id: id,
                targetType: targetType,
                imagePath: imagePath,
                isTripleSpot: isTripleSpot,
                createdAt: createdAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$RegisteredTargetsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $RegisteredTargetsTable,
      RegisteredTarget,
      $$RegisteredTargetsTableFilterComposer,
      $$RegisteredTargetsTableOrderingComposer,
      $$RegisteredTargetsTableAnnotationComposer,
      $$RegisteredTargetsTableCreateCompanionBuilder,
      $$RegisteredTargetsTableUpdateCompanionBuilder,
      (
        RegisteredTarget,
        BaseReferences<
          _$AppDatabase,
          $RegisteredTargetsTable,
          RegisteredTarget
        >,
      ),
      RegisteredTarget,
      PrefetchHooks Function()
    >;
typedef $$AutoPlotUsageTableCreateCompanionBuilder =
    AutoPlotUsageCompanion Function({
      required String id,
      required String yearMonth,
      Value<int> scanCount,
      Value<int> rowid,
    });
typedef $$AutoPlotUsageTableUpdateCompanionBuilder =
    AutoPlotUsageCompanion Function({
      Value<String> id,
      Value<String> yearMonth,
      Value<int> scanCount,
      Value<int> rowid,
    });

class $$AutoPlotUsageTableFilterComposer
    extends Composer<_$AppDatabase, $AutoPlotUsageTable> {
  $$AutoPlotUsageTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get yearMonth => $composableBuilder(
    column: $table.yearMonth,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get scanCount => $composableBuilder(
    column: $table.scanCount,
    builder: (column) => ColumnFilters(column),
  );
}

class $$AutoPlotUsageTableOrderingComposer
    extends Composer<_$AppDatabase, $AutoPlotUsageTable> {
  $$AutoPlotUsageTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get yearMonth => $composableBuilder(
    column: $table.yearMonth,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get scanCount => $composableBuilder(
    column: $table.scanCount,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$AutoPlotUsageTableAnnotationComposer
    extends Composer<_$AppDatabase, $AutoPlotUsageTable> {
  $$AutoPlotUsageTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get yearMonth =>
      $composableBuilder(column: $table.yearMonth, builder: (column) => column);

  GeneratedColumn<int> get scanCount =>
      $composableBuilder(column: $table.scanCount, builder: (column) => column);
}

class $$AutoPlotUsageTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $AutoPlotUsageTable,
          AutoPlotUsageData,
          $$AutoPlotUsageTableFilterComposer,
          $$AutoPlotUsageTableOrderingComposer,
          $$AutoPlotUsageTableAnnotationComposer,
          $$AutoPlotUsageTableCreateCompanionBuilder,
          $$AutoPlotUsageTableUpdateCompanionBuilder,
          (
            AutoPlotUsageData,
            BaseReferences<
              _$AppDatabase,
              $AutoPlotUsageTable,
              AutoPlotUsageData
            >,
          ),
          AutoPlotUsageData,
          PrefetchHooks Function()
        > {
  $$AutoPlotUsageTableTableManager(_$AppDatabase db, $AutoPlotUsageTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$AutoPlotUsageTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$AutoPlotUsageTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$AutoPlotUsageTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> yearMonth = const Value.absent(),
                Value<int> scanCount = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => AutoPlotUsageCompanion(
                id: id,
                yearMonth: yearMonth,
                scanCount: scanCount,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String yearMonth,
                Value<int> scanCount = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => AutoPlotUsageCompanion.insert(
                id: id,
                yearMonth: yearMonth,
                scanCount: scanCount,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$AutoPlotUsageTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $AutoPlotUsageTable,
      AutoPlotUsageData,
      $$AutoPlotUsageTableFilterComposer,
      $$AutoPlotUsageTableOrderingComposer,
      $$AutoPlotUsageTableAnnotationComposer,
      $$AutoPlotUsageTableCreateCompanionBuilder,
      $$AutoPlotUsageTableUpdateCompanionBuilder,
      (
        AutoPlotUsageData,
        BaseReferences<_$AppDatabase, $AutoPlotUsageTable, AutoPlotUsageData>,
      ),
      AutoPlotUsageData,
      PrefetchHooks Function()
    >;
typedef $$UserProfilesTableCreateCompanionBuilder =
    UserProfilesCompanion Function({
      required String id,
      Value<String> primaryBowType,
      Value<String> handedness,
      Value<String?> name,
      Value<String?> clubName,
      Value<int?> yearsShootingStart,
      Value<double> shootingFrequency,
      Value<String> competitionLevels,
      Value<String?> notes,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<int> rowid,
    });
typedef $$UserProfilesTableUpdateCompanionBuilder =
    UserProfilesCompanion Function({
      Value<String> id,
      Value<String> primaryBowType,
      Value<String> handedness,
      Value<String?> name,
      Value<String?> clubName,
      Value<int?> yearsShootingStart,
      Value<double> shootingFrequency,
      Value<String> competitionLevels,
      Value<String?> notes,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<int> rowid,
    });

final class $$UserProfilesTableReferences
    extends BaseReferences<_$AppDatabase, $UserProfilesTable, UserProfile> {
  $$UserProfilesTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static MultiTypedResultKey<$FederationsTable, List<Federation>>
  _federationsRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.federations,
    aliasName: $_aliasNameGenerator(
      db.userProfiles.id,
      db.federations.profileId,
    ),
  );

  $$FederationsTableProcessedTableManager get federationsRefs {
    final manager = $$FederationsTableTableManager(
      $_db,
      $_db.federations,
    ).filter((f) => f.profileId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_federationsRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$UserProfilesTableFilterComposer
    extends Composer<_$AppDatabase, $UserProfilesTable> {
  $$UserProfilesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get primaryBowType => $composableBuilder(
    column: $table.primaryBowType,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get handedness => $composableBuilder(
    column: $table.handedness,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get clubName => $composableBuilder(
    column: $table.clubName,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get yearsShootingStart => $composableBuilder(
    column: $table.yearsShootingStart,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get shootingFrequency => $composableBuilder(
    column: $table.shootingFrequency,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get competitionLevels => $composableBuilder(
    column: $table.competitionLevels,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );

  Expression<bool> federationsRefs(
    Expression<bool> Function($$FederationsTableFilterComposer f) f,
  ) {
    final $$FederationsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.federations,
      getReferencedColumn: (t) => t.profileId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$FederationsTableFilterComposer(
            $db: $db,
            $table: $db.federations,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$UserProfilesTableOrderingComposer
    extends Composer<_$AppDatabase, $UserProfilesTable> {
  $$UserProfilesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get primaryBowType => $composableBuilder(
    column: $table.primaryBowType,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get handedness => $composableBuilder(
    column: $table.handedness,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get clubName => $composableBuilder(
    column: $table.clubName,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get yearsShootingStart => $composableBuilder(
    column: $table.yearsShootingStart,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get shootingFrequency => $composableBuilder(
    column: $table.shootingFrequency,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get competitionLevels => $composableBuilder(
    column: $table.competitionLevels,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$UserProfilesTableAnnotationComposer
    extends Composer<_$AppDatabase, $UserProfilesTable> {
  $$UserProfilesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get primaryBowType => $composableBuilder(
    column: $table.primaryBowType,
    builder: (column) => column,
  );

  GeneratedColumn<String> get handedness => $composableBuilder(
    column: $table.handedness,
    builder: (column) => column,
  );

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get clubName =>
      $composableBuilder(column: $table.clubName, builder: (column) => column);

  GeneratedColumn<int> get yearsShootingStart => $composableBuilder(
    column: $table.yearsShootingStart,
    builder: (column) => column,
  );

  GeneratedColumn<double> get shootingFrequency => $composableBuilder(
    column: $table.shootingFrequency,
    builder: (column) => column,
  );

  GeneratedColumn<String> get competitionLevels => $composableBuilder(
    column: $table.competitionLevels,
    builder: (column) => column,
  );

  GeneratedColumn<String> get notes =>
      $composableBuilder(column: $table.notes, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  Expression<T> federationsRefs<T extends Object>(
    Expression<T> Function($$FederationsTableAnnotationComposer a) f,
  ) {
    final $$FederationsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.federations,
      getReferencedColumn: (t) => t.profileId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$FederationsTableAnnotationComposer(
            $db: $db,
            $table: $db.federations,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$UserProfilesTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $UserProfilesTable,
          UserProfile,
          $$UserProfilesTableFilterComposer,
          $$UserProfilesTableOrderingComposer,
          $$UserProfilesTableAnnotationComposer,
          $$UserProfilesTableCreateCompanionBuilder,
          $$UserProfilesTableUpdateCompanionBuilder,
          (UserProfile, $$UserProfilesTableReferences),
          UserProfile,
          PrefetchHooks Function({bool federationsRefs})
        > {
  $$UserProfilesTableTableManager(_$AppDatabase db, $UserProfilesTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$UserProfilesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$UserProfilesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$UserProfilesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> primaryBowType = const Value.absent(),
                Value<String> handedness = const Value.absent(),
                Value<String?> name = const Value.absent(),
                Value<String?> clubName = const Value.absent(),
                Value<int?> yearsShootingStart = const Value.absent(),
                Value<double> shootingFrequency = const Value.absent(),
                Value<String> competitionLevels = const Value.absent(),
                Value<String?> notes = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => UserProfilesCompanion(
                id: id,
                primaryBowType: primaryBowType,
                handedness: handedness,
                name: name,
                clubName: clubName,
                yearsShootingStart: yearsShootingStart,
                shootingFrequency: shootingFrequency,
                competitionLevels: competitionLevels,
                notes: notes,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                Value<String> primaryBowType = const Value.absent(),
                Value<String> handedness = const Value.absent(),
                Value<String?> name = const Value.absent(),
                Value<String?> clubName = const Value.absent(),
                Value<int?> yearsShootingStart = const Value.absent(),
                Value<double> shootingFrequency = const Value.absent(),
                Value<String> competitionLevels = const Value.absent(),
                Value<String?> notes = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => UserProfilesCompanion.insert(
                id: id,
                primaryBowType: primaryBowType,
                handedness: handedness,
                name: name,
                clubName: clubName,
                yearsShootingStart: yearsShootingStart,
                shootingFrequency: shootingFrequency,
                competitionLevels: competitionLevels,
                notes: notes,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$UserProfilesTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback: ({federationsRefs = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [if (federationsRefs) db.federations],
              addJoins: null,
              getPrefetchedDataCallback: (items) async {
                return [
                  if (federationsRefs)
                    await $_getPrefetchedData<
                      UserProfile,
                      $UserProfilesTable,
                      Federation
                    >(
                      currentTable: table,
                      referencedTable: $$UserProfilesTableReferences
                          ._federationsRefsTable(db),
                      managerFromTypedResult: (p0) =>
                          $$UserProfilesTableReferences(
                            db,
                            table,
                            p0,
                          ).federationsRefs,
                      referencedItemsForCurrentItem: (item, referencedItems) =>
                          referencedItems.where((e) => e.profileId == item.id),
                      typedResults: items,
                    ),
                ];
              },
            );
          },
        ),
      );
}

typedef $$UserProfilesTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $UserProfilesTable,
      UserProfile,
      $$UserProfilesTableFilterComposer,
      $$UserProfilesTableOrderingComposer,
      $$UserProfilesTableAnnotationComposer,
      $$UserProfilesTableCreateCompanionBuilder,
      $$UserProfilesTableUpdateCompanionBuilder,
      (UserProfile, $$UserProfilesTableReferences),
      UserProfile,
      PrefetchHooks Function({bool federationsRefs})
    >;
typedef $$FederationsTableCreateCompanionBuilder =
    FederationsCompanion Function({
      required String id,
      required String profileId,
      required String federationName,
      Value<String?> membershipNumber,
      Value<String?> cardImagePath,
      Value<DateTime?> expiryDate,
      Value<bool> isPrimary,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<int> rowid,
    });
typedef $$FederationsTableUpdateCompanionBuilder =
    FederationsCompanion Function({
      Value<String> id,
      Value<String> profileId,
      Value<String> federationName,
      Value<String?> membershipNumber,
      Value<String?> cardImagePath,
      Value<DateTime?> expiryDate,
      Value<bool> isPrimary,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<int> rowid,
    });

final class $$FederationsTableReferences
    extends BaseReferences<_$AppDatabase, $FederationsTable, Federation> {
  $$FederationsTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $UserProfilesTable _profileIdTable(_$AppDatabase db) =>
      db.userProfiles.createAlias(
        $_aliasNameGenerator(db.federations.profileId, db.userProfiles.id),
      );

  $$UserProfilesTableProcessedTableManager get profileId {
    final $_column = $_itemColumn<String>('profile_id')!;

    final manager = $$UserProfilesTableTableManager(
      $_db,
      $_db.userProfiles,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_profileIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$FederationsTableFilterComposer
    extends Composer<_$AppDatabase, $FederationsTable> {
  $$FederationsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get federationName => $composableBuilder(
    column: $table.federationName,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get membershipNumber => $composableBuilder(
    column: $table.membershipNumber,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get cardImagePath => $composableBuilder(
    column: $table.cardImagePath,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get expiryDate => $composableBuilder(
    column: $table.expiryDate,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isPrimary => $composableBuilder(
    column: $table.isPrimary,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );

  $$UserProfilesTableFilterComposer get profileId {
    final $$UserProfilesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.profileId,
      referencedTable: $db.userProfiles,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UserProfilesTableFilterComposer(
            $db: $db,
            $table: $db.userProfiles,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$FederationsTableOrderingComposer
    extends Composer<_$AppDatabase, $FederationsTable> {
  $$FederationsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get federationName => $composableBuilder(
    column: $table.federationName,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get membershipNumber => $composableBuilder(
    column: $table.membershipNumber,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get cardImagePath => $composableBuilder(
    column: $table.cardImagePath,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get expiryDate => $composableBuilder(
    column: $table.expiryDate,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isPrimary => $composableBuilder(
    column: $table.isPrimary,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  $$UserProfilesTableOrderingComposer get profileId {
    final $$UserProfilesTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.profileId,
      referencedTable: $db.userProfiles,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UserProfilesTableOrderingComposer(
            $db: $db,
            $table: $db.userProfiles,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$FederationsTableAnnotationComposer
    extends Composer<_$AppDatabase, $FederationsTable> {
  $$FederationsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get federationName => $composableBuilder(
    column: $table.federationName,
    builder: (column) => column,
  );

  GeneratedColumn<String> get membershipNumber => $composableBuilder(
    column: $table.membershipNumber,
    builder: (column) => column,
  );

  GeneratedColumn<String> get cardImagePath => $composableBuilder(
    column: $table.cardImagePath,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get expiryDate => $composableBuilder(
    column: $table.expiryDate,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get isPrimary =>
      $composableBuilder(column: $table.isPrimary, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  $$UserProfilesTableAnnotationComposer get profileId {
    final $$UserProfilesTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.profileId,
      referencedTable: $db.userProfiles,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UserProfilesTableAnnotationComposer(
            $db: $db,
            $table: $db.userProfiles,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$FederationsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $FederationsTable,
          Federation,
          $$FederationsTableFilterComposer,
          $$FederationsTableOrderingComposer,
          $$FederationsTableAnnotationComposer,
          $$FederationsTableCreateCompanionBuilder,
          $$FederationsTableUpdateCompanionBuilder,
          (Federation, $$FederationsTableReferences),
          Federation,
          PrefetchHooks Function({bool profileId})
        > {
  $$FederationsTableTableManager(_$AppDatabase db, $FederationsTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$FederationsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$FederationsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$FederationsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> profileId = const Value.absent(),
                Value<String> federationName = const Value.absent(),
                Value<String?> membershipNumber = const Value.absent(),
                Value<String?> cardImagePath = const Value.absent(),
                Value<DateTime?> expiryDate = const Value.absent(),
                Value<bool> isPrimary = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => FederationsCompanion(
                id: id,
                profileId: profileId,
                federationName: federationName,
                membershipNumber: membershipNumber,
                cardImagePath: cardImagePath,
                expiryDate: expiryDate,
                isPrimary: isPrimary,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String profileId,
                required String federationName,
                Value<String?> membershipNumber = const Value.absent(),
                Value<String?> cardImagePath = const Value.absent(),
                Value<DateTime?> expiryDate = const Value.absent(),
                Value<bool> isPrimary = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => FederationsCompanion.insert(
                id: id,
                profileId: profileId,
                federationName: federationName,
                membershipNumber: membershipNumber,
                cardImagePath: cardImagePath,
                expiryDate: expiryDate,
                isPrimary: isPrimary,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$FederationsTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback: ({profileId = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins:
                  <
                    T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic
                    >
                  >(state) {
                    if (profileId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.profileId,
                                referencedTable: $$FederationsTableReferences
                                    ._profileIdTable(db),
                                referencedColumn: $$FederationsTableReferences
                                    ._profileIdTable(db)
                                    .id,
                              )
                              as T;
                    }

                    return state;
                  },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ),
      );
}

typedef $$FederationsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $FederationsTable,
      Federation,
      $$FederationsTableFilterComposer,
      $$FederationsTableOrderingComposer,
      $$FederationsTableAnnotationComposer,
      $$FederationsTableCreateCompanionBuilder,
      $$FederationsTableUpdateCompanionBuilder,
      (Federation, $$FederationsTableReferences),
      Federation,
      PrefetchHooks Function({bool profileId})
    >;

class $AppDatabaseManager {
  final _$AppDatabase _db;
  $AppDatabaseManager(this._db);
  $$RoundTypesTableTableManager get roundTypes =>
      $$RoundTypesTableTableManager(_db, _db.roundTypes);
  $$BowsTableTableManager get bows => $$BowsTableTableManager(_db, _db.bows);
  $$QuiversTableTableManager get quivers =>
      $$QuiversTableTableManager(_db, _db.quivers);
  $$SessionsTableTableManager get sessions =>
      $$SessionsTableTableManager(_db, _db.sessions);
  $$EndsTableTableManager get ends => $$EndsTableTableManager(_db, _db.ends);
  $$ShaftsTableTableManager get shafts =>
      $$ShaftsTableTableManager(_db, _db.shafts);
  $$ArrowsTableTableManager get arrows =>
      $$ArrowsTableTableManager(_db, _db.arrows);
  $$ImportedScoresTableTableManager get importedScores =>
      $$ImportedScoresTableTableManager(_db, _db.importedScores);
  $$UserPreferencesTableTableManager get userPreferences =>
      $$UserPreferencesTableTableManager(_db, _db.userPreferences);
  $$FingerTabsTableTableManager get fingerTabs =>
      $$FingerTabsTableTableManager(_db, _db.fingerTabs);
  $$StabilizersTableTableManager get stabilizers =>
      $$StabilizersTableTableManager(_db, _db.stabilizers);
  $$BowStringsTableTableManager get bowStrings =>
      $$BowStringsTableTableManager(_db, _db.bowStrings);
  $$VolumeEntriesTableTableManager get volumeEntries =>
      $$VolumeEntriesTableTableManager(_db, _db.volumeEntries);
  $$OlyExerciseTypesTableTableManager get olyExerciseTypes =>
      $$OlyExerciseTypesTableTableManager(_db, _db.olyExerciseTypes);
  $$OlySessionTemplatesTableTableManager get olySessionTemplates =>
      $$OlySessionTemplatesTableTableManager(_db, _db.olySessionTemplates);
  $$OlySessionExercisesTableTableManager get olySessionExercises =>
      $$OlySessionExercisesTableTableManager(_db, _db.olySessionExercises);
  $$OlyTrainingLogsTableTableManager get olyTrainingLogs =>
      $$OlyTrainingLogsTableTableManager(_db, _db.olyTrainingLogs);
  $$UserTrainingProgressTableTableManager get userTrainingProgress =>
      $$UserTrainingProgressTableTableManager(_db, _db.userTrainingProgress);
  $$BreathTrainingLogsTableTableManager get breathTrainingLogs =>
      $$BreathTrainingLogsTableTableManager(_db, _db.breathTrainingLogs);
  $$MilestonesTableTableManager get milestones =>
      $$MilestonesTableTableManager(_db, _db.milestones);
  $$VolumeImportsTableTableManager get volumeImports =>
      $$VolumeImportsTableTableManager(_db, _db.volumeImports);
  $$KitSnapshotsTableTableManager get kitSnapshots =>
      $$KitSnapshotsTableTableManager(_db, _db.kitSnapshots);
  $$TuningSessionsTableTableManager get tuningSessions =>
      $$TuningSessionsTableTableManager(_db, _db.tuningSessions);
  $$SkillLevelsTableTableManager get skillLevels =>
      $$SkillLevelsTableTableManager(_db, _db.skillLevels);
  $$XpHistoryTableTableManager get xpHistory =>
      $$XpHistoryTableTableManager(_db, _db.xpHistory);
  $$SightMarksTableTableManager get sightMarks =>
      $$SightMarksTableTableManager(_db, _db.sightMarks);
  $$SightMarkPreferencesTableTableTableManager get sightMarkPreferencesTable =>
      $$SightMarkPreferencesTableTableTableManager(
        _db,
        _db.sightMarkPreferencesTable,
      );
  $$RegisteredTargetsTableTableManager get registeredTargets =>
      $$RegisteredTargetsTableTableManager(_db, _db.registeredTargets);
  $$AutoPlotUsageTableTableManager get autoPlotUsage =>
      $$AutoPlotUsageTableTableManager(_db, _db.autoPlotUsage);
  $$UserProfilesTableTableManager get userProfiles =>
      $$UserProfilesTableTableManager(_db, _db.userProfiles);
  $$FederationsTableTableManager get federations =>
      $$FederationsTableTableManager(_db, _db.federations);
}
