// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'database.dart';

// ignore_for_file: type=lint
class $RoundTypesTable extends RoundTypes
    with TableInfo<$RoundTypesTable, RoundType> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $RoundTypesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _categoryMeta = const VerificationMeta(
    'category',
  );
  @override
  late final GeneratedColumn<String> category = GeneratedColumn<String>(
    'category',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _distanceMeta = const VerificationMeta(
    'distance',
  );
  @override
  late final GeneratedColumn<int> distance = GeneratedColumn<int>(
    'distance',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _faceSizeMeta = const VerificationMeta(
    'faceSize',
  );
  @override
  late final GeneratedColumn<int> faceSize = GeneratedColumn<int>(
    'face_size',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _arrowsPerEndMeta = const VerificationMeta(
    'arrowsPerEnd',
  );
  @override
  late final GeneratedColumn<int> arrowsPerEnd = GeneratedColumn<int>(
    'arrows_per_end',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _totalEndsMeta = const VerificationMeta(
    'totalEnds',
  );
  @override
  late final GeneratedColumn<int> totalEnds = GeneratedColumn<int>(
    'total_ends',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _maxScoreMeta = const VerificationMeta(
    'maxScore',
  );
  @override
  late final GeneratedColumn<int> maxScore = GeneratedColumn<int>(
    'max_score',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _isIndoorMeta = const VerificationMeta(
    'isIndoor',
  );
  @override
  late final GeneratedColumn<bool> isIndoor = GeneratedColumn<bool>(
    'is_indoor',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_indoor" IN (0, 1))',
    ),
  );
  static const VerificationMeta _faceCountMeta = const VerificationMeta(
    'faceCount',
  );
  @override
  late final GeneratedColumn<int> faceCount = GeneratedColumn<int>(
    'face_count',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(1),
  );
  static const VerificationMeta _scoringTypeMeta = const VerificationMeta(
    'scoringType',
  );
  @override
  late final GeneratedColumn<String> scoringType = GeneratedColumn<String>(
    'scoring_type',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('10-zone'),
  );
  static const VerificationMeta _distanceLegsMeta = const VerificationMeta(
    'distanceLegs',
  );
  @override
  late final GeneratedColumn<String> distanceLegs = GeneratedColumn<String>(
    'distance_legs',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    name,
    category,
    distance,
    faceSize,
    arrowsPerEnd,
    totalEnds,
    maxScore,
    isIndoor,
    faceCount,
    scoringType,
    distanceLegs,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'round_types';
  @override
  VerificationContext validateIntegrity(
    Insertable<RoundType> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('category')) {
      context.handle(
        _categoryMeta,
        category.isAcceptableOrUnknown(data['category']!, _categoryMeta),
      );
    } else if (isInserting) {
      context.missing(_categoryMeta);
    }
    if (data.containsKey('distance')) {
      context.handle(
        _distanceMeta,
        distance.isAcceptableOrUnknown(data['distance']!, _distanceMeta),
      );
    } else if (isInserting) {
      context.missing(_distanceMeta);
    }
    if (data.containsKey('face_size')) {
      context.handle(
        _faceSizeMeta,
        faceSize.isAcceptableOrUnknown(data['face_size']!, _faceSizeMeta),
      );
    } else if (isInserting) {
      context.missing(_faceSizeMeta);
    }
    if (data.containsKey('arrows_per_end')) {
      context.handle(
        _arrowsPerEndMeta,
        arrowsPerEnd.isAcceptableOrUnknown(
          data['arrows_per_end']!,
          _arrowsPerEndMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_arrowsPerEndMeta);
    }
    if (data.containsKey('total_ends')) {
      context.handle(
        _totalEndsMeta,
        totalEnds.isAcceptableOrUnknown(data['total_ends']!, _totalEndsMeta),
      );
    } else if (isInserting) {
      context.missing(_totalEndsMeta);
    }
    if (data.containsKey('max_score')) {
      context.handle(
        _maxScoreMeta,
        maxScore.isAcceptableOrUnknown(data['max_score']!, _maxScoreMeta),
      );
    } else if (isInserting) {
      context.missing(_maxScoreMeta);
    }
    if (data.containsKey('is_indoor')) {
      context.handle(
        _isIndoorMeta,
        isIndoor.isAcceptableOrUnknown(data['is_indoor']!, _isIndoorMeta),
      );
    } else if (isInserting) {
      context.missing(_isIndoorMeta);
    }
    if (data.containsKey('face_count')) {
      context.handle(
        _faceCountMeta,
        faceCount.isAcceptableOrUnknown(data['face_count']!, _faceCountMeta),
      );
    }
    if (data.containsKey('scoring_type')) {
      context.handle(
        _scoringTypeMeta,
        scoringType.isAcceptableOrUnknown(
          data['scoring_type']!,
          _scoringTypeMeta,
        ),
      );
    }
    if (data.containsKey('distance_legs')) {
      context.handle(
        _distanceLegsMeta,
        distanceLegs.isAcceptableOrUnknown(
          data['distance_legs']!,
          _distanceLegsMeta,
        ),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  RoundType map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return RoundType(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      category: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}category'],
      )!,
      distance: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}distance'],
      )!,
      faceSize: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}face_size'],
      )!,
      arrowsPerEnd: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}arrows_per_end'],
      )!,
      totalEnds: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}total_ends'],
      )!,
      maxScore: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}max_score'],
      )!,
      isIndoor: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_indoor'],
      )!,
      faceCount: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}face_count'],
      )!,
      scoringType: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}scoring_type'],
      )!,
      distanceLegs: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}distance_legs'],
      ),
    );
  }

  @override
  $RoundTypesTable createAlias(String alias) {
    return $RoundTypesTable(attachedDatabase, alias);
  }
}

class RoundType extends DataClass implements Insertable<RoundType> {
  final String id;
  final String name;
  final String category;
  final int distance;
  final int faceSize;
  final int arrowsPerEnd;
  final int totalEnds;
  final int maxScore;
  final bool isIndoor;
  final int faceCount;
  final String scoringType;

  /// Distance legs for multi-distance rounds (e.g., York: 100/80/60 yards)
  /// JSON array: [{"distance": 100, "unit": "yd", "arrowCount": 72}, ...]
  /// null for single-distance rounds
  final String? distanceLegs;
  const RoundType({
    required this.id,
    required this.name,
    required this.category,
    required this.distance,
    required this.faceSize,
    required this.arrowsPerEnd,
    required this.totalEnds,
    required this.maxScore,
    required this.isIndoor,
    required this.faceCount,
    required this.scoringType,
    this.distanceLegs,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['name'] = Variable<String>(name);
    map['category'] = Variable<String>(category);
    map['distance'] = Variable<int>(distance);
    map['face_size'] = Variable<int>(faceSize);
    map['arrows_per_end'] = Variable<int>(arrowsPerEnd);
    map['total_ends'] = Variable<int>(totalEnds);
    map['max_score'] = Variable<int>(maxScore);
    map['is_indoor'] = Variable<bool>(isIndoor);
    map['face_count'] = Variable<int>(faceCount);
    map['scoring_type'] = Variable<String>(scoringType);
    if (!nullToAbsent || distanceLegs != null) {
      map['distance_legs'] = Variable<String>(distanceLegs);
    }
    return map;
  }

  RoundTypesCompanion toCompanion(bool nullToAbsent) {
    return RoundTypesCompanion(
      id: Value(id),
      name: Value(name),
      category: Value(category),
      distance: Value(distance),
      faceSize: Value(faceSize),
      arrowsPerEnd: Value(arrowsPerEnd),
      totalEnds: Value(totalEnds),
      maxScore: Value(maxScore),
      isIndoor: Value(isIndoor),
      faceCount: Value(faceCount),
      scoringType: Value(scoringType),
      distanceLegs: distanceLegs == null && nullToAbsent
          ? const Value.absent()
          : Value(distanceLegs),
    );
  }

  factory RoundType.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return RoundType(
      id: serializer.fromJson<String>(json['id']),
      name: serializer.fromJson<String>(json['name']),
      category: serializer.fromJson<String>(json['category']),
      distance: serializer.fromJson<int>(json['distance']),
      faceSize: serializer.fromJson<int>(json['faceSize']),
      arrowsPerEnd: serializer.fromJson<int>(json['arrowsPerEnd']),
      totalEnds: serializer.fromJson<int>(json['totalEnds']),
      maxScore: serializer.fromJson<int>(json['maxScore']),
      isIndoor: serializer.fromJson<bool>(json['isIndoor']),
      faceCount: serializer.fromJson<int>(json['faceCount']),
      scoringType: serializer.fromJson<String>(json['scoringType']),
      distanceLegs: serializer.fromJson<String?>(json['distanceLegs']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'name': serializer.toJson<String>(name),
      'category': serializer.toJson<String>(category),
      'distance': serializer.toJson<int>(distance),
      'faceSize': serializer.toJson<int>(faceSize),
      'arrowsPerEnd': serializer.toJson<int>(arrowsPerEnd),
      'totalEnds': serializer.toJson<int>(totalEnds),
      'maxScore': serializer.toJson<int>(maxScore),
      'isIndoor': serializer.toJson<bool>(isIndoor),
      'faceCount': serializer.toJson<int>(faceCount),
      'scoringType': serializer.toJson<String>(scoringType),
      'distanceLegs': serializer.toJson<String?>(distanceLegs),
    };
  }

  RoundType copyWith({
    String? id,
    String? name,
    String? category,
    int? distance,
    int? faceSize,
    int? arrowsPerEnd,
    int? totalEnds,
    int? maxScore,
    bool? isIndoor,
    int? faceCount,
    String? scoringType,
    Value<String?> distanceLegs = const Value.absent(),
  }) => RoundType(
    id: id ?? this.id,
    name: name ?? this.name,
    category: category ?? this.category,
    distance: distance ?? this.distance,
    faceSize: faceSize ?? this.faceSize,
    arrowsPerEnd: arrowsPerEnd ?? this.arrowsPerEnd,
    totalEnds: totalEnds ?? this.totalEnds,
    maxScore: maxScore ?? this.maxScore,
    isIndoor: isIndoor ?? this.isIndoor,
    faceCount: faceCount ?? this.faceCount,
    scoringType: scoringType ?? this.scoringType,
    distanceLegs: distanceLegs.present ? distanceLegs.value : this.distanceLegs,
  );
  RoundType copyWithCompanion(RoundTypesCompanion data) {
    return RoundType(
      id: data.id.present ? data.id.value : this.id,
      name: data.name.present ? data.name.value : this.name,
      category: data.category.present ? data.category.value : this.category,
      distance: data.distance.present ? data.distance.value : this.distance,
      faceSize: data.faceSize.present ? data.faceSize.value : this.faceSize,
      arrowsPerEnd: data.arrowsPerEnd.present
          ? data.arrowsPerEnd.value
          : this.arrowsPerEnd,
      totalEnds: data.totalEnds.present ? data.totalEnds.value : this.totalEnds,
      maxScore: data.maxScore.present ? data.maxScore.value : this.maxScore,
      isIndoor: data.isIndoor.present ? data.isIndoor.value : this.isIndoor,
      faceCount: data.faceCount.present ? data.faceCount.value : this.faceCount,
      scoringType: data.scoringType.present
          ? data.scoringType.value
          : this.scoringType,
      distanceLegs: data.distanceLegs.present
          ? data.distanceLegs.value
          : this.distanceLegs,
    );
  }

  @override
  String toString() {
    return (StringBuffer('RoundType(')
          ..write('id: $id, ')
          ..write('name: $name, ')
          ..write('category: $category, ')
          ..write('distance: $distance, ')
          ..write('faceSize: $faceSize, ')
          ..write('arrowsPerEnd: $arrowsPerEnd, ')
          ..write('totalEnds: $totalEnds, ')
          ..write('maxScore: $maxScore, ')
          ..write('isIndoor: $isIndoor, ')
          ..write('faceCount: $faceCount, ')
          ..write('scoringType: $scoringType, ')
          ..write('distanceLegs: $distanceLegs')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    name,
    category,
    distance,
    faceSize,
    arrowsPerEnd,
    totalEnds,
    maxScore,
    isIndoor,
    faceCount,
    scoringType,
    distanceLegs,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is RoundType &&
          other.id == this.id &&
          other.name == this.name &&
          other.category == this.category &&
          other.distance == this.distance &&
          other.faceSize == this.faceSize &&
          other.arrowsPerEnd == this.arrowsPerEnd &&
          other.totalEnds == this.totalEnds &&
          other.maxScore == this.maxScore &&
          other.isIndoor == this.isIndoor &&
          other.faceCount == this.faceCount &&
          other.scoringType == this.scoringType &&
          other.distanceLegs == this.distanceLegs);
}

class RoundTypesCompanion extends UpdateCompanion<RoundType> {
  final Value<String> id;
  final Value<String> name;
  final Value<String> category;
  final Value<int> distance;
  final Value<int> faceSize;
  final Value<int> arrowsPerEnd;
  final Value<int> totalEnds;
  final Value<int> maxScore;
  final Value<bool> isIndoor;
  final Value<int> faceCount;
  final Value<String> scoringType;
  final Value<String?> distanceLegs;
  final Value<int> rowid;
  const RoundTypesCompanion({
    this.id = const Value.absent(),
    this.name = const Value.absent(),
    this.category = const Value.absent(),
    this.distance = const Value.absent(),
    this.faceSize = const Value.absent(),
    this.arrowsPerEnd = const Value.absent(),
    this.totalEnds = const Value.absent(),
    this.maxScore = const Value.absent(),
    this.isIndoor = const Value.absent(),
    this.faceCount = const Value.absent(),
    this.scoringType = const Value.absent(),
    this.distanceLegs = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  RoundTypesCompanion.insert({
    required String id,
    required String name,
    required String category,
    required int distance,
    required int faceSize,
    required int arrowsPerEnd,
    required int totalEnds,
    required int maxScore,
    required bool isIndoor,
    this.faceCount = const Value.absent(),
    this.scoringType = const Value.absent(),
    this.distanceLegs = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       name = Value(name),
       category = Value(category),
       distance = Value(distance),
       faceSize = Value(faceSize),
       arrowsPerEnd = Value(arrowsPerEnd),
       totalEnds = Value(totalEnds),
       maxScore = Value(maxScore),
       isIndoor = Value(isIndoor);
  static Insertable<RoundType> custom({
    Expression<String>? id,
    Expression<String>? name,
    Expression<String>? category,
    Expression<int>? distance,
    Expression<int>? faceSize,
    Expression<int>? arrowsPerEnd,
    Expression<int>? totalEnds,
    Expression<int>? maxScore,
    Expression<bool>? isIndoor,
    Expression<int>? faceCount,
    Expression<String>? scoringType,
    Expression<String>? distanceLegs,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (name != null) 'name': name,
      if (category != null) 'category': category,
      if (distance != null) 'distance': distance,
      if (faceSize != null) 'face_size': faceSize,
      if (arrowsPerEnd != null) 'arrows_per_end': arrowsPerEnd,
      if (totalEnds != null) 'total_ends': totalEnds,
      if (maxScore != null) 'max_score': maxScore,
      if (isIndoor != null) 'is_indoor': isIndoor,
      if (faceCount != null) 'face_count': faceCount,
      if (scoringType != null) 'scoring_type': scoringType,
      if (distanceLegs != null) 'distance_legs': distanceLegs,
      if (rowid != null) 'rowid': rowid,
    });
  }

  RoundTypesCompanion copyWith({
    Value<String>? id,
    Value<String>? name,
    Value<String>? category,
    Value<int>? distance,
    Value<int>? faceSize,
    Value<int>? arrowsPerEnd,
    Value<int>? totalEnds,
    Value<int>? maxScore,
    Value<bool>? isIndoor,
    Value<int>? faceCount,
    Value<String>? scoringType,
    Value<String?>? distanceLegs,
    Value<int>? rowid,
  }) {
    return RoundTypesCompanion(
      id: id ?? this.id,
      name: name ?? this.name,
      category: category ?? this.category,
      distance: distance ?? this.distance,
      faceSize: faceSize ?? this.faceSize,
      arrowsPerEnd: arrowsPerEnd ?? this.arrowsPerEnd,
      totalEnds: totalEnds ?? this.totalEnds,
      maxScore: maxScore ?? this.maxScore,
      isIndoor: isIndoor ?? this.isIndoor,
      faceCount: faceCount ?? this.faceCount,
      scoringType: scoringType ?? this.scoringType,
      distanceLegs: distanceLegs ?? this.distanceLegs,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (category.present) {
      map['category'] = Variable<String>(category.value);
    }
    if (distance.present) {
      map['distance'] = Variable<int>(distance.value);
    }
    if (faceSize.present) {
      map['face_size'] = Variable<int>(faceSize.value);
    }
    if (arrowsPerEnd.present) {
      map['arrows_per_end'] = Variable<int>(arrowsPerEnd.value);
    }
    if (totalEnds.present) {
      map['total_ends'] = Variable<int>(totalEnds.value);
    }
    if (maxScore.present) {
      map['max_score'] = Variable<int>(maxScore.value);
    }
    if (isIndoor.present) {
      map['is_indoor'] = Variable<bool>(isIndoor.value);
    }
    if (faceCount.present) {
      map['face_count'] = Variable<int>(faceCount.value);
    }
    if (scoringType.present) {
      map['scoring_type'] = Variable<String>(scoringType.value);
    }
    if (distanceLegs.present) {
      map['distance_legs'] = Variable<String>(distanceLegs.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('RoundTypesCompanion(')
          ..write('id: $id, ')
          ..write('name: $name, ')
          ..write('category: $category, ')
          ..write('distance: $distance, ')
          ..write('faceSize: $faceSize, ')
          ..write('arrowsPerEnd: $arrowsPerEnd, ')
          ..write('totalEnds: $totalEnds, ')
          ..write('maxScore: $maxScore, ')
          ..write('isIndoor: $isIndoor, ')
          ..write('faceCount: $faceCount, ')
          ..write('scoringType: $scoringType, ')
          ..write('distanceLegs: $distanceLegs, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $BowsTable extends Bows with TableInfo<$BowsTable, Bow> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $BowsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _bowTypeMeta = const VerificationMeta(
    'bowType',
  );
  @override
  late final GeneratedColumn<String> bowType = GeneratedColumn<String>(
    'bow_type',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _settingsMeta = const VerificationMeta(
    'settings',
  );
  @override
  late final GeneratedColumn<String> settings = GeneratedColumn<String>(
    'settings',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _isDefaultMeta = const VerificationMeta(
    'isDefault',
  );
  @override
  late final GeneratedColumn<bool> isDefault = GeneratedColumn<bool>(
    'is_default',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_default" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _deletedAtMeta = const VerificationMeta(
    'deletedAt',
  );
  @override
  late final GeneratedColumn<DateTime> deletedAt = GeneratedColumn<DateTime>(
    'deleted_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _riserModelMeta = const VerificationMeta(
    'riserModel',
  );
  @override
  late final GeneratedColumn<String> riserModel = GeneratedColumn<String>(
    'riser_model',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _riserPurchaseDateMeta = const VerificationMeta(
    'riserPurchaseDate',
  );
  @override
  late final GeneratedColumn<DateTime> riserPurchaseDate =
      GeneratedColumn<DateTime>(
        'riser_purchase_date',
        aliasedName,
        true,
        type: DriftSqlType.dateTime,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _limbModelMeta = const VerificationMeta(
    'limbModel',
  );
  @override
  late final GeneratedColumn<String> limbModel = GeneratedColumn<String>(
    'limb_model',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _limbPurchaseDateMeta = const VerificationMeta(
    'limbPurchaseDate',
  );
  @override
  late final GeneratedColumn<DateTime> limbPurchaseDate =
      GeneratedColumn<DateTime>(
        'limb_purchase_date',
        aliasedName,
        true,
        type: DriftSqlType.dateTime,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _poundageMeta = const VerificationMeta(
    'poundage',
  );
  @override
  late final GeneratedColumn<double> poundage = GeneratedColumn<double>(
    'poundage',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _drawLengthMeta = const VerificationMeta(
    'drawLength',
  );
  @override
  late final GeneratedColumn<double> drawLength = GeneratedColumn<double>(
    'draw_length',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _tillerTopMeta = const VerificationMeta(
    'tillerTop',
  );
  @override
  late final GeneratedColumn<double> tillerTop = GeneratedColumn<double>(
    'tiller_top',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _tillerBottomMeta = const VerificationMeta(
    'tillerBottom',
  );
  @override
  late final GeneratedColumn<double> tillerBottom = GeneratedColumn<double>(
    'tiller_bottom',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _braceHeightMeta = const VerificationMeta(
    'braceHeight',
  );
  @override
  late final GeneratedColumn<double> braceHeight = GeneratedColumn<double>(
    'brace_height',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _nockingPointHeightMeta =
      const VerificationMeta('nockingPointHeight');
  @override
  late final GeneratedColumn<double> nockingPointHeight =
      GeneratedColumn<double>(
        'nocking_point_height',
        aliasedName,
        true,
        type: DriftSqlType.double,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _buttonPositionMeta = const VerificationMeta(
    'buttonPosition',
  );
  @override
  late final GeneratedColumn<double> buttonPosition = GeneratedColumn<double>(
    'button_position',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _buttonTensionMeta = const VerificationMeta(
    'buttonTension',
  );
  @override
  late final GeneratedColumn<String> buttonTension = GeneratedColumn<String>(
    'button_tension',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _clickerPositionMeta = const VerificationMeta(
    'clickerPosition',
  );
  @override
  late final GeneratedColumn<double> clickerPosition = GeneratedColumn<double>(
    'clicker_position',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _eyeToArrowDistanceMeta =
      const VerificationMeta('eyeToArrowDistance');
  @override
  late final GeneratedColumn<double> eyeToArrowDistance =
      GeneratedColumn<double>(
        'eye_to_arrow_distance',
        aliasedName,
        true,
        type: DriftSqlType.double,
        requiredDuringInsert: false,
      );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    name,
    bowType,
    settings,
    isDefault,
    createdAt,
    updatedAt,
    deletedAt,
    riserModel,
    riserPurchaseDate,
    limbModel,
    limbPurchaseDate,
    poundage,
    drawLength,
    tillerTop,
    tillerBottom,
    braceHeight,
    nockingPointHeight,
    buttonPosition,
    buttonTension,
    clickerPosition,
    eyeToArrowDistance,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'bows';
  @override
  VerificationContext validateIntegrity(
    Insertable<Bow> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('bow_type')) {
      context.handle(
        _bowTypeMeta,
        bowType.isAcceptableOrUnknown(data['bow_type']!, _bowTypeMeta),
      );
    } else if (isInserting) {
      context.missing(_bowTypeMeta);
    }
    if (data.containsKey('settings')) {
      context.handle(
        _settingsMeta,
        settings.isAcceptableOrUnknown(data['settings']!, _settingsMeta),
      );
    }
    if (data.containsKey('is_default')) {
      context.handle(
        _isDefaultMeta,
        isDefault.isAcceptableOrUnknown(data['is_default']!, _isDefaultMeta),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    }
    if (data.containsKey('deleted_at')) {
      context.handle(
        _deletedAtMeta,
        deletedAt.isAcceptableOrUnknown(data['deleted_at']!, _deletedAtMeta),
      );
    }
    if (data.containsKey('riser_model')) {
      context.handle(
        _riserModelMeta,
        riserModel.isAcceptableOrUnknown(data['riser_model']!, _riserModelMeta),
      );
    }
    if (data.containsKey('riser_purchase_date')) {
      context.handle(
        _riserPurchaseDateMeta,
        riserPurchaseDate.isAcceptableOrUnknown(
          data['riser_purchase_date']!,
          _riserPurchaseDateMeta,
        ),
      );
    }
    if (data.containsKey('limb_model')) {
      context.handle(
        _limbModelMeta,
        limbModel.isAcceptableOrUnknown(data['limb_model']!, _limbModelMeta),
      );
    }
    if (data.containsKey('limb_purchase_date')) {
      context.handle(
        _limbPurchaseDateMeta,
        limbPurchaseDate.isAcceptableOrUnknown(
          data['limb_purchase_date']!,
          _limbPurchaseDateMeta,
        ),
      );
    }
    if (data.containsKey('poundage')) {
      context.handle(
        _poundageMeta,
        poundage.isAcceptableOrUnknown(data['poundage']!, _poundageMeta),
      );
    }
    if (data.containsKey('draw_length')) {
      context.handle(
        _drawLengthMeta,
        drawLength.isAcceptableOrUnknown(data['draw_length']!, _drawLengthMeta),
      );
    }
    if (data.containsKey('tiller_top')) {
      context.handle(
        _tillerTopMeta,
        tillerTop.isAcceptableOrUnknown(data['tiller_top']!, _tillerTopMeta),
      );
    }
    if (data.containsKey('tiller_bottom')) {
      context.handle(
        _tillerBottomMeta,
        tillerBottom.isAcceptableOrUnknown(
          data['tiller_bottom']!,
          _tillerBottomMeta,
        ),
      );
    }
    if (data.containsKey('brace_height')) {
      context.handle(
        _braceHeightMeta,
        braceHeight.isAcceptableOrUnknown(
          data['brace_height']!,
          _braceHeightMeta,
        ),
      );
    }
    if (data.containsKey('nocking_point_height')) {
      context.handle(
        _nockingPointHeightMeta,
        nockingPointHeight.isAcceptableOrUnknown(
          data['nocking_point_height']!,
          _nockingPointHeightMeta,
        ),
      );
    }
    if (data.containsKey('button_position')) {
      context.handle(
        _buttonPositionMeta,
        buttonPosition.isAcceptableOrUnknown(
          data['button_position']!,
          _buttonPositionMeta,
        ),
      );
    }
    if (data.containsKey('button_tension')) {
      context.handle(
        _buttonTensionMeta,
        buttonTension.isAcceptableOrUnknown(
          data['button_tension']!,
          _buttonTensionMeta,
        ),
      );
    }
    if (data.containsKey('clicker_position')) {
      context.handle(
        _clickerPositionMeta,
        clickerPosition.isAcceptableOrUnknown(
          data['clicker_position']!,
          _clickerPositionMeta,
        ),
      );
    }
    if (data.containsKey('eye_to_arrow_distance')) {
      context.handle(
        _eyeToArrowDistanceMeta,
        eyeToArrowDistance.isAcceptableOrUnknown(
          data['eye_to_arrow_distance']!,
          _eyeToArrowDistanceMeta,
        ),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  Bow map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Bow(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      bowType: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}bow_type'],
      )!,
      settings: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}settings'],
      ),
      isDefault: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_default'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      )!,
      deletedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}deleted_at'],
      ),
      riserModel: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}riser_model'],
      ),
      riserPurchaseDate: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}riser_purchase_date'],
      ),
      limbModel: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}limb_model'],
      ),
      limbPurchaseDate: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}limb_purchase_date'],
      ),
      poundage: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}poundage'],
      ),
      drawLength: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}draw_length'],
      ),
      tillerTop: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}tiller_top'],
      ),
      tillerBottom: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}tiller_bottom'],
      ),
      braceHeight: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}brace_height'],
      ),
      nockingPointHeight: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}nocking_point_height'],
      ),
      buttonPosition: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}button_position'],
      ),
      buttonTension: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}button_tension'],
      ),
      clickerPosition: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}clicker_position'],
      ),
      eyeToArrowDistance: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}eye_to_arrow_distance'],
      ),
    );
  }

  @override
  $BowsTable createAlias(String alias) {
    return $BowsTable(attachedDatabase, alias);
  }
}

class Bow extends DataClass implements Insertable<Bow> {
  final String id;
  final String name;
  final String bowType;
  final String? settings;
  final bool isDefault;
  final DateTime createdAt;
  final DateTime updatedAt;
  final DateTime? deletedAt;
  final String? riserModel;
  final DateTime? riserPurchaseDate;
  final String? limbModel;
  final DateTime? limbPurchaseDate;
  final double? poundage;
  final double? drawLength;
  final double? tillerTop;
  final double? tillerBottom;
  final double? braceHeight;
  final double? nockingPointHeight;
  final double? buttonPosition;
  final String? buttonTension;
  final double? clickerPosition;
  final double? eyeToArrowDistance;
  const Bow({
    required this.id,
    required this.name,
    required this.bowType,
    this.settings,
    required this.isDefault,
    required this.createdAt,
    required this.updatedAt,
    this.deletedAt,
    this.riserModel,
    this.riserPurchaseDate,
    this.limbModel,
    this.limbPurchaseDate,
    this.poundage,
    this.drawLength,
    this.tillerTop,
    this.tillerBottom,
    this.braceHeight,
    this.nockingPointHeight,
    this.buttonPosition,
    this.buttonTension,
    this.clickerPosition,
    this.eyeToArrowDistance,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['name'] = Variable<String>(name);
    map['bow_type'] = Variable<String>(bowType);
    if (!nullToAbsent || settings != null) {
      map['settings'] = Variable<String>(settings);
    }
    map['is_default'] = Variable<bool>(isDefault);
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    if (!nullToAbsent || deletedAt != null) {
      map['deleted_at'] = Variable<DateTime>(deletedAt);
    }
    if (!nullToAbsent || riserModel != null) {
      map['riser_model'] = Variable<String>(riserModel);
    }
    if (!nullToAbsent || riserPurchaseDate != null) {
      map['riser_purchase_date'] = Variable<DateTime>(riserPurchaseDate);
    }
    if (!nullToAbsent || limbModel != null) {
      map['limb_model'] = Variable<String>(limbModel);
    }
    if (!nullToAbsent || limbPurchaseDate != null) {
      map['limb_purchase_date'] = Variable<DateTime>(limbPurchaseDate);
    }
    if (!nullToAbsent || poundage != null) {
      map['poundage'] = Variable<double>(poundage);
    }
    if (!nullToAbsent || drawLength != null) {
      map['draw_length'] = Variable<double>(drawLength);
    }
    if (!nullToAbsent || tillerTop != null) {
      map['tiller_top'] = Variable<double>(tillerTop);
    }
    if (!nullToAbsent || tillerBottom != null) {
      map['tiller_bottom'] = Variable<double>(tillerBottom);
    }
    if (!nullToAbsent || braceHeight != null) {
      map['brace_height'] = Variable<double>(braceHeight);
    }
    if (!nullToAbsent || nockingPointHeight != null) {
      map['nocking_point_height'] = Variable<double>(nockingPointHeight);
    }
    if (!nullToAbsent || buttonPosition != null) {
      map['button_position'] = Variable<double>(buttonPosition);
    }
    if (!nullToAbsent || buttonTension != null) {
      map['button_tension'] = Variable<String>(buttonTension);
    }
    if (!nullToAbsent || clickerPosition != null) {
      map['clicker_position'] = Variable<double>(clickerPosition);
    }
    if (!nullToAbsent || eyeToArrowDistance != null) {
      map['eye_to_arrow_distance'] = Variable<double>(eyeToArrowDistance);
    }
    return map;
  }

  BowsCompanion toCompanion(bool nullToAbsent) {
    return BowsCompanion(
      id: Value(id),
      name: Value(name),
      bowType: Value(bowType),
      settings: settings == null && nullToAbsent
          ? const Value.absent()
          : Value(settings),
      isDefault: Value(isDefault),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
      deletedAt: deletedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(deletedAt),
      riserModel: riserModel == null && nullToAbsent
          ? const Value.absent()
          : Value(riserModel),
      riserPurchaseDate: riserPurchaseDate == null && nullToAbsent
          ? const Value.absent()
          : Value(riserPurchaseDate),
      limbModel: limbModel == null && nullToAbsent
          ? const Value.absent()
          : Value(limbModel),
      limbPurchaseDate: limbPurchaseDate == null && nullToAbsent
          ? const Value.absent()
          : Value(limbPurchaseDate),
      poundage: poundage == null && nullToAbsent
          ? const Value.absent()
          : Value(poundage),
      drawLength: drawLength == null && nullToAbsent
          ? const Value.absent()
          : Value(drawLength),
      tillerTop: tillerTop == null && nullToAbsent
          ? const Value.absent()
          : Value(tillerTop),
      tillerBottom: tillerBottom == null && nullToAbsent
          ? const Value.absent()
          : Value(tillerBottom),
      braceHeight: braceHeight == null && nullToAbsent
          ? const Value.absent()
          : Value(braceHeight),
      nockingPointHeight: nockingPointHeight == null && nullToAbsent
          ? const Value.absent()
          : Value(nockingPointHeight),
      buttonPosition: buttonPosition == null && nullToAbsent
          ? const Value.absent()
          : Value(buttonPosition),
      buttonTension: buttonTension == null && nullToAbsent
          ? const Value.absent()
          : Value(buttonTension),
      clickerPosition: clickerPosition == null && nullToAbsent
          ? const Value.absent()
          : Value(clickerPosition),
      eyeToArrowDistance: eyeToArrowDistance == null && nullToAbsent
          ? const Value.absent()
          : Value(eyeToArrowDistance),
    );
  }

  factory Bow.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Bow(
      id: serializer.fromJson<String>(json['id']),
      name: serializer.fromJson<String>(json['name']),
      bowType: serializer.fromJson<String>(json['bowType']),
      settings: serializer.fromJson<String?>(json['settings']),
      isDefault: serializer.fromJson<bool>(json['isDefault']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
      deletedAt: serializer.fromJson<DateTime?>(json['deletedAt']),
      riserModel: serializer.fromJson<String?>(json['riserModel']),
      riserPurchaseDate: serializer.fromJson<DateTime?>(
        json['riserPurchaseDate'],
      ),
      limbModel: serializer.fromJson<String?>(json['limbModel']),
      limbPurchaseDate: serializer.fromJson<DateTime?>(
        json['limbPurchaseDate'],
      ),
      poundage: serializer.fromJson<double?>(json['poundage']),
      drawLength: serializer.fromJson<double?>(json['drawLength']),
      tillerTop: serializer.fromJson<double?>(json['tillerTop']),
      tillerBottom: serializer.fromJson<double?>(json['tillerBottom']),
      braceHeight: serializer.fromJson<double?>(json['braceHeight']),
      nockingPointHeight: serializer.fromJson<double?>(
        json['nockingPointHeight'],
      ),
      buttonPosition: serializer.fromJson<double?>(json['buttonPosition']),
      buttonTension: serializer.fromJson<String?>(json['buttonTension']),
      clickerPosition: serializer.fromJson<double?>(json['clickerPosition']),
      eyeToArrowDistance: serializer.fromJson<double?>(
        json['eyeToArrowDistance'],
      ),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'name': serializer.toJson<String>(name),
      'bowType': serializer.toJson<String>(bowType),
      'settings': serializer.toJson<String?>(settings),
      'isDefault': serializer.toJson<bool>(isDefault),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
      'deletedAt': serializer.toJson<DateTime?>(deletedAt),
      'riserModel': serializer.toJson<String?>(riserModel),
      'riserPurchaseDate': serializer.toJson<DateTime?>(riserPurchaseDate),
      'limbModel': serializer.toJson<String?>(limbModel),
      'limbPurchaseDate': serializer.toJson<DateTime?>(limbPurchaseDate),
      'poundage': serializer.toJson<double?>(poundage),
      'drawLength': serializer.toJson<double?>(drawLength),
      'tillerTop': serializer.toJson<double?>(tillerTop),
      'tillerBottom': serializer.toJson<double?>(tillerBottom),
      'braceHeight': serializer.toJson<double?>(braceHeight),
      'nockingPointHeight': serializer.toJson<double?>(nockingPointHeight),
      'buttonPosition': serializer.toJson<double?>(buttonPosition),
      'buttonTension': serializer.toJson<String?>(buttonTension),
      'clickerPosition': serializer.toJson<double?>(clickerPosition),
      'eyeToArrowDistance': serializer.toJson<double?>(eyeToArrowDistance),
    };
  }

  Bow copyWith({
    String? id,
    String? name,
    String? bowType,
    Value<String?> settings = const Value.absent(),
    bool? isDefault,
    DateTime? createdAt,
    DateTime? updatedAt,
    Value<DateTime?> deletedAt = const Value.absent(),
    Value<String?> riserModel = const Value.absent(),
    Value<DateTime?> riserPurchaseDate = const Value.absent(),
    Value<String?> limbModel = const Value.absent(),
    Value<DateTime?> limbPurchaseDate = const Value.absent(),
    Value<double?> poundage = const Value.absent(),
    Value<double?> drawLength = const Value.absent(),
    Value<double?> tillerTop = const Value.absent(),
    Value<double?> tillerBottom = const Value.absent(),
    Value<double?> braceHeight = const Value.absent(),
    Value<double?> nockingPointHeight = const Value.absent(),
    Value<double?> buttonPosition = const Value.absent(),
    Value<String?> buttonTension = const Value.absent(),
    Value<double?> clickerPosition = const Value.absent(),
    Value<double?> eyeToArrowDistance = const Value.absent(),
  }) => Bow(
    id: id ?? this.id,
    name: name ?? this.name,
    bowType: bowType ?? this.bowType,
    settings: settings.present ? settings.value : this.settings,
    isDefault: isDefault ?? this.isDefault,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
    deletedAt: deletedAt.present ? deletedAt.value : this.deletedAt,
    riserModel: riserModel.present ? riserModel.value : this.riserModel,
    riserPurchaseDate: riserPurchaseDate.present
        ? riserPurchaseDate.value
        : this.riserPurchaseDate,
    limbModel: limbModel.present ? limbModel.value : this.limbModel,
    limbPurchaseDate: limbPurchaseDate.present
        ? limbPurchaseDate.value
        : this.limbPurchaseDate,
    poundage: poundage.present ? poundage.value : this.poundage,
    drawLength: drawLength.present ? drawLength.value : this.drawLength,
    tillerTop: tillerTop.present ? tillerTop.value : this.tillerTop,
    tillerBottom: tillerBottom.present ? tillerBottom.value : this.tillerBottom,
    braceHeight: braceHeight.present ? braceHeight.value : this.braceHeight,
    nockingPointHeight: nockingPointHeight.present
        ? nockingPointHeight.value
        : this.nockingPointHeight,
    buttonPosition: buttonPosition.present
        ? buttonPosition.value
        : this.buttonPosition,
    buttonTension: buttonTension.present
        ? buttonTension.value
        : this.buttonTension,
    clickerPosition: clickerPosition.present
        ? clickerPosition.value
        : this.clickerPosition,
    eyeToArrowDistance: eyeToArrowDistance.present
        ? eyeToArrowDistance.value
        : this.eyeToArrowDistance,
  );
  Bow copyWithCompanion(BowsCompanion data) {
    return Bow(
      id: data.id.present ? data.id.value : this.id,
      name: data.name.present ? data.name.value : this.name,
      bowType: data.bowType.present ? data.bowType.value : this.bowType,
      settings: data.settings.present ? data.settings.value : this.settings,
      isDefault: data.isDefault.present ? data.isDefault.value : this.isDefault,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
      deletedAt: data.deletedAt.present ? data.deletedAt.value : this.deletedAt,
      riserModel: data.riserModel.present
          ? data.riserModel.value
          : this.riserModel,
      riserPurchaseDate: data.riserPurchaseDate.present
          ? data.riserPurchaseDate.value
          : this.riserPurchaseDate,
      limbModel: data.limbModel.present ? data.limbModel.value : this.limbModel,
      limbPurchaseDate: data.limbPurchaseDate.present
          ? data.limbPurchaseDate.value
          : this.limbPurchaseDate,
      poundage: data.poundage.present ? data.poundage.value : this.poundage,
      drawLength: data.drawLength.present
          ? data.drawLength.value
          : this.drawLength,
      tillerTop: data.tillerTop.present ? data.tillerTop.value : this.tillerTop,
      tillerBottom: data.tillerBottom.present
          ? data.tillerBottom.value
          : this.tillerBottom,
      braceHeight: data.braceHeight.present
          ? data.braceHeight.value
          : this.braceHeight,
      nockingPointHeight: data.nockingPointHeight.present
          ? data.nockingPointHeight.value
          : this.nockingPointHeight,
      buttonPosition: data.buttonPosition.present
          ? data.buttonPosition.value
          : this.buttonPosition,
      buttonTension: data.buttonTension.present
          ? data.buttonTension.value
          : this.buttonTension,
      clickerPosition: data.clickerPosition.present
          ? data.clickerPosition.value
          : this.clickerPosition,
      eyeToArrowDistance: data.eyeToArrowDistance.present
          ? data.eyeToArrowDistance.value
          : this.eyeToArrowDistance,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Bow(')
          ..write('id: $id, ')
          ..write('name: $name, ')
          ..write('bowType: $bowType, ')
          ..write('settings: $settings, ')
          ..write('isDefault: $isDefault, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('deletedAt: $deletedAt, ')
          ..write('riserModel: $riserModel, ')
          ..write('riserPurchaseDate: $riserPurchaseDate, ')
          ..write('limbModel: $limbModel, ')
          ..write('limbPurchaseDate: $limbPurchaseDate, ')
          ..write('poundage: $poundage, ')
          ..write('drawLength: $drawLength, ')
          ..write('tillerTop: $tillerTop, ')
          ..write('tillerBottom: $tillerBottom, ')
          ..write('braceHeight: $braceHeight, ')
          ..write('nockingPointHeight: $nockingPointHeight, ')
          ..write('buttonPosition: $buttonPosition, ')
          ..write('buttonTension: $buttonTension, ')
          ..write('clickerPosition: $clickerPosition, ')
          ..write('eyeToArrowDistance: $eyeToArrowDistance')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hashAll([
    id,
    name,
    bowType,
    settings,
    isDefault,
    createdAt,
    updatedAt,
    deletedAt,
    riserModel,
    riserPurchaseDate,
    limbModel,
    limbPurchaseDate,
    poundage,
    drawLength,
    tillerTop,
    tillerBottom,
    braceHeight,
    nockingPointHeight,
    buttonPosition,
    buttonTension,
    clickerPosition,
    eyeToArrowDistance,
  ]);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Bow &&
          other.id == this.id &&
          other.name == this.name &&
          other.bowType == this.bowType &&
          other.settings == this.settings &&
          other.isDefault == this.isDefault &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt &&
          other.deletedAt == this.deletedAt &&
          other.riserModel == this.riserModel &&
          other.riserPurchaseDate == this.riserPurchaseDate &&
          other.limbModel == this.limbModel &&
          other.limbPurchaseDate == this.limbPurchaseDate &&
          other.poundage == this.poundage &&
          other.drawLength == this.drawLength &&
          other.tillerTop == this.tillerTop &&
          other.tillerBottom == this.tillerBottom &&
          other.braceHeight == this.braceHeight &&
          other.nockingPointHeight == this.nockingPointHeight &&
          other.buttonPosition == this.buttonPosition &&
          other.buttonTension == this.buttonTension &&
          other.clickerPosition == this.clickerPosition &&
          other.eyeToArrowDistance == this.eyeToArrowDistance);
}

class BowsCompanion extends UpdateCompanion<Bow> {
  final Value<String> id;
  final Value<String> name;
  final Value<String> bowType;
  final Value<String?> settings;
  final Value<bool> isDefault;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  final Value<DateTime?> deletedAt;
  final Value<String?> riserModel;
  final Value<DateTime?> riserPurchaseDate;
  final Value<String?> limbModel;
  final Value<DateTime?> limbPurchaseDate;
  final Value<double?> poundage;
  final Value<double?> drawLength;
  final Value<double?> tillerTop;
  final Value<double?> tillerBottom;
  final Value<double?> braceHeight;
  final Value<double?> nockingPointHeight;
  final Value<double?> buttonPosition;
  final Value<String?> buttonTension;
  final Value<double?> clickerPosition;
  final Value<double?> eyeToArrowDistance;
  final Value<int> rowid;
  const BowsCompanion({
    this.id = const Value.absent(),
    this.name = const Value.absent(),
    this.bowType = const Value.absent(),
    this.settings = const Value.absent(),
    this.isDefault = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.deletedAt = const Value.absent(),
    this.riserModel = const Value.absent(),
    this.riserPurchaseDate = const Value.absent(),
    this.limbModel = const Value.absent(),
    this.limbPurchaseDate = const Value.absent(),
    this.poundage = const Value.absent(),
    this.drawLength = const Value.absent(),
    this.tillerTop = const Value.absent(),
    this.tillerBottom = const Value.absent(),
    this.braceHeight = const Value.absent(),
    this.nockingPointHeight = const Value.absent(),
    this.buttonPosition = const Value.absent(),
    this.buttonTension = const Value.absent(),
    this.clickerPosition = const Value.absent(),
    this.eyeToArrowDistance = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  BowsCompanion.insert({
    required String id,
    required String name,
    required String bowType,
    this.settings = const Value.absent(),
    this.isDefault = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.deletedAt = const Value.absent(),
    this.riserModel = const Value.absent(),
    this.riserPurchaseDate = const Value.absent(),
    this.limbModel = const Value.absent(),
    this.limbPurchaseDate = const Value.absent(),
    this.poundage = const Value.absent(),
    this.drawLength = const Value.absent(),
    this.tillerTop = const Value.absent(),
    this.tillerBottom = const Value.absent(),
    this.braceHeight = const Value.absent(),
    this.nockingPointHeight = const Value.absent(),
    this.buttonPosition = const Value.absent(),
    this.buttonTension = const Value.absent(),
    this.clickerPosition = const Value.absent(),
    this.eyeToArrowDistance = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       name = Value(name),
       bowType = Value(bowType);
  static Insertable<Bow> custom({
    Expression<String>? id,
    Expression<String>? name,
    Expression<String>? bowType,
    Expression<String>? settings,
    Expression<bool>? isDefault,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
    Expression<DateTime>? deletedAt,
    Expression<String>? riserModel,
    Expression<DateTime>? riserPurchaseDate,
    Expression<String>? limbModel,
    Expression<DateTime>? limbPurchaseDate,
    Expression<double>? poundage,
    Expression<double>? drawLength,
    Expression<double>? tillerTop,
    Expression<double>? tillerBottom,
    Expression<double>? braceHeight,
    Expression<double>? nockingPointHeight,
    Expression<double>? buttonPosition,
    Expression<String>? buttonTension,
    Expression<double>? clickerPosition,
    Expression<double>? eyeToArrowDistance,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (name != null) 'name': name,
      if (bowType != null) 'bow_type': bowType,
      if (settings != null) 'settings': settings,
      if (isDefault != null) 'is_default': isDefault,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (deletedAt != null) 'deleted_at': deletedAt,
      if (riserModel != null) 'riser_model': riserModel,
      if (riserPurchaseDate != null) 'riser_purchase_date': riserPurchaseDate,
      if (limbModel != null) 'limb_model': limbModel,
      if (limbPurchaseDate != null) 'limb_purchase_date': limbPurchaseDate,
      if (poundage != null) 'poundage': poundage,
      if (drawLength != null) 'draw_length': drawLength,
      if (tillerTop != null) 'tiller_top': tillerTop,
      if (tillerBottom != null) 'tiller_bottom': tillerBottom,
      if (braceHeight != null) 'brace_height': braceHeight,
      if (nockingPointHeight != null)
        'nocking_point_height': nockingPointHeight,
      if (buttonPosition != null) 'button_position': buttonPosition,
      if (buttonTension != null) 'button_tension': buttonTension,
      if (clickerPosition != null) 'clicker_position': clickerPosition,
      if (eyeToArrowDistance != null)
        'eye_to_arrow_distance': eyeToArrowDistance,
      if (rowid != null) 'rowid': rowid,
    });
  }

  BowsCompanion copyWith({
    Value<String>? id,
    Value<String>? name,
    Value<String>? bowType,
    Value<String?>? settings,
    Value<bool>? isDefault,
    Value<DateTime>? createdAt,
    Value<DateTime>? updatedAt,
    Value<DateTime?>? deletedAt,
    Value<String?>? riserModel,
    Value<DateTime?>? riserPurchaseDate,
    Value<String?>? limbModel,
    Value<DateTime?>? limbPurchaseDate,
    Value<double?>? poundage,
    Value<double?>? drawLength,
    Value<double?>? tillerTop,
    Value<double?>? tillerBottom,
    Value<double?>? braceHeight,
    Value<double?>? nockingPointHeight,
    Value<double?>? buttonPosition,
    Value<String?>? buttonTension,
    Value<double?>? clickerPosition,
    Value<double?>? eyeToArrowDistance,
    Value<int>? rowid,
  }) {
    return BowsCompanion(
      id: id ?? this.id,
      name: name ?? this.name,
      bowType: bowType ?? this.bowType,
      settings: settings ?? this.settings,
      isDefault: isDefault ?? this.isDefault,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      deletedAt: deletedAt ?? this.deletedAt,
      riserModel: riserModel ?? this.riserModel,
      riserPurchaseDate: riserPurchaseDate ?? this.riserPurchaseDate,
      limbModel: limbModel ?? this.limbModel,
      limbPurchaseDate: limbPurchaseDate ?? this.limbPurchaseDate,
      poundage: poundage ?? this.poundage,
      drawLength: drawLength ?? this.drawLength,
      tillerTop: tillerTop ?? this.tillerTop,
      tillerBottom: tillerBottom ?? this.tillerBottom,
      braceHeight: braceHeight ?? this.braceHeight,
      nockingPointHeight: nockingPointHeight ?? this.nockingPointHeight,
      buttonPosition: buttonPosition ?? this.buttonPosition,
      buttonTension: buttonTension ?? this.buttonTension,
      clickerPosition: clickerPosition ?? this.clickerPosition,
      eyeToArrowDistance: eyeToArrowDistance ?? this.eyeToArrowDistance,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (bowType.present) {
      map['bow_type'] = Variable<String>(bowType.value);
    }
    if (settings.present) {
      map['settings'] = Variable<String>(settings.value);
    }
    if (isDefault.present) {
      map['is_default'] = Variable<bool>(isDefault.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (deletedAt.present) {
      map['deleted_at'] = Variable<DateTime>(deletedAt.value);
    }
    if (riserModel.present) {
      map['riser_model'] = Variable<String>(riserModel.value);
    }
    if (riserPurchaseDate.present) {
      map['riser_purchase_date'] = Variable<DateTime>(riserPurchaseDate.value);
    }
    if (limbModel.present) {
      map['limb_model'] = Variable<String>(limbModel.value);
    }
    if (limbPurchaseDate.present) {
      map['limb_purchase_date'] = Variable<DateTime>(limbPurchaseDate.value);
    }
    if (poundage.present) {
      map['poundage'] = Variable<double>(poundage.value);
    }
    if (drawLength.present) {
      map['draw_length'] = Variable<double>(drawLength.value);
    }
    if (tillerTop.present) {
      map['tiller_top'] = Variable<double>(tillerTop.value);
    }
    if (tillerBottom.present) {
      map['tiller_bottom'] = Variable<double>(tillerBottom.value);
    }
    if (braceHeight.present) {
      map['brace_height'] = Variable<double>(braceHeight.value);
    }
    if (nockingPointHeight.present) {
      map['nocking_point_height'] = Variable<double>(nockingPointHeight.value);
    }
    if (buttonPosition.present) {
      map['button_position'] = Variable<double>(buttonPosition.value);
    }
    if (buttonTension.present) {
      map['button_tension'] = Variable<String>(buttonTension.value);
    }
    if (clickerPosition.present) {
      map['clicker_position'] = Variable<double>(clickerPosition.value);
    }
    if (eyeToArrowDistance.present) {
      map['eye_to_arrow_distance'] = Variable<double>(eyeToArrowDistance.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('BowsCompanion(')
          ..write('id: $id, ')
          ..write('name: $name, ')
          ..write('bowType: $bowType, ')
          ..write('settings: $settings, ')
          ..write('isDefault: $isDefault, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('deletedAt: $deletedAt, ')
          ..write('riserModel: $riserModel, ')
          ..write('riserPurchaseDate: $riserPurchaseDate, ')
          ..write('limbModel: $limbModel, ')
          ..write('limbPurchaseDate: $limbPurchaseDate, ')
          ..write('poundage: $poundage, ')
          ..write('drawLength: $drawLength, ')
          ..write('tillerTop: $tillerTop, ')
          ..write('tillerBottom: $tillerBottom, ')
          ..write('braceHeight: $braceHeight, ')
          ..write('nockingPointHeight: $nockingPointHeight, ')
          ..write('buttonPosition: $buttonPosition, ')
          ..write('buttonTension: $buttonTension, ')
          ..write('clickerPosition: $clickerPosition, ')
          ..write('eyeToArrowDistance: $eyeToArrowDistance, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $QuiversTable extends Quivers with TableInfo<$QuiversTable, Quiver> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $QuiversTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _bowIdMeta = const VerificationMeta('bowId');
  @override
  late final GeneratedColumn<String> bowId = GeneratedColumn<String>(
    'bow_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES bows (id)',
    ),
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _shaftCountMeta = const VerificationMeta(
    'shaftCount',
  );
  @override
  late final GeneratedColumn<int> shaftCount = GeneratedColumn<int>(
    'shaft_count',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(12),
  );
  static const VerificationMeta _settingsMeta = const VerificationMeta(
    'settings',
  );
  @override
  late final GeneratedColumn<String> settings = GeneratedColumn<String>(
    'settings',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _isDefaultMeta = const VerificationMeta(
    'isDefault',
  );
  @override
  late final GeneratedColumn<bool> isDefault = GeneratedColumn<bool>(
    'is_default',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_default" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _deletedAtMeta = const VerificationMeta(
    'deletedAt',
  );
  @override
  late final GeneratedColumn<DateTime> deletedAt = GeneratedColumn<DateTime>(
    'deleted_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    bowId,
    name,
    shaftCount,
    settings,
    isDefault,
    createdAt,
    updatedAt,
    deletedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'quivers';
  @override
  VerificationContext validateIntegrity(
    Insertable<Quiver> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('bow_id')) {
      context.handle(
        _bowIdMeta,
        bowId.isAcceptableOrUnknown(data['bow_id']!, _bowIdMeta),
      );
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('shaft_count')) {
      context.handle(
        _shaftCountMeta,
        shaftCount.isAcceptableOrUnknown(data['shaft_count']!, _shaftCountMeta),
      );
    }
    if (data.containsKey('settings')) {
      context.handle(
        _settingsMeta,
        settings.isAcceptableOrUnknown(data['settings']!, _settingsMeta),
      );
    }
    if (data.containsKey('is_default')) {
      context.handle(
        _isDefaultMeta,
        isDefault.isAcceptableOrUnknown(data['is_default']!, _isDefaultMeta),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    }
    if (data.containsKey('deleted_at')) {
      context.handle(
        _deletedAtMeta,
        deletedAt.isAcceptableOrUnknown(data['deleted_at']!, _deletedAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  Quiver map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Quiver(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      bowId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}bow_id'],
      ),
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      shaftCount: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}shaft_count'],
      )!,
      settings: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}settings'],
      ),
      isDefault: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_default'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      )!,
      deletedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}deleted_at'],
      ),
    );
  }

  @override
  $QuiversTable createAlias(String alias) {
    return $QuiversTable(attachedDatabase, alias);
  }
}

class Quiver extends DataClass implements Insertable<Quiver> {
  final String id;
  final String? bowId;
  final String name;
  final int shaftCount;
  final String? settings;
  final bool isDefault;
  final DateTime createdAt;
  final DateTime updatedAt;
  final DateTime? deletedAt;
  const Quiver({
    required this.id,
    this.bowId,
    required this.name,
    required this.shaftCount,
    this.settings,
    required this.isDefault,
    required this.createdAt,
    required this.updatedAt,
    this.deletedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    if (!nullToAbsent || bowId != null) {
      map['bow_id'] = Variable<String>(bowId);
    }
    map['name'] = Variable<String>(name);
    map['shaft_count'] = Variable<int>(shaftCount);
    if (!nullToAbsent || settings != null) {
      map['settings'] = Variable<String>(settings);
    }
    map['is_default'] = Variable<bool>(isDefault);
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    if (!nullToAbsent || deletedAt != null) {
      map['deleted_at'] = Variable<DateTime>(deletedAt);
    }
    return map;
  }

  QuiversCompanion toCompanion(bool nullToAbsent) {
    return QuiversCompanion(
      id: Value(id),
      bowId: bowId == null && nullToAbsent
          ? const Value.absent()
          : Value(bowId),
      name: Value(name),
      shaftCount: Value(shaftCount),
      settings: settings == null && nullToAbsent
          ? const Value.absent()
          : Value(settings),
      isDefault: Value(isDefault),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
      deletedAt: deletedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(deletedAt),
    );
  }

  factory Quiver.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Quiver(
      id: serializer.fromJson<String>(json['id']),
      bowId: serializer.fromJson<String?>(json['bowId']),
      name: serializer.fromJson<String>(json['name']),
      shaftCount: serializer.fromJson<int>(json['shaftCount']),
      settings: serializer.fromJson<String?>(json['settings']),
      isDefault: serializer.fromJson<bool>(json['isDefault']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
      deletedAt: serializer.fromJson<DateTime?>(json['deletedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'bowId': serializer.toJson<String?>(bowId),
      'name': serializer.toJson<String>(name),
      'shaftCount': serializer.toJson<int>(shaftCount),
      'settings': serializer.toJson<String?>(settings),
      'isDefault': serializer.toJson<bool>(isDefault),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
      'deletedAt': serializer.toJson<DateTime?>(deletedAt),
    };
  }

  Quiver copyWith({
    String? id,
    Value<String?> bowId = const Value.absent(),
    String? name,
    int? shaftCount,
    Value<String?> settings = const Value.absent(),
    bool? isDefault,
    DateTime? createdAt,
    DateTime? updatedAt,
    Value<DateTime?> deletedAt = const Value.absent(),
  }) => Quiver(
    id: id ?? this.id,
    bowId: bowId.present ? bowId.value : this.bowId,
    name: name ?? this.name,
    shaftCount: shaftCount ?? this.shaftCount,
    settings: settings.present ? settings.value : this.settings,
    isDefault: isDefault ?? this.isDefault,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
    deletedAt: deletedAt.present ? deletedAt.value : this.deletedAt,
  );
  Quiver copyWithCompanion(QuiversCompanion data) {
    return Quiver(
      id: data.id.present ? data.id.value : this.id,
      bowId: data.bowId.present ? data.bowId.value : this.bowId,
      name: data.name.present ? data.name.value : this.name,
      shaftCount: data.shaftCount.present
          ? data.shaftCount.value
          : this.shaftCount,
      settings: data.settings.present ? data.settings.value : this.settings,
      isDefault: data.isDefault.present ? data.isDefault.value : this.isDefault,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
      deletedAt: data.deletedAt.present ? data.deletedAt.value : this.deletedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Quiver(')
          ..write('id: $id, ')
          ..write('bowId: $bowId, ')
          ..write('name: $name, ')
          ..write('shaftCount: $shaftCount, ')
          ..write('settings: $settings, ')
          ..write('isDefault: $isDefault, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('deletedAt: $deletedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    bowId,
    name,
    shaftCount,
    settings,
    isDefault,
    createdAt,
    updatedAt,
    deletedAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Quiver &&
          other.id == this.id &&
          other.bowId == this.bowId &&
          other.name == this.name &&
          other.shaftCount == this.shaftCount &&
          other.settings == this.settings &&
          other.isDefault == this.isDefault &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt &&
          other.deletedAt == this.deletedAt);
}

class QuiversCompanion extends UpdateCompanion<Quiver> {
  final Value<String> id;
  final Value<String?> bowId;
  final Value<String> name;
  final Value<int> shaftCount;
  final Value<String?> settings;
  final Value<bool> isDefault;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  final Value<DateTime?> deletedAt;
  final Value<int> rowid;
  const QuiversCompanion({
    this.id = const Value.absent(),
    this.bowId = const Value.absent(),
    this.name = const Value.absent(),
    this.shaftCount = const Value.absent(),
    this.settings = const Value.absent(),
    this.isDefault = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.deletedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  QuiversCompanion.insert({
    required String id,
    this.bowId = const Value.absent(),
    required String name,
    this.shaftCount = const Value.absent(),
    this.settings = const Value.absent(),
    this.isDefault = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.deletedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       name = Value(name);
  static Insertable<Quiver> custom({
    Expression<String>? id,
    Expression<String>? bowId,
    Expression<String>? name,
    Expression<int>? shaftCount,
    Expression<String>? settings,
    Expression<bool>? isDefault,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
    Expression<DateTime>? deletedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (bowId != null) 'bow_id': bowId,
      if (name != null) 'name': name,
      if (shaftCount != null) 'shaft_count': shaftCount,
      if (settings != null) 'settings': settings,
      if (isDefault != null) 'is_default': isDefault,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (deletedAt != null) 'deleted_at': deletedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  QuiversCompanion copyWith({
    Value<String>? id,
    Value<String?>? bowId,
    Value<String>? name,
    Value<int>? shaftCount,
    Value<String?>? settings,
    Value<bool>? isDefault,
    Value<DateTime>? createdAt,
    Value<DateTime>? updatedAt,
    Value<DateTime?>? deletedAt,
    Value<int>? rowid,
  }) {
    return QuiversCompanion(
      id: id ?? this.id,
      bowId: bowId ?? this.bowId,
      name: name ?? this.name,
      shaftCount: shaftCount ?? this.shaftCount,
      settings: settings ?? this.settings,
      isDefault: isDefault ?? this.isDefault,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      deletedAt: deletedAt ?? this.deletedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (bowId.present) {
      map['bow_id'] = Variable<String>(bowId.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (shaftCount.present) {
      map['shaft_count'] = Variable<int>(shaftCount.value);
    }
    if (settings.present) {
      map['settings'] = Variable<String>(settings.value);
    }
    if (isDefault.present) {
      map['is_default'] = Variable<bool>(isDefault.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (deletedAt.present) {
      map['deleted_at'] = Variable<DateTime>(deletedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('QuiversCompanion(')
          ..write('id: $id, ')
          ..write('bowId: $bowId, ')
          ..write('name: $name, ')
          ..write('shaftCount: $shaftCount, ')
          ..write('settings: $settings, ')
          ..write('isDefault: $isDefault, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('deletedAt: $deletedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $SessionsTable extends Sessions with TableInfo<$SessionsTable, Session> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $SessionsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _roundTypeIdMeta = const VerificationMeta(
    'roundTypeId',
  );
  @override
  late final GeneratedColumn<String> roundTypeId = GeneratedColumn<String>(
    'round_type_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES round_types (id)',
    ),
  );
  static const VerificationMeta _sessionTypeMeta = const VerificationMeta(
    'sessionType',
  );
  @override
  late final GeneratedColumn<String> sessionType = GeneratedColumn<String>(
    'session_type',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('practice'),
  );
  static const VerificationMeta _titleMeta = const VerificationMeta('title');
  @override
  late final GeneratedColumn<String> title = GeneratedColumn<String>(
    'title',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _locationNameMeta = const VerificationMeta(
    'locationName',
  );
  @override
  late final GeneratedColumn<String> locationName = GeneratedColumn<String>(
    'location_name',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _locationMeta = const VerificationMeta(
    'location',
  );
  @override
  late final GeneratedColumn<String> location = GeneratedColumn<String>(
    'location',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _latitudeMeta = const VerificationMeta(
    'latitude',
  );
  @override
  late final GeneratedColumn<double> latitude = GeneratedColumn<double>(
    'latitude',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _longitudeMeta = const VerificationMeta(
    'longitude',
  );
  @override
  late final GeneratedColumn<double> longitude = GeneratedColumn<double>(
    'longitude',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _notesMeta = const VerificationMeta('notes');
  @override
  late final GeneratedColumn<String> notes = GeneratedColumn<String>(
    'notes',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _startedAtMeta = const VerificationMeta(
    'startedAt',
  );
  @override
  late final GeneratedColumn<DateTime> startedAt = GeneratedColumn<DateTime>(
    'started_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _completedAtMeta = const VerificationMeta(
    'completedAt',
  );
  @override
  late final GeneratedColumn<DateTime> completedAt = GeneratedColumn<DateTime>(
    'completed_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _totalScoreMeta = const VerificationMeta(
    'totalScore',
  );
  @override
  late final GeneratedColumn<int> totalScore = GeneratedColumn<int>(
    'total_score',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _totalXsMeta = const VerificationMeta(
    'totalXs',
  );
  @override
  late final GeneratedColumn<int> totalXs = GeneratedColumn<int>(
    'total_xs',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _bowIdMeta = const VerificationMeta('bowId');
  @override
  late final GeneratedColumn<String> bowId = GeneratedColumn<String>(
    'bow_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES bows (id)',
    ),
  );
  static const VerificationMeta _quiverIdMeta = const VerificationMeta(
    'quiverId',
  );
  @override
  late final GeneratedColumn<String> quiverId = GeneratedColumn<String>(
    'quiver_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES quivers (id)',
    ),
  );
  static const VerificationMeta _shaftTaggingEnabledMeta =
      const VerificationMeta('shaftTaggingEnabled');
  @override
  late final GeneratedColumn<bool> shaftTaggingEnabled = GeneratedColumn<bool>(
    'shaft_tagging_enabled',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("shaft_tagging_enabled" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _deletedAtMeta = const VerificationMeta(
    'deletedAt',
  );
  @override
  late final GeneratedColumn<DateTime> deletedAt = GeneratedColumn<DateTime>(
    'deleted_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    roundTypeId,
    sessionType,
    title,
    locationName,
    location,
    latitude,
    longitude,
    notes,
    startedAt,
    completedAt,
    totalScore,
    totalXs,
    bowId,
    quiverId,
    shaftTaggingEnabled,
    deletedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'sessions';
  @override
  VerificationContext validateIntegrity(
    Insertable<Session> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('round_type_id')) {
      context.handle(
        _roundTypeIdMeta,
        roundTypeId.isAcceptableOrUnknown(
          data['round_type_id']!,
          _roundTypeIdMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_roundTypeIdMeta);
    }
    if (data.containsKey('session_type')) {
      context.handle(
        _sessionTypeMeta,
        sessionType.isAcceptableOrUnknown(
          data['session_type']!,
          _sessionTypeMeta,
        ),
      );
    }
    if (data.containsKey('title')) {
      context.handle(
        _titleMeta,
        title.isAcceptableOrUnknown(data['title']!, _titleMeta),
      );
    }
    if (data.containsKey('location_name')) {
      context.handle(
        _locationNameMeta,
        locationName.isAcceptableOrUnknown(
          data['location_name']!,
          _locationNameMeta,
        ),
      );
    }
    if (data.containsKey('location')) {
      context.handle(
        _locationMeta,
        location.isAcceptableOrUnknown(data['location']!, _locationMeta),
      );
    }
    if (data.containsKey('latitude')) {
      context.handle(
        _latitudeMeta,
        latitude.isAcceptableOrUnknown(data['latitude']!, _latitudeMeta),
      );
    }
    if (data.containsKey('longitude')) {
      context.handle(
        _longitudeMeta,
        longitude.isAcceptableOrUnknown(data['longitude']!, _longitudeMeta),
      );
    }
    if (data.containsKey('notes')) {
      context.handle(
        _notesMeta,
        notes.isAcceptableOrUnknown(data['notes']!, _notesMeta),
      );
    }
    if (data.containsKey('started_at')) {
      context.handle(
        _startedAtMeta,
        startedAt.isAcceptableOrUnknown(data['started_at']!, _startedAtMeta),
      );
    }
    if (data.containsKey('completed_at')) {
      context.handle(
        _completedAtMeta,
        completedAt.isAcceptableOrUnknown(
          data['completed_at']!,
          _completedAtMeta,
        ),
      );
    }
    if (data.containsKey('total_score')) {
      context.handle(
        _totalScoreMeta,
        totalScore.isAcceptableOrUnknown(data['total_score']!, _totalScoreMeta),
      );
    }
    if (data.containsKey('total_xs')) {
      context.handle(
        _totalXsMeta,
        totalXs.isAcceptableOrUnknown(data['total_xs']!, _totalXsMeta),
      );
    }
    if (data.containsKey('bow_id')) {
      context.handle(
        _bowIdMeta,
        bowId.isAcceptableOrUnknown(data['bow_id']!, _bowIdMeta),
      );
    }
    if (data.containsKey('quiver_id')) {
      context.handle(
        _quiverIdMeta,
        quiverId.isAcceptableOrUnknown(data['quiver_id']!, _quiverIdMeta),
      );
    }
    if (data.containsKey('shaft_tagging_enabled')) {
      context.handle(
        _shaftTaggingEnabledMeta,
        shaftTaggingEnabled.isAcceptableOrUnknown(
          data['shaft_tagging_enabled']!,
          _shaftTaggingEnabledMeta,
        ),
      );
    }
    if (data.containsKey('deleted_at')) {
      context.handle(
        _deletedAtMeta,
        deletedAt.isAcceptableOrUnknown(data['deleted_at']!, _deletedAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  Session map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Session(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      roundTypeId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}round_type_id'],
      )!,
      sessionType: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}session_type'],
      )!,
      title: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}title'],
      ),
      locationName: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}location_name'],
      ),
      location: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}location'],
      ),
      latitude: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}latitude'],
      ),
      longitude: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}longitude'],
      ),
      notes: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}notes'],
      ),
      startedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}started_at'],
      )!,
      completedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}completed_at'],
      ),
      totalScore: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}total_score'],
      )!,
      totalXs: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}total_xs'],
      )!,
      bowId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}bow_id'],
      ),
      quiverId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}quiver_id'],
      ),
      shaftTaggingEnabled: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}shaft_tagging_enabled'],
      )!,
      deletedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}deleted_at'],
      ),
    );
  }

  @override
  $SessionsTable createAlias(String alias) {
    return $SessionsTable(attachedDatabase, alias);
  }
}

class Session extends DataClass implements Insertable<Session> {
  final String id;
  final String roundTypeId;
  final String sessionType;
  final String? title;
  final String? locationName;
  final String? location;
  final double? latitude;
  final double? longitude;
  final String? notes;
  final DateTime startedAt;
  final DateTime? completedAt;
  final int totalScore;
  final int totalXs;
  final String? bowId;
  final String? quiverId;
  final bool shaftTaggingEnabled;
  final DateTime? deletedAt;
  const Session({
    required this.id,
    required this.roundTypeId,
    required this.sessionType,
    this.title,
    this.locationName,
    this.location,
    this.latitude,
    this.longitude,
    this.notes,
    required this.startedAt,
    this.completedAt,
    required this.totalScore,
    required this.totalXs,
    this.bowId,
    this.quiverId,
    required this.shaftTaggingEnabled,
    this.deletedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['round_type_id'] = Variable<String>(roundTypeId);
    map['session_type'] = Variable<String>(sessionType);
    if (!nullToAbsent || title != null) {
      map['title'] = Variable<String>(title);
    }
    if (!nullToAbsent || locationName != null) {
      map['location_name'] = Variable<String>(locationName);
    }
    if (!nullToAbsent || location != null) {
      map['location'] = Variable<String>(location);
    }
    if (!nullToAbsent || latitude != null) {
      map['latitude'] = Variable<double>(latitude);
    }
    if (!nullToAbsent || longitude != null) {
      map['longitude'] = Variable<double>(longitude);
    }
    if (!nullToAbsent || notes != null) {
      map['notes'] = Variable<String>(notes);
    }
    map['started_at'] = Variable<DateTime>(startedAt);
    if (!nullToAbsent || completedAt != null) {
      map['completed_at'] = Variable<DateTime>(completedAt);
    }
    map['total_score'] = Variable<int>(totalScore);
    map['total_xs'] = Variable<int>(totalXs);
    if (!nullToAbsent || bowId != null) {
      map['bow_id'] = Variable<String>(bowId);
    }
    if (!nullToAbsent || quiverId != null) {
      map['quiver_id'] = Variable<String>(quiverId);
    }
    map['shaft_tagging_enabled'] = Variable<bool>(shaftTaggingEnabled);
    if (!nullToAbsent || deletedAt != null) {
      map['deleted_at'] = Variable<DateTime>(deletedAt);
    }
    return map;
  }

  SessionsCompanion toCompanion(bool nullToAbsent) {
    return SessionsCompanion(
      id: Value(id),
      roundTypeId: Value(roundTypeId),
      sessionType: Value(sessionType),
      title: title == null && nullToAbsent
          ? const Value.absent()
          : Value(title),
      locationName: locationName == null && nullToAbsent
          ? const Value.absent()
          : Value(locationName),
      location: location == null && nullToAbsent
          ? const Value.absent()
          : Value(location),
      latitude: latitude == null && nullToAbsent
          ? const Value.absent()
          : Value(latitude),
      longitude: longitude == null && nullToAbsent
          ? const Value.absent()
          : Value(longitude),
      notes: notes == null && nullToAbsent
          ? const Value.absent()
          : Value(notes),
      startedAt: Value(startedAt),
      completedAt: completedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(completedAt),
      totalScore: Value(totalScore),
      totalXs: Value(totalXs),
      bowId: bowId == null && nullToAbsent
          ? const Value.absent()
          : Value(bowId),
      quiverId: quiverId == null && nullToAbsent
          ? const Value.absent()
          : Value(quiverId),
      shaftTaggingEnabled: Value(shaftTaggingEnabled),
      deletedAt: deletedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(deletedAt),
    );
  }

  factory Session.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Session(
      id: serializer.fromJson<String>(json['id']),
      roundTypeId: serializer.fromJson<String>(json['roundTypeId']),
      sessionType: serializer.fromJson<String>(json['sessionType']),
      title: serializer.fromJson<String?>(json['title']),
      locationName: serializer.fromJson<String?>(json['locationName']),
      location: serializer.fromJson<String?>(json['location']),
      latitude: serializer.fromJson<double?>(json['latitude']),
      longitude: serializer.fromJson<double?>(json['longitude']),
      notes: serializer.fromJson<String?>(json['notes']),
      startedAt: serializer.fromJson<DateTime>(json['startedAt']),
      completedAt: serializer.fromJson<DateTime?>(json['completedAt']),
      totalScore: serializer.fromJson<int>(json['totalScore']),
      totalXs: serializer.fromJson<int>(json['totalXs']),
      bowId: serializer.fromJson<String?>(json['bowId']),
      quiverId: serializer.fromJson<String?>(json['quiverId']),
      shaftTaggingEnabled: serializer.fromJson<bool>(
        json['shaftTaggingEnabled'],
      ),
      deletedAt: serializer.fromJson<DateTime?>(json['deletedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'roundTypeId': serializer.toJson<String>(roundTypeId),
      'sessionType': serializer.toJson<String>(sessionType),
      'title': serializer.toJson<String?>(title),
      'locationName': serializer.toJson<String?>(locationName),
      'location': serializer.toJson<String?>(location),
      'latitude': serializer.toJson<double?>(latitude),
      'longitude': serializer.toJson<double?>(longitude),
      'notes': serializer.toJson<String?>(notes),
      'startedAt': serializer.toJson<DateTime>(startedAt),
      'completedAt': serializer.toJson<DateTime?>(completedAt),
      'totalScore': serializer.toJson<int>(totalScore),
      'totalXs': serializer.toJson<int>(totalXs),
      'bowId': serializer.toJson<String?>(bowId),
      'quiverId': serializer.toJson<String?>(quiverId),
      'shaftTaggingEnabled': serializer.toJson<bool>(shaftTaggingEnabled),
      'deletedAt': serializer.toJson<DateTime?>(deletedAt),
    };
  }

  Session copyWith({
    String? id,
    String? roundTypeId,
    String? sessionType,
    Value<String?> title = const Value.absent(),
    Value<String?> locationName = const Value.absent(),
    Value<String?> location = const Value.absent(),
    Value<double?> latitude = const Value.absent(),
    Value<double?> longitude = const Value.absent(),
    Value<String?> notes = const Value.absent(),
    DateTime? startedAt,
    Value<DateTime?> completedAt = const Value.absent(),
    int? totalScore,
    int? totalXs,
    Value<String?> bowId = const Value.absent(),
    Value<String?> quiverId = const Value.absent(),
    bool? shaftTaggingEnabled,
    Value<DateTime?> deletedAt = const Value.absent(),
  }) => Session(
    id: id ?? this.id,
    roundTypeId: roundTypeId ?? this.roundTypeId,
    sessionType: sessionType ?? this.sessionType,
    title: title.present ? title.value : this.title,
    locationName: locationName.present ? locationName.value : this.locationName,
    location: location.present ? location.value : this.location,
    latitude: latitude.present ? latitude.value : this.latitude,
    longitude: longitude.present ? longitude.value : this.longitude,
    notes: notes.present ? notes.value : this.notes,
    startedAt: startedAt ?? this.startedAt,
    completedAt: completedAt.present ? completedAt.value : this.completedAt,
    totalScore: totalScore ?? this.totalScore,
    totalXs: totalXs ?? this.totalXs,
    bowId: bowId.present ? bowId.value : this.bowId,
    quiverId: quiverId.present ? quiverId.value : this.quiverId,
    shaftTaggingEnabled: shaftTaggingEnabled ?? this.shaftTaggingEnabled,
    deletedAt: deletedAt.present ? deletedAt.value : this.deletedAt,
  );
  Session copyWithCompanion(SessionsCompanion data) {
    return Session(
      id: data.id.present ? data.id.value : this.id,
      roundTypeId: data.roundTypeId.present
          ? data.roundTypeId.value
          : this.roundTypeId,
      sessionType: data.sessionType.present
          ? data.sessionType.value
          : this.sessionType,
      title: data.title.present ? data.title.value : this.title,
      locationName: data.locationName.present
          ? data.locationName.value
          : this.locationName,
      location: data.location.present ? data.location.value : this.location,
      latitude: data.latitude.present ? data.latitude.value : this.latitude,
      longitude: data.longitude.present ? data.longitude.value : this.longitude,
      notes: data.notes.present ? data.notes.value : this.notes,
      startedAt: data.startedAt.present ? data.startedAt.value : this.startedAt,
      completedAt: data.completedAt.present
          ? data.completedAt.value
          : this.completedAt,
      totalScore: data.totalScore.present
          ? data.totalScore.value
          : this.totalScore,
      totalXs: data.totalXs.present ? data.totalXs.value : this.totalXs,
      bowId: data.bowId.present ? data.bowId.value : this.bowId,
      quiverId: data.quiverId.present ? data.quiverId.value : this.quiverId,
      shaftTaggingEnabled: data.shaftTaggingEnabled.present
          ? data.shaftTaggingEnabled.value
          : this.shaftTaggingEnabled,
      deletedAt: data.deletedAt.present ? data.deletedAt.value : this.deletedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Session(')
          ..write('id: $id, ')
          ..write('roundTypeId: $roundTypeId, ')
          ..write('sessionType: $sessionType, ')
          ..write('title: $title, ')
          ..write('locationName: $locationName, ')
          ..write('location: $location, ')
          ..write('latitude: $latitude, ')
          ..write('longitude: $longitude, ')
          ..write('notes: $notes, ')
          ..write('startedAt: $startedAt, ')
          ..write('completedAt: $completedAt, ')
          ..write('totalScore: $totalScore, ')
          ..write('totalXs: $totalXs, ')
          ..write('bowId: $bowId, ')
          ..write('quiverId: $quiverId, ')
          ..write('shaftTaggingEnabled: $shaftTaggingEnabled, ')
          ..write('deletedAt: $deletedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    roundTypeId,
    sessionType,
    title,
    locationName,
    location,
    latitude,
    longitude,
    notes,
    startedAt,
    completedAt,
    totalScore,
    totalXs,
    bowId,
    quiverId,
    shaftTaggingEnabled,
    deletedAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Session &&
          other.id == this.id &&
          other.roundTypeId == this.roundTypeId &&
          other.sessionType == this.sessionType &&
          other.title == this.title &&
          other.locationName == this.locationName &&
          other.location == this.location &&
          other.latitude == this.latitude &&
          other.longitude == this.longitude &&
          other.notes == this.notes &&
          other.startedAt == this.startedAt &&
          other.completedAt == this.completedAt &&
          other.totalScore == this.totalScore &&
          other.totalXs == this.totalXs &&
          other.bowId == this.bowId &&
          other.quiverId == this.quiverId &&
          other.shaftTaggingEnabled == this.shaftTaggingEnabled &&
          other.deletedAt == this.deletedAt);
}

class SessionsCompanion extends UpdateCompanion<Session> {
  final Value<String> id;
  final Value<String> roundTypeId;
  final Value<String> sessionType;
  final Value<String?> title;
  final Value<String?> locationName;
  final Value<String?> location;
  final Value<double?> latitude;
  final Value<double?> longitude;
  final Value<String?> notes;
  final Value<DateTime> startedAt;
  final Value<DateTime?> completedAt;
  final Value<int> totalScore;
  final Value<int> totalXs;
  final Value<String?> bowId;
  final Value<String?> quiverId;
  final Value<bool> shaftTaggingEnabled;
  final Value<DateTime?> deletedAt;
  final Value<int> rowid;
  const SessionsCompanion({
    this.id = const Value.absent(),
    this.roundTypeId = const Value.absent(),
    this.sessionType = const Value.absent(),
    this.title = const Value.absent(),
    this.locationName = const Value.absent(),
    this.location = const Value.absent(),
    this.latitude = const Value.absent(),
    this.longitude = const Value.absent(),
    this.notes = const Value.absent(),
    this.startedAt = const Value.absent(),
    this.completedAt = const Value.absent(),
    this.totalScore = const Value.absent(),
    this.totalXs = const Value.absent(),
    this.bowId = const Value.absent(),
    this.quiverId = const Value.absent(),
    this.shaftTaggingEnabled = const Value.absent(),
    this.deletedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  SessionsCompanion.insert({
    required String id,
    required String roundTypeId,
    this.sessionType = const Value.absent(),
    this.title = const Value.absent(),
    this.locationName = const Value.absent(),
    this.location = const Value.absent(),
    this.latitude = const Value.absent(),
    this.longitude = const Value.absent(),
    this.notes = const Value.absent(),
    this.startedAt = const Value.absent(),
    this.completedAt = const Value.absent(),
    this.totalScore = const Value.absent(),
    this.totalXs = const Value.absent(),
    this.bowId = const Value.absent(),
    this.quiverId = const Value.absent(),
    this.shaftTaggingEnabled = const Value.absent(),
    this.deletedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       roundTypeId = Value(roundTypeId);
  static Insertable<Session> custom({
    Expression<String>? id,
    Expression<String>? roundTypeId,
    Expression<String>? sessionType,
    Expression<String>? title,
    Expression<String>? locationName,
    Expression<String>? location,
    Expression<double>? latitude,
    Expression<double>? longitude,
    Expression<String>? notes,
    Expression<DateTime>? startedAt,
    Expression<DateTime>? completedAt,
    Expression<int>? totalScore,
    Expression<int>? totalXs,
    Expression<String>? bowId,
    Expression<String>? quiverId,
    Expression<bool>? shaftTaggingEnabled,
    Expression<DateTime>? deletedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (roundTypeId != null) 'round_type_id': roundTypeId,
      if (sessionType != null) 'session_type': sessionType,
      if (title != null) 'title': title,
      if (locationName != null) 'location_name': locationName,
      if (location != null) 'location': location,
      if (latitude != null) 'latitude': latitude,
      if (longitude != null) 'longitude': longitude,
      if (notes != null) 'notes': notes,
      if (startedAt != null) 'started_at': startedAt,
      if (completedAt != null) 'completed_at': completedAt,
      if (totalScore != null) 'total_score': totalScore,
      if (totalXs != null) 'total_xs': totalXs,
      if (bowId != null) 'bow_id': bowId,
      if (quiverId != null) 'quiver_id': quiverId,
      if (shaftTaggingEnabled != null)
        'shaft_tagging_enabled': shaftTaggingEnabled,
      if (deletedAt != null) 'deleted_at': deletedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  SessionsCompanion copyWith({
    Value<String>? id,
    Value<String>? roundTypeId,
    Value<String>? sessionType,
    Value<String?>? title,
    Value<String?>? locationName,
    Value<String?>? location,
    Value<double?>? latitude,
    Value<double?>? longitude,
    Value<String?>? notes,
    Value<DateTime>? startedAt,
    Value<DateTime?>? completedAt,
    Value<int>? totalScore,
    Value<int>? totalXs,
    Value<String?>? bowId,
    Value<String?>? quiverId,
    Value<bool>? shaftTaggingEnabled,
    Value<DateTime?>? deletedAt,
    Value<int>? rowid,
  }) {
    return SessionsCompanion(
      id: id ?? this.id,
      roundTypeId: roundTypeId ?? this.roundTypeId,
      sessionType: sessionType ?? this.sessionType,
      title: title ?? this.title,
      locationName: locationName ?? this.locationName,
      location: location ?? this.location,
      latitude: latitude ?? this.latitude,
      longitude: longitude ?? this.longitude,
      notes: notes ?? this.notes,
      startedAt: startedAt ?? this.startedAt,
      completedAt: completedAt ?? this.completedAt,
      totalScore: totalScore ?? this.totalScore,
      totalXs: totalXs ?? this.totalXs,
      bowId: bowId ?? this.bowId,
      quiverId: quiverId ?? this.quiverId,
      shaftTaggingEnabled: shaftTaggingEnabled ?? this.shaftTaggingEnabled,
      deletedAt: deletedAt ?? this.deletedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (roundTypeId.present) {
      map['round_type_id'] = Variable<String>(roundTypeId.value);
    }
    if (sessionType.present) {
      map['session_type'] = Variable<String>(sessionType.value);
    }
    if (title.present) {
      map['title'] = Variable<String>(title.value);
    }
    if (locationName.present) {
      map['location_name'] = Variable<String>(locationName.value);
    }
    if (location.present) {
      map['location'] = Variable<String>(location.value);
    }
    if (latitude.present) {
      map['latitude'] = Variable<double>(latitude.value);
    }
    if (longitude.present) {
      map['longitude'] = Variable<double>(longitude.value);
    }
    if (notes.present) {
      map['notes'] = Variable<String>(notes.value);
    }
    if (startedAt.present) {
      map['started_at'] = Variable<DateTime>(startedAt.value);
    }
    if (completedAt.present) {
      map['completed_at'] = Variable<DateTime>(completedAt.value);
    }
    if (totalScore.present) {
      map['total_score'] = Variable<int>(totalScore.value);
    }
    if (totalXs.present) {
      map['total_xs'] = Variable<int>(totalXs.value);
    }
    if (bowId.present) {
      map['bow_id'] = Variable<String>(bowId.value);
    }
    if (quiverId.present) {
      map['quiver_id'] = Variable<String>(quiverId.value);
    }
    if (shaftTaggingEnabled.present) {
      map['shaft_tagging_enabled'] = Variable<bool>(shaftTaggingEnabled.value);
    }
    if (deletedAt.present) {
      map['deleted_at'] = Variable<DateTime>(deletedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('SessionsCompanion(')
          ..write('id: $id, ')
          ..write('roundTypeId: $roundTypeId, ')
          ..write('sessionType: $sessionType, ')
          ..write('title: $title, ')
          ..write('locationName: $locationName, ')
          ..write('location: $location, ')
          ..write('latitude: $latitude, ')
          ..write('longitude: $longitude, ')
          ..write('notes: $notes, ')
          ..write('startedAt: $startedAt, ')
          ..write('completedAt: $completedAt, ')
          ..write('totalScore: $totalScore, ')
          ..write('totalXs: $totalXs, ')
          ..write('bowId: $bowId, ')
          ..write('quiverId: $quiverId, ')
          ..write('shaftTaggingEnabled: $shaftTaggingEnabled, ')
          ..write('deletedAt: $deletedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $EndsTable extends Ends with TableInfo<$EndsTable, End> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $EndsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _sessionIdMeta = const VerificationMeta(
    'sessionId',
  );
  @override
  late final GeneratedColumn<String> sessionId = GeneratedColumn<String>(
    'session_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES sessions (id)',
    ),
  );
  static const VerificationMeta _endNumberMeta = const VerificationMeta(
    'endNumber',
  );
  @override
  late final GeneratedColumn<int> endNumber = GeneratedColumn<int>(
    'end_number',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _endScoreMeta = const VerificationMeta(
    'endScore',
  );
  @override
  late final GeneratedColumn<int> endScore = GeneratedColumn<int>(
    'end_score',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _endXsMeta = const VerificationMeta('endXs');
  @override
  late final GeneratedColumn<int> endXs = GeneratedColumn<int>(
    'end_xs',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _statusMeta = const VerificationMeta('status');
  @override
  late final GeneratedColumn<String> status = GeneratedColumn<String>(
    'status',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('active'),
  );
  static const VerificationMeta _committedAtMeta = const VerificationMeta(
    'committedAt',
  );
  @override
  late final GeneratedColumn<DateTime> committedAt = GeneratedColumn<DateTime>(
    'committed_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _deletedAtMeta = const VerificationMeta(
    'deletedAt',
  );
  @override
  late final GeneratedColumn<DateTime> deletedAt = GeneratedColumn<DateTime>(
    'deleted_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    sessionId,
    endNumber,
    endScore,
    endXs,
    status,
    committedAt,
    createdAt,
    updatedAt,
    deletedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'ends';
  @override
  VerificationContext validateIntegrity(
    Insertable<End> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('session_id')) {
      context.handle(
        _sessionIdMeta,
        sessionId.isAcceptableOrUnknown(data['session_id']!, _sessionIdMeta),
      );
    } else if (isInserting) {
      context.missing(_sessionIdMeta);
    }
    if (data.containsKey('end_number')) {
      context.handle(
        _endNumberMeta,
        endNumber.isAcceptableOrUnknown(data['end_number']!, _endNumberMeta),
      );
    } else if (isInserting) {
      context.missing(_endNumberMeta);
    }
    if (data.containsKey('end_score')) {
      context.handle(
        _endScoreMeta,
        endScore.isAcceptableOrUnknown(data['end_score']!, _endScoreMeta),
      );
    }
    if (data.containsKey('end_xs')) {
      context.handle(
        _endXsMeta,
        endXs.isAcceptableOrUnknown(data['end_xs']!, _endXsMeta),
      );
    }
    if (data.containsKey('status')) {
      context.handle(
        _statusMeta,
        status.isAcceptableOrUnknown(data['status']!, _statusMeta),
      );
    }
    if (data.containsKey('committed_at')) {
      context.handle(
        _committedAtMeta,
        committedAt.isAcceptableOrUnknown(
          data['committed_at']!,
          _committedAtMeta,
        ),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    }
    if (data.containsKey('deleted_at')) {
      context.handle(
        _deletedAtMeta,
        deletedAt.isAcceptableOrUnknown(data['deleted_at']!, _deletedAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  End map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return End(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      sessionId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}session_id'],
      )!,
      endNumber: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}end_number'],
      )!,
      endScore: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}end_score'],
      )!,
      endXs: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}end_xs'],
      )!,
      status: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}status'],
      )!,
      committedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}committed_at'],
      ),
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      )!,
      deletedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}deleted_at'],
      ),
    );
  }

  @override
  $EndsTable createAlias(String alias) {
    return $EndsTable(attachedDatabase, alias);
  }
}

class End extends DataClass implements Insertable<End> {
  final String id;
  final String sessionId;
  final int endNumber;
  final int endScore;
  final int endXs;
  final String status;
  final DateTime? committedAt;
  final DateTime createdAt;
  final DateTime updatedAt;
  final DateTime? deletedAt;
  const End({
    required this.id,
    required this.sessionId,
    required this.endNumber,
    required this.endScore,
    required this.endXs,
    required this.status,
    this.committedAt,
    required this.createdAt,
    required this.updatedAt,
    this.deletedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['session_id'] = Variable<String>(sessionId);
    map['end_number'] = Variable<int>(endNumber);
    map['end_score'] = Variable<int>(endScore);
    map['end_xs'] = Variable<int>(endXs);
    map['status'] = Variable<String>(status);
    if (!nullToAbsent || committedAt != null) {
      map['committed_at'] = Variable<DateTime>(committedAt);
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    if (!nullToAbsent || deletedAt != null) {
      map['deleted_at'] = Variable<DateTime>(deletedAt);
    }
    return map;
  }

  EndsCompanion toCompanion(bool nullToAbsent) {
    return EndsCompanion(
      id: Value(id),
      sessionId: Value(sessionId),
      endNumber: Value(endNumber),
      endScore: Value(endScore),
      endXs: Value(endXs),
      status: Value(status),
      committedAt: committedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(committedAt),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
      deletedAt: deletedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(deletedAt),
    );
  }

  factory End.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return End(
      id: serializer.fromJson<String>(json['id']),
      sessionId: serializer.fromJson<String>(json['sessionId']),
      endNumber: serializer.fromJson<int>(json['endNumber']),
      endScore: serializer.fromJson<int>(json['endScore']),
      endXs: serializer.fromJson<int>(json['endXs']),
      status: serializer.fromJson<String>(json['status']),
      committedAt: serializer.fromJson<DateTime?>(json['committedAt']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
      deletedAt: serializer.fromJson<DateTime?>(json['deletedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'sessionId': serializer.toJson<String>(sessionId),
      'endNumber': serializer.toJson<int>(endNumber),
      'endScore': serializer.toJson<int>(endScore),
      'endXs': serializer.toJson<int>(endXs),
      'status': serializer.toJson<String>(status),
      'committedAt': serializer.toJson<DateTime?>(committedAt),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
      'deletedAt': serializer.toJson<DateTime?>(deletedAt),
    };
  }

  End copyWith({
    String? id,
    String? sessionId,
    int? endNumber,
    int? endScore,
    int? endXs,
    String? status,
    Value<DateTime?> committedAt = const Value.absent(),
    DateTime? createdAt,
    DateTime? updatedAt,
    Value<DateTime?> deletedAt = const Value.absent(),
  }) => End(
    id: id ?? this.id,
    sessionId: sessionId ?? this.sessionId,
    endNumber: endNumber ?? this.endNumber,
    endScore: endScore ?? this.endScore,
    endXs: endXs ?? this.endXs,
    status: status ?? this.status,
    committedAt: committedAt.present ? committedAt.value : this.committedAt,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
    deletedAt: deletedAt.present ? deletedAt.value : this.deletedAt,
  );
  End copyWithCompanion(EndsCompanion data) {
    return End(
      id: data.id.present ? data.id.value : this.id,
      sessionId: data.sessionId.present ? data.sessionId.value : this.sessionId,
      endNumber: data.endNumber.present ? data.endNumber.value : this.endNumber,
      endScore: data.endScore.present ? data.endScore.value : this.endScore,
      endXs: data.endXs.present ? data.endXs.value : this.endXs,
      status: data.status.present ? data.status.value : this.status,
      committedAt: data.committedAt.present
          ? data.committedAt.value
          : this.committedAt,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
      deletedAt: data.deletedAt.present ? data.deletedAt.value : this.deletedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('End(')
          ..write('id: $id, ')
          ..write('sessionId: $sessionId, ')
          ..write('endNumber: $endNumber, ')
          ..write('endScore: $endScore, ')
          ..write('endXs: $endXs, ')
          ..write('status: $status, ')
          ..write('committedAt: $committedAt, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('deletedAt: $deletedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    sessionId,
    endNumber,
    endScore,
    endXs,
    status,
    committedAt,
    createdAt,
    updatedAt,
    deletedAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is End &&
          other.id == this.id &&
          other.sessionId == this.sessionId &&
          other.endNumber == this.endNumber &&
          other.endScore == this.endScore &&
          other.endXs == this.endXs &&
          other.status == this.status &&
          other.committedAt == this.committedAt &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt &&
          other.deletedAt == this.deletedAt);
}

class EndsCompanion extends UpdateCompanion<End> {
  final Value<String> id;
  final Value<String> sessionId;
  final Value<int> endNumber;
  final Value<int> endScore;
  final Value<int> endXs;
  final Value<String> status;
  final Value<DateTime?> committedAt;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  final Value<DateTime?> deletedAt;
  final Value<int> rowid;
  const EndsCompanion({
    this.id = const Value.absent(),
    this.sessionId = const Value.absent(),
    this.endNumber = const Value.absent(),
    this.endScore = const Value.absent(),
    this.endXs = const Value.absent(),
    this.status = const Value.absent(),
    this.committedAt = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.deletedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  EndsCompanion.insert({
    required String id,
    required String sessionId,
    required int endNumber,
    this.endScore = const Value.absent(),
    this.endXs = const Value.absent(),
    this.status = const Value.absent(),
    this.committedAt = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.deletedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       sessionId = Value(sessionId),
       endNumber = Value(endNumber);
  static Insertable<End> custom({
    Expression<String>? id,
    Expression<String>? sessionId,
    Expression<int>? endNumber,
    Expression<int>? endScore,
    Expression<int>? endXs,
    Expression<String>? status,
    Expression<DateTime>? committedAt,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
    Expression<DateTime>? deletedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (sessionId != null) 'session_id': sessionId,
      if (endNumber != null) 'end_number': endNumber,
      if (endScore != null) 'end_score': endScore,
      if (endXs != null) 'end_xs': endXs,
      if (status != null) 'status': status,
      if (committedAt != null) 'committed_at': committedAt,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (deletedAt != null) 'deleted_at': deletedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  EndsCompanion copyWith({
    Value<String>? id,
    Value<String>? sessionId,
    Value<int>? endNumber,
    Value<int>? endScore,
    Value<int>? endXs,
    Value<String>? status,
    Value<DateTime?>? committedAt,
    Value<DateTime>? createdAt,
    Value<DateTime>? updatedAt,
    Value<DateTime?>? deletedAt,
    Value<int>? rowid,
  }) {
    return EndsCompanion(
      id: id ?? this.id,
      sessionId: sessionId ?? this.sessionId,
      endNumber: endNumber ?? this.endNumber,
      endScore: endScore ?? this.endScore,
      endXs: endXs ?? this.endXs,
      status: status ?? this.status,
      committedAt: committedAt ?? this.committedAt,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      deletedAt: deletedAt ?? this.deletedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (sessionId.present) {
      map['session_id'] = Variable<String>(sessionId.value);
    }
    if (endNumber.present) {
      map['end_number'] = Variable<int>(endNumber.value);
    }
    if (endScore.present) {
      map['end_score'] = Variable<int>(endScore.value);
    }
    if (endXs.present) {
      map['end_xs'] = Variable<int>(endXs.value);
    }
    if (status.present) {
      map['status'] = Variable<String>(status.value);
    }
    if (committedAt.present) {
      map['committed_at'] = Variable<DateTime>(committedAt.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (deletedAt.present) {
      map['deleted_at'] = Variable<DateTime>(deletedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('EndsCompanion(')
          ..write('id: $id, ')
          ..write('sessionId: $sessionId, ')
          ..write('endNumber: $endNumber, ')
          ..write('endScore: $endScore, ')
          ..write('endXs: $endXs, ')
          ..write('status: $status, ')
          ..write('committedAt: $committedAt, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('deletedAt: $deletedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $ShaftsTable extends Shafts with TableInfo<$ShaftsTable, Shaft> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ShaftsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _quiverIdMeta = const VerificationMeta(
    'quiverId',
  );
  @override
  late final GeneratedColumn<String> quiverId = GeneratedColumn<String>(
    'quiver_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES quivers (id)',
    ),
  );
  static const VerificationMeta _numberMeta = const VerificationMeta('number');
  @override
  late final GeneratedColumn<int> number = GeneratedColumn<int>(
    'number',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _diameterMeta = const VerificationMeta(
    'diameter',
  );
  @override
  late final GeneratedColumn<String> diameter = GeneratedColumn<String>(
    'diameter',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _spineMeta = const VerificationMeta('spine');
  @override
  late final GeneratedColumn<int> spine = GeneratedColumn<int>(
    'spine',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _lengthInchesMeta = const VerificationMeta(
    'lengthInches',
  );
  @override
  late final GeneratedColumn<double> lengthInches = GeneratedColumn<double>(
    'length_inches',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _pointWeightMeta = const VerificationMeta(
    'pointWeight',
  );
  @override
  late final GeneratedColumn<int> pointWeight = GeneratedColumn<int>(
    'point_weight',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _fletchingTypeMeta = const VerificationMeta(
    'fletchingType',
  );
  @override
  late final GeneratedColumn<String> fletchingType = GeneratedColumn<String>(
    'fletching_type',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _fletchingColorMeta = const VerificationMeta(
    'fletchingColor',
  );
  @override
  late final GeneratedColumn<String> fletchingColor = GeneratedColumn<String>(
    'fletching_color',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _nockColorMeta = const VerificationMeta(
    'nockColor',
  );
  @override
  late final GeneratedColumn<String> nockColor = GeneratedColumn<String>(
    'nock_color',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _notesMeta = const VerificationMeta('notes');
  @override
  late final GeneratedColumn<String> notes = GeneratedColumn<String>(
    'notes',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _retiredAtMeta = const VerificationMeta(
    'retiredAt',
  );
  @override
  late final GeneratedColumn<DateTime> retiredAt = GeneratedColumn<DateTime>(
    'retired_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _totalWeightMeta = const VerificationMeta(
    'totalWeight',
  );
  @override
  late final GeneratedColumn<double> totalWeight = GeneratedColumn<double>(
    'total_weight',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _pointTypeMeta = const VerificationMeta(
    'pointType',
  );
  @override
  late final GeneratedColumn<String> pointType = GeneratedColumn<String>(
    'point_type',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _nockBrandMeta = const VerificationMeta(
    'nockBrand',
  );
  @override
  late final GeneratedColumn<String> nockBrand = GeneratedColumn<String>(
    'nock_brand',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _fletchingSizeMeta = const VerificationMeta(
    'fletchingSize',
  );
  @override
  late final GeneratedColumn<String> fletchingSize = GeneratedColumn<String>(
    'fletching_size',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _fletchingAngleMeta = const VerificationMeta(
    'fletchingAngle',
  );
  @override
  late final GeneratedColumn<double> fletchingAngle = GeneratedColumn<double>(
    'fletching_angle',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _hasWrapMeta = const VerificationMeta(
    'hasWrap',
  );
  @override
  late final GeneratedColumn<bool> hasWrap = GeneratedColumn<bool>(
    'has_wrap',
    aliasedName,
    true,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("has_wrap" IN (0, 1))',
    ),
  );
  static const VerificationMeta _wrapColorMeta = const VerificationMeta(
    'wrapColor',
  );
  @override
  late final GeneratedColumn<String> wrapColor = GeneratedColumn<String>(
    'wrap_color',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _purchaseDateMeta = const VerificationMeta(
    'purchaseDate',
  );
  @override
  late final GeneratedColumn<DateTime> purchaseDate = GeneratedColumn<DateTime>(
    'purchase_date',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    quiverId,
    number,
    diameter,
    spine,
    lengthInches,
    pointWeight,
    fletchingType,
    fletchingColor,
    nockColor,
    notes,
    createdAt,
    retiredAt,
    totalWeight,
    pointType,
    nockBrand,
    fletchingSize,
    fletchingAngle,
    hasWrap,
    wrapColor,
    purchaseDate,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'shafts';
  @override
  VerificationContext validateIntegrity(
    Insertable<Shaft> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('quiver_id')) {
      context.handle(
        _quiverIdMeta,
        quiverId.isAcceptableOrUnknown(data['quiver_id']!, _quiverIdMeta),
      );
    } else if (isInserting) {
      context.missing(_quiverIdMeta);
    }
    if (data.containsKey('number')) {
      context.handle(
        _numberMeta,
        number.isAcceptableOrUnknown(data['number']!, _numberMeta),
      );
    } else if (isInserting) {
      context.missing(_numberMeta);
    }
    if (data.containsKey('diameter')) {
      context.handle(
        _diameterMeta,
        diameter.isAcceptableOrUnknown(data['diameter']!, _diameterMeta),
      );
    }
    if (data.containsKey('spine')) {
      context.handle(
        _spineMeta,
        spine.isAcceptableOrUnknown(data['spine']!, _spineMeta),
      );
    }
    if (data.containsKey('length_inches')) {
      context.handle(
        _lengthInchesMeta,
        lengthInches.isAcceptableOrUnknown(
          data['length_inches']!,
          _lengthInchesMeta,
        ),
      );
    }
    if (data.containsKey('point_weight')) {
      context.handle(
        _pointWeightMeta,
        pointWeight.isAcceptableOrUnknown(
          data['point_weight']!,
          _pointWeightMeta,
        ),
      );
    }
    if (data.containsKey('fletching_type')) {
      context.handle(
        _fletchingTypeMeta,
        fletchingType.isAcceptableOrUnknown(
          data['fletching_type']!,
          _fletchingTypeMeta,
        ),
      );
    }
    if (data.containsKey('fletching_color')) {
      context.handle(
        _fletchingColorMeta,
        fletchingColor.isAcceptableOrUnknown(
          data['fletching_color']!,
          _fletchingColorMeta,
        ),
      );
    }
    if (data.containsKey('nock_color')) {
      context.handle(
        _nockColorMeta,
        nockColor.isAcceptableOrUnknown(data['nock_color']!, _nockColorMeta),
      );
    }
    if (data.containsKey('notes')) {
      context.handle(
        _notesMeta,
        notes.isAcceptableOrUnknown(data['notes']!, _notesMeta),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    if (data.containsKey('retired_at')) {
      context.handle(
        _retiredAtMeta,
        retiredAt.isAcceptableOrUnknown(data['retired_at']!, _retiredAtMeta),
      );
    }
    if (data.containsKey('total_weight')) {
      context.handle(
        _totalWeightMeta,
        totalWeight.isAcceptableOrUnknown(
          data['total_weight']!,
          _totalWeightMeta,
        ),
      );
    }
    if (data.containsKey('point_type')) {
      context.handle(
        _pointTypeMeta,
        pointType.isAcceptableOrUnknown(data['point_type']!, _pointTypeMeta),
      );
    }
    if (data.containsKey('nock_brand')) {
      context.handle(
        _nockBrandMeta,
        nockBrand.isAcceptableOrUnknown(data['nock_brand']!, _nockBrandMeta),
      );
    }
    if (data.containsKey('fletching_size')) {
      context.handle(
        _fletchingSizeMeta,
        fletchingSize.isAcceptableOrUnknown(
          data['fletching_size']!,
          _fletchingSizeMeta,
        ),
      );
    }
    if (data.containsKey('fletching_angle')) {
      context.handle(
        _fletchingAngleMeta,
        fletchingAngle.isAcceptableOrUnknown(
          data['fletching_angle']!,
          _fletchingAngleMeta,
        ),
      );
    }
    if (data.containsKey('has_wrap')) {
      context.handle(
        _hasWrapMeta,
        hasWrap.isAcceptableOrUnknown(data['has_wrap']!, _hasWrapMeta),
      );
    }
    if (data.containsKey('wrap_color')) {
      context.handle(
        _wrapColorMeta,
        wrapColor.isAcceptableOrUnknown(data['wrap_color']!, _wrapColorMeta),
      );
    }
    if (data.containsKey('purchase_date')) {
      context.handle(
        _purchaseDateMeta,
        purchaseDate.isAcceptableOrUnknown(
          data['purchase_date']!,
          _purchaseDateMeta,
        ),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  Shaft map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Shaft(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      quiverId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}quiver_id'],
      )!,
      number: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}number'],
      )!,
      diameter: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}diameter'],
      ),
      spine: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}spine'],
      ),
      lengthInches: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}length_inches'],
      ),
      pointWeight: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}point_weight'],
      ),
      fletchingType: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}fletching_type'],
      ),
      fletchingColor: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}fletching_color'],
      ),
      nockColor: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}nock_color'],
      ),
      notes: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}notes'],
      ),
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      retiredAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}retired_at'],
      ),
      totalWeight: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}total_weight'],
      ),
      pointType: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}point_type'],
      ),
      nockBrand: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}nock_brand'],
      ),
      fletchingSize: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}fletching_size'],
      ),
      fletchingAngle: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}fletching_angle'],
      ),
      hasWrap: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}has_wrap'],
      ),
      wrapColor: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}wrap_color'],
      ),
      purchaseDate: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}purchase_date'],
      ),
    );
  }

  @override
  $ShaftsTable createAlias(String alias) {
    return $ShaftsTable(attachedDatabase, alias);
  }
}

class Shaft extends DataClass implements Insertable<Shaft> {
  final String id;
  final String quiverId;
  final int number;
  final String? diameter;
  final int? spine;
  final double? lengthInches;
  final int? pointWeight;
  final String? fletchingType;
  final String? fletchingColor;
  final String? nockColor;
  final String? notes;
  final DateTime createdAt;
  final DateTime? retiredAt;
  final double? totalWeight;
  final String? pointType;
  final String? nockBrand;
  final String? fletchingSize;
  final double? fletchingAngle;
  final bool? hasWrap;
  final String? wrapColor;
  final DateTime? purchaseDate;
  const Shaft({
    required this.id,
    required this.quiverId,
    required this.number,
    this.diameter,
    this.spine,
    this.lengthInches,
    this.pointWeight,
    this.fletchingType,
    this.fletchingColor,
    this.nockColor,
    this.notes,
    required this.createdAt,
    this.retiredAt,
    this.totalWeight,
    this.pointType,
    this.nockBrand,
    this.fletchingSize,
    this.fletchingAngle,
    this.hasWrap,
    this.wrapColor,
    this.purchaseDate,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['quiver_id'] = Variable<String>(quiverId);
    map['number'] = Variable<int>(number);
    if (!nullToAbsent || diameter != null) {
      map['diameter'] = Variable<String>(diameter);
    }
    if (!nullToAbsent || spine != null) {
      map['spine'] = Variable<int>(spine);
    }
    if (!nullToAbsent || lengthInches != null) {
      map['length_inches'] = Variable<double>(lengthInches);
    }
    if (!nullToAbsent || pointWeight != null) {
      map['point_weight'] = Variable<int>(pointWeight);
    }
    if (!nullToAbsent || fletchingType != null) {
      map['fletching_type'] = Variable<String>(fletchingType);
    }
    if (!nullToAbsent || fletchingColor != null) {
      map['fletching_color'] = Variable<String>(fletchingColor);
    }
    if (!nullToAbsent || nockColor != null) {
      map['nock_color'] = Variable<String>(nockColor);
    }
    if (!nullToAbsent || notes != null) {
      map['notes'] = Variable<String>(notes);
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    if (!nullToAbsent || retiredAt != null) {
      map['retired_at'] = Variable<DateTime>(retiredAt);
    }
    if (!nullToAbsent || totalWeight != null) {
      map['total_weight'] = Variable<double>(totalWeight);
    }
    if (!nullToAbsent || pointType != null) {
      map['point_type'] = Variable<String>(pointType);
    }
    if (!nullToAbsent || nockBrand != null) {
      map['nock_brand'] = Variable<String>(nockBrand);
    }
    if (!nullToAbsent || fletchingSize != null) {
      map['fletching_size'] = Variable<String>(fletchingSize);
    }
    if (!nullToAbsent || fletchingAngle != null) {
      map['fletching_angle'] = Variable<double>(fletchingAngle);
    }
    if (!nullToAbsent || hasWrap != null) {
      map['has_wrap'] = Variable<bool>(hasWrap);
    }
    if (!nullToAbsent || wrapColor != null) {
      map['wrap_color'] = Variable<String>(wrapColor);
    }
    if (!nullToAbsent || purchaseDate != null) {
      map['purchase_date'] = Variable<DateTime>(purchaseDate);
    }
    return map;
  }

  ShaftsCompanion toCompanion(bool nullToAbsent) {
    return ShaftsCompanion(
      id: Value(id),
      quiverId: Value(quiverId),
      number: Value(number),
      diameter: diameter == null && nullToAbsent
          ? const Value.absent()
          : Value(diameter),
      spine: spine == null && nullToAbsent
          ? const Value.absent()
          : Value(spine),
      lengthInches: lengthInches == null && nullToAbsent
          ? const Value.absent()
          : Value(lengthInches),
      pointWeight: pointWeight == null && nullToAbsent
          ? const Value.absent()
          : Value(pointWeight),
      fletchingType: fletchingType == null && nullToAbsent
          ? const Value.absent()
          : Value(fletchingType),
      fletchingColor: fletchingColor == null && nullToAbsent
          ? const Value.absent()
          : Value(fletchingColor),
      nockColor: nockColor == null && nullToAbsent
          ? const Value.absent()
          : Value(nockColor),
      notes: notes == null && nullToAbsent
          ? const Value.absent()
          : Value(notes),
      createdAt: Value(createdAt),
      retiredAt: retiredAt == null && nullToAbsent
          ? const Value.absent()
          : Value(retiredAt),
      totalWeight: totalWeight == null && nullToAbsent
          ? const Value.absent()
          : Value(totalWeight),
      pointType: pointType == null && nullToAbsent
          ? const Value.absent()
          : Value(pointType),
      nockBrand: nockBrand == null && nullToAbsent
          ? const Value.absent()
          : Value(nockBrand),
      fletchingSize: fletchingSize == null && nullToAbsent
          ? const Value.absent()
          : Value(fletchingSize),
      fletchingAngle: fletchingAngle == null && nullToAbsent
          ? const Value.absent()
          : Value(fletchingAngle),
      hasWrap: hasWrap == null && nullToAbsent
          ? const Value.absent()
          : Value(hasWrap),
      wrapColor: wrapColor == null && nullToAbsent
          ? const Value.absent()
          : Value(wrapColor),
      purchaseDate: purchaseDate == null && nullToAbsent
          ? const Value.absent()
          : Value(purchaseDate),
    );
  }

  factory Shaft.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Shaft(
      id: serializer.fromJson<String>(json['id']),
      quiverId: serializer.fromJson<String>(json['quiverId']),
      number: serializer.fromJson<int>(json['number']),
      diameter: serializer.fromJson<String?>(json['diameter']),
      spine: serializer.fromJson<int?>(json['spine']),
      lengthInches: serializer.fromJson<double?>(json['lengthInches']),
      pointWeight: serializer.fromJson<int?>(json['pointWeight']),
      fletchingType: serializer.fromJson<String?>(json['fletchingType']),
      fletchingColor: serializer.fromJson<String?>(json['fletchingColor']),
      nockColor: serializer.fromJson<String?>(json['nockColor']),
      notes: serializer.fromJson<String?>(json['notes']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      retiredAt: serializer.fromJson<DateTime?>(json['retiredAt']),
      totalWeight: serializer.fromJson<double?>(json['totalWeight']),
      pointType: serializer.fromJson<String?>(json['pointType']),
      nockBrand: serializer.fromJson<String?>(json['nockBrand']),
      fletchingSize: serializer.fromJson<String?>(json['fletchingSize']),
      fletchingAngle: serializer.fromJson<double?>(json['fletchingAngle']),
      hasWrap: serializer.fromJson<bool?>(json['hasWrap']),
      wrapColor: serializer.fromJson<String?>(json['wrapColor']),
      purchaseDate: serializer.fromJson<DateTime?>(json['purchaseDate']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'quiverId': serializer.toJson<String>(quiverId),
      'number': serializer.toJson<int>(number),
      'diameter': serializer.toJson<String?>(diameter),
      'spine': serializer.toJson<int?>(spine),
      'lengthInches': serializer.toJson<double?>(lengthInches),
      'pointWeight': serializer.toJson<int?>(pointWeight),
      'fletchingType': serializer.toJson<String?>(fletchingType),
      'fletchingColor': serializer.toJson<String?>(fletchingColor),
      'nockColor': serializer.toJson<String?>(nockColor),
      'notes': serializer.toJson<String?>(notes),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'retiredAt': serializer.toJson<DateTime?>(retiredAt),
      'totalWeight': serializer.toJson<double?>(totalWeight),
      'pointType': serializer.toJson<String?>(pointType),
      'nockBrand': serializer.toJson<String?>(nockBrand),
      'fletchingSize': serializer.toJson<String?>(fletchingSize),
      'fletchingAngle': serializer.toJson<double?>(fletchingAngle),
      'hasWrap': serializer.toJson<bool?>(hasWrap),
      'wrapColor': serializer.toJson<String?>(wrapColor),
      'purchaseDate': serializer.toJson<DateTime?>(purchaseDate),
    };
  }

  Shaft copyWith({
    String? id,
    String? quiverId,
    int? number,
    Value<String?> diameter = const Value.absent(),
    Value<int?> spine = const Value.absent(),
    Value<double?> lengthInches = const Value.absent(),
    Value<int?> pointWeight = const Value.absent(),
    Value<String?> fletchingType = const Value.absent(),
    Value<String?> fletchingColor = const Value.absent(),
    Value<String?> nockColor = const Value.absent(),
    Value<String?> notes = const Value.absent(),
    DateTime? createdAt,
    Value<DateTime?> retiredAt = const Value.absent(),
    Value<double?> totalWeight = const Value.absent(),
    Value<String?> pointType = const Value.absent(),
    Value<String?> nockBrand = const Value.absent(),
    Value<String?> fletchingSize = const Value.absent(),
    Value<double?> fletchingAngle = const Value.absent(),
    Value<bool?> hasWrap = const Value.absent(),
    Value<String?> wrapColor = const Value.absent(),
    Value<DateTime?> purchaseDate = const Value.absent(),
  }) => Shaft(
    id: id ?? this.id,
    quiverId: quiverId ?? this.quiverId,
    number: number ?? this.number,
    diameter: diameter.present ? diameter.value : this.diameter,
    spine: spine.present ? spine.value : this.spine,
    lengthInches: lengthInches.present ? lengthInches.value : this.lengthInches,
    pointWeight: pointWeight.present ? pointWeight.value : this.pointWeight,
    fletchingType: fletchingType.present
        ? fletchingType.value
        : this.fletchingType,
    fletchingColor: fletchingColor.present
        ? fletchingColor.value
        : this.fletchingColor,
    nockColor: nockColor.present ? nockColor.value : this.nockColor,
    notes: notes.present ? notes.value : this.notes,
    createdAt: createdAt ?? this.createdAt,
    retiredAt: retiredAt.present ? retiredAt.value : this.retiredAt,
    totalWeight: totalWeight.present ? totalWeight.value : this.totalWeight,
    pointType: pointType.present ? pointType.value : this.pointType,
    nockBrand: nockBrand.present ? nockBrand.value : this.nockBrand,
    fletchingSize: fletchingSize.present
        ? fletchingSize.value
        : this.fletchingSize,
    fletchingAngle: fletchingAngle.present
        ? fletchingAngle.value
        : this.fletchingAngle,
    hasWrap: hasWrap.present ? hasWrap.value : this.hasWrap,
    wrapColor: wrapColor.present ? wrapColor.value : this.wrapColor,
    purchaseDate: purchaseDate.present ? purchaseDate.value : this.purchaseDate,
  );
  Shaft copyWithCompanion(ShaftsCompanion data) {
    return Shaft(
      id: data.id.present ? data.id.value : this.id,
      quiverId: data.quiverId.present ? data.quiverId.value : this.quiverId,
      number: data.number.present ? data.number.value : this.number,
      diameter: data.diameter.present ? data.diameter.value : this.diameter,
      spine: data.spine.present ? data.spine.value : this.spine,
      lengthInches: data.lengthInches.present
          ? data.lengthInches.value
          : this.lengthInches,
      pointWeight: data.pointWeight.present
          ? data.pointWeight.value
          : this.pointWeight,
      fletchingType: data.fletchingType.present
          ? data.fletchingType.value
          : this.fletchingType,
      fletchingColor: data.fletchingColor.present
          ? data.fletchingColor.value
          : this.fletchingColor,
      nockColor: data.nockColor.present ? data.nockColor.value : this.nockColor,
      notes: data.notes.present ? data.notes.value : this.notes,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      retiredAt: data.retiredAt.present ? data.retiredAt.value : this.retiredAt,
      totalWeight: data.totalWeight.present
          ? data.totalWeight.value
          : this.totalWeight,
      pointType: data.pointType.present ? data.pointType.value : this.pointType,
      nockBrand: data.nockBrand.present ? data.nockBrand.value : this.nockBrand,
      fletchingSize: data.fletchingSize.present
          ? data.fletchingSize.value
          : this.fletchingSize,
      fletchingAngle: data.fletchingAngle.present
          ? data.fletchingAngle.value
          : this.fletchingAngle,
      hasWrap: data.hasWrap.present ? data.hasWrap.value : this.hasWrap,
      wrapColor: data.wrapColor.present ? data.wrapColor.value : this.wrapColor,
      purchaseDate: data.purchaseDate.present
          ? data.purchaseDate.value
          : this.purchaseDate,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Shaft(')
          ..write('id: $id, ')
          ..write('quiverId: $quiverId, ')
          ..write('number: $number, ')
          ..write('diameter: $diameter, ')
          ..write('spine: $spine, ')
          ..write('lengthInches: $lengthInches, ')
          ..write('pointWeight: $pointWeight, ')
          ..write('fletchingType: $fletchingType, ')
          ..write('fletchingColor: $fletchingColor, ')
          ..write('nockColor: $nockColor, ')
          ..write('notes: $notes, ')
          ..write('createdAt: $createdAt, ')
          ..write('retiredAt: $retiredAt, ')
          ..write('totalWeight: $totalWeight, ')
          ..write('pointType: $pointType, ')
          ..write('nockBrand: $nockBrand, ')
          ..write('fletchingSize: $fletchingSize, ')
          ..write('fletchingAngle: $fletchingAngle, ')
          ..write('hasWrap: $hasWrap, ')
          ..write('wrapColor: $wrapColor, ')
          ..write('purchaseDate: $purchaseDate')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hashAll([
    id,
    quiverId,
    number,
    diameter,
    spine,
    lengthInches,
    pointWeight,
    fletchingType,
    fletchingColor,
    nockColor,
    notes,
    createdAt,
    retiredAt,
    totalWeight,
    pointType,
    nockBrand,
    fletchingSize,
    fletchingAngle,
    hasWrap,
    wrapColor,
    purchaseDate,
  ]);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Shaft &&
          other.id == this.id &&
          other.quiverId == this.quiverId &&
          other.number == this.number &&
          other.diameter == this.diameter &&
          other.spine == this.spine &&
          other.lengthInches == this.lengthInches &&
          other.pointWeight == this.pointWeight &&
          other.fletchingType == this.fletchingType &&
          other.fletchingColor == this.fletchingColor &&
          other.nockColor == this.nockColor &&
          other.notes == this.notes &&
          other.createdAt == this.createdAt &&
          other.retiredAt == this.retiredAt &&
          other.totalWeight == this.totalWeight &&
          other.pointType == this.pointType &&
          other.nockBrand == this.nockBrand &&
          other.fletchingSize == this.fletchingSize &&
          other.fletchingAngle == this.fletchingAngle &&
          other.hasWrap == this.hasWrap &&
          other.wrapColor == this.wrapColor &&
          other.purchaseDate == this.purchaseDate);
}

class ShaftsCompanion extends UpdateCompanion<Shaft> {
  final Value<String> id;
  final Value<String> quiverId;
  final Value<int> number;
  final Value<String?> diameter;
  final Value<int?> spine;
  final Value<double?> lengthInches;
  final Value<int?> pointWeight;
  final Value<String?> fletchingType;
  final Value<String?> fletchingColor;
  final Value<String?> nockColor;
  final Value<String?> notes;
  final Value<DateTime> createdAt;
  final Value<DateTime?> retiredAt;
  final Value<double?> totalWeight;
  final Value<String?> pointType;
  final Value<String?> nockBrand;
  final Value<String?> fletchingSize;
  final Value<double?> fletchingAngle;
  final Value<bool?> hasWrap;
  final Value<String?> wrapColor;
  final Value<DateTime?> purchaseDate;
  final Value<int> rowid;
  const ShaftsCompanion({
    this.id = const Value.absent(),
    this.quiverId = const Value.absent(),
    this.number = const Value.absent(),
    this.diameter = const Value.absent(),
    this.spine = const Value.absent(),
    this.lengthInches = const Value.absent(),
    this.pointWeight = const Value.absent(),
    this.fletchingType = const Value.absent(),
    this.fletchingColor = const Value.absent(),
    this.nockColor = const Value.absent(),
    this.notes = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.retiredAt = const Value.absent(),
    this.totalWeight = const Value.absent(),
    this.pointType = const Value.absent(),
    this.nockBrand = const Value.absent(),
    this.fletchingSize = const Value.absent(),
    this.fletchingAngle = const Value.absent(),
    this.hasWrap = const Value.absent(),
    this.wrapColor = const Value.absent(),
    this.purchaseDate = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  ShaftsCompanion.insert({
    required String id,
    required String quiverId,
    required int number,
    this.diameter = const Value.absent(),
    this.spine = const Value.absent(),
    this.lengthInches = const Value.absent(),
    this.pointWeight = const Value.absent(),
    this.fletchingType = const Value.absent(),
    this.fletchingColor = const Value.absent(),
    this.nockColor = const Value.absent(),
    this.notes = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.retiredAt = const Value.absent(),
    this.totalWeight = const Value.absent(),
    this.pointType = const Value.absent(),
    this.nockBrand = const Value.absent(),
    this.fletchingSize = const Value.absent(),
    this.fletchingAngle = const Value.absent(),
    this.hasWrap = const Value.absent(),
    this.wrapColor = const Value.absent(),
    this.purchaseDate = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       quiverId = Value(quiverId),
       number = Value(number);
  static Insertable<Shaft> custom({
    Expression<String>? id,
    Expression<String>? quiverId,
    Expression<int>? number,
    Expression<String>? diameter,
    Expression<int>? spine,
    Expression<double>? lengthInches,
    Expression<int>? pointWeight,
    Expression<String>? fletchingType,
    Expression<String>? fletchingColor,
    Expression<String>? nockColor,
    Expression<String>? notes,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? retiredAt,
    Expression<double>? totalWeight,
    Expression<String>? pointType,
    Expression<String>? nockBrand,
    Expression<String>? fletchingSize,
    Expression<double>? fletchingAngle,
    Expression<bool>? hasWrap,
    Expression<String>? wrapColor,
    Expression<DateTime>? purchaseDate,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (quiverId != null) 'quiver_id': quiverId,
      if (number != null) 'number': number,
      if (diameter != null) 'diameter': diameter,
      if (spine != null) 'spine': spine,
      if (lengthInches != null) 'length_inches': lengthInches,
      if (pointWeight != null) 'point_weight': pointWeight,
      if (fletchingType != null) 'fletching_type': fletchingType,
      if (fletchingColor != null) 'fletching_color': fletchingColor,
      if (nockColor != null) 'nock_color': nockColor,
      if (notes != null) 'notes': notes,
      if (createdAt != null) 'created_at': createdAt,
      if (retiredAt != null) 'retired_at': retiredAt,
      if (totalWeight != null) 'total_weight': totalWeight,
      if (pointType != null) 'point_type': pointType,
      if (nockBrand != null) 'nock_brand': nockBrand,
      if (fletchingSize != null) 'fletching_size': fletchingSize,
      if (fletchingAngle != null) 'fletching_angle': fletchingAngle,
      if (hasWrap != null) 'has_wrap': hasWrap,
      if (wrapColor != null) 'wrap_color': wrapColor,
      if (purchaseDate != null) 'purchase_date': purchaseDate,
      if (rowid != null) 'rowid': rowid,
    });
  }

  ShaftsCompanion copyWith({
    Value<String>? id,
    Value<String>? quiverId,
    Value<int>? number,
    Value<String?>? diameter,
    Value<int?>? spine,
    Value<double?>? lengthInches,
    Value<int?>? pointWeight,
    Value<String?>? fletchingType,
    Value<String?>? fletchingColor,
    Value<String?>? nockColor,
    Value<String?>? notes,
    Value<DateTime>? createdAt,
    Value<DateTime?>? retiredAt,
    Value<double?>? totalWeight,
    Value<String?>? pointType,
    Value<String?>? nockBrand,
    Value<String?>? fletchingSize,
    Value<double?>? fletchingAngle,
    Value<bool?>? hasWrap,
    Value<String?>? wrapColor,
    Value<DateTime?>? purchaseDate,
    Value<int>? rowid,
  }) {
    return ShaftsCompanion(
      id: id ?? this.id,
      quiverId: quiverId ?? this.quiverId,
      number: number ?? this.number,
      diameter: diameter ?? this.diameter,
      spine: spine ?? this.spine,
      lengthInches: lengthInches ?? this.lengthInches,
      pointWeight: pointWeight ?? this.pointWeight,
      fletchingType: fletchingType ?? this.fletchingType,
      fletchingColor: fletchingColor ?? this.fletchingColor,
      nockColor: nockColor ?? this.nockColor,
      notes: notes ?? this.notes,
      createdAt: createdAt ?? this.createdAt,
      retiredAt: retiredAt ?? this.retiredAt,
      totalWeight: totalWeight ?? this.totalWeight,
      pointType: pointType ?? this.pointType,
      nockBrand: nockBrand ?? this.nockBrand,
      fletchingSize: fletchingSize ?? this.fletchingSize,
      fletchingAngle: fletchingAngle ?? this.fletchingAngle,
      hasWrap: hasWrap ?? this.hasWrap,
      wrapColor: wrapColor ?? this.wrapColor,
      purchaseDate: purchaseDate ?? this.purchaseDate,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (quiverId.present) {
      map['quiver_id'] = Variable<String>(quiverId.value);
    }
    if (number.present) {
      map['number'] = Variable<int>(number.value);
    }
    if (diameter.present) {
      map['diameter'] = Variable<String>(diameter.value);
    }
    if (spine.present) {
      map['spine'] = Variable<int>(spine.value);
    }
    if (lengthInches.present) {
      map['length_inches'] = Variable<double>(lengthInches.value);
    }
    if (pointWeight.present) {
      map['point_weight'] = Variable<int>(pointWeight.value);
    }
    if (fletchingType.present) {
      map['fletching_type'] = Variable<String>(fletchingType.value);
    }
    if (fletchingColor.present) {
      map['fletching_color'] = Variable<String>(fletchingColor.value);
    }
    if (nockColor.present) {
      map['nock_color'] = Variable<String>(nockColor.value);
    }
    if (notes.present) {
      map['notes'] = Variable<String>(notes.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (retiredAt.present) {
      map['retired_at'] = Variable<DateTime>(retiredAt.value);
    }
    if (totalWeight.present) {
      map['total_weight'] = Variable<double>(totalWeight.value);
    }
    if (pointType.present) {
      map['point_type'] = Variable<String>(pointType.value);
    }
    if (nockBrand.present) {
      map['nock_brand'] = Variable<String>(nockBrand.value);
    }
    if (fletchingSize.present) {
      map['fletching_size'] = Variable<String>(fletchingSize.value);
    }
    if (fletchingAngle.present) {
      map['fletching_angle'] = Variable<double>(fletchingAngle.value);
    }
    if (hasWrap.present) {
      map['has_wrap'] = Variable<bool>(hasWrap.value);
    }
    if (wrapColor.present) {
      map['wrap_color'] = Variable<String>(wrapColor.value);
    }
    if (purchaseDate.present) {
      map['purchase_date'] = Variable<DateTime>(purchaseDate.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ShaftsCompanion(')
          ..write('id: $id, ')
          ..write('quiverId: $quiverId, ')
          ..write('number: $number, ')
          ..write('diameter: $diameter, ')
          ..write('spine: $spine, ')
          ..write('lengthInches: $lengthInches, ')
          ..write('pointWeight: $pointWeight, ')
          ..write('fletchingType: $fletchingType, ')
          ..write('fletchingColor: $fletchingColor, ')
          ..write('nockColor: $nockColor, ')
          ..write('notes: $notes, ')
          ..write('createdAt: $createdAt, ')
          ..write('retiredAt: $retiredAt, ')
          ..write('totalWeight: $totalWeight, ')
          ..write('pointType: $pointType, ')
          ..write('nockBrand: $nockBrand, ')
          ..write('fletchingSize: $fletchingSize, ')
          ..write('fletchingAngle: $fletchingAngle, ')
          ..write('hasWrap: $hasWrap, ')
          ..write('wrapColor: $wrapColor, ')
          ..write('purchaseDate: $purchaseDate, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $ArrowsTable extends Arrows with TableInfo<$ArrowsTable, Arrow> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ArrowsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _endIdMeta = const VerificationMeta('endId');
  @override
  late final GeneratedColumn<String> endId = GeneratedColumn<String>(
    'end_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES ends (id)',
    ),
  );
  static const VerificationMeta _faceIndexMeta = const VerificationMeta(
    'faceIndex',
  );
  @override
  late final GeneratedColumn<int> faceIndex = GeneratedColumn<int>(
    'face_index',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _xMeta = const VerificationMeta('x');
  @override
  late final GeneratedColumn<double> x = GeneratedColumn<double>(
    'x',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _yMeta = const VerificationMeta('y');
  @override
  late final GeneratedColumn<double> y = GeneratedColumn<double>(
    'y',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _xMmMeta = const VerificationMeta('xMm');
  @override
  late final GeneratedColumn<double> xMm = GeneratedColumn<double>(
    'x_mm',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _yMmMeta = const VerificationMeta('yMm');
  @override
  late final GeneratedColumn<double> yMm = GeneratedColumn<double>(
    'y_mm',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _scoreMeta = const VerificationMeta('score');
  @override
  late final GeneratedColumn<int> score = GeneratedColumn<int>(
    'score',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _isXMeta = const VerificationMeta('isX');
  @override
  late final GeneratedColumn<bool> isX = GeneratedColumn<bool>(
    'is_x',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_x" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _sequenceMeta = const VerificationMeta(
    'sequence',
  );
  @override
  late final GeneratedColumn<int> sequence = GeneratedColumn<int>(
    'sequence',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _shaftNumberMeta = const VerificationMeta(
    'shaftNumber',
  );
  @override
  late final GeneratedColumn<int> shaftNumber = GeneratedColumn<int>(
    'shaft_number',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _shaftIdMeta = const VerificationMeta(
    'shaftId',
  );
  @override
  late final GeneratedColumn<String> shaftId = GeneratedColumn<String>(
    'shaft_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES shafts (id)',
    ),
  );
  static const VerificationMeta _nockRotationMeta = const VerificationMeta(
    'nockRotation',
  );
  @override
  late final GeneratedColumn<String> nockRotation = GeneratedColumn<String>(
    'nock_rotation',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _ratingMeta = const VerificationMeta('rating');
  @override
  late final GeneratedColumn<int> rating = GeneratedColumn<int>(
    'rating',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(5),
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _deletedAtMeta = const VerificationMeta(
    'deletedAt',
  );
  @override
  late final GeneratedColumn<DateTime> deletedAt = GeneratedColumn<DateTime>(
    'deleted_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    endId,
    faceIndex,
    x,
    y,
    xMm,
    yMm,
    score,
    isX,
    sequence,
    shaftNumber,
    shaftId,
    nockRotation,
    rating,
    createdAt,
    updatedAt,
    deletedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'arrows';
  @override
  VerificationContext validateIntegrity(
    Insertable<Arrow> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('end_id')) {
      context.handle(
        _endIdMeta,
        endId.isAcceptableOrUnknown(data['end_id']!, _endIdMeta),
      );
    } else if (isInserting) {
      context.missing(_endIdMeta);
    }
    if (data.containsKey('face_index')) {
      context.handle(
        _faceIndexMeta,
        faceIndex.isAcceptableOrUnknown(data['face_index']!, _faceIndexMeta),
      );
    }
    if (data.containsKey('x')) {
      context.handle(_xMeta, x.isAcceptableOrUnknown(data['x']!, _xMeta));
    } else if (isInserting) {
      context.missing(_xMeta);
    }
    if (data.containsKey('y')) {
      context.handle(_yMeta, y.isAcceptableOrUnknown(data['y']!, _yMeta));
    } else if (isInserting) {
      context.missing(_yMeta);
    }
    if (data.containsKey('x_mm')) {
      context.handle(
        _xMmMeta,
        xMm.isAcceptableOrUnknown(data['x_mm']!, _xMmMeta),
      );
    }
    if (data.containsKey('y_mm')) {
      context.handle(
        _yMmMeta,
        yMm.isAcceptableOrUnknown(data['y_mm']!, _yMmMeta),
      );
    }
    if (data.containsKey('score')) {
      context.handle(
        _scoreMeta,
        score.isAcceptableOrUnknown(data['score']!, _scoreMeta),
      );
    } else if (isInserting) {
      context.missing(_scoreMeta);
    }
    if (data.containsKey('is_x')) {
      context.handle(
        _isXMeta,
        isX.isAcceptableOrUnknown(data['is_x']!, _isXMeta),
      );
    }
    if (data.containsKey('sequence')) {
      context.handle(
        _sequenceMeta,
        sequence.isAcceptableOrUnknown(data['sequence']!, _sequenceMeta),
      );
    } else if (isInserting) {
      context.missing(_sequenceMeta);
    }
    if (data.containsKey('shaft_number')) {
      context.handle(
        _shaftNumberMeta,
        shaftNumber.isAcceptableOrUnknown(
          data['shaft_number']!,
          _shaftNumberMeta,
        ),
      );
    }
    if (data.containsKey('shaft_id')) {
      context.handle(
        _shaftIdMeta,
        shaftId.isAcceptableOrUnknown(data['shaft_id']!, _shaftIdMeta),
      );
    }
    if (data.containsKey('nock_rotation')) {
      context.handle(
        _nockRotationMeta,
        nockRotation.isAcceptableOrUnknown(
          data['nock_rotation']!,
          _nockRotationMeta,
        ),
      );
    }
    if (data.containsKey('rating')) {
      context.handle(
        _ratingMeta,
        rating.isAcceptableOrUnknown(data['rating']!, _ratingMeta),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    }
    if (data.containsKey('deleted_at')) {
      context.handle(
        _deletedAtMeta,
        deletedAt.isAcceptableOrUnknown(data['deleted_at']!, _deletedAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  Arrow map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Arrow(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      endId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}end_id'],
      )!,
      faceIndex: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}face_index'],
      )!,
      x: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}x'],
      )!,
      y: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}y'],
      )!,
      xMm: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}x_mm'],
      )!,
      yMm: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}y_mm'],
      )!,
      score: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}score'],
      )!,
      isX: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_x'],
      )!,
      sequence: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sequence'],
      )!,
      shaftNumber: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}shaft_number'],
      ),
      shaftId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}shaft_id'],
      ),
      nockRotation: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}nock_rotation'],
      ),
      rating: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}rating'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      )!,
      deletedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}deleted_at'],
      ),
    );
  }

  @override
  $ArrowsTable createAlias(String alias) {
    return $ArrowsTable(attachedDatabase, alias);
  }
}

class Arrow extends DataClass implements Insertable<Arrow> {
  final String id;
  final String endId;
  final int faceIndex;
  final double x;
  final double y;
  final double xMm;
  final double yMm;
  final int score;
  final bool isX;
  final int sequence;
  final int? shaftNumber;
  final String? shaftId;
  final String? nockRotation;
  final int rating;
  final DateTime createdAt;
  final DateTime updatedAt;
  final DateTime? deletedAt;
  const Arrow({
    required this.id,
    required this.endId,
    required this.faceIndex,
    required this.x,
    required this.y,
    required this.xMm,
    required this.yMm,
    required this.score,
    required this.isX,
    required this.sequence,
    this.shaftNumber,
    this.shaftId,
    this.nockRotation,
    required this.rating,
    required this.createdAt,
    required this.updatedAt,
    this.deletedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['end_id'] = Variable<String>(endId);
    map['face_index'] = Variable<int>(faceIndex);
    map['x'] = Variable<double>(x);
    map['y'] = Variable<double>(y);
    map['x_mm'] = Variable<double>(xMm);
    map['y_mm'] = Variable<double>(yMm);
    map['score'] = Variable<int>(score);
    map['is_x'] = Variable<bool>(isX);
    map['sequence'] = Variable<int>(sequence);
    if (!nullToAbsent || shaftNumber != null) {
      map['shaft_number'] = Variable<int>(shaftNumber);
    }
    if (!nullToAbsent || shaftId != null) {
      map['shaft_id'] = Variable<String>(shaftId);
    }
    if (!nullToAbsent || nockRotation != null) {
      map['nock_rotation'] = Variable<String>(nockRotation);
    }
    map['rating'] = Variable<int>(rating);
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    if (!nullToAbsent || deletedAt != null) {
      map['deleted_at'] = Variable<DateTime>(deletedAt);
    }
    return map;
  }

  ArrowsCompanion toCompanion(bool nullToAbsent) {
    return ArrowsCompanion(
      id: Value(id),
      endId: Value(endId),
      faceIndex: Value(faceIndex),
      x: Value(x),
      y: Value(y),
      xMm: Value(xMm),
      yMm: Value(yMm),
      score: Value(score),
      isX: Value(isX),
      sequence: Value(sequence),
      shaftNumber: shaftNumber == null && nullToAbsent
          ? const Value.absent()
          : Value(shaftNumber),
      shaftId: shaftId == null && nullToAbsent
          ? const Value.absent()
          : Value(shaftId),
      nockRotation: nockRotation == null && nullToAbsent
          ? const Value.absent()
          : Value(nockRotation),
      rating: Value(rating),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
      deletedAt: deletedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(deletedAt),
    );
  }

  factory Arrow.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Arrow(
      id: serializer.fromJson<String>(json['id']),
      endId: serializer.fromJson<String>(json['endId']),
      faceIndex: serializer.fromJson<int>(json['faceIndex']),
      x: serializer.fromJson<double>(json['x']),
      y: serializer.fromJson<double>(json['y']),
      xMm: serializer.fromJson<double>(json['xMm']),
      yMm: serializer.fromJson<double>(json['yMm']),
      score: serializer.fromJson<int>(json['score']),
      isX: serializer.fromJson<bool>(json['isX']),
      sequence: serializer.fromJson<int>(json['sequence']),
      shaftNumber: serializer.fromJson<int?>(json['shaftNumber']),
      shaftId: serializer.fromJson<String?>(json['shaftId']),
      nockRotation: serializer.fromJson<String?>(json['nockRotation']),
      rating: serializer.fromJson<int>(json['rating']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
      deletedAt: serializer.fromJson<DateTime?>(json['deletedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'endId': serializer.toJson<String>(endId),
      'faceIndex': serializer.toJson<int>(faceIndex),
      'x': serializer.toJson<double>(x),
      'y': serializer.toJson<double>(y),
      'xMm': serializer.toJson<double>(xMm),
      'yMm': serializer.toJson<double>(yMm),
      'score': serializer.toJson<int>(score),
      'isX': serializer.toJson<bool>(isX),
      'sequence': serializer.toJson<int>(sequence),
      'shaftNumber': serializer.toJson<int?>(shaftNumber),
      'shaftId': serializer.toJson<String?>(shaftId),
      'nockRotation': serializer.toJson<String?>(nockRotation),
      'rating': serializer.toJson<int>(rating),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
      'deletedAt': serializer.toJson<DateTime?>(deletedAt),
    };
  }

  Arrow copyWith({
    String? id,
    String? endId,
    int? faceIndex,
    double? x,
    double? y,
    double? xMm,
    double? yMm,
    int? score,
    bool? isX,
    int? sequence,
    Value<int?> shaftNumber = const Value.absent(),
    Value<String?> shaftId = const Value.absent(),
    Value<String?> nockRotation = const Value.absent(),
    int? rating,
    DateTime? createdAt,
    DateTime? updatedAt,
    Value<DateTime?> deletedAt = const Value.absent(),
  }) => Arrow(
    id: id ?? this.id,
    endId: endId ?? this.endId,
    faceIndex: faceIndex ?? this.faceIndex,
    x: x ?? this.x,
    y: y ?? this.y,
    xMm: xMm ?? this.xMm,
    yMm: yMm ?? this.yMm,
    score: score ?? this.score,
    isX: isX ?? this.isX,
    sequence: sequence ?? this.sequence,
    shaftNumber: shaftNumber.present ? shaftNumber.value : this.shaftNumber,
    shaftId: shaftId.present ? shaftId.value : this.shaftId,
    nockRotation: nockRotation.present ? nockRotation.value : this.nockRotation,
    rating: rating ?? this.rating,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
    deletedAt: deletedAt.present ? deletedAt.value : this.deletedAt,
  );
  Arrow copyWithCompanion(ArrowsCompanion data) {
    return Arrow(
      id: data.id.present ? data.id.value : this.id,
      endId: data.endId.present ? data.endId.value : this.endId,
      faceIndex: data.faceIndex.present ? data.faceIndex.value : this.faceIndex,
      x: data.x.present ? data.x.value : this.x,
      y: data.y.present ? data.y.value : this.y,
      xMm: data.xMm.present ? data.xMm.value : this.xMm,
      yMm: data.yMm.present ? data.yMm.value : this.yMm,
      score: data.score.present ? data.score.value : this.score,
      isX: data.isX.present ? data.isX.value : this.isX,
      sequence: data.sequence.present ? data.sequence.value : this.sequence,
      shaftNumber: data.shaftNumber.present
          ? data.shaftNumber.value
          : this.shaftNumber,
      shaftId: data.shaftId.present ? data.shaftId.value : this.shaftId,
      nockRotation: data.nockRotation.present
          ? data.nockRotation.value
          : this.nockRotation,
      rating: data.rating.present ? data.rating.value : this.rating,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
      deletedAt: data.deletedAt.present ? data.deletedAt.value : this.deletedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Arrow(')
          ..write('id: $id, ')
          ..write('endId: $endId, ')
          ..write('faceIndex: $faceIndex, ')
          ..write('x: $x, ')
          ..write('y: $y, ')
          ..write('xMm: $xMm, ')
          ..write('yMm: $yMm, ')
          ..write('score: $score, ')
          ..write('isX: $isX, ')
          ..write('sequence: $sequence, ')
          ..write('shaftNumber: $shaftNumber, ')
          ..write('shaftId: $shaftId, ')
          ..write('nockRotation: $nockRotation, ')
          ..write('rating: $rating, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('deletedAt: $deletedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    endId,
    faceIndex,
    x,
    y,
    xMm,
    yMm,
    score,
    isX,
    sequence,
    shaftNumber,
    shaftId,
    nockRotation,
    rating,
    createdAt,
    updatedAt,
    deletedAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Arrow &&
          other.id == this.id &&
          other.endId == this.endId &&
          other.faceIndex == this.faceIndex &&
          other.x == this.x &&
          other.y == this.y &&
          other.xMm == this.xMm &&
          other.yMm == this.yMm &&
          other.score == this.score &&
          other.isX == this.isX &&
          other.sequence == this.sequence &&
          other.shaftNumber == this.shaftNumber &&
          other.shaftId == this.shaftId &&
          other.nockRotation == this.nockRotation &&
          other.rating == this.rating &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt &&
          other.deletedAt == this.deletedAt);
}

class ArrowsCompanion extends UpdateCompanion<Arrow> {
  final Value<String> id;
  final Value<String> endId;
  final Value<int> faceIndex;
  final Value<double> x;
  final Value<double> y;
  final Value<double> xMm;
  final Value<double> yMm;
  final Value<int> score;
  final Value<bool> isX;
  final Value<int> sequence;
  final Value<int?> shaftNumber;
  final Value<String?> shaftId;
  final Value<String?> nockRotation;
  final Value<int> rating;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  final Value<DateTime?> deletedAt;
  final Value<int> rowid;
  const ArrowsCompanion({
    this.id = const Value.absent(),
    this.endId = const Value.absent(),
    this.faceIndex = const Value.absent(),
    this.x = const Value.absent(),
    this.y = const Value.absent(),
    this.xMm = const Value.absent(),
    this.yMm = const Value.absent(),
    this.score = const Value.absent(),
    this.isX = const Value.absent(),
    this.sequence = const Value.absent(),
    this.shaftNumber = const Value.absent(),
    this.shaftId = const Value.absent(),
    this.nockRotation = const Value.absent(),
    this.rating = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.deletedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  ArrowsCompanion.insert({
    required String id,
    required String endId,
    this.faceIndex = const Value.absent(),
    required double x,
    required double y,
    this.xMm = const Value.absent(),
    this.yMm = const Value.absent(),
    required int score,
    this.isX = const Value.absent(),
    required int sequence,
    this.shaftNumber = const Value.absent(),
    this.shaftId = const Value.absent(),
    this.nockRotation = const Value.absent(),
    this.rating = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.deletedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       endId = Value(endId),
       x = Value(x),
       y = Value(y),
       score = Value(score),
       sequence = Value(sequence);
  static Insertable<Arrow> custom({
    Expression<String>? id,
    Expression<String>? endId,
    Expression<int>? faceIndex,
    Expression<double>? x,
    Expression<double>? y,
    Expression<double>? xMm,
    Expression<double>? yMm,
    Expression<int>? score,
    Expression<bool>? isX,
    Expression<int>? sequence,
    Expression<int>? shaftNumber,
    Expression<String>? shaftId,
    Expression<String>? nockRotation,
    Expression<int>? rating,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
    Expression<DateTime>? deletedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (endId != null) 'end_id': endId,
      if (faceIndex != null) 'face_index': faceIndex,
      if (x != null) 'x': x,
      if (y != null) 'y': y,
      if (xMm != null) 'x_mm': xMm,
      if (yMm != null) 'y_mm': yMm,
      if (score != null) 'score': score,
      if (isX != null) 'is_x': isX,
      if (sequence != null) 'sequence': sequence,
      if (shaftNumber != null) 'shaft_number': shaftNumber,
      if (shaftId != null) 'shaft_id': shaftId,
      if (nockRotation != null) 'nock_rotation': nockRotation,
      if (rating != null) 'rating': rating,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (deletedAt != null) 'deleted_at': deletedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  ArrowsCompanion copyWith({
    Value<String>? id,
    Value<String>? endId,
    Value<int>? faceIndex,
    Value<double>? x,
    Value<double>? y,
    Value<double>? xMm,
    Value<double>? yMm,
    Value<int>? score,
    Value<bool>? isX,
    Value<int>? sequence,
    Value<int?>? shaftNumber,
    Value<String?>? shaftId,
    Value<String?>? nockRotation,
    Value<int>? rating,
    Value<DateTime>? createdAt,
    Value<DateTime>? updatedAt,
    Value<DateTime?>? deletedAt,
    Value<int>? rowid,
  }) {
    return ArrowsCompanion(
      id: id ?? this.id,
      endId: endId ?? this.endId,
      faceIndex: faceIndex ?? this.faceIndex,
      x: x ?? this.x,
      y: y ?? this.y,
      xMm: xMm ?? this.xMm,
      yMm: yMm ?? this.yMm,
      score: score ?? this.score,
      isX: isX ?? this.isX,
      sequence: sequence ?? this.sequence,
      shaftNumber: shaftNumber ?? this.shaftNumber,
      shaftId: shaftId ?? this.shaftId,
      nockRotation: nockRotation ?? this.nockRotation,
      rating: rating ?? this.rating,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      deletedAt: deletedAt ?? this.deletedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (endId.present) {
      map['end_id'] = Variable<String>(endId.value);
    }
    if (faceIndex.present) {
      map['face_index'] = Variable<int>(faceIndex.value);
    }
    if (x.present) {
      map['x'] = Variable<double>(x.value);
    }
    if (y.present) {
      map['y'] = Variable<double>(y.value);
    }
    if (xMm.present) {
      map['x_mm'] = Variable<double>(xMm.value);
    }
    if (yMm.present) {
      map['y_mm'] = Variable<double>(yMm.value);
    }
    if (score.present) {
      map['score'] = Variable<int>(score.value);
    }
    if (isX.present) {
      map['is_x'] = Variable<bool>(isX.value);
    }
    if (sequence.present) {
      map['sequence'] = Variable<int>(sequence.value);
    }
    if (shaftNumber.present) {
      map['shaft_number'] = Variable<int>(shaftNumber.value);
    }
    if (shaftId.present) {
      map['shaft_id'] = Variable<String>(shaftId.value);
    }
    if (nockRotation.present) {
      map['nock_rotation'] = Variable<String>(nockRotation.value);
    }
    if (rating.present) {
      map['rating'] = Variable<int>(rating.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (deletedAt.present) {
      map['deleted_at'] = Variable<DateTime>(deletedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ArrowsCompanion(')
          ..write('id: $id, ')
          ..write('endId: $endId, ')
          ..write('faceIndex: $faceIndex, ')
          ..write('x: $x, ')
          ..write('y: $y, ')
          ..write('xMm: $xMm, ')
          ..write('yMm: $yMm, ')
          ..write('score: $score, ')
          ..write('isX: $isX, ')
          ..write('sequence: $sequence, ')
          ..write('shaftNumber: $shaftNumber, ')
          ..write('shaftId: $shaftId, ')
          ..write('nockRotation: $nockRotation, ')
          ..write('rating: $rating, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('deletedAt: $deletedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $ImportedScoresTable extends ImportedScores
    with TableInfo<$ImportedScoresTable, ImportedScore> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ImportedScoresTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _dateMeta = const VerificationMeta('date');
  @override
  late final GeneratedColumn<DateTime> date = GeneratedColumn<DateTime>(
    'date',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _roundNameMeta = const VerificationMeta(
    'roundName',
  );
  @override
  late final GeneratedColumn<String> roundName = GeneratedColumn<String>(
    'round_name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _scoreMeta = const VerificationMeta('score');
  @override
  late final GeneratedColumn<int> score = GeneratedColumn<int>(
    'score',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _xCountMeta = const VerificationMeta('xCount');
  @override
  late final GeneratedColumn<int> xCount = GeneratedColumn<int>(
    'x_count',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _locationMeta = const VerificationMeta(
    'location',
  );
  @override
  late final GeneratedColumn<String> location = GeneratedColumn<String>(
    'location',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _notesMeta = const VerificationMeta('notes');
  @override
  late final GeneratedColumn<String> notes = GeneratedColumn<String>(
    'notes',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _sessionTypeMeta = const VerificationMeta(
    'sessionType',
  );
  @override
  late final GeneratedColumn<String> sessionType = GeneratedColumn<String>(
    'session_type',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('competition'),
  );
  static const VerificationMeta _sourceMeta = const VerificationMeta('source');
  @override
  late final GeneratedColumn<String> source = GeneratedColumn<String>(
    'source',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('manual'),
  );
  static const VerificationMeta _importedAtMeta = const VerificationMeta(
    'importedAt',
  );
  @override
  late final GeneratedColumn<DateTime> importedAt = GeneratedColumn<DateTime>(
    'imported_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _deletedAtMeta = const VerificationMeta(
    'deletedAt',
  );
  @override
  late final GeneratedColumn<DateTime> deletedAt = GeneratedColumn<DateTime>(
    'deleted_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    date,
    roundName,
    score,
    xCount,
    location,
    notes,
    sessionType,
    source,
    importedAt,
    updatedAt,
    deletedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'imported_scores';
  @override
  VerificationContext validateIntegrity(
    Insertable<ImportedScore> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('date')) {
      context.handle(
        _dateMeta,
        date.isAcceptableOrUnknown(data['date']!, _dateMeta),
      );
    } else if (isInserting) {
      context.missing(_dateMeta);
    }
    if (data.containsKey('round_name')) {
      context.handle(
        _roundNameMeta,
        roundName.isAcceptableOrUnknown(data['round_name']!, _roundNameMeta),
      );
    } else if (isInserting) {
      context.missing(_roundNameMeta);
    }
    if (data.containsKey('score')) {
      context.handle(
        _scoreMeta,
        score.isAcceptableOrUnknown(data['score']!, _scoreMeta),
      );
    } else if (isInserting) {
      context.missing(_scoreMeta);
    }
    if (data.containsKey('x_count')) {
      context.handle(
        _xCountMeta,
        xCount.isAcceptableOrUnknown(data['x_count']!, _xCountMeta),
      );
    }
    if (data.containsKey('location')) {
      context.handle(
        _locationMeta,
        location.isAcceptableOrUnknown(data['location']!, _locationMeta),
      );
    }
    if (data.containsKey('notes')) {
      context.handle(
        _notesMeta,
        notes.isAcceptableOrUnknown(data['notes']!, _notesMeta),
      );
    }
    if (data.containsKey('session_type')) {
      context.handle(
        _sessionTypeMeta,
        sessionType.isAcceptableOrUnknown(
          data['session_type']!,
          _sessionTypeMeta,
        ),
      );
    }
    if (data.containsKey('source')) {
      context.handle(
        _sourceMeta,
        source.isAcceptableOrUnknown(data['source']!, _sourceMeta),
      );
    }
    if (data.containsKey('imported_at')) {
      context.handle(
        _importedAtMeta,
        importedAt.isAcceptableOrUnknown(data['imported_at']!, _importedAtMeta),
      );
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    }
    if (data.containsKey('deleted_at')) {
      context.handle(
        _deletedAtMeta,
        deletedAt.isAcceptableOrUnknown(data['deleted_at']!, _deletedAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  ImportedScore map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ImportedScore(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      date: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}date'],
      )!,
      roundName: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}round_name'],
      )!,
      score: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}score'],
      )!,
      xCount: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}x_count'],
      ),
      location: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}location'],
      ),
      notes: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}notes'],
      ),
      sessionType: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}session_type'],
      )!,
      source: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}source'],
      )!,
      importedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}imported_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      )!,
      deletedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}deleted_at'],
      ),
    );
  }

  @override
  $ImportedScoresTable createAlias(String alias) {
    return $ImportedScoresTable(attachedDatabase, alias);
  }
}

class ImportedScore extends DataClass implements Insertable<ImportedScore> {
  final String id;
  final DateTime date;
  final String roundName;
  final int score;
  final int? xCount;
  final String? location;
  final String? notes;
  final String sessionType;
  final String source;
  final DateTime importedAt;
  final DateTime updatedAt;
  final DateTime? deletedAt;
  const ImportedScore({
    required this.id,
    required this.date,
    required this.roundName,
    required this.score,
    this.xCount,
    this.location,
    this.notes,
    required this.sessionType,
    required this.source,
    required this.importedAt,
    required this.updatedAt,
    this.deletedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['date'] = Variable<DateTime>(date);
    map['round_name'] = Variable<String>(roundName);
    map['score'] = Variable<int>(score);
    if (!nullToAbsent || xCount != null) {
      map['x_count'] = Variable<int>(xCount);
    }
    if (!nullToAbsent || location != null) {
      map['location'] = Variable<String>(location);
    }
    if (!nullToAbsent || notes != null) {
      map['notes'] = Variable<String>(notes);
    }
    map['session_type'] = Variable<String>(sessionType);
    map['source'] = Variable<String>(source);
    map['imported_at'] = Variable<DateTime>(importedAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    if (!nullToAbsent || deletedAt != null) {
      map['deleted_at'] = Variable<DateTime>(deletedAt);
    }
    return map;
  }

  ImportedScoresCompanion toCompanion(bool nullToAbsent) {
    return ImportedScoresCompanion(
      id: Value(id),
      date: Value(date),
      roundName: Value(roundName),
      score: Value(score),
      xCount: xCount == null && nullToAbsent
          ? const Value.absent()
          : Value(xCount),
      location: location == null && nullToAbsent
          ? const Value.absent()
          : Value(location),
      notes: notes == null && nullToAbsent
          ? const Value.absent()
          : Value(notes),
      sessionType: Value(sessionType),
      source: Value(source),
      importedAt: Value(importedAt),
      updatedAt: Value(updatedAt),
      deletedAt: deletedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(deletedAt),
    );
  }

  factory ImportedScore.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ImportedScore(
      id: serializer.fromJson<String>(json['id']),
      date: serializer.fromJson<DateTime>(json['date']),
      roundName: serializer.fromJson<String>(json['roundName']),
      score: serializer.fromJson<int>(json['score']),
      xCount: serializer.fromJson<int?>(json['xCount']),
      location: serializer.fromJson<String?>(json['location']),
      notes: serializer.fromJson<String?>(json['notes']),
      sessionType: serializer.fromJson<String>(json['sessionType']),
      source: serializer.fromJson<String>(json['source']),
      importedAt: serializer.fromJson<DateTime>(json['importedAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
      deletedAt: serializer.fromJson<DateTime?>(json['deletedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'date': serializer.toJson<DateTime>(date),
      'roundName': serializer.toJson<String>(roundName),
      'score': serializer.toJson<int>(score),
      'xCount': serializer.toJson<int?>(xCount),
      'location': serializer.toJson<String?>(location),
      'notes': serializer.toJson<String?>(notes),
      'sessionType': serializer.toJson<String>(sessionType),
      'source': serializer.toJson<String>(source),
      'importedAt': serializer.toJson<DateTime>(importedAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
      'deletedAt': serializer.toJson<DateTime?>(deletedAt),
    };
  }

  ImportedScore copyWith({
    String? id,
    DateTime? date,
    String? roundName,
    int? score,
    Value<int?> xCount = const Value.absent(),
    Value<String?> location = const Value.absent(),
    Value<String?> notes = const Value.absent(),
    String? sessionType,
    String? source,
    DateTime? importedAt,
    DateTime? updatedAt,
    Value<DateTime?> deletedAt = const Value.absent(),
  }) => ImportedScore(
    id: id ?? this.id,
    date: date ?? this.date,
    roundName: roundName ?? this.roundName,
    score: score ?? this.score,
    xCount: xCount.present ? xCount.value : this.xCount,
    location: location.present ? location.value : this.location,
    notes: notes.present ? notes.value : this.notes,
    sessionType: sessionType ?? this.sessionType,
    source: source ?? this.source,
    importedAt: importedAt ?? this.importedAt,
    updatedAt: updatedAt ?? this.updatedAt,
    deletedAt: deletedAt.present ? deletedAt.value : this.deletedAt,
  );
  ImportedScore copyWithCompanion(ImportedScoresCompanion data) {
    return ImportedScore(
      id: data.id.present ? data.id.value : this.id,
      date: data.date.present ? data.date.value : this.date,
      roundName: data.roundName.present ? data.roundName.value : this.roundName,
      score: data.score.present ? data.score.value : this.score,
      xCount: data.xCount.present ? data.xCount.value : this.xCount,
      location: data.location.present ? data.location.value : this.location,
      notes: data.notes.present ? data.notes.value : this.notes,
      sessionType: data.sessionType.present
          ? data.sessionType.value
          : this.sessionType,
      source: data.source.present ? data.source.value : this.source,
      importedAt: data.importedAt.present
          ? data.importedAt.value
          : this.importedAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
      deletedAt: data.deletedAt.present ? data.deletedAt.value : this.deletedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('ImportedScore(')
          ..write('id: $id, ')
          ..write('date: $date, ')
          ..write('roundName: $roundName, ')
          ..write('score: $score, ')
          ..write('xCount: $xCount, ')
          ..write('location: $location, ')
          ..write('notes: $notes, ')
          ..write('sessionType: $sessionType, ')
          ..write('source: $source, ')
          ..write('importedAt: $importedAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('deletedAt: $deletedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    date,
    roundName,
    score,
    xCount,
    location,
    notes,
    sessionType,
    source,
    importedAt,
    updatedAt,
    deletedAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ImportedScore &&
          other.id == this.id &&
          other.date == this.date &&
          other.roundName == this.roundName &&
          other.score == this.score &&
          other.xCount == this.xCount &&
          other.location == this.location &&
          other.notes == this.notes &&
          other.sessionType == this.sessionType &&
          other.source == this.source &&
          other.importedAt == this.importedAt &&
          other.updatedAt == this.updatedAt &&
          other.deletedAt == this.deletedAt);
}

class ImportedScoresCompanion extends UpdateCompanion<ImportedScore> {
  final Value<String> id;
  final Value<DateTime> date;
  final Value<String> roundName;
  final Value<int> score;
  final Value<int?> xCount;
  final Value<String?> location;
  final Value<String?> notes;
  final Value<String> sessionType;
  final Value<String> source;
  final Value<DateTime> importedAt;
  final Value<DateTime> updatedAt;
  final Value<DateTime?> deletedAt;
  final Value<int> rowid;
  const ImportedScoresCompanion({
    this.id = const Value.absent(),
    this.date = const Value.absent(),
    this.roundName = const Value.absent(),
    this.score = const Value.absent(),
    this.xCount = const Value.absent(),
    this.location = const Value.absent(),
    this.notes = const Value.absent(),
    this.sessionType = const Value.absent(),
    this.source = const Value.absent(),
    this.importedAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.deletedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  ImportedScoresCompanion.insert({
    required String id,
    required DateTime date,
    required String roundName,
    required int score,
    this.xCount = const Value.absent(),
    this.location = const Value.absent(),
    this.notes = const Value.absent(),
    this.sessionType = const Value.absent(),
    this.source = const Value.absent(),
    this.importedAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.deletedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       date = Value(date),
       roundName = Value(roundName),
       score = Value(score);
  static Insertable<ImportedScore> custom({
    Expression<String>? id,
    Expression<DateTime>? date,
    Expression<String>? roundName,
    Expression<int>? score,
    Expression<int>? xCount,
    Expression<String>? location,
    Expression<String>? notes,
    Expression<String>? sessionType,
    Expression<String>? source,
    Expression<DateTime>? importedAt,
    Expression<DateTime>? updatedAt,
    Expression<DateTime>? deletedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (date != null) 'date': date,
      if (roundName != null) 'round_name': roundName,
      if (score != null) 'score': score,
      if (xCount != null) 'x_count': xCount,
      if (location != null) 'location': location,
      if (notes != null) 'notes': notes,
      if (sessionType != null) 'session_type': sessionType,
      if (source != null) 'source': source,
      if (importedAt != null) 'imported_at': importedAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (deletedAt != null) 'deleted_at': deletedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  ImportedScoresCompanion copyWith({
    Value<String>? id,
    Value<DateTime>? date,
    Value<String>? roundName,
    Value<int>? score,
    Value<int?>? xCount,
    Value<String?>? location,
    Value<String?>? notes,
    Value<String>? sessionType,
    Value<String>? source,
    Value<DateTime>? importedAt,
    Value<DateTime>? updatedAt,
    Value<DateTime?>? deletedAt,
    Value<int>? rowid,
  }) {
    return ImportedScoresCompanion(
      id: id ?? this.id,
      date: date ?? this.date,
      roundName: roundName ?? this.roundName,
      score: score ?? this.score,
      xCount: xCount ?? this.xCount,
      location: location ?? this.location,
      notes: notes ?? this.notes,
      sessionType: sessionType ?? this.sessionType,
      source: source ?? this.source,
      importedAt: importedAt ?? this.importedAt,
      updatedAt: updatedAt ?? this.updatedAt,
      deletedAt: deletedAt ?? this.deletedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (date.present) {
      map['date'] = Variable<DateTime>(date.value);
    }
    if (roundName.present) {
      map['round_name'] = Variable<String>(roundName.value);
    }
    if (score.present) {
      map['score'] = Variable<int>(score.value);
    }
    if (xCount.present) {
      map['x_count'] = Variable<int>(xCount.value);
    }
    if (location.present) {
      map['location'] = Variable<String>(location.value);
    }
    if (notes.present) {
      map['notes'] = Variable<String>(notes.value);
    }
    if (sessionType.present) {
      map['session_type'] = Variable<String>(sessionType.value);
    }
    if (source.present) {
      map['source'] = Variable<String>(source.value);
    }
    if (importedAt.present) {
      map['imported_at'] = Variable<DateTime>(importedAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (deletedAt.present) {
      map['deleted_at'] = Variable<DateTime>(deletedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ImportedScoresCompanion(')
          ..write('id: $id, ')
          ..write('date: $date, ')
          ..write('roundName: $roundName, ')
          ..write('score: $score, ')
          ..write('xCount: $xCount, ')
          ..write('location: $location, ')
          ..write('notes: $notes, ')
          ..write('sessionType: $sessionType, ')
          ..write('source: $source, ')
          ..write('importedAt: $importedAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('deletedAt: $deletedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $UserPreferencesTable extends UserPreferences
    with TableInfo<$UserPreferencesTable, UserPreference> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $UserPreferencesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _keyMeta = const VerificationMeta('key');
  @override
  late final GeneratedColumn<String> key = GeneratedColumn<String>(
    'key',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _valueMeta = const VerificationMeta('value');
  @override
  late final GeneratedColumn<String> value = GeneratedColumn<String>(
    'value',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [key, value];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'user_preferences';
  @override
  VerificationContext validateIntegrity(
    Insertable<UserPreference> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('key')) {
      context.handle(
        _keyMeta,
        key.isAcceptableOrUnknown(data['key']!, _keyMeta),
      );
    } else if (isInserting) {
      context.missing(_keyMeta);
    }
    if (data.containsKey('value')) {
      context.handle(
        _valueMeta,
        value.isAcceptableOrUnknown(data['value']!, _valueMeta),
      );
    } else if (isInserting) {
      context.missing(_valueMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {key};
  @override
  UserPreference map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return UserPreference(
      key: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}key'],
      )!,
      value: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}value'],
      )!,
    );
  }

  @override
  $UserPreferencesTable createAlias(String alias) {
    return $UserPreferencesTable(attachedDatabase, alias);
  }
}

class UserPreference extends DataClass implements Insertable<UserPreference> {
  final String key;
  final String value;
  const UserPreference({required this.key, required this.value});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['key'] = Variable<String>(key);
    map['value'] = Variable<String>(value);
    return map;
  }

  UserPreferencesCompanion toCompanion(bool nullToAbsent) {
    return UserPreferencesCompanion(key: Value(key), value: Value(value));
  }

  factory UserPreference.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return UserPreference(
      key: serializer.fromJson<String>(json['key']),
      value: serializer.fromJson<String>(json['value']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'key': serializer.toJson<String>(key),
      'value': serializer.toJson<String>(value),
    };
  }

  UserPreference copyWith({String? key, String? value}) =>
      UserPreference(key: key ?? this.key, value: value ?? this.value);
  UserPreference copyWithCompanion(UserPreferencesCompanion data) {
    return UserPreference(
      key: data.key.present ? data.key.value : this.key,
      value: data.value.present ? data.value.value : this.value,
    );
  }

  @override
  String toString() {
    return (StringBuffer('UserPreference(')
          ..write('key: $key, ')
          ..write('value: $value')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(key, value);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is UserPreference &&
          other.key == this.key &&
          other.value == this.value);
}

class UserPreferencesCompanion extends UpdateCompanion<UserPreference> {
  final Value<String> key;
  final Value<String> value;
  final Value<int> rowid;
  const UserPreferencesCompanion({
    this.key = const Value.absent(),
    this.value = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  UserPreferencesCompanion.insert({
    required String key,
    required String value,
    this.rowid = const Value.absent(),
  }) : key = Value(key),
       value = Value(value);
  static Insertable<UserPreference> custom({
    Expression<String>? key,
    Expression<String>? value,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (key != null) 'key': key,
      if (value != null) 'value': value,
      if (rowid != null) 'rowid': rowid,
    });
  }

  UserPreferencesCompanion copyWith({
    Value<String>? key,
    Value<String>? value,
    Value<int>? rowid,
  }) {
    return UserPreferencesCompanion(
      key: key ?? this.key,
      value: value ?? this.value,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (key.present) {
      map['key'] = Variable<String>(key.value);
    }
    if (value.present) {
      map['value'] = Variable<String>(value.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('UserPreferencesCompanion(')
          ..write('key: $key, ')
          ..write('value: $value, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $FingerTabsTable extends FingerTabs
    with TableInfo<$FingerTabsTable, FingerTab> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $FingerTabsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _makeMeta = const VerificationMeta('make');
  @override
  late final GeneratedColumn<String> make = GeneratedColumn<String>(
    'make',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _modelMeta = const VerificationMeta('model');
  @override
  late final GeneratedColumn<String> model = GeneratedColumn<String>(
    'model',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _sizeMeta = const VerificationMeta('size');
  @override
  late final GeneratedColumn<String> size = GeneratedColumn<String>(
    'size',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _plateTypeMeta = const VerificationMeta(
    'plateType',
  );
  @override
  late final GeneratedColumn<String> plateType = GeneratedColumn<String>(
    'plate_type',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _fingerSpacerMeta = const VerificationMeta(
    'fingerSpacer',
  );
  @override
  late final GeneratedColumn<String> fingerSpacer = GeneratedColumn<String>(
    'finger_spacer',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _notesMeta = const VerificationMeta('notes');
  @override
  late final GeneratedColumn<String> notes = GeneratedColumn<String>(
    'notes',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _isDefaultMeta = const VerificationMeta(
    'isDefault',
  );
  @override
  late final GeneratedColumn<bool> isDefault = GeneratedColumn<bool>(
    'is_default',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_default" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _deletedAtMeta = const VerificationMeta(
    'deletedAt',
  );
  @override
  late final GeneratedColumn<DateTime> deletedAt = GeneratedColumn<DateTime>(
    'deleted_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    name,
    make,
    model,
    size,
    plateType,
    fingerSpacer,
    notes,
    isDefault,
    createdAt,
    updatedAt,
    deletedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'finger_tabs';
  @override
  VerificationContext validateIntegrity(
    Insertable<FingerTab> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('make')) {
      context.handle(
        _makeMeta,
        make.isAcceptableOrUnknown(data['make']!, _makeMeta),
      );
    }
    if (data.containsKey('model')) {
      context.handle(
        _modelMeta,
        model.isAcceptableOrUnknown(data['model']!, _modelMeta),
      );
    }
    if (data.containsKey('size')) {
      context.handle(
        _sizeMeta,
        size.isAcceptableOrUnknown(data['size']!, _sizeMeta),
      );
    }
    if (data.containsKey('plate_type')) {
      context.handle(
        _plateTypeMeta,
        plateType.isAcceptableOrUnknown(data['plate_type']!, _plateTypeMeta),
      );
    }
    if (data.containsKey('finger_spacer')) {
      context.handle(
        _fingerSpacerMeta,
        fingerSpacer.isAcceptableOrUnknown(
          data['finger_spacer']!,
          _fingerSpacerMeta,
        ),
      );
    }
    if (data.containsKey('notes')) {
      context.handle(
        _notesMeta,
        notes.isAcceptableOrUnknown(data['notes']!, _notesMeta),
      );
    }
    if (data.containsKey('is_default')) {
      context.handle(
        _isDefaultMeta,
        isDefault.isAcceptableOrUnknown(data['is_default']!, _isDefaultMeta),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    }
    if (data.containsKey('deleted_at')) {
      context.handle(
        _deletedAtMeta,
        deletedAt.isAcceptableOrUnknown(data['deleted_at']!, _deletedAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  FingerTab map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return FingerTab(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      make: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}make'],
      ),
      model: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}model'],
      ),
      size: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}size'],
      ),
      plateType: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}plate_type'],
      ),
      fingerSpacer: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}finger_spacer'],
      ),
      notes: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}notes'],
      ),
      isDefault: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_default'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      )!,
      deletedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}deleted_at'],
      ),
    );
  }

  @override
  $FingerTabsTable createAlias(String alias) {
    return $FingerTabsTable(attachedDatabase, alias);
  }
}

class FingerTab extends DataClass implements Insertable<FingerTab> {
  final String id;
  final String name;
  final String? make;
  final String? model;
  final String? size;
  final String? plateType;
  final String? fingerSpacer;
  final String? notes;
  final bool isDefault;
  final DateTime createdAt;
  final DateTime updatedAt;
  final DateTime? deletedAt;
  const FingerTab({
    required this.id,
    required this.name,
    this.make,
    this.model,
    this.size,
    this.plateType,
    this.fingerSpacer,
    this.notes,
    required this.isDefault,
    required this.createdAt,
    required this.updatedAt,
    this.deletedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['name'] = Variable<String>(name);
    if (!nullToAbsent || make != null) {
      map['make'] = Variable<String>(make);
    }
    if (!nullToAbsent || model != null) {
      map['model'] = Variable<String>(model);
    }
    if (!nullToAbsent || size != null) {
      map['size'] = Variable<String>(size);
    }
    if (!nullToAbsent || plateType != null) {
      map['plate_type'] = Variable<String>(plateType);
    }
    if (!nullToAbsent || fingerSpacer != null) {
      map['finger_spacer'] = Variable<String>(fingerSpacer);
    }
    if (!nullToAbsent || notes != null) {
      map['notes'] = Variable<String>(notes);
    }
    map['is_default'] = Variable<bool>(isDefault);
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    if (!nullToAbsent || deletedAt != null) {
      map['deleted_at'] = Variable<DateTime>(deletedAt);
    }
    return map;
  }

  FingerTabsCompanion toCompanion(bool nullToAbsent) {
    return FingerTabsCompanion(
      id: Value(id),
      name: Value(name),
      make: make == null && nullToAbsent ? const Value.absent() : Value(make),
      model: model == null && nullToAbsent
          ? const Value.absent()
          : Value(model),
      size: size == null && nullToAbsent ? const Value.absent() : Value(size),
      plateType: plateType == null && nullToAbsent
          ? const Value.absent()
          : Value(plateType),
      fingerSpacer: fingerSpacer == null && nullToAbsent
          ? const Value.absent()
          : Value(fingerSpacer),
      notes: notes == null && nullToAbsent
          ? const Value.absent()
          : Value(notes),
      isDefault: Value(isDefault),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
      deletedAt: deletedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(deletedAt),
    );
  }

  factory FingerTab.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return FingerTab(
      id: serializer.fromJson<String>(json['id']),
      name: serializer.fromJson<String>(json['name']),
      make: serializer.fromJson<String?>(json['make']),
      model: serializer.fromJson<String?>(json['model']),
      size: serializer.fromJson<String?>(json['size']),
      plateType: serializer.fromJson<String?>(json['plateType']),
      fingerSpacer: serializer.fromJson<String?>(json['fingerSpacer']),
      notes: serializer.fromJson<String?>(json['notes']),
      isDefault: serializer.fromJson<bool>(json['isDefault']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
      deletedAt: serializer.fromJson<DateTime?>(json['deletedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'name': serializer.toJson<String>(name),
      'make': serializer.toJson<String?>(make),
      'model': serializer.toJson<String?>(model),
      'size': serializer.toJson<String?>(size),
      'plateType': serializer.toJson<String?>(plateType),
      'fingerSpacer': serializer.toJson<String?>(fingerSpacer),
      'notes': serializer.toJson<String?>(notes),
      'isDefault': serializer.toJson<bool>(isDefault),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
      'deletedAt': serializer.toJson<DateTime?>(deletedAt),
    };
  }

  FingerTab copyWith({
    String? id,
    String? name,
    Value<String?> make = const Value.absent(),
    Value<String?> model = const Value.absent(),
    Value<String?> size = const Value.absent(),
    Value<String?> plateType = const Value.absent(),
    Value<String?> fingerSpacer = const Value.absent(),
    Value<String?> notes = const Value.absent(),
    bool? isDefault,
    DateTime? createdAt,
    DateTime? updatedAt,
    Value<DateTime?> deletedAt = const Value.absent(),
  }) => FingerTab(
    id: id ?? this.id,
    name: name ?? this.name,
    make: make.present ? make.value : this.make,
    model: model.present ? model.value : this.model,
    size: size.present ? size.value : this.size,
    plateType: plateType.present ? plateType.value : this.plateType,
    fingerSpacer: fingerSpacer.present ? fingerSpacer.value : this.fingerSpacer,
    notes: notes.present ? notes.value : this.notes,
    isDefault: isDefault ?? this.isDefault,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
    deletedAt: deletedAt.present ? deletedAt.value : this.deletedAt,
  );
  FingerTab copyWithCompanion(FingerTabsCompanion data) {
    return FingerTab(
      id: data.id.present ? data.id.value : this.id,
      name: data.name.present ? data.name.value : this.name,
      make: data.make.present ? data.make.value : this.make,
      model: data.model.present ? data.model.value : this.model,
      size: data.size.present ? data.size.value : this.size,
      plateType: data.plateType.present ? data.plateType.value : this.plateType,
      fingerSpacer: data.fingerSpacer.present
          ? data.fingerSpacer.value
          : this.fingerSpacer,
      notes: data.notes.present ? data.notes.value : this.notes,
      isDefault: data.isDefault.present ? data.isDefault.value : this.isDefault,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
      deletedAt: data.deletedAt.present ? data.deletedAt.value : this.deletedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('FingerTab(')
          ..write('id: $id, ')
          ..write('name: $name, ')
          ..write('make: $make, ')
          ..write('model: $model, ')
          ..write('size: $size, ')
          ..write('plateType: $plateType, ')
          ..write('fingerSpacer: $fingerSpacer, ')
          ..write('notes: $notes, ')
          ..write('isDefault: $isDefault, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('deletedAt: $deletedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    name,
    make,
    model,
    size,
    plateType,
    fingerSpacer,
    notes,
    isDefault,
    createdAt,
    updatedAt,
    deletedAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is FingerTab &&
          other.id == this.id &&
          other.name == this.name &&
          other.make == this.make &&
          other.model == this.model &&
          other.size == this.size &&
          other.plateType == this.plateType &&
          other.fingerSpacer == this.fingerSpacer &&
          other.notes == this.notes &&
          other.isDefault == this.isDefault &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt &&
          other.deletedAt == this.deletedAt);
}

class FingerTabsCompanion extends UpdateCompanion<FingerTab> {
  final Value<String> id;
  final Value<String> name;
  final Value<String?> make;
  final Value<String?> model;
  final Value<String?> size;
  final Value<String?> plateType;
  final Value<String?> fingerSpacer;
  final Value<String?> notes;
  final Value<bool> isDefault;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  final Value<DateTime?> deletedAt;
  final Value<int> rowid;
  const FingerTabsCompanion({
    this.id = const Value.absent(),
    this.name = const Value.absent(),
    this.make = const Value.absent(),
    this.model = const Value.absent(),
    this.size = const Value.absent(),
    this.plateType = const Value.absent(),
    this.fingerSpacer = const Value.absent(),
    this.notes = const Value.absent(),
    this.isDefault = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.deletedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  FingerTabsCompanion.insert({
    required String id,
    required String name,
    this.make = const Value.absent(),
    this.model = const Value.absent(),
    this.size = const Value.absent(),
    this.plateType = const Value.absent(),
    this.fingerSpacer = const Value.absent(),
    this.notes = const Value.absent(),
    this.isDefault = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.deletedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       name = Value(name);
  static Insertable<FingerTab> custom({
    Expression<String>? id,
    Expression<String>? name,
    Expression<String>? make,
    Expression<String>? model,
    Expression<String>? size,
    Expression<String>? plateType,
    Expression<String>? fingerSpacer,
    Expression<String>? notes,
    Expression<bool>? isDefault,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
    Expression<DateTime>? deletedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (name != null) 'name': name,
      if (make != null) 'make': make,
      if (model != null) 'model': model,
      if (size != null) 'size': size,
      if (plateType != null) 'plate_type': plateType,
      if (fingerSpacer != null) 'finger_spacer': fingerSpacer,
      if (notes != null) 'notes': notes,
      if (isDefault != null) 'is_default': isDefault,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (deletedAt != null) 'deleted_at': deletedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  FingerTabsCompanion copyWith({
    Value<String>? id,
    Value<String>? name,
    Value<String?>? make,
    Value<String?>? model,
    Value<String?>? size,
    Value<String?>? plateType,
    Value<String?>? fingerSpacer,
    Value<String?>? notes,
    Value<bool>? isDefault,
    Value<DateTime>? createdAt,
    Value<DateTime>? updatedAt,
    Value<DateTime?>? deletedAt,
    Value<int>? rowid,
  }) {
    return FingerTabsCompanion(
      id: id ?? this.id,
      name: name ?? this.name,
      make: make ?? this.make,
      model: model ?? this.model,
      size: size ?? this.size,
      plateType: plateType ?? this.plateType,
      fingerSpacer: fingerSpacer ?? this.fingerSpacer,
      notes: notes ?? this.notes,
      isDefault: isDefault ?? this.isDefault,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      deletedAt: deletedAt ?? this.deletedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (make.present) {
      map['make'] = Variable<String>(make.value);
    }
    if (model.present) {
      map['model'] = Variable<String>(model.value);
    }
    if (size.present) {
      map['size'] = Variable<String>(size.value);
    }
    if (plateType.present) {
      map['plate_type'] = Variable<String>(plateType.value);
    }
    if (fingerSpacer.present) {
      map['finger_spacer'] = Variable<String>(fingerSpacer.value);
    }
    if (notes.present) {
      map['notes'] = Variable<String>(notes.value);
    }
    if (isDefault.present) {
      map['is_default'] = Variable<bool>(isDefault.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (deletedAt.present) {
      map['deleted_at'] = Variable<DateTime>(deletedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('FingerTabsCompanion(')
          ..write('id: $id, ')
          ..write('name: $name, ')
          ..write('make: $make, ')
          ..write('model: $model, ')
          ..write('size: $size, ')
          ..write('plateType: $plateType, ')
          ..write('fingerSpacer: $fingerSpacer, ')
          ..write('notes: $notes, ')
          ..write('isDefault: $isDefault, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('deletedAt: $deletedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $StabilizersTable extends Stabilizers
    with TableInfo<$StabilizersTable, Stabilizer> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $StabilizersTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _bowIdMeta = const VerificationMeta('bowId');
  @override
  late final GeneratedColumn<String> bowId = GeneratedColumn<String>(
    'bow_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES bows (id)',
    ),
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _longRodModelMeta = const VerificationMeta(
    'longRodModel',
  );
  @override
  late final GeneratedColumn<String> longRodModel = GeneratedColumn<String>(
    'long_rod_model',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _longRodLengthMeta = const VerificationMeta(
    'longRodLength',
  );
  @override
  late final GeneratedColumn<double> longRodLength = GeneratedColumn<double>(
    'long_rod_length',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _longRodWeightMeta = const VerificationMeta(
    'longRodWeight',
  );
  @override
  late final GeneratedColumn<double> longRodWeight = GeneratedColumn<double>(
    'long_rod_weight',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _longRodPurchaseDateMeta =
      const VerificationMeta('longRodPurchaseDate');
  @override
  late final GeneratedColumn<DateTime> longRodPurchaseDate =
      GeneratedColumn<DateTime>(
        'long_rod_purchase_date',
        aliasedName,
        true,
        type: DriftSqlType.dateTime,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _leftSideRodModelMeta = const VerificationMeta(
    'leftSideRodModel',
  );
  @override
  late final GeneratedColumn<String> leftSideRodModel = GeneratedColumn<String>(
    'left_side_rod_model',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _leftSideRodLengthMeta = const VerificationMeta(
    'leftSideRodLength',
  );
  @override
  late final GeneratedColumn<double> leftSideRodLength =
      GeneratedColumn<double>(
        'left_side_rod_length',
        aliasedName,
        true,
        type: DriftSqlType.double,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _leftSideRodWeightMeta = const VerificationMeta(
    'leftSideRodWeight',
  );
  @override
  late final GeneratedColumn<double> leftSideRodWeight =
      GeneratedColumn<double>(
        'left_side_rod_weight',
        aliasedName,
        true,
        type: DriftSqlType.double,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _leftWeightsMeta = const VerificationMeta(
    'leftWeights',
  );
  @override
  late final GeneratedColumn<String> leftWeights = GeneratedColumn<String>(
    'left_weights',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _leftAngleHorizontalMeta =
      const VerificationMeta('leftAngleHorizontal');
  @override
  late final GeneratedColumn<double> leftAngleHorizontal =
      GeneratedColumn<double>(
        'left_angle_horizontal',
        aliasedName,
        true,
        type: DriftSqlType.double,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _leftAngleVerticalMeta = const VerificationMeta(
    'leftAngleVertical',
  );
  @override
  late final GeneratedColumn<double> leftAngleVertical =
      GeneratedColumn<double>(
        'left_angle_vertical',
        aliasedName,
        true,
        type: DriftSqlType.double,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _rightSideRodModelMeta = const VerificationMeta(
    'rightSideRodModel',
  );
  @override
  late final GeneratedColumn<String> rightSideRodModel =
      GeneratedColumn<String>(
        'right_side_rod_model',
        aliasedName,
        true,
        type: DriftSqlType.string,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _rightSideRodLengthMeta =
      const VerificationMeta('rightSideRodLength');
  @override
  late final GeneratedColumn<double> rightSideRodLength =
      GeneratedColumn<double>(
        'right_side_rod_length',
        aliasedName,
        true,
        type: DriftSqlType.double,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _rightSideRodWeightMeta =
      const VerificationMeta('rightSideRodWeight');
  @override
  late final GeneratedColumn<double> rightSideRodWeight =
      GeneratedColumn<double>(
        'right_side_rod_weight',
        aliasedName,
        true,
        type: DriftSqlType.double,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _rightWeightsMeta = const VerificationMeta(
    'rightWeights',
  );
  @override
  late final GeneratedColumn<String> rightWeights = GeneratedColumn<String>(
    'right_weights',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _rightAngleHorizontalMeta =
      const VerificationMeta('rightAngleHorizontal');
  @override
  late final GeneratedColumn<double> rightAngleHorizontal =
      GeneratedColumn<double>(
        'right_angle_horizontal',
        aliasedName,
        true,
        type: DriftSqlType.double,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _rightAngleVerticalMeta =
      const VerificationMeta('rightAngleVertical');
  @override
  late final GeneratedColumn<double> rightAngleVertical =
      GeneratedColumn<double>(
        'right_angle_vertical',
        aliasedName,
        true,
        type: DriftSqlType.double,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _sideRodModelMeta = const VerificationMeta(
    'sideRodModel',
  );
  @override
  late final GeneratedColumn<String> sideRodModel = GeneratedColumn<String>(
    'side_rod_model',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _sideRodLengthMeta = const VerificationMeta(
    'sideRodLength',
  );
  @override
  late final GeneratedColumn<double> sideRodLength = GeneratedColumn<double>(
    'side_rod_length',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _sideRodWeightMeta = const VerificationMeta(
    'sideRodWeight',
  );
  @override
  late final GeneratedColumn<double> sideRodWeight = GeneratedColumn<double>(
    'side_rod_weight',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _sideRodPurchaseDateMeta =
      const VerificationMeta('sideRodPurchaseDate');
  @override
  late final GeneratedColumn<DateTime> sideRodPurchaseDate =
      GeneratedColumn<DateTime>(
        'side_rod_purchase_date',
        aliasedName,
        true,
        type: DriftSqlType.dateTime,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _extenderLengthMeta = const VerificationMeta(
    'extenderLength',
  );
  @override
  late final GeneratedColumn<double> extenderLength = GeneratedColumn<double>(
    'extender_length',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _vbarModelMeta = const VerificationMeta(
    'vbarModel',
  );
  @override
  late final GeneratedColumn<String> vbarModel = GeneratedColumn<String>(
    'vbar_model',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _vbarAngleHorizontalMeta =
      const VerificationMeta('vbarAngleHorizontal');
  @override
  late final GeneratedColumn<double> vbarAngleHorizontal =
      GeneratedColumn<double>(
        'vbar_angle_horizontal',
        aliasedName,
        true,
        type: DriftSqlType.double,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _vbarAngleVerticalMeta = const VerificationMeta(
    'vbarAngleVertical',
  );
  @override
  late final GeneratedColumn<double> vbarAngleVertical =
      GeneratedColumn<double>(
        'vbar_angle_vertical',
        aliasedName,
        true,
        type: DriftSqlType.double,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _longRodWeightsMeta = const VerificationMeta(
    'longRodWeights',
  );
  @override
  late final GeneratedColumn<String> longRodWeights = GeneratedColumn<String>(
    'long_rod_weights',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _weightArrangementMeta = const VerificationMeta(
    'weightArrangement',
  );
  @override
  late final GeneratedColumn<String> weightArrangement =
      GeneratedColumn<String>(
        'weight_arrangement',
        aliasedName,
        true,
        type: DriftSqlType.string,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _setupPhotoPathMeta = const VerificationMeta(
    'setupPhotoPath',
  );
  @override
  late final GeneratedColumn<String> setupPhotoPath = GeneratedColumn<String>(
    'setup_photo_path',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _damperModelMeta = const VerificationMeta(
    'damperModel',
  );
  @override
  late final GeneratedColumn<String> damperModel = GeneratedColumn<String>(
    'damper_model',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _damperPositionsMeta = const VerificationMeta(
    'damperPositions',
  );
  @override
  late final GeneratedColumn<String> damperPositions = GeneratedColumn<String>(
    'damper_positions',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _notesMeta = const VerificationMeta('notes');
  @override
  late final GeneratedColumn<String> notes = GeneratedColumn<String>(
    'notes',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    bowId,
    name,
    longRodModel,
    longRodLength,
    longRodWeight,
    longRodPurchaseDate,
    leftSideRodModel,
    leftSideRodLength,
    leftSideRodWeight,
    leftWeights,
    leftAngleHorizontal,
    leftAngleVertical,
    rightSideRodModel,
    rightSideRodLength,
    rightSideRodWeight,
    rightWeights,
    rightAngleHorizontal,
    rightAngleVertical,
    sideRodModel,
    sideRodLength,
    sideRodWeight,
    sideRodPurchaseDate,
    extenderLength,
    vbarModel,
    vbarAngleHorizontal,
    vbarAngleVertical,
    longRodWeights,
    weightArrangement,
    setupPhotoPath,
    damperModel,
    damperPositions,
    notes,
    createdAt,
    updatedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'stabilizers';
  @override
  VerificationContext validateIntegrity(
    Insertable<Stabilizer> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('bow_id')) {
      context.handle(
        _bowIdMeta,
        bowId.isAcceptableOrUnknown(data['bow_id']!, _bowIdMeta),
      );
    } else if (isInserting) {
      context.missing(_bowIdMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    }
    if (data.containsKey('long_rod_model')) {
      context.handle(
        _longRodModelMeta,
        longRodModel.isAcceptableOrUnknown(
          data['long_rod_model']!,
          _longRodModelMeta,
        ),
      );
    }
    if (data.containsKey('long_rod_length')) {
      context.handle(
        _longRodLengthMeta,
        longRodLength.isAcceptableOrUnknown(
          data['long_rod_length']!,
          _longRodLengthMeta,
        ),
      );
    }
    if (data.containsKey('long_rod_weight')) {
      context.handle(
        _longRodWeightMeta,
        longRodWeight.isAcceptableOrUnknown(
          data['long_rod_weight']!,
          _longRodWeightMeta,
        ),
      );
    }
    if (data.containsKey('long_rod_purchase_date')) {
      context.handle(
        _longRodPurchaseDateMeta,
        longRodPurchaseDate.isAcceptableOrUnknown(
          data['long_rod_purchase_date']!,
          _longRodPurchaseDateMeta,
        ),
      );
    }
    if (data.containsKey('left_side_rod_model')) {
      context.handle(
        _leftSideRodModelMeta,
        leftSideRodModel.isAcceptableOrUnknown(
          data['left_side_rod_model']!,
          _leftSideRodModelMeta,
        ),
      );
    }
    if (data.containsKey('left_side_rod_length')) {
      context.handle(
        _leftSideRodLengthMeta,
        leftSideRodLength.isAcceptableOrUnknown(
          data['left_side_rod_length']!,
          _leftSideRodLengthMeta,
        ),
      );
    }
    if (data.containsKey('left_side_rod_weight')) {
      context.handle(
        _leftSideRodWeightMeta,
        leftSideRodWeight.isAcceptableOrUnknown(
          data['left_side_rod_weight']!,
          _leftSideRodWeightMeta,
        ),
      );
    }
    if (data.containsKey('left_weights')) {
      context.handle(
        _leftWeightsMeta,
        leftWeights.isAcceptableOrUnknown(
          data['left_weights']!,
          _leftWeightsMeta,
        ),
      );
    }
    if (data.containsKey('left_angle_horizontal')) {
      context.handle(
        _leftAngleHorizontalMeta,
        leftAngleHorizontal.isAcceptableOrUnknown(
          data['left_angle_horizontal']!,
          _leftAngleHorizontalMeta,
        ),
      );
    }
    if (data.containsKey('left_angle_vertical')) {
      context.handle(
        _leftAngleVerticalMeta,
        leftAngleVertical.isAcceptableOrUnknown(
          data['left_angle_vertical']!,
          _leftAngleVerticalMeta,
        ),
      );
    }
    if (data.containsKey('right_side_rod_model')) {
      context.handle(
        _rightSideRodModelMeta,
        rightSideRodModel.isAcceptableOrUnknown(
          data['right_side_rod_model']!,
          _rightSideRodModelMeta,
        ),
      );
    }
    if (data.containsKey('right_side_rod_length')) {
      context.handle(
        _rightSideRodLengthMeta,
        rightSideRodLength.isAcceptableOrUnknown(
          data['right_side_rod_length']!,
          _rightSideRodLengthMeta,
        ),
      );
    }
    if (data.containsKey('right_side_rod_weight')) {
      context.handle(
        _rightSideRodWeightMeta,
        rightSideRodWeight.isAcceptableOrUnknown(
          data['right_side_rod_weight']!,
          _rightSideRodWeightMeta,
        ),
      );
    }
    if (data.containsKey('right_weights')) {
      context.handle(
        _rightWeightsMeta,
        rightWeights.isAcceptableOrUnknown(
          data['right_weights']!,
          _rightWeightsMeta,
        ),
      );
    }
    if (data.containsKey('right_angle_horizontal')) {
      context.handle(
        _rightAngleHorizontalMeta,
        rightAngleHorizontal.isAcceptableOrUnknown(
          data['right_angle_horizontal']!,
          _rightAngleHorizontalMeta,
        ),
      );
    }
    if (data.containsKey('right_angle_vertical')) {
      context.handle(
        _rightAngleVerticalMeta,
        rightAngleVertical.isAcceptableOrUnknown(
          data['right_angle_vertical']!,
          _rightAngleVerticalMeta,
        ),
      );
    }
    if (data.containsKey('side_rod_model')) {
      context.handle(
        _sideRodModelMeta,
        sideRodModel.isAcceptableOrUnknown(
          data['side_rod_model']!,
          _sideRodModelMeta,
        ),
      );
    }
    if (data.containsKey('side_rod_length')) {
      context.handle(
        _sideRodLengthMeta,
        sideRodLength.isAcceptableOrUnknown(
          data['side_rod_length']!,
          _sideRodLengthMeta,
        ),
      );
    }
    if (data.containsKey('side_rod_weight')) {
      context.handle(
        _sideRodWeightMeta,
        sideRodWeight.isAcceptableOrUnknown(
          data['side_rod_weight']!,
          _sideRodWeightMeta,
        ),
      );
    }
    if (data.containsKey('side_rod_purchase_date')) {
      context.handle(
        _sideRodPurchaseDateMeta,
        sideRodPurchaseDate.isAcceptableOrUnknown(
          data['side_rod_purchase_date']!,
          _sideRodPurchaseDateMeta,
        ),
      );
    }
    if (data.containsKey('extender_length')) {
      context.handle(
        _extenderLengthMeta,
        extenderLength.isAcceptableOrUnknown(
          data['extender_length']!,
          _extenderLengthMeta,
        ),
      );
    }
    if (data.containsKey('vbar_model')) {
      context.handle(
        _vbarModelMeta,
        vbarModel.isAcceptableOrUnknown(data['vbar_model']!, _vbarModelMeta),
      );
    }
    if (data.containsKey('vbar_angle_horizontal')) {
      context.handle(
        _vbarAngleHorizontalMeta,
        vbarAngleHorizontal.isAcceptableOrUnknown(
          data['vbar_angle_horizontal']!,
          _vbarAngleHorizontalMeta,
        ),
      );
    }
    if (data.containsKey('vbar_angle_vertical')) {
      context.handle(
        _vbarAngleVerticalMeta,
        vbarAngleVertical.isAcceptableOrUnknown(
          data['vbar_angle_vertical']!,
          _vbarAngleVerticalMeta,
        ),
      );
    }
    if (data.containsKey('long_rod_weights')) {
      context.handle(
        _longRodWeightsMeta,
        longRodWeights.isAcceptableOrUnknown(
          data['long_rod_weights']!,
          _longRodWeightsMeta,
        ),
      );
    }
    if (data.containsKey('weight_arrangement')) {
      context.handle(
        _weightArrangementMeta,
        weightArrangement.isAcceptableOrUnknown(
          data['weight_arrangement']!,
          _weightArrangementMeta,
        ),
      );
    }
    if (data.containsKey('setup_photo_path')) {
      context.handle(
        _setupPhotoPathMeta,
        setupPhotoPath.isAcceptableOrUnknown(
          data['setup_photo_path']!,
          _setupPhotoPathMeta,
        ),
      );
    }
    if (data.containsKey('damper_model')) {
      context.handle(
        _damperModelMeta,
        damperModel.isAcceptableOrUnknown(
          data['damper_model']!,
          _damperModelMeta,
        ),
      );
    }
    if (data.containsKey('damper_positions')) {
      context.handle(
        _damperPositionsMeta,
        damperPositions.isAcceptableOrUnknown(
          data['damper_positions']!,
          _damperPositionsMeta,
        ),
      );
    }
    if (data.containsKey('notes')) {
      context.handle(
        _notesMeta,
        notes.isAcceptableOrUnknown(data['notes']!, _notesMeta),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  Stabilizer map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Stabilizer(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      bowId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}bow_id'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      ),
      longRodModel: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}long_rod_model'],
      ),
      longRodLength: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}long_rod_length'],
      ),
      longRodWeight: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}long_rod_weight'],
      ),
      longRodPurchaseDate: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}long_rod_purchase_date'],
      ),
      leftSideRodModel: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}left_side_rod_model'],
      ),
      leftSideRodLength: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}left_side_rod_length'],
      ),
      leftSideRodWeight: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}left_side_rod_weight'],
      ),
      leftWeights: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}left_weights'],
      ),
      leftAngleHorizontal: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}left_angle_horizontal'],
      ),
      leftAngleVertical: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}left_angle_vertical'],
      ),
      rightSideRodModel: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}right_side_rod_model'],
      ),
      rightSideRodLength: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}right_side_rod_length'],
      ),
      rightSideRodWeight: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}right_side_rod_weight'],
      ),
      rightWeights: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}right_weights'],
      ),
      rightAngleHorizontal: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}right_angle_horizontal'],
      ),
      rightAngleVertical: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}right_angle_vertical'],
      ),
      sideRodModel: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}side_rod_model'],
      ),
      sideRodLength: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}side_rod_length'],
      ),
      sideRodWeight: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}side_rod_weight'],
      ),
      sideRodPurchaseDate: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}side_rod_purchase_date'],
      ),
      extenderLength: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}extender_length'],
      ),
      vbarModel: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}vbar_model'],
      ),
      vbarAngleHorizontal: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}vbar_angle_horizontal'],
      ),
      vbarAngleVertical: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}vbar_angle_vertical'],
      ),
      longRodWeights: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}long_rod_weights'],
      ),
      weightArrangement: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}weight_arrangement'],
      ),
      setupPhotoPath: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}setup_photo_path'],
      ),
      damperModel: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}damper_model'],
      ),
      damperPositions: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}damper_positions'],
      ),
      notes: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}notes'],
      ),
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      )!,
    );
  }

  @override
  $StabilizersTable createAlias(String alias) {
    return $StabilizersTable(attachedDatabase, alias);
  }
}

class Stabilizer extends DataClass implements Insertable<Stabilizer> {
  final String id;
  final String bowId;
  final String? name;
  final String? longRodModel;
  final double? longRodLength;
  final double? longRodWeight;
  final DateTime? longRodPurchaseDate;
  final String? leftSideRodModel;
  final double? leftSideRodLength;
  final double? leftSideRodWeight;
  final String? leftWeights;
  final double? leftAngleHorizontal;
  final double? leftAngleVertical;
  final String? rightSideRodModel;
  final double? rightSideRodLength;
  final double? rightSideRodWeight;
  final String? rightWeights;
  final double? rightAngleHorizontal;
  final double? rightAngleVertical;
  final String? sideRodModel;
  final double? sideRodLength;
  final double? sideRodWeight;
  final DateTime? sideRodPurchaseDate;
  final double? extenderLength;
  final String? vbarModel;
  final double? vbarAngleHorizontal;
  final double? vbarAngleVertical;
  final String? longRodWeights;
  final String? weightArrangement;
  final String? setupPhotoPath;
  final String? damperModel;
  final String? damperPositions;
  final String? notes;
  final DateTime createdAt;
  final DateTime updatedAt;
  const Stabilizer({
    required this.id,
    required this.bowId,
    this.name,
    this.longRodModel,
    this.longRodLength,
    this.longRodWeight,
    this.longRodPurchaseDate,
    this.leftSideRodModel,
    this.leftSideRodLength,
    this.leftSideRodWeight,
    this.leftWeights,
    this.leftAngleHorizontal,
    this.leftAngleVertical,
    this.rightSideRodModel,
    this.rightSideRodLength,
    this.rightSideRodWeight,
    this.rightWeights,
    this.rightAngleHorizontal,
    this.rightAngleVertical,
    this.sideRodModel,
    this.sideRodLength,
    this.sideRodWeight,
    this.sideRodPurchaseDate,
    this.extenderLength,
    this.vbarModel,
    this.vbarAngleHorizontal,
    this.vbarAngleVertical,
    this.longRodWeights,
    this.weightArrangement,
    this.setupPhotoPath,
    this.damperModel,
    this.damperPositions,
    this.notes,
    required this.createdAt,
    required this.updatedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['bow_id'] = Variable<String>(bowId);
    if (!nullToAbsent || name != null) {
      map['name'] = Variable<String>(name);
    }
    if (!nullToAbsent || longRodModel != null) {
      map['long_rod_model'] = Variable<String>(longRodModel);
    }
    if (!nullToAbsent || longRodLength != null) {
      map['long_rod_length'] = Variable<double>(longRodLength);
    }
    if (!nullToAbsent || longRodWeight != null) {
      map['long_rod_weight'] = Variable<double>(longRodWeight);
    }
    if (!nullToAbsent || longRodPurchaseDate != null) {
      map['long_rod_purchase_date'] = Variable<DateTime>(longRodPurchaseDate);
    }
    if (!nullToAbsent || leftSideRodModel != null) {
      map['left_side_rod_model'] = Variable<String>(leftSideRodModel);
    }
    if (!nullToAbsent || leftSideRodLength != null) {
      map['left_side_rod_length'] = Variable<double>(leftSideRodLength);
    }
    if (!nullToAbsent || leftSideRodWeight != null) {
      map['left_side_rod_weight'] = Variable<double>(leftSideRodWeight);
    }
    if (!nullToAbsent || leftWeights != null) {
      map['left_weights'] = Variable<String>(leftWeights);
    }
    if (!nullToAbsent || leftAngleHorizontal != null) {
      map['left_angle_horizontal'] = Variable<double>(leftAngleHorizontal);
    }
    if (!nullToAbsent || leftAngleVertical != null) {
      map['left_angle_vertical'] = Variable<double>(leftAngleVertical);
    }
    if (!nullToAbsent || rightSideRodModel != null) {
      map['right_side_rod_model'] = Variable<String>(rightSideRodModel);
    }
    if (!nullToAbsent || rightSideRodLength != null) {
      map['right_side_rod_length'] = Variable<double>(rightSideRodLength);
    }
    if (!nullToAbsent || rightSideRodWeight != null) {
      map['right_side_rod_weight'] = Variable<double>(rightSideRodWeight);
    }
    if (!nullToAbsent || rightWeights != null) {
      map['right_weights'] = Variable<String>(rightWeights);
    }
    if (!nullToAbsent || rightAngleHorizontal != null) {
      map['right_angle_horizontal'] = Variable<double>(rightAngleHorizontal);
    }
    if (!nullToAbsent || rightAngleVertical != null) {
      map['right_angle_vertical'] = Variable<double>(rightAngleVertical);
    }
    if (!nullToAbsent || sideRodModel != null) {
      map['side_rod_model'] = Variable<String>(sideRodModel);
    }
    if (!nullToAbsent || sideRodLength != null) {
      map['side_rod_length'] = Variable<double>(sideRodLength);
    }
    if (!nullToAbsent || sideRodWeight != null) {
      map['side_rod_weight'] = Variable<double>(sideRodWeight);
    }
    if (!nullToAbsent || sideRodPurchaseDate != null) {
      map['side_rod_purchase_date'] = Variable<DateTime>(sideRodPurchaseDate);
    }
    if (!nullToAbsent || extenderLength != null) {
      map['extender_length'] = Variable<double>(extenderLength);
    }
    if (!nullToAbsent || vbarModel != null) {
      map['vbar_model'] = Variable<String>(vbarModel);
    }
    if (!nullToAbsent || vbarAngleHorizontal != null) {
      map['vbar_angle_horizontal'] = Variable<double>(vbarAngleHorizontal);
    }
    if (!nullToAbsent || vbarAngleVertical != null) {
      map['vbar_angle_vertical'] = Variable<double>(vbarAngleVertical);
    }
    if (!nullToAbsent || longRodWeights != null) {
      map['long_rod_weights'] = Variable<String>(longRodWeights);
    }
    if (!nullToAbsent || weightArrangement != null) {
      map['weight_arrangement'] = Variable<String>(weightArrangement);
    }
    if (!nullToAbsent || setupPhotoPath != null) {
      map['setup_photo_path'] = Variable<String>(setupPhotoPath);
    }
    if (!nullToAbsent || damperModel != null) {
      map['damper_model'] = Variable<String>(damperModel);
    }
    if (!nullToAbsent || damperPositions != null) {
      map['damper_positions'] = Variable<String>(damperPositions);
    }
    if (!nullToAbsent || notes != null) {
      map['notes'] = Variable<String>(notes);
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    return map;
  }

  StabilizersCompanion toCompanion(bool nullToAbsent) {
    return StabilizersCompanion(
      id: Value(id),
      bowId: Value(bowId),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      longRodModel: longRodModel == null && nullToAbsent
          ? const Value.absent()
          : Value(longRodModel),
      longRodLength: longRodLength == null && nullToAbsent
          ? const Value.absent()
          : Value(longRodLength),
      longRodWeight: longRodWeight == null && nullToAbsent
          ? const Value.absent()
          : Value(longRodWeight),
      longRodPurchaseDate: longRodPurchaseDate == null && nullToAbsent
          ? const Value.absent()
          : Value(longRodPurchaseDate),
      leftSideRodModel: leftSideRodModel == null && nullToAbsent
          ? const Value.absent()
          : Value(leftSideRodModel),
      leftSideRodLength: leftSideRodLength == null && nullToAbsent
          ? const Value.absent()
          : Value(leftSideRodLength),
      leftSideRodWeight: leftSideRodWeight == null && nullToAbsent
          ? const Value.absent()
          : Value(leftSideRodWeight),
      leftWeights: leftWeights == null && nullToAbsent
          ? const Value.absent()
          : Value(leftWeights),
      leftAngleHorizontal: leftAngleHorizontal == null && nullToAbsent
          ? const Value.absent()
          : Value(leftAngleHorizontal),
      leftAngleVertical: leftAngleVertical == null && nullToAbsent
          ? const Value.absent()
          : Value(leftAngleVertical),
      rightSideRodModel: rightSideRodModel == null && nullToAbsent
          ? const Value.absent()
          : Value(rightSideRodModel),
      rightSideRodLength: rightSideRodLength == null && nullToAbsent
          ? const Value.absent()
          : Value(rightSideRodLength),
      rightSideRodWeight: rightSideRodWeight == null && nullToAbsent
          ? const Value.absent()
          : Value(rightSideRodWeight),
      rightWeights: rightWeights == null && nullToAbsent
          ? const Value.absent()
          : Value(rightWeights),
      rightAngleHorizontal: rightAngleHorizontal == null && nullToAbsent
          ? const Value.absent()
          : Value(rightAngleHorizontal),
      rightAngleVertical: rightAngleVertical == null && nullToAbsent
          ? const Value.absent()
          : Value(rightAngleVertical),
      sideRodModel: sideRodModel == null && nullToAbsent
          ? const Value.absent()
          : Value(sideRodModel),
      sideRodLength: sideRodLength == null && nullToAbsent
          ? const Value.absent()
          : Value(sideRodLength),
      sideRodWeight: sideRodWeight == null && nullToAbsent
          ? const Value.absent()
          : Value(sideRodWeight),
      sideRodPurchaseDate: sideRodPurchaseDate == null && nullToAbsent
          ? const Value.absent()
          : Value(sideRodPurchaseDate),
      extenderLength: extenderLength == null && nullToAbsent
          ? const Value.absent()
          : Value(extenderLength),
      vbarModel: vbarModel == null && nullToAbsent
          ? const Value.absent()
          : Value(vbarModel),
      vbarAngleHorizontal: vbarAngleHorizontal == null && nullToAbsent
          ? const Value.absent()
          : Value(vbarAngleHorizontal),
      vbarAngleVertical: vbarAngleVertical == null && nullToAbsent
          ? const Value.absent()
          : Value(vbarAngleVertical),
      longRodWeights: longRodWeights == null && nullToAbsent
          ? const Value.absent()
          : Value(longRodWeights),
      weightArrangement: weightArrangement == null && nullToAbsent
          ? const Value.absent()
          : Value(weightArrangement),
      setupPhotoPath: setupPhotoPath == null && nullToAbsent
          ? const Value.absent()
          : Value(setupPhotoPath),
      damperModel: damperModel == null && nullToAbsent
          ? const Value.absent()
          : Value(damperModel),
      damperPositions: damperPositions == null && nullToAbsent
          ? const Value.absent()
          : Value(damperPositions),
      notes: notes == null && nullToAbsent
          ? const Value.absent()
          : Value(notes),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory Stabilizer.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Stabilizer(
      id: serializer.fromJson<String>(json['id']),
      bowId: serializer.fromJson<String>(json['bowId']),
      name: serializer.fromJson<String?>(json['name']),
      longRodModel: serializer.fromJson<String?>(json['longRodModel']),
      longRodLength: serializer.fromJson<double?>(json['longRodLength']),
      longRodWeight: serializer.fromJson<double?>(json['longRodWeight']),
      longRodPurchaseDate: serializer.fromJson<DateTime?>(
        json['longRodPurchaseDate'],
      ),
      leftSideRodModel: serializer.fromJson<String?>(json['leftSideRodModel']),
      leftSideRodLength: serializer.fromJson<double?>(
        json['leftSideRodLength'],
      ),
      leftSideRodWeight: serializer.fromJson<double?>(
        json['leftSideRodWeight'],
      ),
      leftWeights: serializer.fromJson<String?>(json['leftWeights']),
      leftAngleHorizontal: serializer.fromJson<double?>(
        json['leftAngleHorizontal'],
      ),
      leftAngleVertical: serializer.fromJson<double?>(
        json['leftAngleVertical'],
      ),
      rightSideRodModel: serializer.fromJson<String?>(
        json['rightSideRodModel'],
      ),
      rightSideRodLength: serializer.fromJson<double?>(
        json['rightSideRodLength'],
      ),
      rightSideRodWeight: serializer.fromJson<double?>(
        json['rightSideRodWeight'],
      ),
      rightWeights: serializer.fromJson<String?>(json['rightWeights']),
      rightAngleHorizontal: serializer.fromJson<double?>(
        json['rightAngleHorizontal'],
      ),
      rightAngleVertical: serializer.fromJson<double?>(
        json['rightAngleVertical'],
      ),
      sideRodModel: serializer.fromJson<String?>(json['sideRodModel']),
      sideRodLength: serializer.fromJson<double?>(json['sideRodLength']),
      sideRodWeight: serializer.fromJson<double?>(json['sideRodWeight']),
      sideRodPurchaseDate: serializer.fromJson<DateTime?>(
        json['sideRodPurchaseDate'],
      ),
      extenderLength: serializer.fromJson<double?>(json['extenderLength']),
      vbarModel: serializer.fromJson<String?>(json['vbarModel']),
      vbarAngleHorizontal: serializer.fromJson<double?>(
        json['vbarAngleHorizontal'],
      ),
      vbarAngleVertical: serializer.fromJson<double?>(
        json['vbarAngleVertical'],
      ),
      longRodWeights: serializer.fromJson<String?>(json['longRodWeights']),
      weightArrangement: serializer.fromJson<String?>(
        json['weightArrangement'],
      ),
      setupPhotoPath: serializer.fromJson<String?>(json['setupPhotoPath']),
      damperModel: serializer.fromJson<String?>(json['damperModel']),
      damperPositions: serializer.fromJson<String?>(json['damperPositions']),
      notes: serializer.fromJson<String?>(json['notes']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'bowId': serializer.toJson<String>(bowId),
      'name': serializer.toJson<String?>(name),
      'longRodModel': serializer.toJson<String?>(longRodModel),
      'longRodLength': serializer.toJson<double?>(longRodLength),
      'longRodWeight': serializer.toJson<double?>(longRodWeight),
      'longRodPurchaseDate': serializer.toJson<DateTime?>(longRodPurchaseDate),
      'leftSideRodModel': serializer.toJson<String?>(leftSideRodModel),
      'leftSideRodLength': serializer.toJson<double?>(leftSideRodLength),
      'leftSideRodWeight': serializer.toJson<double?>(leftSideRodWeight),
      'leftWeights': serializer.toJson<String?>(leftWeights),
      'leftAngleHorizontal': serializer.toJson<double?>(leftAngleHorizontal),
      'leftAngleVertical': serializer.toJson<double?>(leftAngleVertical),
      'rightSideRodModel': serializer.toJson<String?>(rightSideRodModel),
      'rightSideRodLength': serializer.toJson<double?>(rightSideRodLength),
      'rightSideRodWeight': serializer.toJson<double?>(rightSideRodWeight),
      'rightWeights': serializer.toJson<String?>(rightWeights),
      'rightAngleHorizontal': serializer.toJson<double?>(rightAngleHorizontal),
      'rightAngleVertical': serializer.toJson<double?>(rightAngleVertical),
      'sideRodModel': serializer.toJson<String?>(sideRodModel),
      'sideRodLength': serializer.toJson<double?>(sideRodLength),
      'sideRodWeight': serializer.toJson<double?>(sideRodWeight),
      'sideRodPurchaseDate': serializer.toJson<DateTime?>(sideRodPurchaseDate),
      'extenderLength': serializer.toJson<double?>(extenderLength),
      'vbarModel': serializer.toJson<String?>(vbarModel),
      'vbarAngleHorizontal': serializer.toJson<double?>(vbarAngleHorizontal),
      'vbarAngleVertical': serializer.toJson<double?>(vbarAngleVertical),
      'longRodWeights': serializer.toJson<String?>(longRodWeights),
      'weightArrangement': serializer.toJson<String?>(weightArrangement),
      'setupPhotoPath': serializer.toJson<String?>(setupPhotoPath),
      'damperModel': serializer.toJson<String?>(damperModel),
      'damperPositions': serializer.toJson<String?>(damperPositions),
      'notes': serializer.toJson<String?>(notes),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
    };
  }

  Stabilizer copyWith({
    String? id,
    String? bowId,
    Value<String?> name = const Value.absent(),
    Value<String?> longRodModel = const Value.absent(),
    Value<double?> longRodLength = const Value.absent(),
    Value<double?> longRodWeight = const Value.absent(),
    Value<DateTime?> longRodPurchaseDate = const Value.absent(),
    Value<String?> leftSideRodModel = const Value.absent(),
    Value<double?> leftSideRodLength = const Value.absent(),
    Value<double?> leftSideRodWeight = const Value.absent(),
    Value<String?> leftWeights = const Value.absent(),
    Value<double?> leftAngleHorizontal = const Value.absent(),
    Value<double?> leftAngleVertical = const Value.absent(),
    Value<String?> rightSideRodModel = const Value.absent(),
    Value<double?> rightSideRodLength = const Value.absent(),
    Value<double?> rightSideRodWeight = const Value.absent(),
    Value<String?> rightWeights = const Value.absent(),
    Value<double?> rightAngleHorizontal = const Value.absent(),
    Value<double?> rightAngleVertical = const Value.absent(),
    Value<String?> sideRodModel = const Value.absent(),
    Value<double?> sideRodLength = const Value.absent(),
    Value<double?> sideRodWeight = const Value.absent(),
    Value<DateTime?> sideRodPurchaseDate = const Value.absent(),
    Value<double?> extenderLength = const Value.absent(),
    Value<String?> vbarModel = const Value.absent(),
    Value<double?> vbarAngleHorizontal = const Value.absent(),
    Value<double?> vbarAngleVertical = const Value.absent(),
    Value<String?> longRodWeights = const Value.absent(),
    Value<String?> weightArrangement = const Value.absent(),
    Value<String?> setupPhotoPath = const Value.absent(),
    Value<String?> damperModel = const Value.absent(),
    Value<String?> damperPositions = const Value.absent(),
    Value<String?> notes = const Value.absent(),
    DateTime? createdAt,
    DateTime? updatedAt,
  }) => Stabilizer(
    id: id ?? this.id,
    bowId: bowId ?? this.bowId,
    name: name.present ? name.value : this.name,
    longRodModel: longRodModel.present ? longRodModel.value : this.longRodModel,
    longRodLength: longRodLength.present
        ? longRodLength.value
        : this.longRodLength,
    longRodWeight: longRodWeight.present
        ? longRodWeight.value
        : this.longRodWeight,
    longRodPurchaseDate: longRodPurchaseDate.present
        ? longRodPurchaseDate.value
        : this.longRodPurchaseDate,
    leftSideRodModel: leftSideRodModel.present
        ? leftSideRodModel.value
        : this.leftSideRodModel,
    leftSideRodLength: leftSideRodLength.present
        ? leftSideRodLength.value
        : this.leftSideRodLength,
    leftSideRodWeight: leftSideRodWeight.present
        ? leftSideRodWeight.value
        : this.leftSideRodWeight,
    leftWeights: leftWeights.present ? leftWeights.value : this.leftWeights,
    leftAngleHorizontal: leftAngleHorizontal.present
        ? leftAngleHorizontal.value
        : this.leftAngleHorizontal,
    leftAngleVertical: leftAngleVertical.present
        ? leftAngleVertical.value
        : this.leftAngleVertical,
    rightSideRodModel: rightSideRodModel.present
        ? rightSideRodModel.value
        : this.rightSideRodModel,
    rightSideRodLength: rightSideRodLength.present
        ? rightSideRodLength.value
        : this.rightSideRodLength,
    rightSideRodWeight: rightSideRodWeight.present
        ? rightSideRodWeight.value
        : this.rightSideRodWeight,
    rightWeights: rightWeights.present ? rightWeights.value : this.rightWeights,
    rightAngleHorizontal: rightAngleHorizontal.present
        ? rightAngleHorizontal.value
        : this.rightAngleHorizontal,
    rightAngleVertical: rightAngleVertical.present
        ? rightAngleVertical.value
        : this.rightAngleVertical,
    sideRodModel: sideRodModel.present ? sideRodModel.value : this.sideRodModel,
    sideRodLength: sideRodLength.present
        ? sideRodLength.value
        : this.sideRodLength,
    sideRodWeight: sideRodWeight.present
        ? sideRodWeight.value
        : this.sideRodWeight,
    sideRodPurchaseDate: sideRodPurchaseDate.present
        ? sideRodPurchaseDate.value
        : this.sideRodPurchaseDate,
    extenderLength: extenderLength.present
        ? extenderLength.value
        : this.extenderLength,
    vbarModel: vbarModel.present ? vbarModel.value : this.vbarModel,
    vbarAngleHorizontal: vbarAngleHorizontal.present
        ? vbarAngleHorizontal.value
        : this.vbarAngleHorizontal,
    vbarAngleVertical: vbarAngleVertical.present
        ? vbarAngleVertical.value
        : this.vbarAngleVertical,
    longRodWeights: longRodWeights.present
        ? longRodWeights.value
        : this.longRodWeights,
    weightArrangement: weightArrangement.present
        ? weightArrangement.value
        : this.weightArrangement,
    setupPhotoPath: setupPhotoPath.present
        ? setupPhotoPath.value
        : this.setupPhotoPath,
    damperModel: damperModel.present ? damperModel.value : this.damperModel,
    damperPositions: damperPositions.present
        ? damperPositions.value
        : this.damperPositions,
    notes: notes.present ? notes.value : this.notes,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
  );
  Stabilizer copyWithCompanion(StabilizersCompanion data) {
    return Stabilizer(
      id: data.id.present ? data.id.value : this.id,
      bowId: data.bowId.present ? data.bowId.value : this.bowId,
      name: data.name.present ? data.name.value : this.name,
      longRodModel: data.longRodModel.present
          ? data.longRodModel.value
          : this.longRodModel,
      longRodLength: data.longRodLength.present
          ? data.longRodLength.value
          : this.longRodLength,
      longRodWeight: data.longRodWeight.present
          ? data.longRodWeight.value
          : this.longRodWeight,
      longRodPurchaseDate: data.longRodPurchaseDate.present
          ? data.longRodPurchaseDate.value
          : this.longRodPurchaseDate,
      leftSideRodModel: data.leftSideRodModel.present
          ? data.leftSideRodModel.value
          : this.leftSideRodModel,
      leftSideRodLength: data.leftSideRodLength.present
          ? data.leftSideRodLength.value
          : this.leftSideRodLength,
      leftSideRodWeight: data.leftSideRodWeight.present
          ? data.leftSideRodWeight.value
          : this.leftSideRodWeight,
      leftWeights: data.leftWeights.present
          ? data.leftWeights.value
          : this.leftWeights,
      leftAngleHorizontal: data.leftAngleHorizontal.present
          ? data.leftAngleHorizontal.value
          : this.leftAngleHorizontal,
      leftAngleVertical: data.leftAngleVertical.present
          ? data.leftAngleVertical.value
          : this.leftAngleVertical,
      rightSideRodModel: data.rightSideRodModel.present
          ? data.rightSideRodModel.value
          : this.rightSideRodModel,
      rightSideRodLength: data.rightSideRodLength.present
          ? data.rightSideRodLength.value
          : this.rightSideRodLength,
      rightSideRodWeight: data.rightSideRodWeight.present
          ? data.rightSideRodWeight.value
          : this.rightSideRodWeight,
      rightWeights: data.rightWeights.present
          ? data.rightWeights.value
          : this.rightWeights,
      rightAngleHorizontal: data.rightAngleHorizontal.present
          ? data.rightAngleHorizontal.value
          : this.rightAngleHorizontal,
      rightAngleVertical: data.rightAngleVertical.present
          ? data.rightAngleVertical.value
          : this.rightAngleVertical,
      sideRodModel: data.sideRodModel.present
          ? data.sideRodModel.value
          : this.sideRodModel,
      sideRodLength: data.sideRodLength.present
          ? data.sideRodLength.value
          : this.sideRodLength,
      sideRodWeight: data.sideRodWeight.present
          ? data.sideRodWeight.value
          : this.sideRodWeight,
      sideRodPurchaseDate: data.sideRodPurchaseDate.present
          ? data.sideRodPurchaseDate.value
          : this.sideRodPurchaseDate,
      extenderLength: data.extenderLength.present
          ? data.extenderLength.value
          : this.extenderLength,
      vbarModel: data.vbarModel.present ? data.vbarModel.value : this.vbarModel,
      vbarAngleHorizontal: data.vbarAngleHorizontal.present
          ? data.vbarAngleHorizontal.value
          : this.vbarAngleHorizontal,
      vbarAngleVertical: data.vbarAngleVertical.present
          ? data.vbarAngleVertical.value
          : this.vbarAngleVertical,
      longRodWeights: data.longRodWeights.present
          ? data.longRodWeights.value
          : this.longRodWeights,
      weightArrangement: data.weightArrangement.present
          ? data.weightArrangement.value
          : this.weightArrangement,
      setupPhotoPath: data.setupPhotoPath.present
          ? data.setupPhotoPath.value
          : this.setupPhotoPath,
      damperModel: data.damperModel.present
          ? data.damperModel.value
          : this.damperModel,
      damperPositions: data.damperPositions.present
          ? data.damperPositions.value
          : this.damperPositions,
      notes: data.notes.present ? data.notes.value : this.notes,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Stabilizer(')
          ..write('id: $id, ')
          ..write('bowId: $bowId, ')
          ..write('name: $name, ')
          ..write('longRodModel: $longRodModel, ')
          ..write('longRodLength: $longRodLength, ')
          ..write('longRodWeight: $longRodWeight, ')
          ..write('longRodPurchaseDate: $longRodPurchaseDate, ')
          ..write('leftSideRodModel: $leftSideRodModel, ')
          ..write('leftSideRodLength: $leftSideRodLength, ')
          ..write('leftSideRodWeight: $leftSideRodWeight, ')
          ..write('leftWeights: $leftWeights, ')
          ..write('leftAngleHorizontal: $leftAngleHorizontal, ')
          ..write('leftAngleVertical: $leftAngleVertical, ')
          ..write('rightSideRodModel: $rightSideRodModel, ')
          ..write('rightSideRodLength: $rightSideRodLength, ')
          ..write('rightSideRodWeight: $rightSideRodWeight, ')
          ..write('rightWeights: $rightWeights, ')
          ..write('rightAngleHorizontal: $rightAngleHorizontal, ')
          ..write('rightAngleVertical: $rightAngleVertical, ')
          ..write('sideRodModel: $sideRodModel, ')
          ..write('sideRodLength: $sideRodLength, ')
          ..write('sideRodWeight: $sideRodWeight, ')
          ..write('sideRodPurchaseDate: $sideRodPurchaseDate, ')
          ..write('extenderLength: $extenderLength, ')
          ..write('vbarModel: $vbarModel, ')
          ..write('vbarAngleHorizontal: $vbarAngleHorizontal, ')
          ..write('vbarAngleVertical: $vbarAngleVertical, ')
          ..write('longRodWeights: $longRodWeights, ')
          ..write('weightArrangement: $weightArrangement, ')
          ..write('setupPhotoPath: $setupPhotoPath, ')
          ..write('damperModel: $damperModel, ')
          ..write('damperPositions: $damperPositions, ')
          ..write('notes: $notes, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hashAll([
    id,
    bowId,
    name,
    longRodModel,
    longRodLength,
    longRodWeight,
    longRodPurchaseDate,
    leftSideRodModel,
    leftSideRodLength,
    leftSideRodWeight,
    leftWeights,
    leftAngleHorizontal,
    leftAngleVertical,
    rightSideRodModel,
    rightSideRodLength,
    rightSideRodWeight,
    rightWeights,
    rightAngleHorizontal,
    rightAngleVertical,
    sideRodModel,
    sideRodLength,
    sideRodWeight,
    sideRodPurchaseDate,
    extenderLength,
    vbarModel,
    vbarAngleHorizontal,
    vbarAngleVertical,
    longRodWeights,
    weightArrangement,
    setupPhotoPath,
    damperModel,
    damperPositions,
    notes,
    createdAt,
    updatedAt,
  ]);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Stabilizer &&
          other.id == this.id &&
          other.bowId == this.bowId &&
          other.name == this.name &&
          other.longRodModel == this.longRodModel &&
          other.longRodLength == this.longRodLength &&
          other.longRodWeight == this.longRodWeight &&
          other.longRodPurchaseDate == this.longRodPurchaseDate &&
          other.leftSideRodModel == this.leftSideRodModel &&
          other.leftSideRodLength == this.leftSideRodLength &&
          other.leftSideRodWeight == this.leftSideRodWeight &&
          other.leftWeights == this.leftWeights &&
          other.leftAngleHorizontal == this.leftAngleHorizontal &&
          other.leftAngleVertical == this.leftAngleVertical &&
          other.rightSideRodModel == this.rightSideRodModel &&
          other.rightSideRodLength == this.rightSideRodLength &&
          other.rightSideRodWeight == this.rightSideRodWeight &&
          other.rightWeights == this.rightWeights &&
          other.rightAngleHorizontal == this.rightAngleHorizontal &&
          other.rightAngleVertical == this.rightAngleVertical &&
          other.sideRodModel == this.sideRodModel &&
          other.sideRodLength == this.sideRodLength &&
          other.sideRodWeight == this.sideRodWeight &&
          other.sideRodPurchaseDate == this.sideRodPurchaseDate &&
          other.extenderLength == this.extenderLength &&
          other.vbarModel == this.vbarModel &&
          other.vbarAngleHorizontal == this.vbarAngleHorizontal &&
          other.vbarAngleVertical == this.vbarAngleVertical &&
          other.longRodWeights == this.longRodWeights &&
          other.weightArrangement == this.weightArrangement &&
          other.setupPhotoPath == this.setupPhotoPath &&
          other.damperModel == this.damperModel &&
          other.damperPositions == this.damperPositions &&
          other.notes == this.notes &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class StabilizersCompanion extends UpdateCompanion<Stabilizer> {
  final Value<String> id;
  final Value<String> bowId;
  final Value<String?> name;
  final Value<String?> longRodModel;
  final Value<double?> longRodLength;
  final Value<double?> longRodWeight;
  final Value<DateTime?> longRodPurchaseDate;
  final Value<String?> leftSideRodModel;
  final Value<double?> leftSideRodLength;
  final Value<double?> leftSideRodWeight;
  final Value<String?> leftWeights;
  final Value<double?> leftAngleHorizontal;
  final Value<double?> leftAngleVertical;
  final Value<String?> rightSideRodModel;
  final Value<double?> rightSideRodLength;
  final Value<double?> rightSideRodWeight;
  final Value<String?> rightWeights;
  final Value<double?> rightAngleHorizontal;
  final Value<double?> rightAngleVertical;
  final Value<String?> sideRodModel;
  final Value<double?> sideRodLength;
  final Value<double?> sideRodWeight;
  final Value<DateTime?> sideRodPurchaseDate;
  final Value<double?> extenderLength;
  final Value<String?> vbarModel;
  final Value<double?> vbarAngleHorizontal;
  final Value<double?> vbarAngleVertical;
  final Value<String?> longRodWeights;
  final Value<String?> weightArrangement;
  final Value<String?> setupPhotoPath;
  final Value<String?> damperModel;
  final Value<String?> damperPositions;
  final Value<String?> notes;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  final Value<int> rowid;
  const StabilizersCompanion({
    this.id = const Value.absent(),
    this.bowId = const Value.absent(),
    this.name = const Value.absent(),
    this.longRodModel = const Value.absent(),
    this.longRodLength = const Value.absent(),
    this.longRodWeight = const Value.absent(),
    this.longRodPurchaseDate = const Value.absent(),
    this.leftSideRodModel = const Value.absent(),
    this.leftSideRodLength = const Value.absent(),
    this.leftSideRodWeight = const Value.absent(),
    this.leftWeights = const Value.absent(),
    this.leftAngleHorizontal = const Value.absent(),
    this.leftAngleVertical = const Value.absent(),
    this.rightSideRodModel = const Value.absent(),
    this.rightSideRodLength = const Value.absent(),
    this.rightSideRodWeight = const Value.absent(),
    this.rightWeights = const Value.absent(),
    this.rightAngleHorizontal = const Value.absent(),
    this.rightAngleVertical = const Value.absent(),
    this.sideRodModel = const Value.absent(),
    this.sideRodLength = const Value.absent(),
    this.sideRodWeight = const Value.absent(),
    this.sideRodPurchaseDate = const Value.absent(),
    this.extenderLength = const Value.absent(),
    this.vbarModel = const Value.absent(),
    this.vbarAngleHorizontal = const Value.absent(),
    this.vbarAngleVertical = const Value.absent(),
    this.longRodWeights = const Value.absent(),
    this.weightArrangement = const Value.absent(),
    this.setupPhotoPath = const Value.absent(),
    this.damperModel = const Value.absent(),
    this.damperPositions = const Value.absent(),
    this.notes = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  StabilizersCompanion.insert({
    required String id,
    required String bowId,
    this.name = const Value.absent(),
    this.longRodModel = const Value.absent(),
    this.longRodLength = const Value.absent(),
    this.longRodWeight = const Value.absent(),
    this.longRodPurchaseDate = const Value.absent(),
    this.leftSideRodModel = const Value.absent(),
    this.leftSideRodLength = const Value.absent(),
    this.leftSideRodWeight = const Value.absent(),
    this.leftWeights = const Value.absent(),
    this.leftAngleHorizontal = const Value.absent(),
    this.leftAngleVertical = const Value.absent(),
    this.rightSideRodModel = const Value.absent(),
    this.rightSideRodLength = const Value.absent(),
    this.rightSideRodWeight = const Value.absent(),
    this.rightWeights = const Value.absent(),
    this.rightAngleHorizontal = const Value.absent(),
    this.rightAngleVertical = const Value.absent(),
    this.sideRodModel = const Value.absent(),
    this.sideRodLength = const Value.absent(),
    this.sideRodWeight = const Value.absent(),
    this.sideRodPurchaseDate = const Value.absent(),
    this.extenderLength = const Value.absent(),
    this.vbarModel = const Value.absent(),
    this.vbarAngleHorizontal = const Value.absent(),
    this.vbarAngleVertical = const Value.absent(),
    this.longRodWeights = const Value.absent(),
    this.weightArrangement = const Value.absent(),
    this.setupPhotoPath = const Value.absent(),
    this.damperModel = const Value.absent(),
    this.damperPositions = const Value.absent(),
    this.notes = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       bowId = Value(bowId);
  static Insertable<Stabilizer> custom({
    Expression<String>? id,
    Expression<String>? bowId,
    Expression<String>? name,
    Expression<String>? longRodModel,
    Expression<double>? longRodLength,
    Expression<double>? longRodWeight,
    Expression<DateTime>? longRodPurchaseDate,
    Expression<String>? leftSideRodModel,
    Expression<double>? leftSideRodLength,
    Expression<double>? leftSideRodWeight,
    Expression<String>? leftWeights,
    Expression<double>? leftAngleHorizontal,
    Expression<double>? leftAngleVertical,
    Expression<String>? rightSideRodModel,
    Expression<double>? rightSideRodLength,
    Expression<double>? rightSideRodWeight,
    Expression<String>? rightWeights,
    Expression<double>? rightAngleHorizontal,
    Expression<double>? rightAngleVertical,
    Expression<String>? sideRodModel,
    Expression<double>? sideRodLength,
    Expression<double>? sideRodWeight,
    Expression<DateTime>? sideRodPurchaseDate,
    Expression<double>? extenderLength,
    Expression<String>? vbarModel,
    Expression<double>? vbarAngleHorizontal,
    Expression<double>? vbarAngleVertical,
    Expression<String>? longRodWeights,
    Expression<String>? weightArrangement,
    Expression<String>? setupPhotoPath,
    Expression<String>? damperModel,
    Expression<String>? damperPositions,
    Expression<String>? notes,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (bowId != null) 'bow_id': bowId,
      if (name != null) 'name': name,
      if (longRodModel != null) 'long_rod_model': longRodModel,
      if (longRodLength != null) 'long_rod_length': longRodLength,
      if (longRodWeight != null) 'long_rod_weight': longRodWeight,
      if (longRodPurchaseDate != null)
        'long_rod_purchase_date': longRodPurchaseDate,
      if (leftSideRodModel != null) 'left_side_rod_model': leftSideRodModel,
      if (leftSideRodLength != null) 'left_side_rod_length': leftSideRodLength,
      if (leftSideRodWeight != null) 'left_side_rod_weight': leftSideRodWeight,
      if (leftWeights != null) 'left_weights': leftWeights,
      if (leftAngleHorizontal != null)
        'left_angle_horizontal': leftAngleHorizontal,
      if (leftAngleVertical != null) 'left_angle_vertical': leftAngleVertical,
      if (rightSideRodModel != null) 'right_side_rod_model': rightSideRodModel,
      if (rightSideRodLength != null)
        'right_side_rod_length': rightSideRodLength,
      if (rightSideRodWeight != null)
        'right_side_rod_weight': rightSideRodWeight,
      if (rightWeights != null) 'right_weights': rightWeights,
      if (rightAngleHorizontal != null)
        'right_angle_horizontal': rightAngleHorizontal,
      if (rightAngleVertical != null)
        'right_angle_vertical': rightAngleVertical,
      if (sideRodModel != null) 'side_rod_model': sideRodModel,
      if (sideRodLength != null) 'side_rod_length': sideRodLength,
      if (sideRodWeight != null) 'side_rod_weight': sideRodWeight,
      if (sideRodPurchaseDate != null)
        'side_rod_purchase_date': sideRodPurchaseDate,
      if (extenderLength != null) 'extender_length': extenderLength,
      if (vbarModel != null) 'vbar_model': vbarModel,
      if (vbarAngleHorizontal != null)
        'vbar_angle_horizontal': vbarAngleHorizontal,
      if (vbarAngleVertical != null) 'vbar_angle_vertical': vbarAngleVertical,
      if (longRodWeights != null) 'long_rod_weights': longRodWeights,
      if (weightArrangement != null) 'weight_arrangement': weightArrangement,
      if (setupPhotoPath != null) 'setup_photo_path': setupPhotoPath,
      if (damperModel != null) 'damper_model': damperModel,
      if (damperPositions != null) 'damper_positions': damperPositions,
      if (notes != null) 'notes': notes,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  StabilizersCompanion copyWith({
    Value<String>? id,
    Value<String>? bowId,
    Value<String?>? name,
    Value<String?>? longRodModel,
    Value<double?>? longRodLength,
    Value<double?>? longRodWeight,
    Value<DateTime?>? longRodPurchaseDate,
    Value<String?>? leftSideRodModel,
    Value<double?>? leftSideRodLength,
    Value<double?>? leftSideRodWeight,
    Value<String?>? leftWeights,
    Value<double?>? leftAngleHorizontal,
    Value<double?>? leftAngleVertical,
    Value<String?>? rightSideRodModel,
    Value<double?>? rightSideRodLength,
    Value<double?>? rightSideRodWeight,
    Value<String?>? rightWeights,
    Value<double?>? rightAngleHorizontal,
    Value<double?>? rightAngleVertical,
    Value<String?>? sideRodModel,
    Value<double?>? sideRodLength,
    Value<double?>? sideRodWeight,
    Value<DateTime?>? sideRodPurchaseDate,
    Value<double?>? extenderLength,
    Value<String?>? vbarModel,
    Value<double?>? vbarAngleHorizontal,
    Value<double?>? vbarAngleVertical,
    Value<String?>? longRodWeights,
    Value<String?>? weightArrangement,
    Value<String?>? setupPhotoPath,
    Value<String?>? damperModel,
    Value<String?>? damperPositions,
    Value<String?>? notes,
    Value<DateTime>? createdAt,
    Value<DateTime>? updatedAt,
    Value<int>? rowid,
  }) {
    return StabilizersCompanion(
      id: id ?? this.id,
      bowId: bowId ?? this.bowId,
      name: name ?? this.name,
      longRodModel: longRodModel ?? this.longRodModel,
      longRodLength: longRodLength ?? this.longRodLength,
      longRodWeight: longRodWeight ?? this.longRodWeight,
      longRodPurchaseDate: longRodPurchaseDate ?? this.longRodPurchaseDate,
      leftSideRodModel: leftSideRodModel ?? this.leftSideRodModel,
      leftSideRodLength: leftSideRodLength ?? this.leftSideRodLength,
      leftSideRodWeight: leftSideRodWeight ?? this.leftSideRodWeight,
      leftWeights: leftWeights ?? this.leftWeights,
      leftAngleHorizontal: leftAngleHorizontal ?? this.leftAngleHorizontal,
      leftAngleVertical: leftAngleVertical ?? this.leftAngleVertical,
      rightSideRodModel: rightSideRodModel ?? this.rightSideRodModel,
      rightSideRodLength: rightSideRodLength ?? this.rightSideRodLength,
      rightSideRodWeight: rightSideRodWeight ?? this.rightSideRodWeight,
      rightWeights: rightWeights ?? this.rightWeights,
      rightAngleHorizontal: rightAngleHorizontal ?? this.rightAngleHorizontal,
      rightAngleVertical: rightAngleVertical ?? this.rightAngleVertical,
      sideRodModel: sideRodModel ?? this.sideRodModel,
      sideRodLength: sideRodLength ?? this.sideRodLength,
      sideRodWeight: sideRodWeight ?? this.sideRodWeight,
      sideRodPurchaseDate: sideRodPurchaseDate ?? this.sideRodPurchaseDate,
      extenderLength: extenderLength ?? this.extenderLength,
      vbarModel: vbarModel ?? this.vbarModel,
      vbarAngleHorizontal: vbarAngleHorizontal ?? this.vbarAngleHorizontal,
      vbarAngleVertical: vbarAngleVertical ?? this.vbarAngleVertical,
      longRodWeights: longRodWeights ?? this.longRodWeights,
      weightArrangement: weightArrangement ?? this.weightArrangement,
      setupPhotoPath: setupPhotoPath ?? this.setupPhotoPath,
      damperModel: damperModel ?? this.damperModel,
      damperPositions: damperPositions ?? this.damperPositions,
      notes: notes ?? this.notes,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (bowId.present) {
      map['bow_id'] = Variable<String>(bowId.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (longRodModel.present) {
      map['long_rod_model'] = Variable<String>(longRodModel.value);
    }
    if (longRodLength.present) {
      map['long_rod_length'] = Variable<double>(longRodLength.value);
    }
    if (longRodWeight.present) {
      map['long_rod_weight'] = Variable<double>(longRodWeight.value);
    }
    if (longRodPurchaseDate.present) {
      map['long_rod_purchase_date'] = Variable<DateTime>(
        longRodPurchaseDate.value,
      );
    }
    if (leftSideRodModel.present) {
      map['left_side_rod_model'] = Variable<String>(leftSideRodModel.value);
    }
    if (leftSideRodLength.present) {
      map['left_side_rod_length'] = Variable<double>(leftSideRodLength.value);
    }
    if (leftSideRodWeight.present) {
      map['left_side_rod_weight'] = Variable<double>(leftSideRodWeight.value);
    }
    if (leftWeights.present) {
      map['left_weights'] = Variable<String>(leftWeights.value);
    }
    if (leftAngleHorizontal.present) {
      map['left_angle_horizontal'] = Variable<double>(
        leftAngleHorizontal.value,
      );
    }
    if (leftAngleVertical.present) {
      map['left_angle_vertical'] = Variable<double>(leftAngleVertical.value);
    }
    if (rightSideRodModel.present) {
      map['right_side_rod_model'] = Variable<String>(rightSideRodModel.value);
    }
    if (rightSideRodLength.present) {
      map['right_side_rod_length'] = Variable<double>(rightSideRodLength.value);
    }
    if (rightSideRodWeight.present) {
      map['right_side_rod_weight'] = Variable<double>(rightSideRodWeight.value);
    }
    if (rightWeights.present) {
      map['right_weights'] = Variable<String>(rightWeights.value);
    }
    if (rightAngleHorizontal.present) {
      map['right_angle_horizontal'] = Variable<double>(
        rightAngleHorizontal.value,
      );
    }
    if (rightAngleVertical.present) {
      map['right_angle_vertical'] = Variable<double>(rightAngleVertical.value);
    }
    if (sideRodModel.present) {
      map['side_rod_model'] = Variable<String>(sideRodModel.value);
    }
    if (sideRodLength.present) {
      map['side_rod_length'] = Variable<double>(sideRodLength.value);
    }
    if (sideRodWeight.present) {
      map['side_rod_weight'] = Variable<double>(sideRodWeight.value);
    }
    if (sideRodPurchaseDate.present) {
      map['side_rod_purchase_date'] = Variable<DateTime>(
        sideRodPurchaseDate.value,
      );
    }
    if (extenderLength.present) {
      map['extender_length'] = Variable<double>(extenderLength.value);
    }
    if (vbarModel.present) {
      map['vbar_model'] = Variable<String>(vbarModel.value);
    }
    if (vbarAngleHorizontal.present) {
      map['vbar_angle_horizontal'] = Variable<double>(
        vbarAngleHorizontal.value,
      );
    }
    if (vbarAngleVertical.present) {
      map['vbar_angle_vertical'] = Variable<double>(vbarAngleVertical.value);
    }
    if (longRodWeights.present) {
      map['long_rod_weights'] = Variable<String>(longRodWeights.value);
    }
    if (weightArrangement.present) {
      map['weight_arrangement'] = Variable<String>(weightArrangement.value);
    }
    if (setupPhotoPath.present) {
      map['setup_photo_path'] = Variable<String>(setupPhotoPath.value);
    }
    if (damperModel.present) {
      map['damper_model'] = Variable<String>(damperModel.value);
    }
    if (damperPositions.present) {
      map['damper_positions'] = Variable<String>(damperPositions.value);
    }
    if (notes.present) {
      map['notes'] = Variable<String>(notes.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('StabilizersCompanion(')
          ..write('id: $id, ')
          ..write('bowId: $bowId, ')
          ..write('name: $name, ')
          ..write('longRodModel: $longRodModel, ')
          ..write('longRodLength: $longRodLength, ')
          ..write('longRodWeight: $longRodWeight, ')
          ..write('longRodPurchaseDate: $longRodPurchaseDate, ')
          ..write('leftSideRodModel: $leftSideRodModel, ')
          ..write('leftSideRodLength: $leftSideRodLength, ')
          ..write('leftSideRodWeight: $leftSideRodWeight, ')
          ..write('leftWeights: $leftWeights, ')
          ..write('leftAngleHorizontal: $leftAngleHorizontal, ')
          ..write('leftAngleVertical: $leftAngleVertical, ')
          ..write('rightSideRodModel: $rightSideRodModel, ')
          ..write('rightSideRodLength: $rightSideRodLength, ')
          ..write('rightSideRodWeight: $rightSideRodWeight, ')
          ..write('rightWeights: $rightWeights, ')
          ..write('rightAngleHorizontal: $rightAngleHorizontal, ')
          ..write('rightAngleVertical: $rightAngleVertical, ')
          ..write('sideRodModel: $sideRodModel, ')
          ..write('sideRodLength: $sideRodLength, ')
          ..write('sideRodWeight: $sideRodWeight, ')
          ..write('sideRodPurchaseDate: $sideRodPurchaseDate, ')
          ..write('extenderLength: $extenderLength, ')
          ..write('vbarModel: $vbarModel, ')
          ..write('vbarAngleHorizontal: $vbarAngleHorizontal, ')
          ..write('vbarAngleVertical: $vbarAngleVertical, ')
          ..write('longRodWeights: $longRodWeights, ')
          ..write('weightArrangement: $weightArrangement, ')
          ..write('setupPhotoPath: $setupPhotoPath, ')
          ..write('damperModel: $damperModel, ')
          ..write('damperPositions: $damperPositions, ')
          ..write('notes: $notes, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $BowStringsTable extends BowStrings
    with TableInfo<$BowStringsTable, BowString> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $BowStringsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _bowIdMeta = const VerificationMeta('bowId');
  @override
  late final GeneratedColumn<String> bowId = GeneratedColumn<String>(
    'bow_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES bows (id)',
    ),
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _materialMeta = const VerificationMeta(
    'material',
  );
  @override
  late final GeneratedColumn<String> material = GeneratedColumn<String>(
    'material',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _strandCountMeta = const VerificationMeta(
    'strandCount',
  );
  @override
  late final GeneratedColumn<int> strandCount = GeneratedColumn<int>(
    'strand_count',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _servingMaterialMeta = const VerificationMeta(
    'servingMaterial',
  );
  @override
  late final GeneratedColumn<String> servingMaterial = GeneratedColumn<String>(
    'serving_material',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _stringLengthMeta = const VerificationMeta(
    'stringLength',
  );
  @override
  late final GeneratedColumn<double> stringLength = GeneratedColumn<double>(
    'string_length',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _colorMeta = const VerificationMeta('color');
  @override
  late final GeneratedColumn<String> color = GeneratedColumn<String>(
    'color',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _isActiveMeta = const VerificationMeta(
    'isActive',
  );
  @override
  late final GeneratedColumn<bool> isActive = GeneratedColumn<bool>(
    'is_active',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_active" IN (0, 1))',
    ),
    defaultValue: const Constant(true),
  );
  static const VerificationMeta _purchaseDateMeta = const VerificationMeta(
    'purchaseDate',
  );
  @override
  late final GeneratedColumn<DateTime> purchaseDate = GeneratedColumn<DateTime>(
    'purchase_date',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _retiredAtMeta = const VerificationMeta(
    'retiredAt',
  );
  @override
  late final GeneratedColumn<DateTime> retiredAt = GeneratedColumn<DateTime>(
    'retired_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _notesMeta = const VerificationMeta('notes');
  @override
  late final GeneratedColumn<String> notes = GeneratedColumn<String>(
    'notes',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    bowId,
    name,
    material,
    strandCount,
    servingMaterial,
    stringLength,
    color,
    isActive,
    purchaseDate,
    retiredAt,
    notes,
    createdAt,
    updatedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'bow_strings';
  @override
  VerificationContext validateIntegrity(
    Insertable<BowString> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('bow_id')) {
      context.handle(
        _bowIdMeta,
        bowId.isAcceptableOrUnknown(data['bow_id']!, _bowIdMeta),
      );
    } else if (isInserting) {
      context.missing(_bowIdMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    }
    if (data.containsKey('material')) {
      context.handle(
        _materialMeta,
        material.isAcceptableOrUnknown(data['material']!, _materialMeta),
      );
    }
    if (data.containsKey('strand_count')) {
      context.handle(
        _strandCountMeta,
        strandCount.isAcceptableOrUnknown(
          data['strand_count']!,
          _strandCountMeta,
        ),
      );
    }
    if (data.containsKey('serving_material')) {
      context.handle(
        _servingMaterialMeta,
        servingMaterial.isAcceptableOrUnknown(
          data['serving_material']!,
          _servingMaterialMeta,
        ),
      );
    }
    if (data.containsKey('string_length')) {
      context.handle(
        _stringLengthMeta,
        stringLength.isAcceptableOrUnknown(
          data['string_length']!,
          _stringLengthMeta,
        ),
      );
    }
    if (data.containsKey('color')) {
      context.handle(
        _colorMeta,
        color.isAcceptableOrUnknown(data['color']!, _colorMeta),
      );
    }
    if (data.containsKey('is_active')) {
      context.handle(
        _isActiveMeta,
        isActive.isAcceptableOrUnknown(data['is_active']!, _isActiveMeta),
      );
    }
    if (data.containsKey('purchase_date')) {
      context.handle(
        _purchaseDateMeta,
        purchaseDate.isAcceptableOrUnknown(
          data['purchase_date']!,
          _purchaseDateMeta,
        ),
      );
    }
    if (data.containsKey('retired_at')) {
      context.handle(
        _retiredAtMeta,
        retiredAt.isAcceptableOrUnknown(data['retired_at']!, _retiredAtMeta),
      );
    }
    if (data.containsKey('notes')) {
      context.handle(
        _notesMeta,
        notes.isAcceptableOrUnknown(data['notes']!, _notesMeta),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  BowString map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return BowString(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      bowId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}bow_id'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      ),
      material: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}material'],
      ),
      strandCount: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}strand_count'],
      ),
      servingMaterial: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}serving_material'],
      ),
      stringLength: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}string_length'],
      ),
      color: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}color'],
      ),
      isActive: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_active'],
      )!,
      purchaseDate: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}purchase_date'],
      ),
      retiredAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}retired_at'],
      ),
      notes: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}notes'],
      ),
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      )!,
    );
  }

  @override
  $BowStringsTable createAlias(String alias) {
    return $BowStringsTable(attachedDatabase, alias);
  }
}

class BowString extends DataClass implements Insertable<BowString> {
  final String id;
  final String bowId;
  final String? name;
  final String? material;
  final int? strandCount;
  final String? servingMaterial;
  final double? stringLength;
  final String? color;
  final bool isActive;
  final DateTime? purchaseDate;
  final DateTime? retiredAt;
  final String? notes;
  final DateTime createdAt;
  final DateTime updatedAt;
  const BowString({
    required this.id,
    required this.bowId,
    this.name,
    this.material,
    this.strandCount,
    this.servingMaterial,
    this.stringLength,
    this.color,
    required this.isActive,
    this.purchaseDate,
    this.retiredAt,
    this.notes,
    required this.createdAt,
    required this.updatedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['bow_id'] = Variable<String>(bowId);
    if (!nullToAbsent || name != null) {
      map['name'] = Variable<String>(name);
    }
    if (!nullToAbsent || material != null) {
      map['material'] = Variable<String>(material);
    }
    if (!nullToAbsent || strandCount != null) {
      map['strand_count'] = Variable<int>(strandCount);
    }
    if (!nullToAbsent || servingMaterial != null) {
      map['serving_material'] = Variable<String>(servingMaterial);
    }
    if (!nullToAbsent || stringLength != null) {
      map['string_length'] = Variable<double>(stringLength);
    }
    if (!nullToAbsent || color != null) {
      map['color'] = Variable<String>(color);
    }
    map['is_active'] = Variable<bool>(isActive);
    if (!nullToAbsent || purchaseDate != null) {
      map['purchase_date'] = Variable<DateTime>(purchaseDate);
    }
    if (!nullToAbsent || retiredAt != null) {
      map['retired_at'] = Variable<DateTime>(retiredAt);
    }
    if (!nullToAbsent || notes != null) {
      map['notes'] = Variable<String>(notes);
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    return map;
  }

  BowStringsCompanion toCompanion(bool nullToAbsent) {
    return BowStringsCompanion(
      id: Value(id),
      bowId: Value(bowId),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      material: material == null && nullToAbsent
          ? const Value.absent()
          : Value(material),
      strandCount: strandCount == null && nullToAbsent
          ? const Value.absent()
          : Value(strandCount),
      servingMaterial: servingMaterial == null && nullToAbsent
          ? const Value.absent()
          : Value(servingMaterial),
      stringLength: stringLength == null && nullToAbsent
          ? const Value.absent()
          : Value(stringLength),
      color: color == null && nullToAbsent
          ? const Value.absent()
          : Value(color),
      isActive: Value(isActive),
      purchaseDate: purchaseDate == null && nullToAbsent
          ? const Value.absent()
          : Value(purchaseDate),
      retiredAt: retiredAt == null && nullToAbsent
          ? const Value.absent()
          : Value(retiredAt),
      notes: notes == null && nullToAbsent
          ? const Value.absent()
          : Value(notes),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory BowString.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return BowString(
      id: serializer.fromJson<String>(json['id']),
      bowId: serializer.fromJson<String>(json['bowId']),
      name: serializer.fromJson<String?>(json['name']),
      material: serializer.fromJson<String?>(json['material']),
      strandCount: serializer.fromJson<int?>(json['strandCount']),
      servingMaterial: serializer.fromJson<String?>(json['servingMaterial']),
      stringLength: serializer.fromJson<double?>(json['stringLength']),
      color: serializer.fromJson<String?>(json['color']),
      isActive: serializer.fromJson<bool>(json['isActive']),
      purchaseDate: serializer.fromJson<DateTime?>(json['purchaseDate']),
      retiredAt: serializer.fromJson<DateTime?>(json['retiredAt']),
      notes: serializer.fromJson<String?>(json['notes']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'bowId': serializer.toJson<String>(bowId),
      'name': serializer.toJson<String?>(name),
      'material': serializer.toJson<String?>(material),
      'strandCount': serializer.toJson<int?>(strandCount),
      'servingMaterial': serializer.toJson<String?>(servingMaterial),
      'stringLength': serializer.toJson<double?>(stringLength),
      'color': serializer.toJson<String?>(color),
      'isActive': serializer.toJson<bool>(isActive),
      'purchaseDate': serializer.toJson<DateTime?>(purchaseDate),
      'retiredAt': serializer.toJson<DateTime?>(retiredAt),
      'notes': serializer.toJson<String?>(notes),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
    };
  }

  BowString copyWith({
    String? id,
    String? bowId,
    Value<String?> name = const Value.absent(),
    Value<String?> material = const Value.absent(),
    Value<int?> strandCount = const Value.absent(),
    Value<String?> servingMaterial = const Value.absent(),
    Value<double?> stringLength = const Value.absent(),
    Value<String?> color = const Value.absent(),
    bool? isActive,
    Value<DateTime?> purchaseDate = const Value.absent(),
    Value<DateTime?> retiredAt = const Value.absent(),
    Value<String?> notes = const Value.absent(),
    DateTime? createdAt,
    DateTime? updatedAt,
  }) => BowString(
    id: id ?? this.id,
    bowId: bowId ?? this.bowId,
    name: name.present ? name.value : this.name,
    material: material.present ? material.value : this.material,
    strandCount: strandCount.present ? strandCount.value : this.strandCount,
    servingMaterial: servingMaterial.present
        ? servingMaterial.value
        : this.servingMaterial,
    stringLength: stringLength.present ? stringLength.value : this.stringLength,
    color: color.present ? color.value : this.color,
    isActive: isActive ?? this.isActive,
    purchaseDate: purchaseDate.present ? purchaseDate.value : this.purchaseDate,
    retiredAt: retiredAt.present ? retiredAt.value : this.retiredAt,
    notes: notes.present ? notes.value : this.notes,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
  );
  BowString copyWithCompanion(BowStringsCompanion data) {
    return BowString(
      id: data.id.present ? data.id.value : this.id,
      bowId: data.bowId.present ? data.bowId.value : this.bowId,
      name: data.name.present ? data.name.value : this.name,
      material: data.material.present ? data.material.value : this.material,
      strandCount: data.strandCount.present
          ? data.strandCount.value
          : this.strandCount,
      servingMaterial: data.servingMaterial.present
          ? data.servingMaterial.value
          : this.servingMaterial,
      stringLength: data.stringLength.present
          ? data.stringLength.value
          : this.stringLength,
      color: data.color.present ? data.color.value : this.color,
      isActive: data.isActive.present ? data.isActive.value : this.isActive,
      purchaseDate: data.purchaseDate.present
          ? data.purchaseDate.value
          : this.purchaseDate,
      retiredAt: data.retiredAt.present ? data.retiredAt.value : this.retiredAt,
      notes: data.notes.present ? data.notes.value : this.notes,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('BowString(')
          ..write('id: $id, ')
          ..write('bowId: $bowId, ')
          ..write('name: $name, ')
          ..write('material: $material, ')
          ..write('strandCount: $strandCount, ')
          ..write('servingMaterial: $servingMaterial, ')
          ..write('stringLength: $stringLength, ')
          ..write('color: $color, ')
          ..write('isActive: $isActive, ')
          ..write('purchaseDate: $purchaseDate, ')
          ..write('retiredAt: $retiredAt, ')
          ..write('notes: $notes, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    bowId,
    name,
    material,
    strandCount,
    servingMaterial,
    stringLength,
    color,
    isActive,
    purchaseDate,
    retiredAt,
    notes,
    createdAt,
    updatedAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is BowString &&
          other.id == this.id &&
          other.bowId == this.bowId &&
          other.name == this.name &&
          other.material == this.material &&
          other.strandCount == this.strandCount &&
          other.servingMaterial == this.servingMaterial &&
          other.stringLength == this.stringLength &&
          other.color == this.color &&
          other.isActive == this.isActive &&
          other.purchaseDate == this.purchaseDate &&
          other.retiredAt == this.retiredAt &&
          other.notes == this.notes &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class BowStringsCompanion extends UpdateCompanion<BowString> {
  final Value<String> id;
  final Value<String> bowId;
  final Value<String?> name;
  final Value<String?> material;
  final Value<int?> strandCount;
  final Value<String?> servingMaterial;
  final Value<double?> stringLength;
  final Value<String?> color;
  final Value<bool> isActive;
  final Value<DateTime?> purchaseDate;
  final Value<DateTime?> retiredAt;
  final Value<String?> notes;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  final Value<int> rowid;
  const BowStringsCompanion({
    this.id = const Value.absent(),
    this.bowId = const Value.absent(),
    this.name = const Value.absent(),
    this.material = const Value.absent(),
    this.strandCount = const Value.absent(),
    this.servingMaterial = const Value.absent(),
    this.stringLength = const Value.absent(),
    this.color = const Value.absent(),
    this.isActive = const Value.absent(),
    this.purchaseDate = const Value.absent(),
    this.retiredAt = const Value.absent(),
    this.notes = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  BowStringsCompanion.insert({
    required String id,
    required String bowId,
    this.name = const Value.absent(),
    this.material = const Value.absent(),
    this.strandCount = const Value.absent(),
    this.servingMaterial = const Value.absent(),
    this.stringLength = const Value.absent(),
    this.color = const Value.absent(),
    this.isActive = const Value.absent(),
    this.purchaseDate = const Value.absent(),
    this.retiredAt = const Value.absent(),
    this.notes = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       bowId = Value(bowId);
  static Insertable<BowString> custom({
    Expression<String>? id,
    Expression<String>? bowId,
    Expression<String>? name,
    Expression<String>? material,
    Expression<int>? strandCount,
    Expression<String>? servingMaterial,
    Expression<double>? stringLength,
    Expression<String>? color,
    Expression<bool>? isActive,
    Expression<DateTime>? purchaseDate,
    Expression<DateTime>? retiredAt,
    Expression<String>? notes,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (bowId != null) 'bow_id': bowId,
      if (name != null) 'name': name,
      if (material != null) 'material': material,
      if (strandCount != null) 'strand_count': strandCount,
      if (servingMaterial != null) 'serving_material': servingMaterial,
      if (stringLength != null) 'string_length': stringLength,
      if (color != null) 'color': color,
      if (isActive != null) 'is_active': isActive,
      if (purchaseDate != null) 'purchase_date': purchaseDate,
      if (retiredAt != null) 'retired_at': retiredAt,
      if (notes != null) 'notes': notes,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  BowStringsCompanion copyWith({
    Value<String>? id,
    Value<String>? bowId,
    Value<String?>? name,
    Value<String?>? material,
    Value<int?>? strandCount,
    Value<String?>? servingMaterial,
    Value<double?>? stringLength,
    Value<String?>? color,
    Value<bool>? isActive,
    Value<DateTime?>? purchaseDate,
    Value<DateTime?>? retiredAt,
    Value<String?>? notes,
    Value<DateTime>? createdAt,
    Value<DateTime>? updatedAt,
    Value<int>? rowid,
  }) {
    return BowStringsCompanion(
      id: id ?? this.id,
      bowId: bowId ?? this.bowId,
      name: name ?? this.name,
      material: material ?? this.material,
      strandCount: strandCount ?? this.strandCount,
      servingMaterial: servingMaterial ?? this.servingMaterial,
      stringLength: stringLength ?? this.stringLength,
      color: color ?? this.color,
      isActive: isActive ?? this.isActive,
      purchaseDate: purchaseDate ?? this.purchaseDate,
      retiredAt: retiredAt ?? this.retiredAt,
      notes: notes ?? this.notes,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (bowId.present) {
      map['bow_id'] = Variable<String>(bowId.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (material.present) {
      map['material'] = Variable<String>(material.value);
    }
    if (strandCount.present) {
      map['strand_count'] = Variable<int>(strandCount.value);
    }
    if (servingMaterial.present) {
      map['serving_material'] = Variable<String>(servingMaterial.value);
    }
    if (stringLength.present) {
      map['string_length'] = Variable<double>(stringLength.value);
    }
    if (color.present) {
      map['color'] = Variable<String>(color.value);
    }
    if (isActive.present) {
      map['is_active'] = Variable<bool>(isActive.value);
    }
    if (purchaseDate.present) {
      map['purchase_date'] = Variable<DateTime>(purchaseDate.value);
    }
    if (retiredAt.present) {
      map['retired_at'] = Variable<DateTime>(retiredAt.value);
    }
    if (notes.present) {
      map['notes'] = Variable<String>(notes.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('BowStringsCompanion(')
          ..write('id: $id, ')
          ..write('bowId: $bowId, ')
          ..write('name: $name, ')
          ..write('material: $material, ')
          ..write('strandCount: $strandCount, ')
          ..write('servingMaterial: $servingMaterial, ')
          ..write('stringLength: $stringLength, ')
          ..write('color: $color, ')
          ..write('isActive: $isActive, ')
          ..write('purchaseDate: $purchaseDate, ')
          ..write('retiredAt: $retiredAt, ')
          ..write('notes: $notes, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $VolumeEntriesTable extends VolumeEntries
    with TableInfo<$VolumeEntriesTable, VolumeEntry> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $VolumeEntriesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _dateMeta = const VerificationMeta('date');
  @override
  late final GeneratedColumn<DateTime> date = GeneratedColumn<DateTime>(
    'date',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _arrowCountMeta = const VerificationMeta(
    'arrowCount',
  );
  @override
  late final GeneratedColumn<int> arrowCount = GeneratedColumn<int>(
    'arrow_count',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _titleMeta = const VerificationMeta('title');
  @override
  late final GeneratedColumn<String> title = GeneratedColumn<String>(
    'title',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _notesMeta = const VerificationMeta('notes');
  @override
  late final GeneratedColumn<String> notes = GeneratedColumn<String>(
    'notes',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _deletedAtMeta = const VerificationMeta(
    'deletedAt',
  );
  @override
  late final GeneratedColumn<DateTime> deletedAt = GeneratedColumn<DateTime>(
    'deleted_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    date,
    arrowCount,
    title,
    notes,
    createdAt,
    updatedAt,
    deletedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'volume_entries';
  @override
  VerificationContext validateIntegrity(
    Insertable<VolumeEntry> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('date')) {
      context.handle(
        _dateMeta,
        date.isAcceptableOrUnknown(data['date']!, _dateMeta),
      );
    } else if (isInserting) {
      context.missing(_dateMeta);
    }
    if (data.containsKey('arrow_count')) {
      context.handle(
        _arrowCountMeta,
        arrowCount.isAcceptableOrUnknown(data['arrow_count']!, _arrowCountMeta),
      );
    } else if (isInserting) {
      context.missing(_arrowCountMeta);
    }
    if (data.containsKey('title')) {
      context.handle(
        _titleMeta,
        title.isAcceptableOrUnknown(data['title']!, _titleMeta),
      );
    }
    if (data.containsKey('notes')) {
      context.handle(
        _notesMeta,
        notes.isAcceptableOrUnknown(data['notes']!, _notesMeta),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    }
    if (data.containsKey('deleted_at')) {
      context.handle(
        _deletedAtMeta,
        deletedAt.isAcceptableOrUnknown(data['deleted_at']!, _deletedAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  VolumeEntry map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return VolumeEntry(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      date: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}date'],
      )!,
      arrowCount: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}arrow_count'],
      )!,
      title: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}title'],
      ),
      notes: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}notes'],
      ),
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      )!,
      deletedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}deleted_at'],
      ),
    );
  }

  @override
  $VolumeEntriesTable createAlias(String alias) {
    return $VolumeEntriesTable(attachedDatabase, alias);
  }
}

class VolumeEntry extends DataClass implements Insertable<VolumeEntry> {
  final String id;
  final DateTime date;
  final int arrowCount;
  final String? title;
  final String? notes;
  final DateTime createdAt;
  final DateTime updatedAt;
  final DateTime? deletedAt;
  const VolumeEntry({
    required this.id,
    required this.date,
    required this.arrowCount,
    this.title,
    this.notes,
    required this.createdAt,
    required this.updatedAt,
    this.deletedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['date'] = Variable<DateTime>(date);
    map['arrow_count'] = Variable<int>(arrowCount);
    if (!nullToAbsent || title != null) {
      map['title'] = Variable<String>(title);
    }
    if (!nullToAbsent || notes != null) {
      map['notes'] = Variable<String>(notes);
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    if (!nullToAbsent || deletedAt != null) {
      map['deleted_at'] = Variable<DateTime>(deletedAt);
    }
    return map;
  }

  VolumeEntriesCompanion toCompanion(bool nullToAbsent) {
    return VolumeEntriesCompanion(
      id: Value(id),
      date: Value(date),
      arrowCount: Value(arrowCount),
      title: title == null && nullToAbsent
          ? const Value.absent()
          : Value(title),
      notes: notes == null && nullToAbsent
          ? const Value.absent()
          : Value(notes),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
      deletedAt: deletedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(deletedAt),
    );
  }

  factory VolumeEntry.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return VolumeEntry(
      id: serializer.fromJson<String>(json['id']),
      date: serializer.fromJson<DateTime>(json['date']),
      arrowCount: serializer.fromJson<int>(json['arrowCount']),
      title: serializer.fromJson<String?>(json['title']),
      notes: serializer.fromJson<String?>(json['notes']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
      deletedAt: serializer.fromJson<DateTime?>(json['deletedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'date': serializer.toJson<DateTime>(date),
      'arrowCount': serializer.toJson<int>(arrowCount),
      'title': serializer.toJson<String?>(title),
      'notes': serializer.toJson<String?>(notes),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
      'deletedAt': serializer.toJson<DateTime?>(deletedAt),
    };
  }

  VolumeEntry copyWith({
    String? id,
    DateTime? date,
    int? arrowCount,
    Value<String?> title = const Value.absent(),
    Value<String?> notes = const Value.absent(),
    DateTime? createdAt,
    DateTime? updatedAt,
    Value<DateTime?> deletedAt = const Value.absent(),
  }) => VolumeEntry(
    id: id ?? this.id,
    date: date ?? this.date,
    arrowCount: arrowCount ?? this.arrowCount,
    title: title.present ? title.value : this.title,
    notes: notes.present ? notes.value : this.notes,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
    deletedAt: deletedAt.present ? deletedAt.value : this.deletedAt,
  );
  VolumeEntry copyWithCompanion(VolumeEntriesCompanion data) {
    return VolumeEntry(
      id: data.id.present ? data.id.value : this.id,
      date: data.date.present ? data.date.value : this.date,
      arrowCount: data.arrowCount.present
          ? data.arrowCount.value
          : this.arrowCount,
      title: data.title.present ? data.title.value : this.title,
      notes: data.notes.present ? data.notes.value : this.notes,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
      deletedAt: data.deletedAt.present ? data.deletedAt.value : this.deletedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('VolumeEntry(')
          ..write('id: $id, ')
          ..write('date: $date, ')
          ..write('arrowCount: $arrowCount, ')
          ..write('title: $title, ')
          ..write('notes: $notes, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('deletedAt: $deletedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    date,
    arrowCount,
    title,
    notes,
    createdAt,
    updatedAt,
    deletedAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is VolumeEntry &&
          other.id == this.id &&
          other.date == this.date &&
          other.arrowCount == this.arrowCount &&
          other.title == this.title &&
          other.notes == this.notes &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt &&
          other.deletedAt == this.deletedAt);
}

class VolumeEntriesCompanion extends UpdateCompanion<VolumeEntry> {
  final Value<String> id;
  final Value<DateTime> date;
  final Value<int> arrowCount;
  final Value<String?> title;
  final Value<String?> notes;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  final Value<DateTime?> deletedAt;
  final Value<int> rowid;
  const VolumeEntriesCompanion({
    this.id = const Value.absent(),
    this.date = const Value.absent(),
    this.arrowCount = const Value.absent(),
    this.title = const Value.absent(),
    this.notes = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.deletedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  VolumeEntriesCompanion.insert({
    required String id,
    required DateTime date,
    required int arrowCount,
    this.title = const Value.absent(),
    this.notes = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.deletedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       date = Value(date),
       arrowCount = Value(arrowCount);
  static Insertable<VolumeEntry> custom({
    Expression<String>? id,
    Expression<DateTime>? date,
    Expression<int>? arrowCount,
    Expression<String>? title,
    Expression<String>? notes,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
    Expression<DateTime>? deletedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (date != null) 'date': date,
      if (arrowCount != null) 'arrow_count': arrowCount,
      if (title != null) 'title': title,
      if (notes != null) 'notes': notes,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (deletedAt != null) 'deleted_at': deletedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  VolumeEntriesCompanion copyWith({
    Value<String>? id,
    Value<DateTime>? date,
    Value<int>? arrowCount,
    Value<String?>? title,
    Value<String?>? notes,
    Value<DateTime>? createdAt,
    Value<DateTime>? updatedAt,
    Value<DateTime?>? deletedAt,
    Value<int>? rowid,
  }) {
    return VolumeEntriesCompanion(
      id: id ?? this.id,
      date: date ?? this.date,
      arrowCount: arrowCount ?? this.arrowCount,
      title: title ?? this.title,
      notes: notes ?? this.notes,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      deletedAt: deletedAt ?? this.deletedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (date.present) {
      map['date'] = Variable<DateTime>(date.value);
    }
    if (arrowCount.present) {
      map['arrow_count'] = Variable<int>(arrowCount.value);
    }
    if (title.present) {
      map['title'] = Variable<String>(title.value);
    }
    if (notes.present) {
      map['notes'] = Variable<String>(notes.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (deletedAt.present) {
      map['deleted_at'] = Variable<DateTime>(deletedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('VolumeEntriesCompanion(')
          ..write('id: $id, ')
          ..write('date: $date, ')
          ..write('arrowCount: $arrowCount, ')
          ..write('title: $title, ')
          ..write('notes: $notes, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('deletedAt: $deletedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $OlyExerciseTypesTable extends OlyExerciseTypes
    with TableInfo<$OlyExerciseTypesTable, OlyExerciseType> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $OlyExerciseTypesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _descriptionMeta = const VerificationMeta(
    'description',
  );
  @override
  late final GeneratedColumn<String> description = GeneratedColumn<String>(
    'description',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _intensityMeta = const VerificationMeta(
    'intensity',
  );
  @override
  late final GeneratedColumn<double> intensity = GeneratedColumn<double>(
    'intensity',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
    defaultValue: const Constant(1.0),
  );
  static const VerificationMeta _categoryMeta = const VerificationMeta(
    'category',
  );
  @override
  late final GeneratedColumn<String> category = GeneratedColumn<String>(
    'category',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('static'),
  );
  static const VerificationMeta _firstIntroducedAtMeta = const VerificationMeta(
    'firstIntroducedAt',
  );
  @override
  late final GeneratedColumn<String> firstIntroducedAt =
      GeneratedColumn<String>(
        'first_introduced_at',
        aliasedName,
        true,
        type: DriftSqlType.string,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _sortOrderMeta = const VerificationMeta(
    'sortOrder',
  );
  @override
  late final GeneratedColumn<int> sortOrder = GeneratedColumn<int>(
    'sort_order',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    name,
    description,
    intensity,
    category,
    firstIntroducedAt,
    sortOrder,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'oly_exercise_types';
  @override
  VerificationContext validateIntegrity(
    Insertable<OlyExerciseType> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('description')) {
      context.handle(
        _descriptionMeta,
        description.isAcceptableOrUnknown(
          data['description']!,
          _descriptionMeta,
        ),
      );
    }
    if (data.containsKey('intensity')) {
      context.handle(
        _intensityMeta,
        intensity.isAcceptableOrUnknown(data['intensity']!, _intensityMeta),
      );
    }
    if (data.containsKey('category')) {
      context.handle(
        _categoryMeta,
        category.isAcceptableOrUnknown(data['category']!, _categoryMeta),
      );
    }
    if (data.containsKey('first_introduced_at')) {
      context.handle(
        _firstIntroducedAtMeta,
        firstIntroducedAt.isAcceptableOrUnknown(
          data['first_introduced_at']!,
          _firstIntroducedAtMeta,
        ),
      );
    }
    if (data.containsKey('sort_order')) {
      context.handle(
        _sortOrderMeta,
        sortOrder.isAcceptableOrUnknown(data['sort_order']!, _sortOrderMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  OlyExerciseType map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return OlyExerciseType(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      description: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}description'],
      ),
      intensity: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}intensity'],
      )!,
      category: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}category'],
      )!,
      firstIntroducedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}first_introduced_at'],
      ),
      sortOrder: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sort_order'],
      )!,
    );
  }

  @override
  $OlyExerciseTypesTable createAlias(String alias) {
    return $OlyExerciseTypesTable(attachedDatabase, alias);
  }
}

class OlyExerciseType extends DataClass implements Insertable<OlyExerciseType> {
  final String id;
  final String name;
  final String? description;
  final double intensity;
  final String category;
  final String? firstIntroducedAt;
  final int sortOrder;
  const OlyExerciseType({
    required this.id,
    required this.name,
    this.description,
    required this.intensity,
    required this.category,
    this.firstIntroducedAt,
    required this.sortOrder,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['name'] = Variable<String>(name);
    if (!nullToAbsent || description != null) {
      map['description'] = Variable<String>(description);
    }
    map['intensity'] = Variable<double>(intensity);
    map['category'] = Variable<String>(category);
    if (!nullToAbsent || firstIntroducedAt != null) {
      map['first_introduced_at'] = Variable<String>(firstIntroducedAt);
    }
    map['sort_order'] = Variable<int>(sortOrder);
    return map;
  }

  OlyExerciseTypesCompanion toCompanion(bool nullToAbsent) {
    return OlyExerciseTypesCompanion(
      id: Value(id),
      name: Value(name),
      description: description == null && nullToAbsent
          ? const Value.absent()
          : Value(description),
      intensity: Value(intensity),
      category: Value(category),
      firstIntroducedAt: firstIntroducedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(firstIntroducedAt),
      sortOrder: Value(sortOrder),
    );
  }

  factory OlyExerciseType.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return OlyExerciseType(
      id: serializer.fromJson<String>(json['id']),
      name: serializer.fromJson<String>(json['name']),
      description: serializer.fromJson<String?>(json['description']),
      intensity: serializer.fromJson<double>(json['intensity']),
      category: serializer.fromJson<String>(json['category']),
      firstIntroducedAt: serializer.fromJson<String?>(
        json['firstIntroducedAt'],
      ),
      sortOrder: serializer.fromJson<int>(json['sortOrder']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'name': serializer.toJson<String>(name),
      'description': serializer.toJson<String?>(description),
      'intensity': serializer.toJson<double>(intensity),
      'category': serializer.toJson<String>(category),
      'firstIntroducedAt': serializer.toJson<String?>(firstIntroducedAt),
      'sortOrder': serializer.toJson<int>(sortOrder),
    };
  }

  OlyExerciseType copyWith({
    String? id,
    String? name,
    Value<String?> description = const Value.absent(),
    double? intensity,
    String? category,
    Value<String?> firstIntroducedAt = const Value.absent(),
    int? sortOrder,
  }) => OlyExerciseType(
    id: id ?? this.id,
    name: name ?? this.name,
    description: description.present ? description.value : this.description,
    intensity: intensity ?? this.intensity,
    category: category ?? this.category,
    firstIntroducedAt: firstIntroducedAt.present
        ? firstIntroducedAt.value
        : this.firstIntroducedAt,
    sortOrder: sortOrder ?? this.sortOrder,
  );
  OlyExerciseType copyWithCompanion(OlyExerciseTypesCompanion data) {
    return OlyExerciseType(
      id: data.id.present ? data.id.value : this.id,
      name: data.name.present ? data.name.value : this.name,
      description: data.description.present
          ? data.description.value
          : this.description,
      intensity: data.intensity.present ? data.intensity.value : this.intensity,
      category: data.category.present ? data.category.value : this.category,
      firstIntroducedAt: data.firstIntroducedAt.present
          ? data.firstIntroducedAt.value
          : this.firstIntroducedAt,
      sortOrder: data.sortOrder.present ? data.sortOrder.value : this.sortOrder,
    );
  }

  @override
  String toString() {
    return (StringBuffer('OlyExerciseType(')
          ..write('id: $id, ')
          ..write('name: $name, ')
          ..write('description: $description, ')
          ..write('intensity: $intensity, ')
          ..write('category: $category, ')
          ..write('firstIntroducedAt: $firstIntroducedAt, ')
          ..write('sortOrder: $sortOrder')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    name,
    description,
    intensity,
    category,
    firstIntroducedAt,
    sortOrder,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is OlyExerciseType &&
          other.id == this.id &&
          other.name == this.name &&
          other.description == this.description &&
          other.intensity == this.intensity &&
          other.category == this.category &&
          other.firstIntroducedAt == this.firstIntroducedAt &&
          other.sortOrder == this.sortOrder);
}

class OlyExerciseTypesCompanion extends UpdateCompanion<OlyExerciseType> {
  final Value<String> id;
  final Value<String> name;
  final Value<String?> description;
  final Value<double> intensity;
  final Value<String> category;
  final Value<String?> firstIntroducedAt;
  final Value<int> sortOrder;
  final Value<int> rowid;
  const OlyExerciseTypesCompanion({
    this.id = const Value.absent(),
    this.name = const Value.absent(),
    this.description = const Value.absent(),
    this.intensity = const Value.absent(),
    this.category = const Value.absent(),
    this.firstIntroducedAt = const Value.absent(),
    this.sortOrder = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  OlyExerciseTypesCompanion.insert({
    required String id,
    required String name,
    this.description = const Value.absent(),
    this.intensity = const Value.absent(),
    this.category = const Value.absent(),
    this.firstIntroducedAt = const Value.absent(),
    this.sortOrder = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       name = Value(name);
  static Insertable<OlyExerciseType> custom({
    Expression<String>? id,
    Expression<String>? name,
    Expression<String>? description,
    Expression<double>? intensity,
    Expression<String>? category,
    Expression<String>? firstIntroducedAt,
    Expression<int>? sortOrder,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (name != null) 'name': name,
      if (description != null) 'description': description,
      if (intensity != null) 'intensity': intensity,
      if (category != null) 'category': category,
      if (firstIntroducedAt != null) 'first_introduced_at': firstIntroducedAt,
      if (sortOrder != null) 'sort_order': sortOrder,
      if (rowid != null) 'rowid': rowid,
    });
  }

  OlyExerciseTypesCompanion copyWith({
    Value<String>? id,
    Value<String>? name,
    Value<String?>? description,
    Value<double>? intensity,
    Value<String>? category,
    Value<String?>? firstIntroducedAt,
    Value<int>? sortOrder,
    Value<int>? rowid,
  }) {
    return OlyExerciseTypesCompanion(
      id: id ?? this.id,
      name: name ?? this.name,
      description: description ?? this.description,
      intensity: intensity ?? this.intensity,
      category: category ?? this.category,
      firstIntroducedAt: firstIntroducedAt ?? this.firstIntroducedAt,
      sortOrder: sortOrder ?? this.sortOrder,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (description.present) {
      map['description'] = Variable<String>(description.value);
    }
    if (intensity.present) {
      map['intensity'] = Variable<double>(intensity.value);
    }
    if (category.present) {
      map['category'] = Variable<String>(category.value);
    }
    if (firstIntroducedAt.present) {
      map['first_introduced_at'] = Variable<String>(firstIntroducedAt.value);
    }
    if (sortOrder.present) {
      map['sort_order'] = Variable<int>(sortOrder.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('OlyExerciseTypesCompanion(')
          ..write('id: $id, ')
          ..write('name: $name, ')
          ..write('description: $description, ')
          ..write('intensity: $intensity, ')
          ..write('category: $category, ')
          ..write('firstIntroducedAt: $firstIntroducedAt, ')
          ..write('sortOrder: $sortOrder, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $OlySessionTemplatesTable extends OlySessionTemplates
    with TableInfo<$OlySessionTemplatesTable, OlySessionTemplate> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $OlySessionTemplatesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _versionMeta = const VerificationMeta(
    'version',
  );
  @override
  late final GeneratedColumn<String> version = GeneratedColumn<String>(
    'version',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _focusMeta = const VerificationMeta('focus');
  @override
  late final GeneratedColumn<String> focus = GeneratedColumn<String>(
    'focus',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _durationMinutesMeta = const VerificationMeta(
    'durationMinutes',
  );
  @override
  late final GeneratedColumn<int> durationMinutes = GeneratedColumn<int>(
    'duration_minutes',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _volumeLoadMeta = const VerificationMeta(
    'volumeLoad',
  );
  @override
  late final GeneratedColumn<int> volumeLoad = GeneratedColumn<int>(
    'volume_load',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _adjustedVolumeLoadMeta =
      const VerificationMeta('adjustedVolumeLoad');
  @override
  late final GeneratedColumn<int> adjustedVolumeLoad = GeneratedColumn<int>(
    'adjusted_volume_load',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _workRatioMeta = const VerificationMeta(
    'workRatio',
  );
  @override
  late final GeneratedColumn<double> workRatio = GeneratedColumn<double>(
    'work_ratio',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _adjustedWorkRatioMeta = const VerificationMeta(
    'adjustedWorkRatio',
  );
  @override
  late final GeneratedColumn<double> adjustedWorkRatio =
      GeneratedColumn<double>(
        'adjusted_work_ratio',
        aliasedName,
        false,
        type: DriftSqlType.double,
        requiredDuringInsert: true,
      );
  static const VerificationMeta _requirementsMeta = const VerificationMeta(
    'requirements',
  );
  @override
  late final GeneratedColumn<String> requirements = GeneratedColumn<String>(
    'requirements',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _equipmentMeta = const VerificationMeta(
    'equipment',
  );
  @override
  late final GeneratedColumn<String> equipment = GeneratedColumn<String>(
    'equipment',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('Bow, elbow sling, stabilisers'),
  );
  static const VerificationMeta _notesMeta = const VerificationMeta('notes');
  @override
  late final GeneratedColumn<String> notes = GeneratedColumn<String>(
    'notes',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _sortOrderMeta = const VerificationMeta(
    'sortOrder',
  );
  @override
  late final GeneratedColumn<int> sortOrder = GeneratedColumn<int>(
    'sort_order',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    version,
    name,
    focus,
    durationMinutes,
    volumeLoad,
    adjustedVolumeLoad,
    workRatio,
    adjustedWorkRatio,
    requirements,
    equipment,
    notes,
    sortOrder,
    createdAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'oly_session_templates';
  @override
  VerificationContext validateIntegrity(
    Insertable<OlySessionTemplate> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('version')) {
      context.handle(
        _versionMeta,
        version.isAcceptableOrUnknown(data['version']!, _versionMeta),
      );
    } else if (isInserting) {
      context.missing(_versionMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('focus')) {
      context.handle(
        _focusMeta,
        focus.isAcceptableOrUnknown(data['focus']!, _focusMeta),
      );
    }
    if (data.containsKey('duration_minutes')) {
      context.handle(
        _durationMinutesMeta,
        durationMinutes.isAcceptableOrUnknown(
          data['duration_minutes']!,
          _durationMinutesMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_durationMinutesMeta);
    }
    if (data.containsKey('volume_load')) {
      context.handle(
        _volumeLoadMeta,
        volumeLoad.isAcceptableOrUnknown(data['volume_load']!, _volumeLoadMeta),
      );
    } else if (isInserting) {
      context.missing(_volumeLoadMeta);
    }
    if (data.containsKey('adjusted_volume_load')) {
      context.handle(
        _adjustedVolumeLoadMeta,
        adjustedVolumeLoad.isAcceptableOrUnknown(
          data['adjusted_volume_load']!,
          _adjustedVolumeLoadMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_adjustedVolumeLoadMeta);
    }
    if (data.containsKey('work_ratio')) {
      context.handle(
        _workRatioMeta,
        workRatio.isAcceptableOrUnknown(data['work_ratio']!, _workRatioMeta),
      );
    } else if (isInserting) {
      context.missing(_workRatioMeta);
    }
    if (data.containsKey('adjusted_work_ratio')) {
      context.handle(
        _adjustedWorkRatioMeta,
        adjustedWorkRatio.isAcceptableOrUnknown(
          data['adjusted_work_ratio']!,
          _adjustedWorkRatioMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_adjustedWorkRatioMeta);
    }
    if (data.containsKey('requirements')) {
      context.handle(
        _requirementsMeta,
        requirements.isAcceptableOrUnknown(
          data['requirements']!,
          _requirementsMeta,
        ),
      );
    }
    if (data.containsKey('equipment')) {
      context.handle(
        _equipmentMeta,
        equipment.isAcceptableOrUnknown(data['equipment']!, _equipmentMeta),
      );
    }
    if (data.containsKey('notes')) {
      context.handle(
        _notesMeta,
        notes.isAcceptableOrUnknown(data['notes']!, _notesMeta),
      );
    }
    if (data.containsKey('sort_order')) {
      context.handle(
        _sortOrderMeta,
        sortOrder.isAcceptableOrUnknown(data['sort_order']!, _sortOrderMeta),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  OlySessionTemplate map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return OlySessionTemplate(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      version: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}version'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      focus: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}focus'],
      ),
      durationMinutes: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}duration_minutes'],
      )!,
      volumeLoad: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}volume_load'],
      )!,
      adjustedVolumeLoad: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}adjusted_volume_load'],
      )!,
      workRatio: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}work_ratio'],
      )!,
      adjustedWorkRatio: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}adjusted_work_ratio'],
      )!,
      requirements: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}requirements'],
      ),
      equipment: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}equipment'],
      )!,
      notes: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}notes'],
      ),
      sortOrder: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sort_order'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
    );
  }

  @override
  $OlySessionTemplatesTable createAlias(String alias) {
    return $OlySessionTemplatesTable(attachedDatabase, alias);
  }
}

class OlySessionTemplate extends DataClass
    implements Insertable<OlySessionTemplate> {
  final String id;
  final String version;
  final String name;
  final String? focus;
  final int durationMinutes;
  final int volumeLoad;
  final int adjustedVolumeLoad;
  final double workRatio;
  final double adjustedWorkRatio;
  final String? requirements;
  final String equipment;
  final String? notes;
  final int sortOrder;
  final DateTime createdAt;
  const OlySessionTemplate({
    required this.id,
    required this.version,
    required this.name,
    this.focus,
    required this.durationMinutes,
    required this.volumeLoad,
    required this.adjustedVolumeLoad,
    required this.workRatio,
    required this.adjustedWorkRatio,
    this.requirements,
    required this.equipment,
    this.notes,
    required this.sortOrder,
    required this.createdAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['version'] = Variable<String>(version);
    map['name'] = Variable<String>(name);
    if (!nullToAbsent || focus != null) {
      map['focus'] = Variable<String>(focus);
    }
    map['duration_minutes'] = Variable<int>(durationMinutes);
    map['volume_load'] = Variable<int>(volumeLoad);
    map['adjusted_volume_load'] = Variable<int>(adjustedVolumeLoad);
    map['work_ratio'] = Variable<double>(workRatio);
    map['adjusted_work_ratio'] = Variable<double>(adjustedWorkRatio);
    if (!nullToAbsent || requirements != null) {
      map['requirements'] = Variable<String>(requirements);
    }
    map['equipment'] = Variable<String>(equipment);
    if (!nullToAbsent || notes != null) {
      map['notes'] = Variable<String>(notes);
    }
    map['sort_order'] = Variable<int>(sortOrder);
    map['created_at'] = Variable<DateTime>(createdAt);
    return map;
  }

  OlySessionTemplatesCompanion toCompanion(bool nullToAbsent) {
    return OlySessionTemplatesCompanion(
      id: Value(id),
      version: Value(version),
      name: Value(name),
      focus: focus == null && nullToAbsent
          ? const Value.absent()
          : Value(focus),
      durationMinutes: Value(durationMinutes),
      volumeLoad: Value(volumeLoad),
      adjustedVolumeLoad: Value(adjustedVolumeLoad),
      workRatio: Value(workRatio),
      adjustedWorkRatio: Value(adjustedWorkRatio),
      requirements: requirements == null && nullToAbsent
          ? const Value.absent()
          : Value(requirements),
      equipment: Value(equipment),
      notes: notes == null && nullToAbsent
          ? const Value.absent()
          : Value(notes),
      sortOrder: Value(sortOrder),
      createdAt: Value(createdAt),
    );
  }

  factory OlySessionTemplate.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return OlySessionTemplate(
      id: serializer.fromJson<String>(json['id']),
      version: serializer.fromJson<String>(json['version']),
      name: serializer.fromJson<String>(json['name']),
      focus: serializer.fromJson<String?>(json['focus']),
      durationMinutes: serializer.fromJson<int>(json['durationMinutes']),
      volumeLoad: serializer.fromJson<int>(json['volumeLoad']),
      adjustedVolumeLoad: serializer.fromJson<int>(json['adjustedVolumeLoad']),
      workRatio: serializer.fromJson<double>(json['workRatio']),
      adjustedWorkRatio: serializer.fromJson<double>(json['adjustedWorkRatio']),
      requirements: serializer.fromJson<String?>(json['requirements']),
      equipment: serializer.fromJson<String>(json['equipment']),
      notes: serializer.fromJson<String?>(json['notes']),
      sortOrder: serializer.fromJson<int>(json['sortOrder']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'version': serializer.toJson<String>(version),
      'name': serializer.toJson<String>(name),
      'focus': serializer.toJson<String?>(focus),
      'durationMinutes': serializer.toJson<int>(durationMinutes),
      'volumeLoad': serializer.toJson<int>(volumeLoad),
      'adjustedVolumeLoad': serializer.toJson<int>(adjustedVolumeLoad),
      'workRatio': serializer.toJson<double>(workRatio),
      'adjustedWorkRatio': serializer.toJson<double>(adjustedWorkRatio),
      'requirements': serializer.toJson<String?>(requirements),
      'equipment': serializer.toJson<String>(equipment),
      'notes': serializer.toJson<String?>(notes),
      'sortOrder': serializer.toJson<int>(sortOrder),
      'createdAt': serializer.toJson<DateTime>(createdAt),
    };
  }

  OlySessionTemplate copyWith({
    String? id,
    String? version,
    String? name,
    Value<String?> focus = const Value.absent(),
    int? durationMinutes,
    int? volumeLoad,
    int? adjustedVolumeLoad,
    double? workRatio,
    double? adjustedWorkRatio,
    Value<String?> requirements = const Value.absent(),
    String? equipment,
    Value<String?> notes = const Value.absent(),
    int? sortOrder,
    DateTime? createdAt,
  }) => OlySessionTemplate(
    id: id ?? this.id,
    version: version ?? this.version,
    name: name ?? this.name,
    focus: focus.present ? focus.value : this.focus,
    durationMinutes: durationMinutes ?? this.durationMinutes,
    volumeLoad: volumeLoad ?? this.volumeLoad,
    adjustedVolumeLoad: adjustedVolumeLoad ?? this.adjustedVolumeLoad,
    workRatio: workRatio ?? this.workRatio,
    adjustedWorkRatio: adjustedWorkRatio ?? this.adjustedWorkRatio,
    requirements: requirements.present ? requirements.value : this.requirements,
    equipment: equipment ?? this.equipment,
    notes: notes.present ? notes.value : this.notes,
    sortOrder: sortOrder ?? this.sortOrder,
    createdAt: createdAt ?? this.createdAt,
  );
  OlySessionTemplate copyWithCompanion(OlySessionTemplatesCompanion data) {
    return OlySessionTemplate(
      id: data.id.present ? data.id.value : this.id,
      version: data.version.present ? data.version.value : this.version,
      name: data.name.present ? data.name.value : this.name,
      focus: data.focus.present ? data.focus.value : this.focus,
      durationMinutes: data.durationMinutes.present
          ? data.durationMinutes.value
          : this.durationMinutes,
      volumeLoad: data.volumeLoad.present
          ? data.volumeLoad.value
          : this.volumeLoad,
      adjustedVolumeLoad: data.adjustedVolumeLoad.present
          ? data.adjustedVolumeLoad.value
          : this.adjustedVolumeLoad,
      workRatio: data.workRatio.present ? data.workRatio.value : this.workRatio,
      adjustedWorkRatio: data.adjustedWorkRatio.present
          ? data.adjustedWorkRatio.value
          : this.adjustedWorkRatio,
      requirements: data.requirements.present
          ? data.requirements.value
          : this.requirements,
      equipment: data.equipment.present ? data.equipment.value : this.equipment,
      notes: data.notes.present ? data.notes.value : this.notes,
      sortOrder: data.sortOrder.present ? data.sortOrder.value : this.sortOrder,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('OlySessionTemplate(')
          ..write('id: $id, ')
          ..write('version: $version, ')
          ..write('name: $name, ')
          ..write('focus: $focus, ')
          ..write('durationMinutes: $durationMinutes, ')
          ..write('volumeLoad: $volumeLoad, ')
          ..write('adjustedVolumeLoad: $adjustedVolumeLoad, ')
          ..write('workRatio: $workRatio, ')
          ..write('adjustedWorkRatio: $adjustedWorkRatio, ')
          ..write('requirements: $requirements, ')
          ..write('equipment: $equipment, ')
          ..write('notes: $notes, ')
          ..write('sortOrder: $sortOrder, ')
          ..write('createdAt: $createdAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    version,
    name,
    focus,
    durationMinutes,
    volumeLoad,
    adjustedVolumeLoad,
    workRatio,
    adjustedWorkRatio,
    requirements,
    equipment,
    notes,
    sortOrder,
    createdAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is OlySessionTemplate &&
          other.id == this.id &&
          other.version == this.version &&
          other.name == this.name &&
          other.focus == this.focus &&
          other.durationMinutes == this.durationMinutes &&
          other.volumeLoad == this.volumeLoad &&
          other.adjustedVolumeLoad == this.adjustedVolumeLoad &&
          other.workRatio == this.workRatio &&
          other.adjustedWorkRatio == this.adjustedWorkRatio &&
          other.requirements == this.requirements &&
          other.equipment == this.equipment &&
          other.notes == this.notes &&
          other.sortOrder == this.sortOrder &&
          other.createdAt == this.createdAt);
}

class OlySessionTemplatesCompanion extends UpdateCompanion<OlySessionTemplate> {
  final Value<String> id;
  final Value<String> version;
  final Value<String> name;
  final Value<String?> focus;
  final Value<int> durationMinutes;
  final Value<int> volumeLoad;
  final Value<int> adjustedVolumeLoad;
  final Value<double> workRatio;
  final Value<double> adjustedWorkRatio;
  final Value<String?> requirements;
  final Value<String> equipment;
  final Value<String?> notes;
  final Value<int> sortOrder;
  final Value<DateTime> createdAt;
  final Value<int> rowid;
  const OlySessionTemplatesCompanion({
    this.id = const Value.absent(),
    this.version = const Value.absent(),
    this.name = const Value.absent(),
    this.focus = const Value.absent(),
    this.durationMinutes = const Value.absent(),
    this.volumeLoad = const Value.absent(),
    this.adjustedVolumeLoad = const Value.absent(),
    this.workRatio = const Value.absent(),
    this.adjustedWorkRatio = const Value.absent(),
    this.requirements = const Value.absent(),
    this.equipment = const Value.absent(),
    this.notes = const Value.absent(),
    this.sortOrder = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  OlySessionTemplatesCompanion.insert({
    required String id,
    required String version,
    required String name,
    this.focus = const Value.absent(),
    required int durationMinutes,
    required int volumeLoad,
    required int adjustedVolumeLoad,
    required double workRatio,
    required double adjustedWorkRatio,
    this.requirements = const Value.absent(),
    this.equipment = const Value.absent(),
    this.notes = const Value.absent(),
    this.sortOrder = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       version = Value(version),
       name = Value(name),
       durationMinutes = Value(durationMinutes),
       volumeLoad = Value(volumeLoad),
       adjustedVolumeLoad = Value(adjustedVolumeLoad),
       workRatio = Value(workRatio),
       adjustedWorkRatio = Value(adjustedWorkRatio);
  static Insertable<OlySessionTemplate> custom({
    Expression<String>? id,
    Expression<String>? version,
    Expression<String>? name,
    Expression<String>? focus,
    Expression<int>? durationMinutes,
    Expression<int>? volumeLoad,
    Expression<int>? adjustedVolumeLoad,
    Expression<double>? workRatio,
    Expression<double>? adjustedWorkRatio,
    Expression<String>? requirements,
    Expression<String>? equipment,
    Expression<String>? notes,
    Expression<int>? sortOrder,
    Expression<DateTime>? createdAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (version != null) 'version': version,
      if (name != null) 'name': name,
      if (focus != null) 'focus': focus,
      if (durationMinutes != null) 'duration_minutes': durationMinutes,
      if (volumeLoad != null) 'volume_load': volumeLoad,
      if (adjustedVolumeLoad != null)
        'adjusted_volume_load': adjustedVolumeLoad,
      if (workRatio != null) 'work_ratio': workRatio,
      if (adjustedWorkRatio != null) 'adjusted_work_ratio': adjustedWorkRatio,
      if (requirements != null) 'requirements': requirements,
      if (equipment != null) 'equipment': equipment,
      if (notes != null) 'notes': notes,
      if (sortOrder != null) 'sort_order': sortOrder,
      if (createdAt != null) 'created_at': createdAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  OlySessionTemplatesCompanion copyWith({
    Value<String>? id,
    Value<String>? version,
    Value<String>? name,
    Value<String?>? focus,
    Value<int>? durationMinutes,
    Value<int>? volumeLoad,
    Value<int>? adjustedVolumeLoad,
    Value<double>? workRatio,
    Value<double>? adjustedWorkRatio,
    Value<String?>? requirements,
    Value<String>? equipment,
    Value<String?>? notes,
    Value<int>? sortOrder,
    Value<DateTime>? createdAt,
    Value<int>? rowid,
  }) {
    return OlySessionTemplatesCompanion(
      id: id ?? this.id,
      version: version ?? this.version,
      name: name ?? this.name,
      focus: focus ?? this.focus,
      durationMinutes: durationMinutes ?? this.durationMinutes,
      volumeLoad: volumeLoad ?? this.volumeLoad,
      adjustedVolumeLoad: adjustedVolumeLoad ?? this.adjustedVolumeLoad,
      workRatio: workRatio ?? this.workRatio,
      adjustedWorkRatio: adjustedWorkRatio ?? this.adjustedWorkRatio,
      requirements: requirements ?? this.requirements,
      equipment: equipment ?? this.equipment,
      notes: notes ?? this.notes,
      sortOrder: sortOrder ?? this.sortOrder,
      createdAt: createdAt ?? this.createdAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (version.present) {
      map['version'] = Variable<String>(version.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (focus.present) {
      map['focus'] = Variable<String>(focus.value);
    }
    if (durationMinutes.present) {
      map['duration_minutes'] = Variable<int>(durationMinutes.value);
    }
    if (volumeLoad.present) {
      map['volume_load'] = Variable<int>(volumeLoad.value);
    }
    if (adjustedVolumeLoad.present) {
      map['adjusted_volume_load'] = Variable<int>(adjustedVolumeLoad.value);
    }
    if (workRatio.present) {
      map['work_ratio'] = Variable<double>(workRatio.value);
    }
    if (adjustedWorkRatio.present) {
      map['adjusted_work_ratio'] = Variable<double>(adjustedWorkRatio.value);
    }
    if (requirements.present) {
      map['requirements'] = Variable<String>(requirements.value);
    }
    if (equipment.present) {
      map['equipment'] = Variable<String>(equipment.value);
    }
    if (notes.present) {
      map['notes'] = Variable<String>(notes.value);
    }
    if (sortOrder.present) {
      map['sort_order'] = Variable<int>(sortOrder.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('OlySessionTemplatesCompanion(')
          ..write('id: $id, ')
          ..write('version: $version, ')
          ..write('name: $name, ')
          ..write('focus: $focus, ')
          ..write('durationMinutes: $durationMinutes, ')
          ..write('volumeLoad: $volumeLoad, ')
          ..write('adjustedVolumeLoad: $adjustedVolumeLoad, ')
          ..write('workRatio: $workRatio, ')
          ..write('adjustedWorkRatio: $adjustedWorkRatio, ')
          ..write('requirements: $requirements, ')
          ..write('equipment: $equipment, ')
          ..write('notes: $notes, ')
          ..write('sortOrder: $sortOrder, ')
          ..write('createdAt: $createdAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $OlySessionExercisesTable extends OlySessionExercises
    with TableInfo<$OlySessionExercisesTable, OlySessionExercise> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $OlySessionExercisesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _sessionTemplateIdMeta = const VerificationMeta(
    'sessionTemplateId',
  );
  @override
  late final GeneratedColumn<String> sessionTemplateId =
      GeneratedColumn<String>(
        'session_template_id',
        aliasedName,
        false,
        type: DriftSqlType.string,
        requiredDuringInsert: true,
        defaultConstraints: GeneratedColumn.constraintIsAlways(
          'REFERENCES oly_session_templates (id)',
        ),
      );
  static const VerificationMeta _exerciseTypeIdMeta = const VerificationMeta(
    'exerciseTypeId',
  );
  @override
  late final GeneratedColumn<String> exerciseTypeId = GeneratedColumn<String>(
    'exercise_type_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES oly_exercise_types (id)',
    ),
  );
  static const VerificationMeta _exerciseOrderMeta = const VerificationMeta(
    'exerciseOrder',
  );
  @override
  late final GeneratedColumn<int> exerciseOrder = GeneratedColumn<int>(
    'exercise_order',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _repsMeta = const VerificationMeta('reps');
  @override
  late final GeneratedColumn<int> reps = GeneratedColumn<int>(
    'reps',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _workSecondsMeta = const VerificationMeta(
    'workSeconds',
  );
  @override
  late final GeneratedColumn<int> workSeconds = GeneratedColumn<int>(
    'work_seconds',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _restSecondsMeta = const VerificationMeta(
    'restSeconds',
  );
  @override
  late final GeneratedColumn<int> restSeconds = GeneratedColumn<int>(
    'rest_seconds',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _detailsMeta = const VerificationMeta(
    'details',
  );
  @override
  late final GeneratedColumn<String> details = GeneratedColumn<String>(
    'details',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _intensityOverrideMeta = const VerificationMeta(
    'intensityOverride',
  );
  @override
  late final GeneratedColumn<double> intensityOverride =
      GeneratedColumn<double>(
        'intensity_override',
        aliasedName,
        true,
        type: DriftSqlType.double,
        requiredDuringInsert: false,
      );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    sessionTemplateId,
    exerciseTypeId,
    exerciseOrder,
    reps,
    workSeconds,
    restSeconds,
    details,
    intensityOverride,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'oly_session_exercises';
  @override
  VerificationContext validateIntegrity(
    Insertable<OlySessionExercise> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('session_template_id')) {
      context.handle(
        _sessionTemplateIdMeta,
        sessionTemplateId.isAcceptableOrUnknown(
          data['session_template_id']!,
          _sessionTemplateIdMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_sessionTemplateIdMeta);
    }
    if (data.containsKey('exercise_type_id')) {
      context.handle(
        _exerciseTypeIdMeta,
        exerciseTypeId.isAcceptableOrUnknown(
          data['exercise_type_id']!,
          _exerciseTypeIdMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_exerciseTypeIdMeta);
    }
    if (data.containsKey('exercise_order')) {
      context.handle(
        _exerciseOrderMeta,
        exerciseOrder.isAcceptableOrUnknown(
          data['exercise_order']!,
          _exerciseOrderMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_exerciseOrderMeta);
    }
    if (data.containsKey('reps')) {
      context.handle(
        _repsMeta,
        reps.isAcceptableOrUnknown(data['reps']!, _repsMeta),
      );
    } else if (isInserting) {
      context.missing(_repsMeta);
    }
    if (data.containsKey('work_seconds')) {
      context.handle(
        _workSecondsMeta,
        workSeconds.isAcceptableOrUnknown(
          data['work_seconds']!,
          _workSecondsMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_workSecondsMeta);
    }
    if (data.containsKey('rest_seconds')) {
      context.handle(
        _restSecondsMeta,
        restSeconds.isAcceptableOrUnknown(
          data['rest_seconds']!,
          _restSecondsMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_restSecondsMeta);
    }
    if (data.containsKey('details')) {
      context.handle(
        _detailsMeta,
        details.isAcceptableOrUnknown(data['details']!, _detailsMeta),
      );
    }
    if (data.containsKey('intensity_override')) {
      context.handle(
        _intensityOverrideMeta,
        intensityOverride.isAcceptableOrUnknown(
          data['intensity_override']!,
          _intensityOverrideMeta,
        ),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  OlySessionExercise map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return OlySessionExercise(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      sessionTemplateId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}session_template_id'],
      )!,
      exerciseTypeId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}exercise_type_id'],
      )!,
      exerciseOrder: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}exercise_order'],
      )!,
      reps: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}reps'],
      )!,
      workSeconds: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}work_seconds'],
      )!,
      restSeconds: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}rest_seconds'],
      )!,
      details: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}details'],
      ),
      intensityOverride: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}intensity_override'],
      ),
    );
  }

  @override
  $OlySessionExercisesTable createAlias(String alias) {
    return $OlySessionExercisesTable(attachedDatabase, alias);
  }
}

class OlySessionExercise extends DataClass
    implements Insertable<OlySessionExercise> {
  final String id;
  final String sessionTemplateId;
  final String exerciseTypeId;
  final int exerciseOrder;
  final int reps;
  final int workSeconds;
  final int restSeconds;
  final String? details;
  final double? intensityOverride;
  const OlySessionExercise({
    required this.id,
    required this.sessionTemplateId,
    required this.exerciseTypeId,
    required this.exerciseOrder,
    required this.reps,
    required this.workSeconds,
    required this.restSeconds,
    this.details,
    this.intensityOverride,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['session_template_id'] = Variable<String>(sessionTemplateId);
    map['exercise_type_id'] = Variable<String>(exerciseTypeId);
    map['exercise_order'] = Variable<int>(exerciseOrder);
    map['reps'] = Variable<int>(reps);
    map['work_seconds'] = Variable<int>(workSeconds);
    map['rest_seconds'] = Variable<int>(restSeconds);
    if (!nullToAbsent || details != null) {
      map['details'] = Variable<String>(details);
    }
    if (!nullToAbsent || intensityOverride != null) {
      map['intensity_override'] = Variable<double>(intensityOverride);
    }
    return map;
  }

  OlySessionExercisesCompanion toCompanion(bool nullToAbsent) {
    return OlySessionExercisesCompanion(
      id: Value(id),
      sessionTemplateId: Value(sessionTemplateId),
      exerciseTypeId: Value(exerciseTypeId),
      exerciseOrder: Value(exerciseOrder),
      reps: Value(reps),
      workSeconds: Value(workSeconds),
      restSeconds: Value(restSeconds),
      details: details == null && nullToAbsent
          ? const Value.absent()
          : Value(details),
      intensityOverride: intensityOverride == null && nullToAbsent
          ? const Value.absent()
          : Value(intensityOverride),
    );
  }

  factory OlySessionExercise.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return OlySessionExercise(
      id: serializer.fromJson<String>(json['id']),
      sessionTemplateId: serializer.fromJson<String>(json['sessionTemplateId']),
      exerciseTypeId: serializer.fromJson<String>(json['exerciseTypeId']),
      exerciseOrder: serializer.fromJson<int>(json['exerciseOrder']),
      reps: serializer.fromJson<int>(json['reps']),
      workSeconds: serializer.fromJson<int>(json['workSeconds']),
      restSeconds: serializer.fromJson<int>(json['restSeconds']),
      details: serializer.fromJson<String?>(json['details']),
      intensityOverride: serializer.fromJson<double?>(
        json['intensityOverride'],
      ),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'sessionTemplateId': serializer.toJson<String>(sessionTemplateId),
      'exerciseTypeId': serializer.toJson<String>(exerciseTypeId),
      'exerciseOrder': serializer.toJson<int>(exerciseOrder),
      'reps': serializer.toJson<int>(reps),
      'workSeconds': serializer.toJson<int>(workSeconds),
      'restSeconds': serializer.toJson<int>(restSeconds),
      'details': serializer.toJson<String?>(details),
      'intensityOverride': serializer.toJson<double?>(intensityOverride),
    };
  }

  OlySessionExercise copyWith({
    String? id,
    String? sessionTemplateId,
    String? exerciseTypeId,
    int? exerciseOrder,
    int? reps,
    int? workSeconds,
    int? restSeconds,
    Value<String?> details = const Value.absent(),
    Value<double?> intensityOverride = const Value.absent(),
  }) => OlySessionExercise(
    id: id ?? this.id,
    sessionTemplateId: sessionTemplateId ?? this.sessionTemplateId,
    exerciseTypeId: exerciseTypeId ?? this.exerciseTypeId,
    exerciseOrder: exerciseOrder ?? this.exerciseOrder,
    reps: reps ?? this.reps,
    workSeconds: workSeconds ?? this.workSeconds,
    restSeconds: restSeconds ?? this.restSeconds,
    details: details.present ? details.value : this.details,
    intensityOverride: intensityOverride.present
        ? intensityOverride.value
        : this.intensityOverride,
  );
  OlySessionExercise copyWithCompanion(OlySessionExercisesCompanion data) {
    return OlySessionExercise(
      id: data.id.present ? data.id.value : this.id,
      sessionTemplateId: data.sessionTemplateId.present
          ? data.sessionTemplateId.value
          : this.sessionTemplateId,
      exerciseTypeId: data.exerciseTypeId.present
          ? data.exerciseTypeId.value
          : this.exerciseTypeId,
      exerciseOrder: data.exerciseOrder.present
          ? data.exerciseOrder.value
          : this.exerciseOrder,
      reps: data.reps.present ? data.reps.value : this.reps,
      workSeconds: data.workSeconds.present
          ? data.workSeconds.value
          : this.workSeconds,
      restSeconds: data.restSeconds.present
          ? data.restSeconds.value
          : this.restSeconds,
      details: data.details.present ? data.details.value : this.details,
      intensityOverride: data.intensityOverride.present
          ? data.intensityOverride.value
          : this.intensityOverride,
    );
  }

  @override
  String toString() {
    return (StringBuffer('OlySessionExercise(')
          ..write('id: $id, ')
          ..write('sessionTemplateId: $sessionTemplateId, ')
          ..write('exerciseTypeId: $exerciseTypeId, ')
          ..write('exerciseOrder: $exerciseOrder, ')
          ..write('reps: $reps, ')
          ..write('workSeconds: $workSeconds, ')
          ..write('restSeconds: $restSeconds, ')
          ..write('details: $details, ')
          ..write('intensityOverride: $intensityOverride')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    sessionTemplateId,
    exerciseTypeId,
    exerciseOrder,
    reps,
    workSeconds,
    restSeconds,
    details,
    intensityOverride,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is OlySessionExercise &&
          other.id == this.id &&
          other.sessionTemplateId == this.sessionTemplateId &&
          other.exerciseTypeId == this.exerciseTypeId &&
          other.exerciseOrder == this.exerciseOrder &&
          other.reps == this.reps &&
          other.workSeconds == this.workSeconds &&
          other.restSeconds == this.restSeconds &&
          other.details == this.details &&
          other.intensityOverride == this.intensityOverride);
}

class OlySessionExercisesCompanion extends UpdateCompanion<OlySessionExercise> {
  final Value<String> id;
  final Value<String> sessionTemplateId;
  final Value<String> exerciseTypeId;
  final Value<int> exerciseOrder;
  final Value<int> reps;
  final Value<int> workSeconds;
  final Value<int> restSeconds;
  final Value<String?> details;
  final Value<double?> intensityOverride;
  final Value<int> rowid;
  const OlySessionExercisesCompanion({
    this.id = const Value.absent(),
    this.sessionTemplateId = const Value.absent(),
    this.exerciseTypeId = const Value.absent(),
    this.exerciseOrder = const Value.absent(),
    this.reps = const Value.absent(),
    this.workSeconds = const Value.absent(),
    this.restSeconds = const Value.absent(),
    this.details = const Value.absent(),
    this.intensityOverride = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  OlySessionExercisesCompanion.insert({
    required String id,
    required String sessionTemplateId,
    required String exerciseTypeId,
    required int exerciseOrder,
    required int reps,
    required int workSeconds,
    required int restSeconds,
    this.details = const Value.absent(),
    this.intensityOverride = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       sessionTemplateId = Value(sessionTemplateId),
       exerciseTypeId = Value(exerciseTypeId),
       exerciseOrder = Value(exerciseOrder),
       reps = Value(reps),
       workSeconds = Value(workSeconds),
       restSeconds = Value(restSeconds);
  static Insertable<OlySessionExercise> custom({
    Expression<String>? id,
    Expression<String>? sessionTemplateId,
    Expression<String>? exerciseTypeId,
    Expression<int>? exerciseOrder,
    Expression<int>? reps,
    Expression<int>? workSeconds,
    Expression<int>? restSeconds,
    Expression<String>? details,
    Expression<double>? intensityOverride,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (sessionTemplateId != null) 'session_template_id': sessionTemplateId,
      if (exerciseTypeId != null) 'exercise_type_id': exerciseTypeId,
      if (exerciseOrder != null) 'exercise_order': exerciseOrder,
      if (reps != null) 'reps': reps,
      if (workSeconds != null) 'work_seconds': workSeconds,
      if (restSeconds != null) 'rest_seconds': restSeconds,
      if (details != null) 'details': details,
      if (intensityOverride != null) 'intensity_override': intensityOverride,
      if (rowid != null) 'rowid': rowid,
    });
  }

  OlySessionExercisesCompanion copyWith({
    Value<String>? id,
    Value<String>? sessionTemplateId,
    Value<String>? exerciseTypeId,
    Value<int>? exerciseOrder,
    Value<int>? reps,
    Value<int>? workSeconds,
    Value<int>? restSeconds,
    Value<String?>? details,
    Value<double?>? intensityOverride,
    Value<int>? rowid,
  }) {
    return OlySessionExercisesCompanion(
      id: id ?? this.id,
      sessionTemplateId: sessionTemplateId ?? this.sessionTemplateId,
      exerciseTypeId: exerciseTypeId ?? this.exerciseTypeId,
      exerciseOrder: exerciseOrder ?? this.exerciseOrder,
      reps: reps ?? this.reps,
      workSeconds: workSeconds ?? this.workSeconds,
      restSeconds: restSeconds ?? this.restSeconds,
      details: details ?? this.details,
      intensityOverride: intensityOverride ?? this.intensityOverride,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (sessionTemplateId.present) {
      map['session_template_id'] = Variable<String>(sessionTemplateId.value);
    }
    if (exerciseTypeId.present) {
      map['exercise_type_id'] = Variable<String>(exerciseTypeId.value);
    }
    if (exerciseOrder.present) {
      map['exercise_order'] = Variable<int>(exerciseOrder.value);
    }
    if (reps.present) {
      map['reps'] = Variable<int>(reps.value);
    }
    if (workSeconds.present) {
      map['work_seconds'] = Variable<int>(workSeconds.value);
    }
    if (restSeconds.present) {
      map['rest_seconds'] = Variable<int>(restSeconds.value);
    }
    if (details.present) {
      map['details'] = Variable<String>(details.value);
    }
    if (intensityOverride.present) {
      map['intensity_override'] = Variable<double>(intensityOverride.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('OlySessionExercisesCompanion(')
          ..write('id: $id, ')
          ..write('sessionTemplateId: $sessionTemplateId, ')
          ..write('exerciseTypeId: $exerciseTypeId, ')
          ..write('exerciseOrder: $exerciseOrder, ')
          ..write('reps: $reps, ')
          ..write('workSeconds: $workSeconds, ')
          ..write('restSeconds: $restSeconds, ')
          ..write('details: $details, ')
          ..write('intensityOverride: $intensityOverride, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $OlyTrainingLogsTable extends OlyTrainingLogs
    with TableInfo<$OlyTrainingLogsTable, OlyTrainingLog> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $OlyTrainingLogsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _sessionTemplateIdMeta = const VerificationMeta(
    'sessionTemplateId',
  );
  @override
  late final GeneratedColumn<String> sessionTemplateId =
      GeneratedColumn<String>(
        'session_template_id',
        aliasedName,
        true,
        type: DriftSqlType.string,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _sessionVersionMeta = const VerificationMeta(
    'sessionVersion',
  );
  @override
  late final GeneratedColumn<String> sessionVersion = GeneratedColumn<String>(
    'session_version',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _sessionNameMeta = const VerificationMeta(
    'sessionName',
  );
  @override
  late final GeneratedColumn<String> sessionName = GeneratedColumn<String>(
    'session_name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _plannedDurationSecondsMeta =
      const VerificationMeta('plannedDurationSeconds');
  @override
  late final GeneratedColumn<int> plannedDurationSeconds = GeneratedColumn<int>(
    'planned_duration_seconds',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _actualDurationSecondsMeta =
      const VerificationMeta('actualDurationSeconds');
  @override
  late final GeneratedColumn<int> actualDurationSeconds = GeneratedColumn<int>(
    'actual_duration_seconds',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _plannedExercisesMeta = const VerificationMeta(
    'plannedExercises',
  );
  @override
  late final GeneratedColumn<int> plannedExercises = GeneratedColumn<int>(
    'planned_exercises',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _completedExercisesMeta =
      const VerificationMeta('completedExercises');
  @override
  late final GeneratedColumn<int> completedExercises = GeneratedColumn<int>(
    'completed_exercises',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _totalHoldSecondsMeta = const VerificationMeta(
    'totalHoldSeconds',
  );
  @override
  late final GeneratedColumn<int> totalHoldSeconds = GeneratedColumn<int>(
    'total_hold_seconds',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _totalRestSecondsMeta = const VerificationMeta(
    'totalRestSeconds',
  );
  @override
  late final GeneratedColumn<int> totalRestSeconds = GeneratedColumn<int>(
    'total_rest_seconds',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _feedbackShakingMeta = const VerificationMeta(
    'feedbackShaking',
  );
  @override
  late final GeneratedColumn<int> feedbackShaking = GeneratedColumn<int>(
    'feedback_shaking',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _feedbackStructureMeta = const VerificationMeta(
    'feedbackStructure',
  );
  @override
  late final GeneratedColumn<int> feedbackStructure = GeneratedColumn<int>(
    'feedback_structure',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _feedbackRestMeta = const VerificationMeta(
    'feedbackRest',
  );
  @override
  late final GeneratedColumn<int> feedbackRest = GeneratedColumn<int>(
    'feedback_rest',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _progressionSuggestionMeta =
      const VerificationMeta('progressionSuggestion');
  @override
  late final GeneratedColumn<String> progressionSuggestion =
      GeneratedColumn<String>(
        'progression_suggestion',
        aliasedName,
        true,
        type: DriftSqlType.string,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _suggestedNextVersionMeta =
      const VerificationMeta('suggestedNextVersion');
  @override
  late final GeneratedColumn<String> suggestedNextVersion =
      GeneratedColumn<String>(
        'suggested_next_version',
        aliasedName,
        true,
        type: DriftSqlType.string,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _notesMeta = const VerificationMeta('notes');
  @override
  late final GeneratedColumn<String> notes = GeneratedColumn<String>(
    'notes',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _startedAtMeta = const VerificationMeta(
    'startedAt',
  );
  @override
  late final GeneratedColumn<DateTime> startedAt = GeneratedColumn<DateTime>(
    'started_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _completedAtMeta = const VerificationMeta(
    'completedAt',
  );
  @override
  late final GeneratedColumn<DateTime> completedAt = GeneratedColumn<DateTime>(
    'completed_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _deletedAtMeta = const VerificationMeta(
    'deletedAt',
  );
  @override
  late final GeneratedColumn<DateTime> deletedAt = GeneratedColumn<DateTime>(
    'deleted_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    sessionTemplateId,
    sessionVersion,
    sessionName,
    plannedDurationSeconds,
    actualDurationSeconds,
    plannedExercises,
    completedExercises,
    totalHoldSeconds,
    totalRestSeconds,
    feedbackShaking,
    feedbackStructure,
    feedbackRest,
    progressionSuggestion,
    suggestedNextVersion,
    notes,
    startedAt,
    completedAt,
    createdAt,
    deletedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'oly_training_logs';
  @override
  VerificationContext validateIntegrity(
    Insertable<OlyTrainingLog> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('session_template_id')) {
      context.handle(
        _sessionTemplateIdMeta,
        sessionTemplateId.isAcceptableOrUnknown(
          data['session_template_id']!,
          _sessionTemplateIdMeta,
        ),
      );
    }
    if (data.containsKey('session_version')) {
      context.handle(
        _sessionVersionMeta,
        sessionVersion.isAcceptableOrUnknown(
          data['session_version']!,
          _sessionVersionMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_sessionVersionMeta);
    }
    if (data.containsKey('session_name')) {
      context.handle(
        _sessionNameMeta,
        sessionName.isAcceptableOrUnknown(
          data['session_name']!,
          _sessionNameMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_sessionNameMeta);
    }
    if (data.containsKey('planned_duration_seconds')) {
      context.handle(
        _plannedDurationSecondsMeta,
        plannedDurationSeconds.isAcceptableOrUnknown(
          data['planned_duration_seconds']!,
          _plannedDurationSecondsMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_plannedDurationSecondsMeta);
    }
    if (data.containsKey('actual_duration_seconds')) {
      context.handle(
        _actualDurationSecondsMeta,
        actualDurationSeconds.isAcceptableOrUnknown(
          data['actual_duration_seconds']!,
          _actualDurationSecondsMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_actualDurationSecondsMeta);
    }
    if (data.containsKey('planned_exercises')) {
      context.handle(
        _plannedExercisesMeta,
        plannedExercises.isAcceptableOrUnknown(
          data['planned_exercises']!,
          _plannedExercisesMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_plannedExercisesMeta);
    }
    if (data.containsKey('completed_exercises')) {
      context.handle(
        _completedExercisesMeta,
        completedExercises.isAcceptableOrUnknown(
          data['completed_exercises']!,
          _completedExercisesMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_completedExercisesMeta);
    }
    if (data.containsKey('total_hold_seconds')) {
      context.handle(
        _totalHoldSecondsMeta,
        totalHoldSeconds.isAcceptableOrUnknown(
          data['total_hold_seconds']!,
          _totalHoldSecondsMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_totalHoldSecondsMeta);
    }
    if (data.containsKey('total_rest_seconds')) {
      context.handle(
        _totalRestSecondsMeta,
        totalRestSeconds.isAcceptableOrUnknown(
          data['total_rest_seconds']!,
          _totalRestSecondsMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_totalRestSecondsMeta);
    }
    if (data.containsKey('feedback_shaking')) {
      context.handle(
        _feedbackShakingMeta,
        feedbackShaking.isAcceptableOrUnknown(
          data['feedback_shaking']!,
          _feedbackShakingMeta,
        ),
      );
    }
    if (data.containsKey('feedback_structure')) {
      context.handle(
        _feedbackStructureMeta,
        feedbackStructure.isAcceptableOrUnknown(
          data['feedback_structure']!,
          _feedbackStructureMeta,
        ),
      );
    }
    if (data.containsKey('feedback_rest')) {
      context.handle(
        _feedbackRestMeta,
        feedbackRest.isAcceptableOrUnknown(
          data['feedback_rest']!,
          _feedbackRestMeta,
        ),
      );
    }
    if (data.containsKey('progression_suggestion')) {
      context.handle(
        _progressionSuggestionMeta,
        progressionSuggestion.isAcceptableOrUnknown(
          data['progression_suggestion']!,
          _progressionSuggestionMeta,
        ),
      );
    }
    if (data.containsKey('suggested_next_version')) {
      context.handle(
        _suggestedNextVersionMeta,
        suggestedNextVersion.isAcceptableOrUnknown(
          data['suggested_next_version']!,
          _suggestedNextVersionMeta,
        ),
      );
    }
    if (data.containsKey('notes')) {
      context.handle(
        _notesMeta,
        notes.isAcceptableOrUnknown(data['notes']!, _notesMeta),
      );
    }
    if (data.containsKey('started_at')) {
      context.handle(
        _startedAtMeta,
        startedAt.isAcceptableOrUnknown(data['started_at']!, _startedAtMeta),
      );
    } else if (isInserting) {
      context.missing(_startedAtMeta);
    }
    if (data.containsKey('completed_at')) {
      context.handle(
        _completedAtMeta,
        completedAt.isAcceptableOrUnknown(
          data['completed_at']!,
          _completedAtMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_completedAtMeta);
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    if (data.containsKey('deleted_at')) {
      context.handle(
        _deletedAtMeta,
        deletedAt.isAcceptableOrUnknown(data['deleted_at']!, _deletedAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  OlyTrainingLog map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return OlyTrainingLog(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      sessionTemplateId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}session_template_id'],
      ),
      sessionVersion: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}session_version'],
      )!,
      sessionName: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}session_name'],
      )!,
      plannedDurationSeconds: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}planned_duration_seconds'],
      )!,
      actualDurationSeconds: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}actual_duration_seconds'],
      )!,
      plannedExercises: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}planned_exercises'],
      )!,
      completedExercises: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}completed_exercises'],
      )!,
      totalHoldSeconds: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}total_hold_seconds'],
      )!,
      totalRestSeconds: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}total_rest_seconds'],
      )!,
      feedbackShaking: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}feedback_shaking'],
      ),
      feedbackStructure: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}feedback_structure'],
      ),
      feedbackRest: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}feedback_rest'],
      ),
      progressionSuggestion: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}progression_suggestion'],
      ),
      suggestedNextVersion: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}suggested_next_version'],
      ),
      notes: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}notes'],
      ),
      startedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}started_at'],
      )!,
      completedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}completed_at'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      deletedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}deleted_at'],
      ),
    );
  }

  @override
  $OlyTrainingLogsTable createAlias(String alias) {
    return $OlyTrainingLogsTable(attachedDatabase, alias);
  }
}

class OlyTrainingLog extends DataClass implements Insertable<OlyTrainingLog> {
  final String id;
  final String? sessionTemplateId;
  final String sessionVersion;
  final String sessionName;
  final int plannedDurationSeconds;
  final int actualDurationSeconds;
  final int plannedExercises;
  final int completedExercises;
  final int totalHoldSeconds;
  final int totalRestSeconds;
  final int? feedbackShaking;
  final int? feedbackStructure;
  final int? feedbackRest;
  final String? progressionSuggestion;
  final String? suggestedNextVersion;
  final String? notes;
  final DateTime startedAt;
  final DateTime completedAt;
  final DateTime createdAt;
  final DateTime? deletedAt;
  const OlyTrainingLog({
    required this.id,
    this.sessionTemplateId,
    required this.sessionVersion,
    required this.sessionName,
    required this.plannedDurationSeconds,
    required this.actualDurationSeconds,
    required this.plannedExercises,
    required this.completedExercises,
    required this.totalHoldSeconds,
    required this.totalRestSeconds,
    this.feedbackShaking,
    this.feedbackStructure,
    this.feedbackRest,
    this.progressionSuggestion,
    this.suggestedNextVersion,
    this.notes,
    required this.startedAt,
    required this.completedAt,
    required this.createdAt,
    this.deletedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    if (!nullToAbsent || sessionTemplateId != null) {
      map['session_template_id'] = Variable<String>(sessionTemplateId);
    }
    map['session_version'] = Variable<String>(sessionVersion);
    map['session_name'] = Variable<String>(sessionName);
    map['planned_duration_seconds'] = Variable<int>(plannedDurationSeconds);
    map['actual_duration_seconds'] = Variable<int>(actualDurationSeconds);
    map['planned_exercises'] = Variable<int>(plannedExercises);
    map['completed_exercises'] = Variable<int>(completedExercises);
    map['total_hold_seconds'] = Variable<int>(totalHoldSeconds);
    map['total_rest_seconds'] = Variable<int>(totalRestSeconds);
    if (!nullToAbsent || feedbackShaking != null) {
      map['feedback_shaking'] = Variable<int>(feedbackShaking);
    }
    if (!nullToAbsent || feedbackStructure != null) {
      map['feedback_structure'] = Variable<int>(feedbackStructure);
    }
    if (!nullToAbsent || feedbackRest != null) {
      map['feedback_rest'] = Variable<int>(feedbackRest);
    }
    if (!nullToAbsent || progressionSuggestion != null) {
      map['progression_suggestion'] = Variable<String>(progressionSuggestion);
    }
    if (!nullToAbsent || suggestedNextVersion != null) {
      map['suggested_next_version'] = Variable<String>(suggestedNextVersion);
    }
    if (!nullToAbsent || notes != null) {
      map['notes'] = Variable<String>(notes);
    }
    map['started_at'] = Variable<DateTime>(startedAt);
    map['completed_at'] = Variable<DateTime>(completedAt);
    map['created_at'] = Variable<DateTime>(createdAt);
    if (!nullToAbsent || deletedAt != null) {
      map['deleted_at'] = Variable<DateTime>(deletedAt);
    }
    return map;
  }

  OlyTrainingLogsCompanion toCompanion(bool nullToAbsent) {
    return OlyTrainingLogsCompanion(
      id: Value(id),
      sessionTemplateId: sessionTemplateId == null && nullToAbsent
          ? const Value.absent()
          : Value(sessionTemplateId),
      sessionVersion: Value(sessionVersion),
      sessionName: Value(sessionName),
      plannedDurationSeconds: Value(plannedDurationSeconds),
      actualDurationSeconds: Value(actualDurationSeconds),
      plannedExercises: Value(plannedExercises),
      completedExercises: Value(completedExercises),
      totalHoldSeconds: Value(totalHoldSeconds),
      totalRestSeconds: Value(totalRestSeconds),
      feedbackShaking: feedbackShaking == null && nullToAbsent
          ? const Value.absent()
          : Value(feedbackShaking),
      feedbackStructure: feedbackStructure == null && nullToAbsent
          ? const Value.absent()
          : Value(feedbackStructure),
      feedbackRest: feedbackRest == null && nullToAbsent
          ? const Value.absent()
          : Value(feedbackRest),
      progressionSuggestion: progressionSuggestion == null && nullToAbsent
          ? const Value.absent()
          : Value(progressionSuggestion),
      suggestedNextVersion: suggestedNextVersion == null && nullToAbsent
          ? const Value.absent()
          : Value(suggestedNextVersion),
      notes: notes == null && nullToAbsent
          ? const Value.absent()
          : Value(notes),
      startedAt: Value(startedAt),
      completedAt: Value(completedAt),
      createdAt: Value(createdAt),
      deletedAt: deletedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(deletedAt),
    );
  }

  factory OlyTrainingLog.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return OlyTrainingLog(
      id: serializer.fromJson<String>(json['id']),
      sessionTemplateId: serializer.fromJson<String?>(
        json['sessionTemplateId'],
      ),
      sessionVersion: serializer.fromJson<String>(json['sessionVersion']),
      sessionName: serializer.fromJson<String>(json['sessionName']),
      plannedDurationSeconds: serializer.fromJson<int>(
        json['plannedDurationSeconds'],
      ),
      actualDurationSeconds: serializer.fromJson<int>(
        json['actualDurationSeconds'],
      ),
      plannedExercises: serializer.fromJson<int>(json['plannedExercises']),
      completedExercises: serializer.fromJson<int>(json['completedExercises']),
      totalHoldSeconds: serializer.fromJson<int>(json['totalHoldSeconds']),
      totalRestSeconds: serializer.fromJson<int>(json['totalRestSeconds']),
      feedbackShaking: serializer.fromJson<int?>(json['feedbackShaking']),
      feedbackStructure: serializer.fromJson<int?>(json['feedbackStructure']),
      feedbackRest: serializer.fromJson<int?>(json['feedbackRest']),
      progressionSuggestion: serializer.fromJson<String?>(
        json['progressionSuggestion'],
      ),
      suggestedNextVersion: serializer.fromJson<String?>(
        json['suggestedNextVersion'],
      ),
      notes: serializer.fromJson<String?>(json['notes']),
      startedAt: serializer.fromJson<DateTime>(json['startedAt']),
      completedAt: serializer.fromJson<DateTime>(json['completedAt']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      deletedAt: serializer.fromJson<DateTime?>(json['deletedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'sessionTemplateId': serializer.toJson<String?>(sessionTemplateId),
      'sessionVersion': serializer.toJson<String>(sessionVersion),
      'sessionName': serializer.toJson<String>(sessionName),
      'plannedDurationSeconds': serializer.toJson<int>(plannedDurationSeconds),
      'actualDurationSeconds': serializer.toJson<int>(actualDurationSeconds),
      'plannedExercises': serializer.toJson<int>(plannedExercises),
      'completedExercises': serializer.toJson<int>(completedExercises),
      'totalHoldSeconds': serializer.toJson<int>(totalHoldSeconds),
      'totalRestSeconds': serializer.toJson<int>(totalRestSeconds),
      'feedbackShaking': serializer.toJson<int?>(feedbackShaking),
      'feedbackStructure': serializer.toJson<int?>(feedbackStructure),
      'feedbackRest': serializer.toJson<int?>(feedbackRest),
      'progressionSuggestion': serializer.toJson<String?>(
        progressionSuggestion,
      ),
      'suggestedNextVersion': serializer.toJson<String?>(suggestedNextVersion),
      'notes': serializer.toJson<String?>(notes),
      'startedAt': serializer.toJson<DateTime>(startedAt),
      'completedAt': serializer.toJson<DateTime>(completedAt),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'deletedAt': serializer.toJson<DateTime?>(deletedAt),
    };
  }

  OlyTrainingLog copyWith({
    String? id,
    Value<String?> sessionTemplateId = const Value.absent(),
    String? sessionVersion,
    String? sessionName,
    int? plannedDurationSeconds,
    int? actualDurationSeconds,
    int? plannedExercises,
    int? completedExercises,
    int? totalHoldSeconds,
    int? totalRestSeconds,
    Value<int?> feedbackShaking = const Value.absent(),
    Value<int?> feedbackStructure = const Value.absent(),
    Value<int?> feedbackRest = const Value.absent(),
    Value<String?> progressionSuggestion = const Value.absent(),
    Value<String?> suggestedNextVersion = const Value.absent(),
    Value<String?> notes = const Value.absent(),
    DateTime? startedAt,
    DateTime? completedAt,
    DateTime? createdAt,
    Value<DateTime?> deletedAt = const Value.absent(),
  }) => OlyTrainingLog(
    id: id ?? this.id,
    sessionTemplateId: sessionTemplateId.present
        ? sessionTemplateId.value
        : this.sessionTemplateId,
    sessionVersion: sessionVersion ?? this.sessionVersion,
    sessionName: sessionName ?? this.sessionName,
    plannedDurationSeconds:
        plannedDurationSeconds ?? this.plannedDurationSeconds,
    actualDurationSeconds: actualDurationSeconds ?? this.actualDurationSeconds,
    plannedExercises: plannedExercises ?? this.plannedExercises,
    completedExercises: completedExercises ?? this.completedExercises,
    totalHoldSeconds: totalHoldSeconds ?? this.totalHoldSeconds,
    totalRestSeconds: totalRestSeconds ?? this.totalRestSeconds,
    feedbackShaking: feedbackShaking.present
        ? feedbackShaking.value
        : this.feedbackShaking,
    feedbackStructure: feedbackStructure.present
        ? feedbackStructure.value
        : this.feedbackStructure,
    feedbackRest: feedbackRest.present ? feedbackRest.value : this.feedbackRest,
    progressionSuggestion: progressionSuggestion.present
        ? progressionSuggestion.value
        : this.progressionSuggestion,
    suggestedNextVersion: suggestedNextVersion.present
        ? suggestedNextVersion.value
        : this.suggestedNextVersion,
    notes: notes.present ? notes.value : this.notes,
    startedAt: startedAt ?? this.startedAt,
    completedAt: completedAt ?? this.completedAt,
    createdAt: createdAt ?? this.createdAt,
    deletedAt: deletedAt.present ? deletedAt.value : this.deletedAt,
  );
  OlyTrainingLog copyWithCompanion(OlyTrainingLogsCompanion data) {
    return OlyTrainingLog(
      id: data.id.present ? data.id.value : this.id,
      sessionTemplateId: data.sessionTemplateId.present
          ? data.sessionTemplateId.value
          : this.sessionTemplateId,
      sessionVersion: data.sessionVersion.present
          ? data.sessionVersion.value
          : this.sessionVersion,
      sessionName: data.sessionName.present
          ? data.sessionName.value
          : this.sessionName,
      plannedDurationSeconds: data.plannedDurationSeconds.present
          ? data.plannedDurationSeconds.value
          : this.plannedDurationSeconds,
      actualDurationSeconds: data.actualDurationSeconds.present
          ? data.actualDurationSeconds.value
          : this.actualDurationSeconds,
      plannedExercises: data.plannedExercises.present
          ? data.plannedExercises.value
          : this.plannedExercises,
      completedExercises: data.completedExercises.present
          ? data.completedExercises.value
          : this.completedExercises,
      totalHoldSeconds: data.totalHoldSeconds.present
          ? data.totalHoldSeconds.value
          : this.totalHoldSeconds,
      totalRestSeconds: data.totalRestSeconds.present
          ? data.totalRestSeconds.value
          : this.totalRestSeconds,
      feedbackShaking: data.feedbackShaking.present
          ? data.feedbackShaking.value
          : this.feedbackShaking,
      feedbackStructure: data.feedbackStructure.present
          ? data.feedbackStructure.value
          : this.feedbackStructure,
      feedbackRest: data.feedbackRest.present
          ? data.feedbackRest.value
          : this.feedbackRest,
      progressionSuggestion: data.progressionSuggestion.present
          ? data.progressionSuggestion.value
          : this.progressionSuggestion,
      suggestedNextVersion: data.suggestedNextVersion.present
          ? data.suggestedNextVersion.value
          : this.suggestedNextVersion,
      notes: data.notes.present ? data.notes.value : this.notes,
      startedAt: data.startedAt.present ? data.startedAt.value : this.startedAt,
      completedAt: data.completedAt.present
          ? data.completedAt.value
          : this.completedAt,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      deletedAt: data.deletedAt.present ? data.deletedAt.value : this.deletedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('OlyTrainingLog(')
          ..write('id: $id, ')
          ..write('sessionTemplateId: $sessionTemplateId, ')
          ..write('sessionVersion: $sessionVersion, ')
          ..write('sessionName: $sessionName, ')
          ..write('plannedDurationSeconds: $plannedDurationSeconds, ')
          ..write('actualDurationSeconds: $actualDurationSeconds, ')
          ..write('plannedExercises: $plannedExercises, ')
          ..write('completedExercises: $completedExercises, ')
          ..write('totalHoldSeconds: $totalHoldSeconds, ')
          ..write('totalRestSeconds: $totalRestSeconds, ')
          ..write('feedbackShaking: $feedbackShaking, ')
          ..write('feedbackStructure: $feedbackStructure, ')
          ..write('feedbackRest: $feedbackRest, ')
          ..write('progressionSuggestion: $progressionSuggestion, ')
          ..write('suggestedNextVersion: $suggestedNextVersion, ')
          ..write('notes: $notes, ')
          ..write('startedAt: $startedAt, ')
          ..write('completedAt: $completedAt, ')
          ..write('createdAt: $createdAt, ')
          ..write('deletedAt: $deletedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    sessionTemplateId,
    sessionVersion,
    sessionName,
    plannedDurationSeconds,
    actualDurationSeconds,
    plannedExercises,
    completedExercises,
    totalHoldSeconds,
    totalRestSeconds,
    feedbackShaking,
    feedbackStructure,
    feedbackRest,
    progressionSuggestion,
    suggestedNextVersion,
    notes,
    startedAt,
    completedAt,
    createdAt,
    deletedAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is OlyTrainingLog &&
          other.id == this.id &&
          other.sessionTemplateId == this.sessionTemplateId &&
          other.sessionVersion == this.sessionVersion &&
          other.sessionName == this.sessionName &&
          other.plannedDurationSeconds == this.plannedDurationSeconds &&
          other.actualDurationSeconds == this.actualDurationSeconds &&
          other.plannedExercises == this.plannedExercises &&
          other.completedExercises == this.completedExercises &&
          other.totalHoldSeconds == this.totalHoldSeconds &&
          other.totalRestSeconds == this.totalRestSeconds &&
          other.feedbackShaking == this.feedbackShaking &&
          other.feedbackStructure == this.feedbackStructure &&
          other.feedbackRest == this.feedbackRest &&
          other.progressionSuggestion == this.progressionSuggestion &&
          other.suggestedNextVersion == this.suggestedNextVersion &&
          other.notes == this.notes &&
          other.startedAt == this.startedAt &&
          other.completedAt == this.completedAt &&
          other.createdAt == this.createdAt &&
          other.deletedAt == this.deletedAt);
}

class OlyTrainingLogsCompanion extends UpdateCompanion<OlyTrainingLog> {
  final Value<String> id;
  final Value<String?> sessionTemplateId;
  final Value<String> sessionVersion;
  final Value<String> sessionName;
  final Value<int> plannedDurationSeconds;
  final Value<int> actualDurationSeconds;
  final Value<int> plannedExercises;
  final Value<int> completedExercises;
  final Value<int> totalHoldSeconds;
  final Value<int> totalRestSeconds;
  final Value<int?> feedbackShaking;
  final Value<int?> feedbackStructure;
  final Value<int?> feedbackRest;
  final Value<String?> progressionSuggestion;
  final Value<String?> suggestedNextVersion;
  final Value<String?> notes;
  final Value<DateTime> startedAt;
  final Value<DateTime> completedAt;
  final Value<DateTime> createdAt;
  final Value<DateTime?> deletedAt;
  final Value<int> rowid;
  const OlyTrainingLogsCompanion({
    this.id = const Value.absent(),
    this.sessionTemplateId = const Value.absent(),
    this.sessionVersion = const Value.absent(),
    this.sessionName = const Value.absent(),
    this.plannedDurationSeconds = const Value.absent(),
    this.actualDurationSeconds = const Value.absent(),
    this.plannedExercises = const Value.absent(),
    this.completedExercises = const Value.absent(),
    this.totalHoldSeconds = const Value.absent(),
    this.totalRestSeconds = const Value.absent(),
    this.feedbackShaking = const Value.absent(),
    this.feedbackStructure = const Value.absent(),
    this.feedbackRest = const Value.absent(),
    this.progressionSuggestion = const Value.absent(),
    this.suggestedNextVersion = const Value.absent(),
    this.notes = const Value.absent(),
    this.startedAt = const Value.absent(),
    this.completedAt = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.deletedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  OlyTrainingLogsCompanion.insert({
    required String id,
    this.sessionTemplateId = const Value.absent(),
    required String sessionVersion,
    required String sessionName,
    required int plannedDurationSeconds,
    required int actualDurationSeconds,
    required int plannedExercises,
    required int completedExercises,
    required int totalHoldSeconds,
    required int totalRestSeconds,
    this.feedbackShaking = const Value.absent(),
    this.feedbackStructure = const Value.absent(),
    this.feedbackRest = const Value.absent(),
    this.progressionSuggestion = const Value.absent(),
    this.suggestedNextVersion = const Value.absent(),
    this.notes = const Value.absent(),
    required DateTime startedAt,
    required DateTime completedAt,
    this.createdAt = const Value.absent(),
    this.deletedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       sessionVersion = Value(sessionVersion),
       sessionName = Value(sessionName),
       plannedDurationSeconds = Value(plannedDurationSeconds),
       actualDurationSeconds = Value(actualDurationSeconds),
       plannedExercises = Value(plannedExercises),
       completedExercises = Value(completedExercises),
       totalHoldSeconds = Value(totalHoldSeconds),
       totalRestSeconds = Value(totalRestSeconds),
       startedAt = Value(startedAt),
       completedAt = Value(completedAt);
  static Insertable<OlyTrainingLog> custom({
    Expression<String>? id,
    Expression<String>? sessionTemplateId,
    Expression<String>? sessionVersion,
    Expression<String>? sessionName,
    Expression<int>? plannedDurationSeconds,
    Expression<int>? actualDurationSeconds,
    Expression<int>? plannedExercises,
    Expression<int>? completedExercises,
    Expression<int>? totalHoldSeconds,
    Expression<int>? totalRestSeconds,
    Expression<int>? feedbackShaking,
    Expression<int>? feedbackStructure,
    Expression<int>? feedbackRest,
    Expression<String>? progressionSuggestion,
    Expression<String>? suggestedNextVersion,
    Expression<String>? notes,
    Expression<DateTime>? startedAt,
    Expression<DateTime>? completedAt,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? deletedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (sessionTemplateId != null) 'session_template_id': sessionTemplateId,
      if (sessionVersion != null) 'session_version': sessionVersion,
      if (sessionName != null) 'session_name': sessionName,
      if (plannedDurationSeconds != null)
        'planned_duration_seconds': plannedDurationSeconds,
      if (actualDurationSeconds != null)
        'actual_duration_seconds': actualDurationSeconds,
      if (plannedExercises != null) 'planned_exercises': plannedExercises,
      if (completedExercises != null) 'completed_exercises': completedExercises,
      if (totalHoldSeconds != null) 'total_hold_seconds': totalHoldSeconds,
      if (totalRestSeconds != null) 'total_rest_seconds': totalRestSeconds,
      if (feedbackShaking != null) 'feedback_shaking': feedbackShaking,
      if (feedbackStructure != null) 'feedback_structure': feedbackStructure,
      if (feedbackRest != null) 'feedback_rest': feedbackRest,
      if (progressionSuggestion != null)
        'progression_suggestion': progressionSuggestion,
      if (suggestedNextVersion != null)
        'suggested_next_version': suggestedNextVersion,
      if (notes != null) 'notes': notes,
      if (startedAt != null) 'started_at': startedAt,
      if (completedAt != null) 'completed_at': completedAt,
      if (createdAt != null) 'created_at': createdAt,
      if (deletedAt != null) 'deleted_at': deletedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  OlyTrainingLogsCompanion copyWith({
    Value<String>? id,
    Value<String?>? sessionTemplateId,
    Value<String>? sessionVersion,
    Value<String>? sessionName,
    Value<int>? plannedDurationSeconds,
    Value<int>? actualDurationSeconds,
    Value<int>? plannedExercises,
    Value<int>? completedExercises,
    Value<int>? totalHoldSeconds,
    Value<int>? totalRestSeconds,
    Value<int?>? feedbackShaking,
    Value<int?>? feedbackStructure,
    Value<int?>? feedbackRest,
    Value<String?>? progressionSuggestion,
    Value<String?>? suggestedNextVersion,
    Value<String?>? notes,
    Value<DateTime>? startedAt,
    Value<DateTime>? completedAt,
    Value<DateTime>? createdAt,
    Value<DateTime?>? deletedAt,
    Value<int>? rowid,
  }) {
    return OlyTrainingLogsCompanion(
      id: id ?? this.id,
      sessionTemplateId: sessionTemplateId ?? this.sessionTemplateId,
      sessionVersion: sessionVersion ?? this.sessionVersion,
      sessionName: sessionName ?? this.sessionName,
      plannedDurationSeconds:
          plannedDurationSeconds ?? this.plannedDurationSeconds,
      actualDurationSeconds:
          actualDurationSeconds ?? this.actualDurationSeconds,
      plannedExercises: plannedExercises ?? this.plannedExercises,
      completedExercises: completedExercises ?? this.completedExercises,
      totalHoldSeconds: totalHoldSeconds ?? this.totalHoldSeconds,
      totalRestSeconds: totalRestSeconds ?? this.totalRestSeconds,
      feedbackShaking: feedbackShaking ?? this.feedbackShaking,
      feedbackStructure: feedbackStructure ?? this.feedbackStructure,
      feedbackRest: feedbackRest ?? this.feedbackRest,
      progressionSuggestion:
          progressionSuggestion ?? this.progressionSuggestion,
      suggestedNextVersion: suggestedNextVersion ?? this.suggestedNextVersion,
      notes: notes ?? this.notes,
      startedAt: startedAt ?? this.startedAt,
      completedAt: completedAt ?? this.completedAt,
      createdAt: createdAt ?? this.createdAt,
      deletedAt: deletedAt ?? this.deletedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (sessionTemplateId.present) {
      map['session_template_id'] = Variable<String>(sessionTemplateId.value);
    }
    if (sessionVersion.present) {
      map['session_version'] = Variable<String>(sessionVersion.value);
    }
    if (sessionName.present) {
      map['session_name'] = Variable<String>(sessionName.value);
    }
    if (plannedDurationSeconds.present) {
      map['planned_duration_seconds'] = Variable<int>(
        plannedDurationSeconds.value,
      );
    }
    if (actualDurationSeconds.present) {
      map['actual_duration_seconds'] = Variable<int>(
        actualDurationSeconds.value,
      );
    }
    if (plannedExercises.present) {
      map['planned_exercises'] = Variable<int>(plannedExercises.value);
    }
    if (completedExercises.present) {
      map['completed_exercises'] = Variable<int>(completedExercises.value);
    }
    if (totalHoldSeconds.present) {
      map['total_hold_seconds'] = Variable<int>(totalHoldSeconds.value);
    }
    if (totalRestSeconds.present) {
      map['total_rest_seconds'] = Variable<int>(totalRestSeconds.value);
    }
    if (feedbackShaking.present) {
      map['feedback_shaking'] = Variable<int>(feedbackShaking.value);
    }
    if (feedbackStructure.present) {
      map['feedback_structure'] = Variable<int>(feedbackStructure.value);
    }
    if (feedbackRest.present) {
      map['feedback_rest'] = Variable<int>(feedbackRest.value);
    }
    if (progressionSuggestion.present) {
      map['progression_suggestion'] = Variable<String>(
        progressionSuggestion.value,
      );
    }
    if (suggestedNextVersion.present) {
      map['suggested_next_version'] = Variable<String>(
        suggestedNextVersion.value,
      );
    }
    if (notes.present) {
      map['notes'] = Variable<String>(notes.value);
    }
    if (startedAt.present) {
      map['started_at'] = Variable<DateTime>(startedAt.value);
    }
    if (completedAt.present) {
      map['completed_at'] = Variable<DateTime>(completedAt.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (deletedAt.present) {
      map['deleted_at'] = Variable<DateTime>(deletedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('OlyTrainingLogsCompanion(')
          ..write('id: $id, ')
          ..write('sessionTemplateId: $sessionTemplateId, ')
          ..write('sessionVersion: $sessionVersion, ')
          ..write('sessionName: $sessionName, ')
          ..write('plannedDurationSeconds: $plannedDurationSeconds, ')
          ..write('actualDurationSeconds: $actualDurationSeconds, ')
          ..write('plannedExercises: $plannedExercises, ')
          ..write('completedExercises: $completedExercises, ')
          ..write('totalHoldSeconds: $totalHoldSeconds, ')
          ..write('totalRestSeconds: $totalRestSeconds, ')
          ..write('feedbackShaking: $feedbackShaking, ')
          ..write('feedbackStructure: $feedbackStructure, ')
          ..write('feedbackRest: $feedbackRest, ')
          ..write('progressionSuggestion: $progressionSuggestion, ')
          ..write('suggestedNextVersion: $suggestedNextVersion, ')
          ..write('notes: $notes, ')
          ..write('startedAt: $startedAt, ')
          ..write('completedAt: $completedAt, ')
          ..write('createdAt: $createdAt, ')
          ..write('deletedAt: $deletedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $UserTrainingProgressTable extends UserTrainingProgress
    with TableInfo<$UserTrainingProgressTable, UserTrainingProgressData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $UserTrainingProgressTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _currentLevelMeta = const VerificationMeta(
    'currentLevel',
  );
  @override
  late final GeneratedColumn<String> currentLevel = GeneratedColumn<String>(
    'current_level',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('1.0'),
  );
  static const VerificationMeta _sessionsAtCurrentLevelMeta =
      const VerificationMeta('sessionsAtCurrentLevel');
  @override
  late final GeneratedColumn<int> sessionsAtCurrentLevel = GeneratedColumn<int>(
    'sessions_at_current_level',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _lastSessionAtMeta = const VerificationMeta(
    'lastSessionAt',
  );
  @override
  late final GeneratedColumn<DateTime> lastSessionAt =
      GeneratedColumn<DateTime>(
        'last_session_at',
        aliasedName,
        true,
        type: DriftSqlType.dateTime,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _lastSessionVersionMeta =
      const VerificationMeta('lastSessionVersion');
  @override
  late final GeneratedColumn<String> lastSessionVersion =
      GeneratedColumn<String>(
        'last_session_version',
        aliasedName,
        true,
        type: DriftSqlType.string,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _totalSessionsCompletedMeta =
      const VerificationMeta('totalSessionsCompleted');
  @override
  late final GeneratedColumn<int> totalSessionsCompleted = GeneratedColumn<int>(
    'total_sessions_completed',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _hasCompletedAssessmentMeta =
      const VerificationMeta('hasCompletedAssessment');
  @override
  late final GeneratedColumn<bool> hasCompletedAssessment =
      GeneratedColumn<bool>(
        'has_completed_assessment',
        aliasedName,
        false,
        type: DriftSqlType.bool,
        requiredDuringInsert: false,
        defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("has_completed_assessment" IN (0, 1))',
        ),
        defaultValue: const Constant(false),
      );
  static const VerificationMeta _assessmentMaxHoldSecondsMeta =
      const VerificationMeta('assessmentMaxHoldSeconds');
  @override
  late final GeneratedColumn<int> assessmentMaxHoldSeconds =
      GeneratedColumn<int>(
        'assessment_max_hold_seconds',
        aliasedName,
        true,
        type: DriftSqlType.int,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _assessmentDateMeta = const VerificationMeta(
    'assessmentDate',
  );
  @override
  late final GeneratedColumn<DateTime> assessmentDate =
      GeneratedColumn<DateTime>(
        'assessment_date',
        aliasedName,
        true,
        type: DriftSqlType.dateTime,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    currentLevel,
    sessionsAtCurrentLevel,
    lastSessionAt,
    lastSessionVersion,
    totalSessionsCompleted,
    hasCompletedAssessment,
    assessmentMaxHoldSeconds,
    assessmentDate,
    createdAt,
    updatedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'user_training_progress';
  @override
  VerificationContext validateIntegrity(
    Insertable<UserTrainingProgressData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('current_level')) {
      context.handle(
        _currentLevelMeta,
        currentLevel.isAcceptableOrUnknown(
          data['current_level']!,
          _currentLevelMeta,
        ),
      );
    }
    if (data.containsKey('sessions_at_current_level')) {
      context.handle(
        _sessionsAtCurrentLevelMeta,
        sessionsAtCurrentLevel.isAcceptableOrUnknown(
          data['sessions_at_current_level']!,
          _sessionsAtCurrentLevelMeta,
        ),
      );
    }
    if (data.containsKey('last_session_at')) {
      context.handle(
        _lastSessionAtMeta,
        lastSessionAt.isAcceptableOrUnknown(
          data['last_session_at']!,
          _lastSessionAtMeta,
        ),
      );
    }
    if (data.containsKey('last_session_version')) {
      context.handle(
        _lastSessionVersionMeta,
        lastSessionVersion.isAcceptableOrUnknown(
          data['last_session_version']!,
          _lastSessionVersionMeta,
        ),
      );
    }
    if (data.containsKey('total_sessions_completed')) {
      context.handle(
        _totalSessionsCompletedMeta,
        totalSessionsCompleted.isAcceptableOrUnknown(
          data['total_sessions_completed']!,
          _totalSessionsCompletedMeta,
        ),
      );
    }
    if (data.containsKey('has_completed_assessment')) {
      context.handle(
        _hasCompletedAssessmentMeta,
        hasCompletedAssessment.isAcceptableOrUnknown(
          data['has_completed_assessment']!,
          _hasCompletedAssessmentMeta,
        ),
      );
    }
    if (data.containsKey('assessment_max_hold_seconds')) {
      context.handle(
        _assessmentMaxHoldSecondsMeta,
        assessmentMaxHoldSeconds.isAcceptableOrUnknown(
          data['assessment_max_hold_seconds']!,
          _assessmentMaxHoldSecondsMeta,
        ),
      );
    }
    if (data.containsKey('assessment_date')) {
      context.handle(
        _assessmentDateMeta,
        assessmentDate.isAcceptableOrUnknown(
          data['assessment_date']!,
          _assessmentDateMeta,
        ),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  UserTrainingProgressData map(
    Map<String, dynamic> data, {
    String? tablePrefix,
  }) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return UserTrainingProgressData(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      currentLevel: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}current_level'],
      )!,
      sessionsAtCurrentLevel: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sessions_at_current_level'],
      )!,
      lastSessionAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}last_session_at'],
      ),
      lastSessionVersion: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}last_session_version'],
      ),
      totalSessionsCompleted: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}total_sessions_completed'],
      )!,
      hasCompletedAssessment: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}has_completed_assessment'],
      )!,
      assessmentMaxHoldSeconds: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}assessment_max_hold_seconds'],
      ),
      assessmentDate: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}assessment_date'],
      ),
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      )!,
    );
  }

  @override
  $UserTrainingProgressTable createAlias(String alias) {
    return $UserTrainingProgressTable(attachedDatabase, alias);
  }
}

class UserTrainingProgressData extends DataClass
    implements Insertable<UserTrainingProgressData> {
  final String id;
  final String currentLevel;
  final int sessionsAtCurrentLevel;
  final DateTime? lastSessionAt;
  final String? lastSessionVersion;
  final int totalSessionsCompleted;
  final bool hasCompletedAssessment;
  final int? assessmentMaxHoldSeconds;
  final DateTime? assessmentDate;
  final DateTime createdAt;
  final DateTime updatedAt;
  const UserTrainingProgressData({
    required this.id,
    required this.currentLevel,
    required this.sessionsAtCurrentLevel,
    this.lastSessionAt,
    this.lastSessionVersion,
    required this.totalSessionsCompleted,
    required this.hasCompletedAssessment,
    this.assessmentMaxHoldSeconds,
    this.assessmentDate,
    required this.createdAt,
    required this.updatedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['current_level'] = Variable<String>(currentLevel);
    map['sessions_at_current_level'] = Variable<int>(sessionsAtCurrentLevel);
    if (!nullToAbsent || lastSessionAt != null) {
      map['last_session_at'] = Variable<DateTime>(lastSessionAt);
    }
    if (!nullToAbsent || lastSessionVersion != null) {
      map['last_session_version'] = Variable<String>(lastSessionVersion);
    }
    map['total_sessions_completed'] = Variable<int>(totalSessionsCompleted);
    map['has_completed_assessment'] = Variable<bool>(hasCompletedAssessment);
    if (!nullToAbsent || assessmentMaxHoldSeconds != null) {
      map['assessment_max_hold_seconds'] = Variable<int>(
        assessmentMaxHoldSeconds,
      );
    }
    if (!nullToAbsent || assessmentDate != null) {
      map['assessment_date'] = Variable<DateTime>(assessmentDate);
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    return map;
  }

  UserTrainingProgressCompanion toCompanion(bool nullToAbsent) {
    return UserTrainingProgressCompanion(
      id: Value(id),
      currentLevel: Value(currentLevel),
      sessionsAtCurrentLevel: Value(sessionsAtCurrentLevel),
      lastSessionAt: lastSessionAt == null && nullToAbsent
          ? const Value.absent()
          : Value(lastSessionAt),
      lastSessionVersion: lastSessionVersion == null && nullToAbsent
          ? const Value.absent()
          : Value(lastSessionVersion),
      totalSessionsCompleted: Value(totalSessionsCompleted),
      hasCompletedAssessment: Value(hasCompletedAssessment),
      assessmentMaxHoldSeconds: assessmentMaxHoldSeconds == null && nullToAbsent
          ? const Value.absent()
          : Value(assessmentMaxHoldSeconds),
      assessmentDate: assessmentDate == null && nullToAbsent
          ? const Value.absent()
          : Value(assessmentDate),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory UserTrainingProgressData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return UserTrainingProgressData(
      id: serializer.fromJson<String>(json['id']),
      currentLevel: serializer.fromJson<String>(json['currentLevel']),
      sessionsAtCurrentLevel: serializer.fromJson<int>(
        json['sessionsAtCurrentLevel'],
      ),
      lastSessionAt: serializer.fromJson<DateTime?>(json['lastSessionAt']),
      lastSessionVersion: serializer.fromJson<String?>(
        json['lastSessionVersion'],
      ),
      totalSessionsCompleted: serializer.fromJson<int>(
        json['totalSessionsCompleted'],
      ),
      hasCompletedAssessment: serializer.fromJson<bool>(
        json['hasCompletedAssessment'],
      ),
      assessmentMaxHoldSeconds: serializer.fromJson<int?>(
        json['assessmentMaxHoldSeconds'],
      ),
      assessmentDate: serializer.fromJson<DateTime?>(json['assessmentDate']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'currentLevel': serializer.toJson<String>(currentLevel),
      'sessionsAtCurrentLevel': serializer.toJson<int>(sessionsAtCurrentLevel),
      'lastSessionAt': serializer.toJson<DateTime?>(lastSessionAt),
      'lastSessionVersion': serializer.toJson<String?>(lastSessionVersion),
      'totalSessionsCompleted': serializer.toJson<int>(totalSessionsCompleted),
      'hasCompletedAssessment': serializer.toJson<bool>(hasCompletedAssessment),
      'assessmentMaxHoldSeconds': serializer.toJson<int?>(
        assessmentMaxHoldSeconds,
      ),
      'assessmentDate': serializer.toJson<DateTime?>(assessmentDate),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
    };
  }

  UserTrainingProgressData copyWith({
    String? id,
    String? currentLevel,
    int? sessionsAtCurrentLevel,
    Value<DateTime?> lastSessionAt = const Value.absent(),
    Value<String?> lastSessionVersion = const Value.absent(),
    int? totalSessionsCompleted,
    bool? hasCompletedAssessment,
    Value<int?> assessmentMaxHoldSeconds = const Value.absent(),
    Value<DateTime?> assessmentDate = const Value.absent(),
    DateTime? createdAt,
    DateTime? updatedAt,
  }) => UserTrainingProgressData(
    id: id ?? this.id,
    currentLevel: currentLevel ?? this.currentLevel,
    sessionsAtCurrentLevel:
        sessionsAtCurrentLevel ?? this.sessionsAtCurrentLevel,
    lastSessionAt: lastSessionAt.present
        ? lastSessionAt.value
        : this.lastSessionAt,
    lastSessionVersion: lastSessionVersion.present
        ? lastSessionVersion.value
        : this.lastSessionVersion,
    totalSessionsCompleted:
        totalSessionsCompleted ?? this.totalSessionsCompleted,
    hasCompletedAssessment:
        hasCompletedAssessment ?? this.hasCompletedAssessment,
    assessmentMaxHoldSeconds: assessmentMaxHoldSeconds.present
        ? assessmentMaxHoldSeconds.value
        : this.assessmentMaxHoldSeconds,
    assessmentDate: assessmentDate.present
        ? assessmentDate.value
        : this.assessmentDate,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
  );
  UserTrainingProgressData copyWithCompanion(
    UserTrainingProgressCompanion data,
  ) {
    return UserTrainingProgressData(
      id: data.id.present ? data.id.value : this.id,
      currentLevel: data.currentLevel.present
          ? data.currentLevel.value
          : this.currentLevel,
      sessionsAtCurrentLevel: data.sessionsAtCurrentLevel.present
          ? data.sessionsAtCurrentLevel.value
          : this.sessionsAtCurrentLevel,
      lastSessionAt: data.lastSessionAt.present
          ? data.lastSessionAt.value
          : this.lastSessionAt,
      lastSessionVersion: data.lastSessionVersion.present
          ? data.lastSessionVersion.value
          : this.lastSessionVersion,
      totalSessionsCompleted: data.totalSessionsCompleted.present
          ? data.totalSessionsCompleted.value
          : this.totalSessionsCompleted,
      hasCompletedAssessment: data.hasCompletedAssessment.present
          ? data.hasCompletedAssessment.value
          : this.hasCompletedAssessment,
      assessmentMaxHoldSeconds: data.assessmentMaxHoldSeconds.present
          ? data.assessmentMaxHoldSeconds.value
          : this.assessmentMaxHoldSeconds,
      assessmentDate: data.assessmentDate.present
          ? data.assessmentDate.value
          : this.assessmentDate,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('UserTrainingProgressData(')
          ..write('id: $id, ')
          ..write('currentLevel: $currentLevel, ')
          ..write('sessionsAtCurrentLevel: $sessionsAtCurrentLevel, ')
          ..write('lastSessionAt: $lastSessionAt, ')
          ..write('lastSessionVersion: $lastSessionVersion, ')
          ..write('totalSessionsCompleted: $totalSessionsCompleted, ')
          ..write('hasCompletedAssessment: $hasCompletedAssessment, ')
          ..write('assessmentMaxHoldSeconds: $assessmentMaxHoldSeconds, ')
          ..write('assessmentDate: $assessmentDate, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    currentLevel,
    sessionsAtCurrentLevel,
    lastSessionAt,
    lastSessionVersion,
    totalSessionsCompleted,
    hasCompletedAssessment,
    assessmentMaxHoldSeconds,
    assessmentDate,
    createdAt,
    updatedAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is UserTrainingProgressData &&
          other.id == this.id &&
          other.currentLevel == this.currentLevel &&
          other.sessionsAtCurrentLevel == this.sessionsAtCurrentLevel &&
          other.lastSessionAt == this.lastSessionAt &&
          other.lastSessionVersion == this.lastSessionVersion &&
          other.totalSessionsCompleted == this.totalSessionsCompleted &&
          other.hasCompletedAssessment == this.hasCompletedAssessment &&
          other.assessmentMaxHoldSeconds == this.assessmentMaxHoldSeconds &&
          other.assessmentDate == this.assessmentDate &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class UserTrainingProgressCompanion
    extends UpdateCompanion<UserTrainingProgressData> {
  final Value<String> id;
  final Value<String> currentLevel;
  final Value<int> sessionsAtCurrentLevel;
  final Value<DateTime?> lastSessionAt;
  final Value<String?> lastSessionVersion;
  final Value<int> totalSessionsCompleted;
  final Value<bool> hasCompletedAssessment;
  final Value<int?> assessmentMaxHoldSeconds;
  final Value<DateTime?> assessmentDate;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  final Value<int> rowid;
  const UserTrainingProgressCompanion({
    this.id = const Value.absent(),
    this.currentLevel = const Value.absent(),
    this.sessionsAtCurrentLevel = const Value.absent(),
    this.lastSessionAt = const Value.absent(),
    this.lastSessionVersion = const Value.absent(),
    this.totalSessionsCompleted = const Value.absent(),
    this.hasCompletedAssessment = const Value.absent(),
    this.assessmentMaxHoldSeconds = const Value.absent(),
    this.assessmentDate = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  UserTrainingProgressCompanion.insert({
    required String id,
    this.currentLevel = const Value.absent(),
    this.sessionsAtCurrentLevel = const Value.absent(),
    this.lastSessionAt = const Value.absent(),
    this.lastSessionVersion = const Value.absent(),
    this.totalSessionsCompleted = const Value.absent(),
    this.hasCompletedAssessment = const Value.absent(),
    this.assessmentMaxHoldSeconds = const Value.absent(),
    this.assessmentDate = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id);
  static Insertable<UserTrainingProgressData> custom({
    Expression<String>? id,
    Expression<String>? currentLevel,
    Expression<int>? sessionsAtCurrentLevel,
    Expression<DateTime>? lastSessionAt,
    Expression<String>? lastSessionVersion,
    Expression<int>? totalSessionsCompleted,
    Expression<bool>? hasCompletedAssessment,
    Expression<int>? assessmentMaxHoldSeconds,
    Expression<DateTime>? assessmentDate,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (currentLevel != null) 'current_level': currentLevel,
      if (sessionsAtCurrentLevel != null)
        'sessions_at_current_level': sessionsAtCurrentLevel,
      if (lastSessionAt != null) 'last_session_at': lastSessionAt,
      if (lastSessionVersion != null)
        'last_session_version': lastSessionVersion,
      if (totalSessionsCompleted != null)
        'total_sessions_completed': totalSessionsCompleted,
      if (hasCompletedAssessment != null)
        'has_completed_assessment': hasCompletedAssessment,
      if (assessmentMaxHoldSeconds != null)
        'assessment_max_hold_seconds': assessmentMaxHoldSeconds,
      if (assessmentDate != null) 'assessment_date': assessmentDate,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  UserTrainingProgressCompanion copyWith({
    Value<String>? id,
    Value<String>? currentLevel,
    Value<int>? sessionsAtCurrentLevel,
    Value<DateTime?>? lastSessionAt,
    Value<String?>? lastSessionVersion,
    Value<int>? totalSessionsCompleted,
    Value<bool>? hasCompletedAssessment,
    Value<int?>? assessmentMaxHoldSeconds,
    Value<DateTime?>? assessmentDate,
    Value<DateTime>? createdAt,
    Value<DateTime>? updatedAt,
    Value<int>? rowid,
  }) {
    return UserTrainingProgressCompanion(
      id: id ?? this.id,
      currentLevel: currentLevel ?? this.currentLevel,
      sessionsAtCurrentLevel:
          sessionsAtCurrentLevel ?? this.sessionsAtCurrentLevel,
      lastSessionAt: lastSessionAt ?? this.lastSessionAt,
      lastSessionVersion: lastSessionVersion ?? this.lastSessionVersion,
      totalSessionsCompleted:
          totalSessionsCompleted ?? this.totalSessionsCompleted,
      hasCompletedAssessment:
          hasCompletedAssessment ?? this.hasCompletedAssessment,
      assessmentMaxHoldSeconds:
          assessmentMaxHoldSeconds ?? this.assessmentMaxHoldSeconds,
      assessmentDate: assessmentDate ?? this.assessmentDate,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (currentLevel.present) {
      map['current_level'] = Variable<String>(currentLevel.value);
    }
    if (sessionsAtCurrentLevel.present) {
      map['sessions_at_current_level'] = Variable<int>(
        sessionsAtCurrentLevel.value,
      );
    }
    if (lastSessionAt.present) {
      map['last_session_at'] = Variable<DateTime>(lastSessionAt.value);
    }
    if (lastSessionVersion.present) {
      map['last_session_version'] = Variable<String>(lastSessionVersion.value);
    }
    if (totalSessionsCompleted.present) {
      map['total_sessions_completed'] = Variable<int>(
        totalSessionsCompleted.value,
      );
    }
    if (hasCompletedAssessment.present) {
      map['has_completed_assessment'] = Variable<bool>(
        hasCompletedAssessment.value,
      );
    }
    if (assessmentMaxHoldSeconds.present) {
      map['assessment_max_hold_seconds'] = Variable<int>(
        assessmentMaxHoldSeconds.value,
      );
    }
    if (assessmentDate.present) {
      map['assessment_date'] = Variable<DateTime>(assessmentDate.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('UserTrainingProgressCompanion(')
          ..write('id: $id, ')
          ..write('currentLevel: $currentLevel, ')
          ..write('sessionsAtCurrentLevel: $sessionsAtCurrentLevel, ')
          ..write('lastSessionAt: $lastSessionAt, ')
          ..write('lastSessionVersion: $lastSessionVersion, ')
          ..write('totalSessionsCompleted: $totalSessionsCompleted, ')
          ..write('hasCompletedAssessment: $hasCompletedAssessment, ')
          ..write('assessmentMaxHoldSeconds: $assessmentMaxHoldSeconds, ')
          ..write('assessmentDate: $assessmentDate, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $BreathTrainingLogsTable extends BreathTrainingLogs
    with TableInfo<$BreathTrainingLogsTable, BreathTrainingLog> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $BreathTrainingLogsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _sessionTypeMeta = const VerificationMeta(
    'sessionType',
  );
  @override
  late final GeneratedColumn<String> sessionType = GeneratedColumn<String>(
    'session_type',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _totalHoldSecondsMeta = const VerificationMeta(
    'totalHoldSeconds',
  );
  @override
  late final GeneratedColumn<int> totalHoldSeconds = GeneratedColumn<int>(
    'total_hold_seconds',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _bestHoldThisSessionMeta =
      const VerificationMeta('bestHoldThisSession');
  @override
  late final GeneratedColumn<int> bestHoldThisSession = GeneratedColumn<int>(
    'best_hold_this_session',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _bestExhaleSecondsMeta = const VerificationMeta(
    'bestExhaleSeconds',
  );
  @override
  late final GeneratedColumn<int> bestExhaleSeconds = GeneratedColumn<int>(
    'best_exhale_seconds',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _roundsMeta = const VerificationMeta('rounds');
  @override
  late final GeneratedColumn<int> rounds = GeneratedColumn<int>(
    'rounds',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _difficultyMeta = const VerificationMeta(
    'difficulty',
  );
  @override
  late final GeneratedColumn<String> difficulty = GeneratedColumn<String>(
    'difficulty',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _durationMinutesMeta = const VerificationMeta(
    'durationMinutes',
  );
  @override
  late final GeneratedColumn<int> durationMinutes = GeneratedColumn<int>(
    'duration_minutes',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _completedAtMeta = const VerificationMeta(
    'completedAt',
  );
  @override
  late final GeneratedColumn<DateTime> completedAt = GeneratedColumn<DateTime>(
    'completed_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _deletedAtMeta = const VerificationMeta(
    'deletedAt',
  );
  @override
  late final GeneratedColumn<DateTime> deletedAt = GeneratedColumn<DateTime>(
    'deleted_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    sessionType,
    totalHoldSeconds,
    bestHoldThisSession,
    bestExhaleSeconds,
    rounds,
    difficulty,
    durationMinutes,
    completedAt,
    createdAt,
    updatedAt,
    deletedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'breath_training_logs';
  @override
  VerificationContext validateIntegrity(
    Insertable<BreathTrainingLog> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('session_type')) {
      context.handle(
        _sessionTypeMeta,
        sessionType.isAcceptableOrUnknown(
          data['session_type']!,
          _sessionTypeMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_sessionTypeMeta);
    }
    if (data.containsKey('total_hold_seconds')) {
      context.handle(
        _totalHoldSecondsMeta,
        totalHoldSeconds.isAcceptableOrUnknown(
          data['total_hold_seconds']!,
          _totalHoldSecondsMeta,
        ),
      );
    }
    if (data.containsKey('best_hold_this_session')) {
      context.handle(
        _bestHoldThisSessionMeta,
        bestHoldThisSession.isAcceptableOrUnknown(
          data['best_hold_this_session']!,
          _bestHoldThisSessionMeta,
        ),
      );
    }
    if (data.containsKey('best_exhale_seconds')) {
      context.handle(
        _bestExhaleSecondsMeta,
        bestExhaleSeconds.isAcceptableOrUnknown(
          data['best_exhale_seconds']!,
          _bestExhaleSecondsMeta,
        ),
      );
    }
    if (data.containsKey('rounds')) {
      context.handle(
        _roundsMeta,
        rounds.isAcceptableOrUnknown(data['rounds']!, _roundsMeta),
      );
    }
    if (data.containsKey('difficulty')) {
      context.handle(
        _difficultyMeta,
        difficulty.isAcceptableOrUnknown(data['difficulty']!, _difficultyMeta),
      );
    }
    if (data.containsKey('duration_minutes')) {
      context.handle(
        _durationMinutesMeta,
        durationMinutes.isAcceptableOrUnknown(
          data['duration_minutes']!,
          _durationMinutesMeta,
        ),
      );
    }
    if (data.containsKey('completed_at')) {
      context.handle(
        _completedAtMeta,
        completedAt.isAcceptableOrUnknown(
          data['completed_at']!,
          _completedAtMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_completedAtMeta);
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    }
    if (data.containsKey('deleted_at')) {
      context.handle(
        _deletedAtMeta,
        deletedAt.isAcceptableOrUnknown(data['deleted_at']!, _deletedAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  BreathTrainingLog map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return BreathTrainingLog(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      sessionType: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}session_type'],
      )!,
      totalHoldSeconds: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}total_hold_seconds'],
      ),
      bestHoldThisSession: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}best_hold_this_session'],
      ),
      bestExhaleSeconds: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}best_exhale_seconds'],
      ),
      rounds: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}rounds'],
      ),
      difficulty: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}difficulty'],
      ),
      durationMinutes: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}duration_minutes'],
      ),
      completedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}completed_at'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      )!,
      deletedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}deleted_at'],
      ),
    );
  }

  @override
  $BreathTrainingLogsTable createAlias(String alias) {
    return $BreathTrainingLogsTable(attachedDatabase, alias);
  }
}

class BreathTrainingLog extends DataClass
    implements Insertable<BreathTrainingLog> {
  final String id;
  final String sessionType;
  final int? totalHoldSeconds;
  final int? bestHoldThisSession;
  final int? bestExhaleSeconds;
  final int? rounds;
  final String? difficulty;
  final int? durationMinutes;
  final DateTime completedAt;
  final DateTime createdAt;
  final DateTime updatedAt;
  final DateTime? deletedAt;
  const BreathTrainingLog({
    required this.id,
    required this.sessionType,
    this.totalHoldSeconds,
    this.bestHoldThisSession,
    this.bestExhaleSeconds,
    this.rounds,
    this.difficulty,
    this.durationMinutes,
    required this.completedAt,
    required this.createdAt,
    required this.updatedAt,
    this.deletedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['session_type'] = Variable<String>(sessionType);
    if (!nullToAbsent || totalHoldSeconds != null) {
      map['total_hold_seconds'] = Variable<int>(totalHoldSeconds);
    }
    if (!nullToAbsent || bestHoldThisSession != null) {
      map['best_hold_this_session'] = Variable<int>(bestHoldThisSession);
    }
    if (!nullToAbsent || bestExhaleSeconds != null) {
      map['best_exhale_seconds'] = Variable<int>(bestExhaleSeconds);
    }
    if (!nullToAbsent || rounds != null) {
      map['rounds'] = Variable<int>(rounds);
    }
    if (!nullToAbsent || difficulty != null) {
      map['difficulty'] = Variable<String>(difficulty);
    }
    if (!nullToAbsent || durationMinutes != null) {
      map['duration_minutes'] = Variable<int>(durationMinutes);
    }
    map['completed_at'] = Variable<DateTime>(completedAt);
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    if (!nullToAbsent || deletedAt != null) {
      map['deleted_at'] = Variable<DateTime>(deletedAt);
    }
    return map;
  }

  BreathTrainingLogsCompanion toCompanion(bool nullToAbsent) {
    return BreathTrainingLogsCompanion(
      id: Value(id),
      sessionType: Value(sessionType),
      totalHoldSeconds: totalHoldSeconds == null && nullToAbsent
          ? const Value.absent()
          : Value(totalHoldSeconds),
      bestHoldThisSession: bestHoldThisSession == null && nullToAbsent
          ? const Value.absent()
          : Value(bestHoldThisSession),
      bestExhaleSeconds: bestExhaleSeconds == null && nullToAbsent
          ? const Value.absent()
          : Value(bestExhaleSeconds),
      rounds: rounds == null && nullToAbsent
          ? const Value.absent()
          : Value(rounds),
      difficulty: difficulty == null && nullToAbsent
          ? const Value.absent()
          : Value(difficulty),
      durationMinutes: durationMinutes == null && nullToAbsent
          ? const Value.absent()
          : Value(durationMinutes),
      completedAt: Value(completedAt),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
      deletedAt: deletedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(deletedAt),
    );
  }

  factory BreathTrainingLog.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return BreathTrainingLog(
      id: serializer.fromJson<String>(json['id']),
      sessionType: serializer.fromJson<String>(json['sessionType']),
      totalHoldSeconds: serializer.fromJson<int?>(json['totalHoldSeconds']),
      bestHoldThisSession: serializer.fromJson<int?>(
        json['bestHoldThisSession'],
      ),
      bestExhaleSeconds: serializer.fromJson<int?>(json['bestExhaleSeconds']),
      rounds: serializer.fromJson<int?>(json['rounds']),
      difficulty: serializer.fromJson<String?>(json['difficulty']),
      durationMinutes: serializer.fromJson<int?>(json['durationMinutes']),
      completedAt: serializer.fromJson<DateTime>(json['completedAt']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
      deletedAt: serializer.fromJson<DateTime?>(json['deletedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'sessionType': serializer.toJson<String>(sessionType),
      'totalHoldSeconds': serializer.toJson<int?>(totalHoldSeconds),
      'bestHoldThisSession': serializer.toJson<int?>(bestHoldThisSession),
      'bestExhaleSeconds': serializer.toJson<int?>(bestExhaleSeconds),
      'rounds': serializer.toJson<int?>(rounds),
      'difficulty': serializer.toJson<String?>(difficulty),
      'durationMinutes': serializer.toJson<int?>(durationMinutes),
      'completedAt': serializer.toJson<DateTime>(completedAt),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
      'deletedAt': serializer.toJson<DateTime?>(deletedAt),
    };
  }

  BreathTrainingLog copyWith({
    String? id,
    String? sessionType,
    Value<int?> totalHoldSeconds = const Value.absent(),
    Value<int?> bestHoldThisSession = const Value.absent(),
    Value<int?> bestExhaleSeconds = const Value.absent(),
    Value<int?> rounds = const Value.absent(),
    Value<String?> difficulty = const Value.absent(),
    Value<int?> durationMinutes = const Value.absent(),
    DateTime? completedAt,
    DateTime? createdAt,
    DateTime? updatedAt,
    Value<DateTime?> deletedAt = const Value.absent(),
  }) => BreathTrainingLog(
    id: id ?? this.id,
    sessionType: sessionType ?? this.sessionType,
    totalHoldSeconds: totalHoldSeconds.present
        ? totalHoldSeconds.value
        : this.totalHoldSeconds,
    bestHoldThisSession: bestHoldThisSession.present
        ? bestHoldThisSession.value
        : this.bestHoldThisSession,
    bestExhaleSeconds: bestExhaleSeconds.present
        ? bestExhaleSeconds.value
        : this.bestExhaleSeconds,
    rounds: rounds.present ? rounds.value : this.rounds,
    difficulty: difficulty.present ? difficulty.value : this.difficulty,
    durationMinutes: durationMinutes.present
        ? durationMinutes.value
        : this.durationMinutes,
    completedAt: completedAt ?? this.completedAt,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
    deletedAt: deletedAt.present ? deletedAt.value : this.deletedAt,
  );
  BreathTrainingLog copyWithCompanion(BreathTrainingLogsCompanion data) {
    return BreathTrainingLog(
      id: data.id.present ? data.id.value : this.id,
      sessionType: data.sessionType.present
          ? data.sessionType.value
          : this.sessionType,
      totalHoldSeconds: data.totalHoldSeconds.present
          ? data.totalHoldSeconds.value
          : this.totalHoldSeconds,
      bestHoldThisSession: data.bestHoldThisSession.present
          ? data.bestHoldThisSession.value
          : this.bestHoldThisSession,
      bestExhaleSeconds: data.bestExhaleSeconds.present
          ? data.bestExhaleSeconds.value
          : this.bestExhaleSeconds,
      rounds: data.rounds.present ? data.rounds.value : this.rounds,
      difficulty: data.difficulty.present
          ? data.difficulty.value
          : this.difficulty,
      durationMinutes: data.durationMinutes.present
          ? data.durationMinutes.value
          : this.durationMinutes,
      completedAt: data.completedAt.present
          ? data.completedAt.value
          : this.completedAt,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
      deletedAt: data.deletedAt.present ? data.deletedAt.value : this.deletedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('BreathTrainingLog(')
          ..write('id: $id, ')
          ..write('sessionType: $sessionType, ')
          ..write('totalHoldSeconds: $totalHoldSeconds, ')
          ..write('bestHoldThisSession: $bestHoldThisSession, ')
          ..write('bestExhaleSeconds: $bestExhaleSeconds, ')
          ..write('rounds: $rounds, ')
          ..write('difficulty: $difficulty, ')
          ..write('durationMinutes: $durationMinutes, ')
          ..write('completedAt: $completedAt, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('deletedAt: $deletedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    sessionType,
    totalHoldSeconds,
    bestHoldThisSession,
    bestExhaleSeconds,
    rounds,
    difficulty,
    durationMinutes,
    completedAt,
    createdAt,
    updatedAt,
    deletedAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is BreathTrainingLog &&
          other.id == this.id &&
          other.sessionType == this.sessionType &&
          other.totalHoldSeconds == this.totalHoldSeconds &&
          other.bestHoldThisSession == this.bestHoldThisSession &&
          other.bestExhaleSeconds == this.bestExhaleSeconds &&
          other.rounds == this.rounds &&
          other.difficulty == this.difficulty &&
          other.durationMinutes == this.durationMinutes &&
          other.completedAt == this.completedAt &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt &&
          other.deletedAt == this.deletedAt);
}

class BreathTrainingLogsCompanion extends UpdateCompanion<BreathTrainingLog> {
  final Value<String> id;
  final Value<String> sessionType;
  final Value<int?> totalHoldSeconds;
  final Value<int?> bestHoldThisSession;
  final Value<int?> bestExhaleSeconds;
  final Value<int?> rounds;
  final Value<String?> difficulty;
  final Value<int?> durationMinutes;
  final Value<DateTime> completedAt;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  final Value<DateTime?> deletedAt;
  final Value<int> rowid;
  const BreathTrainingLogsCompanion({
    this.id = const Value.absent(),
    this.sessionType = const Value.absent(),
    this.totalHoldSeconds = const Value.absent(),
    this.bestHoldThisSession = const Value.absent(),
    this.bestExhaleSeconds = const Value.absent(),
    this.rounds = const Value.absent(),
    this.difficulty = const Value.absent(),
    this.durationMinutes = const Value.absent(),
    this.completedAt = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.deletedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  BreathTrainingLogsCompanion.insert({
    required String id,
    required String sessionType,
    this.totalHoldSeconds = const Value.absent(),
    this.bestHoldThisSession = const Value.absent(),
    this.bestExhaleSeconds = const Value.absent(),
    this.rounds = const Value.absent(),
    this.difficulty = const Value.absent(),
    this.durationMinutes = const Value.absent(),
    required DateTime completedAt,
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.deletedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       sessionType = Value(sessionType),
       completedAt = Value(completedAt);
  static Insertable<BreathTrainingLog> custom({
    Expression<String>? id,
    Expression<String>? sessionType,
    Expression<int>? totalHoldSeconds,
    Expression<int>? bestHoldThisSession,
    Expression<int>? bestExhaleSeconds,
    Expression<int>? rounds,
    Expression<String>? difficulty,
    Expression<int>? durationMinutes,
    Expression<DateTime>? completedAt,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
    Expression<DateTime>? deletedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (sessionType != null) 'session_type': sessionType,
      if (totalHoldSeconds != null) 'total_hold_seconds': totalHoldSeconds,
      if (bestHoldThisSession != null)
        'best_hold_this_session': bestHoldThisSession,
      if (bestExhaleSeconds != null) 'best_exhale_seconds': bestExhaleSeconds,
      if (rounds != null) 'rounds': rounds,
      if (difficulty != null) 'difficulty': difficulty,
      if (durationMinutes != null) 'duration_minutes': durationMinutes,
      if (completedAt != null) 'completed_at': completedAt,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (deletedAt != null) 'deleted_at': deletedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  BreathTrainingLogsCompanion copyWith({
    Value<String>? id,
    Value<String>? sessionType,
    Value<int?>? totalHoldSeconds,
    Value<int?>? bestHoldThisSession,
    Value<int?>? bestExhaleSeconds,
    Value<int?>? rounds,
    Value<String?>? difficulty,
    Value<int?>? durationMinutes,
    Value<DateTime>? completedAt,
    Value<DateTime>? createdAt,
    Value<DateTime>? updatedAt,
    Value<DateTime?>? deletedAt,
    Value<int>? rowid,
  }) {
    return BreathTrainingLogsCompanion(
      id: id ?? this.id,
      sessionType: sessionType ?? this.sessionType,
      totalHoldSeconds: totalHoldSeconds ?? this.totalHoldSeconds,
      bestHoldThisSession: bestHoldThisSession ?? this.bestHoldThisSession,
      bestExhaleSeconds: bestExhaleSeconds ?? this.bestExhaleSeconds,
      rounds: rounds ?? this.rounds,
      difficulty: difficulty ?? this.difficulty,
      durationMinutes: durationMinutes ?? this.durationMinutes,
      completedAt: completedAt ?? this.completedAt,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      deletedAt: deletedAt ?? this.deletedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (sessionType.present) {
      map['session_type'] = Variable<String>(sessionType.value);
    }
    if (totalHoldSeconds.present) {
      map['total_hold_seconds'] = Variable<int>(totalHoldSeconds.value);
    }
    if (bestHoldThisSession.present) {
      map['best_hold_this_session'] = Variable<int>(bestHoldThisSession.value);
    }
    if (bestExhaleSeconds.present) {
      map['best_exhale_seconds'] = Variable<int>(bestExhaleSeconds.value);
    }
    if (rounds.present) {
      map['rounds'] = Variable<int>(rounds.value);
    }
    if (difficulty.present) {
      map['difficulty'] = Variable<String>(difficulty.value);
    }
    if (durationMinutes.present) {
      map['duration_minutes'] = Variable<int>(durationMinutes.value);
    }
    if (completedAt.present) {
      map['completed_at'] = Variable<DateTime>(completedAt.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (deletedAt.present) {
      map['deleted_at'] = Variable<DateTime>(deletedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('BreathTrainingLogsCompanion(')
          ..write('id: $id, ')
          ..write('sessionType: $sessionType, ')
          ..write('totalHoldSeconds: $totalHoldSeconds, ')
          ..write('bestHoldThisSession: $bestHoldThisSession, ')
          ..write('bestExhaleSeconds: $bestExhaleSeconds, ')
          ..write('rounds: $rounds, ')
          ..write('difficulty: $difficulty, ')
          ..write('durationMinutes: $durationMinutes, ')
          ..write('completedAt: $completedAt, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('deletedAt: $deletedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $BreathHoldAwardsTable extends BreathHoldAwards
    with TableInfo<$BreathHoldAwardsTable, BreathHoldAward> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $BreathHoldAwardsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _secondsThresholdMeta = const VerificationMeta(
    'secondsThreshold',
  );
  @override
  late final GeneratedColumn<int> secondsThreshold = GeneratedColumn<int>(
    'seconds_threshold',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _titleMeta = const VerificationMeta('title');
  @override
  late final GeneratedColumn<String> title = GeneratedColumn<String>(
    'title',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _sessionLogIdMeta = const VerificationMeta(
    'sessionLogId',
  );
  @override
  late final GeneratedColumn<String> sessionLogId = GeneratedColumn<String>(
    'session_log_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES breath_training_logs (id)',
    ),
  );
  static const VerificationMeta _earnedAtMeta = const VerificationMeta(
    'earnedAt',
  );
  @override
  late final GeneratedColumn<DateTime> earnedAt = GeneratedColumn<DateTime>(
    'earned_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    secondsThreshold,
    title,
    sessionLogId,
    earnedAt,
    createdAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'breath_hold_awards';
  @override
  VerificationContext validateIntegrity(
    Insertable<BreathHoldAward> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('seconds_threshold')) {
      context.handle(
        _secondsThresholdMeta,
        secondsThreshold.isAcceptableOrUnknown(
          data['seconds_threshold']!,
          _secondsThresholdMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_secondsThresholdMeta);
    }
    if (data.containsKey('title')) {
      context.handle(
        _titleMeta,
        title.isAcceptableOrUnknown(data['title']!, _titleMeta),
      );
    } else if (isInserting) {
      context.missing(_titleMeta);
    }
    if (data.containsKey('session_log_id')) {
      context.handle(
        _sessionLogIdMeta,
        sessionLogId.isAcceptableOrUnknown(
          data['session_log_id']!,
          _sessionLogIdMeta,
        ),
      );
    }
    if (data.containsKey('earned_at')) {
      context.handle(
        _earnedAtMeta,
        earnedAt.isAcceptableOrUnknown(data['earned_at']!, _earnedAtMeta),
      );
    } else if (isInserting) {
      context.missing(_earnedAtMeta);
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  BreathHoldAward map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return BreathHoldAward(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      secondsThreshold: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}seconds_threshold'],
      )!,
      title: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}title'],
      )!,
      sessionLogId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}session_log_id'],
      ),
      earnedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}earned_at'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
    );
  }

  @override
  $BreathHoldAwardsTable createAlias(String alias) {
    return $BreathHoldAwardsTable(attachedDatabase, alias);
  }
}

class BreathHoldAward extends DataClass implements Insertable<BreathHoldAward> {
  final String id;
  final int secondsThreshold;
  final String title;
  final String? sessionLogId;
  final DateTime earnedAt;
  final DateTime createdAt;
  const BreathHoldAward({
    required this.id,
    required this.secondsThreshold,
    required this.title,
    this.sessionLogId,
    required this.earnedAt,
    required this.createdAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['seconds_threshold'] = Variable<int>(secondsThreshold);
    map['title'] = Variable<String>(title);
    if (!nullToAbsent || sessionLogId != null) {
      map['session_log_id'] = Variable<String>(sessionLogId);
    }
    map['earned_at'] = Variable<DateTime>(earnedAt);
    map['created_at'] = Variable<DateTime>(createdAt);
    return map;
  }

  BreathHoldAwardsCompanion toCompanion(bool nullToAbsent) {
    return BreathHoldAwardsCompanion(
      id: Value(id),
      secondsThreshold: Value(secondsThreshold),
      title: Value(title),
      sessionLogId: sessionLogId == null && nullToAbsent
          ? const Value.absent()
          : Value(sessionLogId),
      earnedAt: Value(earnedAt),
      createdAt: Value(createdAt),
    );
  }

  factory BreathHoldAward.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return BreathHoldAward(
      id: serializer.fromJson<String>(json['id']),
      secondsThreshold: serializer.fromJson<int>(json['secondsThreshold']),
      title: serializer.fromJson<String>(json['title']),
      sessionLogId: serializer.fromJson<String?>(json['sessionLogId']),
      earnedAt: serializer.fromJson<DateTime>(json['earnedAt']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'secondsThreshold': serializer.toJson<int>(secondsThreshold),
      'title': serializer.toJson<String>(title),
      'sessionLogId': serializer.toJson<String?>(sessionLogId),
      'earnedAt': serializer.toJson<DateTime>(earnedAt),
      'createdAt': serializer.toJson<DateTime>(createdAt),
    };
  }

  BreathHoldAward copyWith({
    String? id,
    int? secondsThreshold,
    String? title,
    Value<String?> sessionLogId = const Value.absent(),
    DateTime? earnedAt,
    DateTime? createdAt,
  }) => BreathHoldAward(
    id: id ?? this.id,
    secondsThreshold: secondsThreshold ?? this.secondsThreshold,
    title: title ?? this.title,
    sessionLogId: sessionLogId.present ? sessionLogId.value : this.sessionLogId,
    earnedAt: earnedAt ?? this.earnedAt,
    createdAt: createdAt ?? this.createdAt,
  );
  BreathHoldAward copyWithCompanion(BreathHoldAwardsCompanion data) {
    return BreathHoldAward(
      id: data.id.present ? data.id.value : this.id,
      secondsThreshold: data.secondsThreshold.present
          ? data.secondsThreshold.value
          : this.secondsThreshold,
      title: data.title.present ? data.title.value : this.title,
      sessionLogId: data.sessionLogId.present
          ? data.sessionLogId.value
          : this.sessionLogId,
      earnedAt: data.earnedAt.present ? data.earnedAt.value : this.earnedAt,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('BreathHoldAward(')
          ..write('id: $id, ')
          ..write('secondsThreshold: $secondsThreshold, ')
          ..write('title: $title, ')
          ..write('sessionLogId: $sessionLogId, ')
          ..write('earnedAt: $earnedAt, ')
          ..write('createdAt: $createdAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    secondsThreshold,
    title,
    sessionLogId,
    earnedAt,
    createdAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is BreathHoldAward &&
          other.id == this.id &&
          other.secondsThreshold == this.secondsThreshold &&
          other.title == this.title &&
          other.sessionLogId == this.sessionLogId &&
          other.earnedAt == this.earnedAt &&
          other.createdAt == this.createdAt);
}

class BreathHoldAwardsCompanion extends UpdateCompanion<BreathHoldAward> {
  final Value<String> id;
  final Value<int> secondsThreshold;
  final Value<String> title;
  final Value<String?> sessionLogId;
  final Value<DateTime> earnedAt;
  final Value<DateTime> createdAt;
  final Value<int> rowid;
  const BreathHoldAwardsCompanion({
    this.id = const Value.absent(),
    this.secondsThreshold = const Value.absent(),
    this.title = const Value.absent(),
    this.sessionLogId = const Value.absent(),
    this.earnedAt = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  BreathHoldAwardsCompanion.insert({
    required String id,
    required int secondsThreshold,
    required String title,
    this.sessionLogId = const Value.absent(),
    required DateTime earnedAt,
    this.createdAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       secondsThreshold = Value(secondsThreshold),
       title = Value(title),
       earnedAt = Value(earnedAt);
  static Insertable<BreathHoldAward> custom({
    Expression<String>? id,
    Expression<int>? secondsThreshold,
    Expression<String>? title,
    Expression<String>? sessionLogId,
    Expression<DateTime>? earnedAt,
    Expression<DateTime>? createdAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (secondsThreshold != null) 'seconds_threshold': secondsThreshold,
      if (title != null) 'title': title,
      if (sessionLogId != null) 'session_log_id': sessionLogId,
      if (earnedAt != null) 'earned_at': earnedAt,
      if (createdAt != null) 'created_at': createdAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  BreathHoldAwardsCompanion copyWith({
    Value<String>? id,
    Value<int>? secondsThreshold,
    Value<String>? title,
    Value<String?>? sessionLogId,
    Value<DateTime>? earnedAt,
    Value<DateTime>? createdAt,
    Value<int>? rowid,
  }) {
    return BreathHoldAwardsCompanion(
      id: id ?? this.id,
      secondsThreshold: secondsThreshold ?? this.secondsThreshold,
      title: title ?? this.title,
      sessionLogId: sessionLogId ?? this.sessionLogId,
      earnedAt: earnedAt ?? this.earnedAt,
      createdAt: createdAt ?? this.createdAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (secondsThreshold.present) {
      map['seconds_threshold'] = Variable<int>(secondsThreshold.value);
    }
    if (title.present) {
      map['title'] = Variable<String>(title.value);
    }
    if (sessionLogId.present) {
      map['session_log_id'] = Variable<String>(sessionLogId.value);
    }
    if (earnedAt.present) {
      map['earned_at'] = Variable<DateTime>(earnedAt.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('BreathHoldAwardsCompanion(')
          ..write('id: $id, ')
          ..write('secondsThreshold: $secondsThreshold, ')
          ..write('title: $title, ')
          ..write('sessionLogId: $sessionLogId, ')
          ..write('earnedAt: $earnedAt, ')
          ..write('createdAt: $createdAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $MilestonesTable extends Milestones
    with TableInfo<$MilestonesTable, Milestone> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $MilestonesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _dateMeta = const VerificationMeta('date');
  @override
  late final GeneratedColumn<DateTime> date = GeneratedColumn<DateTime>(
    'date',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _titleMeta = const VerificationMeta('title');
  @override
  late final GeneratedColumn<String> title = GeneratedColumn<String>(
    'title',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _descriptionMeta = const VerificationMeta(
    'description',
  );
  @override
  late final GeneratedColumn<String> description = GeneratedColumn<String>(
    'description',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _colorMeta = const VerificationMeta('color');
  @override
  late final GeneratedColumn<String> color = GeneratedColumn<String>(
    'color',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('#FFD700'),
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _deletedAtMeta = const VerificationMeta(
    'deletedAt',
  );
  @override
  late final GeneratedColumn<DateTime> deletedAt = GeneratedColumn<DateTime>(
    'deleted_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    date,
    title,
    description,
    color,
    createdAt,
    updatedAt,
    deletedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'milestones';
  @override
  VerificationContext validateIntegrity(
    Insertable<Milestone> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('date')) {
      context.handle(
        _dateMeta,
        date.isAcceptableOrUnknown(data['date']!, _dateMeta),
      );
    } else if (isInserting) {
      context.missing(_dateMeta);
    }
    if (data.containsKey('title')) {
      context.handle(
        _titleMeta,
        title.isAcceptableOrUnknown(data['title']!, _titleMeta),
      );
    } else if (isInserting) {
      context.missing(_titleMeta);
    }
    if (data.containsKey('description')) {
      context.handle(
        _descriptionMeta,
        description.isAcceptableOrUnknown(
          data['description']!,
          _descriptionMeta,
        ),
      );
    }
    if (data.containsKey('color')) {
      context.handle(
        _colorMeta,
        color.isAcceptableOrUnknown(data['color']!, _colorMeta),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    }
    if (data.containsKey('deleted_at')) {
      context.handle(
        _deletedAtMeta,
        deletedAt.isAcceptableOrUnknown(data['deleted_at']!, _deletedAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  Milestone map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Milestone(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      date: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}date'],
      )!,
      title: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}title'],
      )!,
      description: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}description'],
      ),
      color: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}color'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      )!,
      deletedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}deleted_at'],
      ),
    );
  }

  @override
  $MilestonesTable createAlias(String alias) {
    return $MilestonesTable(attachedDatabase, alias);
  }
}

class Milestone extends DataClass implements Insertable<Milestone> {
  final String id;
  final DateTime date;
  final String title;
  final String? description;
  final String color;
  final DateTime createdAt;
  final DateTime updatedAt;
  final DateTime? deletedAt;
  const Milestone({
    required this.id,
    required this.date,
    required this.title,
    this.description,
    required this.color,
    required this.createdAt,
    required this.updatedAt,
    this.deletedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['date'] = Variable<DateTime>(date);
    map['title'] = Variable<String>(title);
    if (!nullToAbsent || description != null) {
      map['description'] = Variable<String>(description);
    }
    map['color'] = Variable<String>(color);
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    if (!nullToAbsent || deletedAt != null) {
      map['deleted_at'] = Variable<DateTime>(deletedAt);
    }
    return map;
  }

  MilestonesCompanion toCompanion(bool nullToAbsent) {
    return MilestonesCompanion(
      id: Value(id),
      date: Value(date),
      title: Value(title),
      description: description == null && nullToAbsent
          ? const Value.absent()
          : Value(description),
      color: Value(color),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
      deletedAt: deletedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(deletedAt),
    );
  }

  factory Milestone.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Milestone(
      id: serializer.fromJson<String>(json['id']),
      date: serializer.fromJson<DateTime>(json['date']),
      title: serializer.fromJson<String>(json['title']),
      description: serializer.fromJson<String?>(json['description']),
      color: serializer.fromJson<String>(json['color']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
      deletedAt: serializer.fromJson<DateTime?>(json['deletedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'date': serializer.toJson<DateTime>(date),
      'title': serializer.toJson<String>(title),
      'description': serializer.toJson<String?>(description),
      'color': serializer.toJson<String>(color),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
      'deletedAt': serializer.toJson<DateTime?>(deletedAt),
    };
  }

  Milestone copyWith({
    String? id,
    DateTime? date,
    String? title,
    Value<String?> description = const Value.absent(),
    String? color,
    DateTime? createdAt,
    DateTime? updatedAt,
    Value<DateTime?> deletedAt = const Value.absent(),
  }) => Milestone(
    id: id ?? this.id,
    date: date ?? this.date,
    title: title ?? this.title,
    description: description.present ? description.value : this.description,
    color: color ?? this.color,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
    deletedAt: deletedAt.present ? deletedAt.value : this.deletedAt,
  );
  Milestone copyWithCompanion(MilestonesCompanion data) {
    return Milestone(
      id: data.id.present ? data.id.value : this.id,
      date: data.date.present ? data.date.value : this.date,
      title: data.title.present ? data.title.value : this.title,
      description: data.description.present
          ? data.description.value
          : this.description,
      color: data.color.present ? data.color.value : this.color,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
      deletedAt: data.deletedAt.present ? data.deletedAt.value : this.deletedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Milestone(')
          ..write('id: $id, ')
          ..write('date: $date, ')
          ..write('title: $title, ')
          ..write('description: $description, ')
          ..write('color: $color, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('deletedAt: $deletedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    date,
    title,
    description,
    color,
    createdAt,
    updatedAt,
    deletedAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Milestone &&
          other.id == this.id &&
          other.date == this.date &&
          other.title == this.title &&
          other.description == this.description &&
          other.color == this.color &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt &&
          other.deletedAt == this.deletedAt);
}

class MilestonesCompanion extends UpdateCompanion<Milestone> {
  final Value<String> id;
  final Value<DateTime> date;
  final Value<String> title;
  final Value<String?> description;
  final Value<String> color;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  final Value<DateTime?> deletedAt;
  final Value<int> rowid;
  const MilestonesCompanion({
    this.id = const Value.absent(),
    this.date = const Value.absent(),
    this.title = const Value.absent(),
    this.description = const Value.absent(),
    this.color = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.deletedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  MilestonesCompanion.insert({
    required String id,
    required DateTime date,
    required String title,
    this.description = const Value.absent(),
    this.color = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.deletedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       date = Value(date),
       title = Value(title);
  static Insertable<Milestone> custom({
    Expression<String>? id,
    Expression<DateTime>? date,
    Expression<String>? title,
    Expression<String>? description,
    Expression<String>? color,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
    Expression<DateTime>? deletedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (date != null) 'date': date,
      if (title != null) 'title': title,
      if (description != null) 'description': description,
      if (color != null) 'color': color,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (deletedAt != null) 'deleted_at': deletedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  MilestonesCompanion copyWith({
    Value<String>? id,
    Value<DateTime>? date,
    Value<String>? title,
    Value<String?>? description,
    Value<String>? color,
    Value<DateTime>? createdAt,
    Value<DateTime>? updatedAt,
    Value<DateTime?>? deletedAt,
    Value<int>? rowid,
  }) {
    return MilestonesCompanion(
      id: id ?? this.id,
      date: date ?? this.date,
      title: title ?? this.title,
      description: description ?? this.description,
      color: color ?? this.color,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      deletedAt: deletedAt ?? this.deletedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (date.present) {
      map['date'] = Variable<DateTime>(date.value);
    }
    if (title.present) {
      map['title'] = Variable<String>(title.value);
    }
    if (description.present) {
      map['description'] = Variable<String>(description.value);
    }
    if (color.present) {
      map['color'] = Variable<String>(color.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (deletedAt.present) {
      map['deleted_at'] = Variable<DateTime>(deletedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('MilestonesCompanion(')
          ..write('id: $id, ')
          ..write('date: $date, ')
          ..write('title: $title, ')
          ..write('description: $description, ')
          ..write('color: $color, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('deletedAt: $deletedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $VolumeImportsTable extends VolumeImports
    with TableInfo<$VolumeImportsTable, VolumeImport> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $VolumeImportsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _rawDataMeta = const VerificationMeta(
    'rawData',
  );
  @override
  late final GeneratedColumn<String> rawData = GeneratedColumn<String>(
    'raw_data',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _columnMappingMeta = const VerificationMeta(
    'columnMapping',
  );
  @override
  late final GeneratedColumn<String> columnMapping = GeneratedColumn<String>(
    'column_mapping',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _rowCountMeta = const VerificationMeta(
    'rowCount',
  );
  @override
  late final GeneratedColumn<int> rowCount = GeneratedColumn<int>(
    'row_count',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _importedCountMeta = const VerificationMeta(
    'importedCount',
  );
  @override
  late final GeneratedColumn<int> importedCount = GeneratedColumn<int>(
    'imported_count',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    name,
    rawData,
    columnMapping,
    rowCount,
    importedCount,
    createdAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'volume_imports';
  @override
  VerificationContext validateIntegrity(
    Insertable<VolumeImport> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('raw_data')) {
      context.handle(
        _rawDataMeta,
        rawData.isAcceptableOrUnknown(data['raw_data']!, _rawDataMeta),
      );
    } else if (isInserting) {
      context.missing(_rawDataMeta);
    }
    if (data.containsKey('column_mapping')) {
      context.handle(
        _columnMappingMeta,
        columnMapping.isAcceptableOrUnknown(
          data['column_mapping']!,
          _columnMappingMeta,
        ),
      );
    }
    if (data.containsKey('row_count')) {
      context.handle(
        _rowCountMeta,
        rowCount.isAcceptableOrUnknown(data['row_count']!, _rowCountMeta),
      );
    } else if (isInserting) {
      context.missing(_rowCountMeta);
    }
    if (data.containsKey('imported_count')) {
      context.handle(
        _importedCountMeta,
        importedCount.isAcceptableOrUnknown(
          data['imported_count']!,
          _importedCountMeta,
        ),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  VolumeImport map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return VolumeImport(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      rawData: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}raw_data'],
      )!,
      columnMapping: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}column_mapping'],
      ),
      rowCount: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}row_count'],
      )!,
      importedCount: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}imported_count'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
    );
  }

  @override
  $VolumeImportsTable createAlias(String alias) {
    return $VolumeImportsTable(attachedDatabase, alias);
  }
}

class VolumeImport extends DataClass implements Insertable<VolumeImport> {
  final String id;
  final String name;
  final String rawData;
  final String? columnMapping;
  final int rowCount;
  final int importedCount;
  final DateTime createdAt;
  const VolumeImport({
    required this.id,
    required this.name,
    required this.rawData,
    this.columnMapping,
    required this.rowCount,
    required this.importedCount,
    required this.createdAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['name'] = Variable<String>(name);
    map['raw_data'] = Variable<String>(rawData);
    if (!nullToAbsent || columnMapping != null) {
      map['column_mapping'] = Variable<String>(columnMapping);
    }
    map['row_count'] = Variable<int>(rowCount);
    map['imported_count'] = Variable<int>(importedCount);
    map['created_at'] = Variable<DateTime>(createdAt);
    return map;
  }

  VolumeImportsCompanion toCompanion(bool nullToAbsent) {
    return VolumeImportsCompanion(
      id: Value(id),
      name: Value(name),
      rawData: Value(rawData),
      columnMapping: columnMapping == null && nullToAbsent
          ? const Value.absent()
          : Value(columnMapping),
      rowCount: Value(rowCount),
      importedCount: Value(importedCount),
      createdAt: Value(createdAt),
    );
  }

  factory VolumeImport.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return VolumeImport(
      id: serializer.fromJson<String>(json['id']),
      name: serializer.fromJson<String>(json['name']),
      rawData: serializer.fromJson<String>(json['rawData']),
      columnMapping: serializer.fromJson<String?>(json['columnMapping']),
      rowCount: serializer.fromJson<int>(json['rowCount']),
      importedCount: serializer.fromJson<int>(json['importedCount']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'name': serializer.toJson<String>(name),
      'rawData': serializer.toJson<String>(rawData),
      'columnMapping': serializer.toJson<String?>(columnMapping),
      'rowCount': serializer.toJson<int>(rowCount),
      'importedCount': serializer.toJson<int>(importedCount),
      'createdAt': serializer.toJson<DateTime>(createdAt),
    };
  }

  VolumeImport copyWith({
    String? id,
    String? name,
    String? rawData,
    Value<String?> columnMapping = const Value.absent(),
    int? rowCount,
    int? importedCount,
    DateTime? createdAt,
  }) => VolumeImport(
    id: id ?? this.id,
    name: name ?? this.name,
    rawData: rawData ?? this.rawData,
    columnMapping: columnMapping.present
        ? columnMapping.value
        : this.columnMapping,
    rowCount: rowCount ?? this.rowCount,
    importedCount: importedCount ?? this.importedCount,
    createdAt: createdAt ?? this.createdAt,
  );
  VolumeImport copyWithCompanion(VolumeImportsCompanion data) {
    return VolumeImport(
      id: data.id.present ? data.id.value : this.id,
      name: data.name.present ? data.name.value : this.name,
      rawData: data.rawData.present ? data.rawData.value : this.rawData,
      columnMapping: data.columnMapping.present
          ? data.columnMapping.value
          : this.columnMapping,
      rowCount: data.rowCount.present ? data.rowCount.value : this.rowCount,
      importedCount: data.importedCount.present
          ? data.importedCount.value
          : this.importedCount,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('VolumeImport(')
          ..write('id: $id, ')
          ..write('name: $name, ')
          ..write('rawData: $rawData, ')
          ..write('columnMapping: $columnMapping, ')
          ..write('rowCount: $rowCount, ')
          ..write('importedCount: $importedCount, ')
          ..write('createdAt: $createdAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    name,
    rawData,
    columnMapping,
    rowCount,
    importedCount,
    createdAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is VolumeImport &&
          other.id == this.id &&
          other.name == this.name &&
          other.rawData == this.rawData &&
          other.columnMapping == this.columnMapping &&
          other.rowCount == this.rowCount &&
          other.importedCount == this.importedCount &&
          other.createdAt == this.createdAt);
}

class VolumeImportsCompanion extends UpdateCompanion<VolumeImport> {
  final Value<String> id;
  final Value<String> name;
  final Value<String> rawData;
  final Value<String?> columnMapping;
  final Value<int> rowCount;
  final Value<int> importedCount;
  final Value<DateTime> createdAt;
  final Value<int> rowid;
  const VolumeImportsCompanion({
    this.id = const Value.absent(),
    this.name = const Value.absent(),
    this.rawData = const Value.absent(),
    this.columnMapping = const Value.absent(),
    this.rowCount = const Value.absent(),
    this.importedCount = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  VolumeImportsCompanion.insert({
    required String id,
    required String name,
    required String rawData,
    this.columnMapping = const Value.absent(),
    required int rowCount,
    this.importedCount = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       name = Value(name),
       rawData = Value(rawData),
       rowCount = Value(rowCount);
  static Insertable<VolumeImport> custom({
    Expression<String>? id,
    Expression<String>? name,
    Expression<String>? rawData,
    Expression<String>? columnMapping,
    Expression<int>? rowCount,
    Expression<int>? importedCount,
    Expression<DateTime>? createdAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (name != null) 'name': name,
      if (rawData != null) 'raw_data': rawData,
      if (columnMapping != null) 'column_mapping': columnMapping,
      if (rowCount != null) 'row_count': rowCount,
      if (importedCount != null) 'imported_count': importedCount,
      if (createdAt != null) 'created_at': createdAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  VolumeImportsCompanion copyWith({
    Value<String>? id,
    Value<String>? name,
    Value<String>? rawData,
    Value<String?>? columnMapping,
    Value<int>? rowCount,
    Value<int>? importedCount,
    Value<DateTime>? createdAt,
    Value<int>? rowid,
  }) {
    return VolumeImportsCompanion(
      id: id ?? this.id,
      name: name ?? this.name,
      rawData: rawData ?? this.rawData,
      columnMapping: columnMapping ?? this.columnMapping,
      rowCount: rowCount ?? this.rowCount,
      importedCount: importedCount ?? this.importedCount,
      createdAt: createdAt ?? this.createdAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (rawData.present) {
      map['raw_data'] = Variable<String>(rawData.value);
    }
    if (columnMapping.present) {
      map['column_mapping'] = Variable<String>(columnMapping.value);
    }
    if (rowCount.present) {
      map['row_count'] = Variable<int>(rowCount.value);
    }
    if (importedCount.present) {
      map['imported_count'] = Variable<int>(importedCount.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('VolumeImportsCompanion(')
          ..write('id: $id, ')
          ..write('name: $name, ')
          ..write('rawData: $rawData, ')
          ..write('columnMapping: $columnMapping, ')
          ..write('rowCount: $rowCount, ')
          ..write('importedCount: $importedCount, ')
          ..write('createdAt: $createdAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $KitSnapshotsTable extends KitSnapshots
    with TableInfo<$KitSnapshotsTable, KitSnapshot> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $KitSnapshotsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _sessionIdMeta = const VerificationMeta(
    'sessionId',
  );
  @override
  late final GeneratedColumn<String> sessionId = GeneratedColumn<String>(
    'session_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _bowIdMeta = const VerificationMeta('bowId');
  @override
  late final GeneratedColumn<String> bowId = GeneratedColumn<String>(
    'bow_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _quiverIdMeta = const VerificationMeta(
    'quiverId',
  );
  @override
  late final GeneratedColumn<String> quiverId = GeneratedColumn<String>(
    'quiver_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _snapshotDateMeta = const VerificationMeta(
    'snapshotDate',
  );
  @override
  late final GeneratedColumn<DateTime> snapshotDate = GeneratedColumn<DateTime>(
    'snapshot_date',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _scoreMeta = const VerificationMeta('score');
  @override
  late final GeneratedColumn<int> score = GeneratedColumn<int>(
    'score',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _maxScoreMeta = const VerificationMeta(
    'maxScore',
  );
  @override
  late final GeneratedColumn<int> maxScore = GeneratedColumn<int>(
    'max_score',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _roundNameMeta = const VerificationMeta(
    'roundName',
  );
  @override
  late final GeneratedColumn<String> roundName = GeneratedColumn<String>(
    'round_name',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _reasonMeta = const VerificationMeta('reason');
  @override
  late final GeneratedColumn<String> reason = GeneratedColumn<String>(
    'reason',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _bowNameMeta = const VerificationMeta(
    'bowName',
  );
  @override
  late final GeneratedColumn<String> bowName = GeneratedColumn<String>(
    'bow_name',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _bowTypeMeta = const VerificationMeta(
    'bowType',
  );
  @override
  late final GeneratedColumn<String> bowType = GeneratedColumn<String>(
    'bow_type',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _bowSettingsMeta = const VerificationMeta(
    'bowSettings',
  );
  @override
  late final GeneratedColumn<String> bowSettings = GeneratedColumn<String>(
    'bow_settings',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _quiverNameMeta = const VerificationMeta(
    'quiverName',
  );
  @override
  late final GeneratedColumn<String> quiverName = GeneratedColumn<String>(
    'quiver_name',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _arrowSettingsMeta = const VerificationMeta(
    'arrowSettings',
  );
  @override
  late final GeneratedColumn<String> arrowSettings = GeneratedColumn<String>(
    'arrow_settings',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _notesMeta = const VerificationMeta('notes');
  @override
  late final GeneratedColumn<String> notes = GeneratedColumn<String>(
    'notes',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    sessionId,
    bowId,
    quiverId,
    snapshotDate,
    score,
    maxScore,
    roundName,
    reason,
    bowName,
    bowType,
    bowSettings,
    quiverName,
    arrowSettings,
    notes,
    createdAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'kit_snapshots';
  @override
  VerificationContext validateIntegrity(
    Insertable<KitSnapshot> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('session_id')) {
      context.handle(
        _sessionIdMeta,
        sessionId.isAcceptableOrUnknown(data['session_id']!, _sessionIdMeta),
      );
    }
    if (data.containsKey('bow_id')) {
      context.handle(
        _bowIdMeta,
        bowId.isAcceptableOrUnknown(data['bow_id']!, _bowIdMeta),
      );
    }
    if (data.containsKey('quiver_id')) {
      context.handle(
        _quiverIdMeta,
        quiverId.isAcceptableOrUnknown(data['quiver_id']!, _quiverIdMeta),
      );
    }
    if (data.containsKey('snapshot_date')) {
      context.handle(
        _snapshotDateMeta,
        snapshotDate.isAcceptableOrUnknown(
          data['snapshot_date']!,
          _snapshotDateMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_snapshotDateMeta);
    }
    if (data.containsKey('score')) {
      context.handle(
        _scoreMeta,
        score.isAcceptableOrUnknown(data['score']!, _scoreMeta),
      );
    }
    if (data.containsKey('max_score')) {
      context.handle(
        _maxScoreMeta,
        maxScore.isAcceptableOrUnknown(data['max_score']!, _maxScoreMeta),
      );
    }
    if (data.containsKey('round_name')) {
      context.handle(
        _roundNameMeta,
        roundName.isAcceptableOrUnknown(data['round_name']!, _roundNameMeta),
      );
    }
    if (data.containsKey('reason')) {
      context.handle(
        _reasonMeta,
        reason.isAcceptableOrUnknown(data['reason']!, _reasonMeta),
      );
    }
    if (data.containsKey('bow_name')) {
      context.handle(
        _bowNameMeta,
        bowName.isAcceptableOrUnknown(data['bow_name']!, _bowNameMeta),
      );
    }
    if (data.containsKey('bow_type')) {
      context.handle(
        _bowTypeMeta,
        bowType.isAcceptableOrUnknown(data['bow_type']!, _bowTypeMeta),
      );
    }
    if (data.containsKey('bow_settings')) {
      context.handle(
        _bowSettingsMeta,
        bowSettings.isAcceptableOrUnknown(
          data['bow_settings']!,
          _bowSettingsMeta,
        ),
      );
    }
    if (data.containsKey('quiver_name')) {
      context.handle(
        _quiverNameMeta,
        quiverName.isAcceptableOrUnknown(data['quiver_name']!, _quiverNameMeta),
      );
    }
    if (data.containsKey('arrow_settings')) {
      context.handle(
        _arrowSettingsMeta,
        arrowSettings.isAcceptableOrUnknown(
          data['arrow_settings']!,
          _arrowSettingsMeta,
        ),
      );
    }
    if (data.containsKey('notes')) {
      context.handle(
        _notesMeta,
        notes.isAcceptableOrUnknown(data['notes']!, _notesMeta),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  KitSnapshot map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return KitSnapshot(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      sessionId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}session_id'],
      ),
      bowId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}bow_id'],
      ),
      quiverId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}quiver_id'],
      ),
      snapshotDate: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}snapshot_date'],
      )!,
      score: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}score'],
      ),
      maxScore: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}max_score'],
      ),
      roundName: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}round_name'],
      ),
      reason: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}reason'],
      ),
      bowName: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}bow_name'],
      ),
      bowType: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}bow_type'],
      ),
      bowSettings: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}bow_settings'],
      ),
      quiverName: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}quiver_name'],
      ),
      arrowSettings: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}arrow_settings'],
      ),
      notes: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}notes'],
      ),
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
    );
  }

  @override
  $KitSnapshotsTable createAlias(String alias) {
    return $KitSnapshotsTable(attachedDatabase, alias);
  }
}

class KitSnapshot extends DataClass implements Insertable<KitSnapshot> {
  final String id;
  final String? sessionId;
  final String? bowId;
  final String? quiverId;
  final DateTime snapshotDate;
  final int? score;
  final int? maxScore;
  final String? roundName;
  final String? reason;
  final String? bowName;
  final String? bowType;
  final String? bowSettings;
  final String? quiverName;
  final String? arrowSettings;
  final String? notes;
  final DateTime createdAt;
  const KitSnapshot({
    required this.id,
    this.sessionId,
    this.bowId,
    this.quiverId,
    required this.snapshotDate,
    this.score,
    this.maxScore,
    this.roundName,
    this.reason,
    this.bowName,
    this.bowType,
    this.bowSettings,
    this.quiverName,
    this.arrowSettings,
    this.notes,
    required this.createdAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    if (!nullToAbsent || sessionId != null) {
      map['session_id'] = Variable<String>(sessionId);
    }
    if (!nullToAbsent || bowId != null) {
      map['bow_id'] = Variable<String>(bowId);
    }
    if (!nullToAbsent || quiverId != null) {
      map['quiver_id'] = Variable<String>(quiverId);
    }
    map['snapshot_date'] = Variable<DateTime>(snapshotDate);
    if (!nullToAbsent || score != null) {
      map['score'] = Variable<int>(score);
    }
    if (!nullToAbsent || maxScore != null) {
      map['max_score'] = Variable<int>(maxScore);
    }
    if (!nullToAbsent || roundName != null) {
      map['round_name'] = Variable<String>(roundName);
    }
    if (!nullToAbsent || reason != null) {
      map['reason'] = Variable<String>(reason);
    }
    if (!nullToAbsent || bowName != null) {
      map['bow_name'] = Variable<String>(bowName);
    }
    if (!nullToAbsent || bowType != null) {
      map['bow_type'] = Variable<String>(bowType);
    }
    if (!nullToAbsent || bowSettings != null) {
      map['bow_settings'] = Variable<String>(bowSettings);
    }
    if (!nullToAbsent || quiverName != null) {
      map['quiver_name'] = Variable<String>(quiverName);
    }
    if (!nullToAbsent || arrowSettings != null) {
      map['arrow_settings'] = Variable<String>(arrowSettings);
    }
    if (!nullToAbsent || notes != null) {
      map['notes'] = Variable<String>(notes);
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    return map;
  }

  KitSnapshotsCompanion toCompanion(bool nullToAbsent) {
    return KitSnapshotsCompanion(
      id: Value(id),
      sessionId: sessionId == null && nullToAbsent
          ? const Value.absent()
          : Value(sessionId),
      bowId: bowId == null && nullToAbsent
          ? const Value.absent()
          : Value(bowId),
      quiverId: quiverId == null && nullToAbsent
          ? const Value.absent()
          : Value(quiverId),
      snapshotDate: Value(snapshotDate),
      score: score == null && nullToAbsent
          ? const Value.absent()
          : Value(score),
      maxScore: maxScore == null && nullToAbsent
          ? const Value.absent()
          : Value(maxScore),
      roundName: roundName == null && nullToAbsent
          ? const Value.absent()
          : Value(roundName),
      reason: reason == null && nullToAbsent
          ? const Value.absent()
          : Value(reason),
      bowName: bowName == null && nullToAbsent
          ? const Value.absent()
          : Value(bowName),
      bowType: bowType == null && nullToAbsent
          ? const Value.absent()
          : Value(bowType),
      bowSettings: bowSettings == null && nullToAbsent
          ? const Value.absent()
          : Value(bowSettings),
      quiverName: quiverName == null && nullToAbsent
          ? const Value.absent()
          : Value(quiverName),
      arrowSettings: arrowSettings == null && nullToAbsent
          ? const Value.absent()
          : Value(arrowSettings),
      notes: notes == null && nullToAbsent
          ? const Value.absent()
          : Value(notes),
      createdAt: Value(createdAt),
    );
  }

  factory KitSnapshot.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return KitSnapshot(
      id: serializer.fromJson<String>(json['id']),
      sessionId: serializer.fromJson<String?>(json['sessionId']),
      bowId: serializer.fromJson<String?>(json['bowId']),
      quiverId: serializer.fromJson<String?>(json['quiverId']),
      snapshotDate: serializer.fromJson<DateTime>(json['snapshotDate']),
      score: serializer.fromJson<int?>(json['score']),
      maxScore: serializer.fromJson<int?>(json['maxScore']),
      roundName: serializer.fromJson<String?>(json['roundName']),
      reason: serializer.fromJson<String?>(json['reason']),
      bowName: serializer.fromJson<String?>(json['bowName']),
      bowType: serializer.fromJson<String?>(json['bowType']),
      bowSettings: serializer.fromJson<String?>(json['bowSettings']),
      quiverName: serializer.fromJson<String?>(json['quiverName']),
      arrowSettings: serializer.fromJson<String?>(json['arrowSettings']),
      notes: serializer.fromJson<String?>(json['notes']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'sessionId': serializer.toJson<String?>(sessionId),
      'bowId': serializer.toJson<String?>(bowId),
      'quiverId': serializer.toJson<String?>(quiverId),
      'snapshotDate': serializer.toJson<DateTime>(snapshotDate),
      'score': serializer.toJson<int?>(score),
      'maxScore': serializer.toJson<int?>(maxScore),
      'roundName': serializer.toJson<String?>(roundName),
      'reason': serializer.toJson<String?>(reason),
      'bowName': serializer.toJson<String?>(bowName),
      'bowType': serializer.toJson<String?>(bowType),
      'bowSettings': serializer.toJson<String?>(bowSettings),
      'quiverName': serializer.toJson<String?>(quiverName),
      'arrowSettings': serializer.toJson<String?>(arrowSettings),
      'notes': serializer.toJson<String?>(notes),
      'createdAt': serializer.toJson<DateTime>(createdAt),
    };
  }

  KitSnapshot copyWith({
    String? id,
    Value<String?> sessionId = const Value.absent(),
    Value<String?> bowId = const Value.absent(),
    Value<String?> quiverId = const Value.absent(),
    DateTime? snapshotDate,
    Value<int?> score = const Value.absent(),
    Value<int?> maxScore = const Value.absent(),
    Value<String?> roundName = const Value.absent(),
    Value<String?> reason = const Value.absent(),
    Value<String?> bowName = const Value.absent(),
    Value<String?> bowType = const Value.absent(),
    Value<String?> bowSettings = const Value.absent(),
    Value<String?> quiverName = const Value.absent(),
    Value<String?> arrowSettings = const Value.absent(),
    Value<String?> notes = const Value.absent(),
    DateTime? createdAt,
  }) => KitSnapshot(
    id: id ?? this.id,
    sessionId: sessionId.present ? sessionId.value : this.sessionId,
    bowId: bowId.present ? bowId.value : this.bowId,
    quiverId: quiverId.present ? quiverId.value : this.quiverId,
    snapshotDate: snapshotDate ?? this.snapshotDate,
    score: score.present ? score.value : this.score,
    maxScore: maxScore.present ? maxScore.value : this.maxScore,
    roundName: roundName.present ? roundName.value : this.roundName,
    reason: reason.present ? reason.value : this.reason,
    bowName: bowName.present ? bowName.value : this.bowName,
    bowType: bowType.present ? bowType.value : this.bowType,
    bowSettings: bowSettings.present ? bowSettings.value : this.bowSettings,
    quiverName: quiverName.present ? quiverName.value : this.quiverName,
    arrowSettings: arrowSettings.present
        ? arrowSettings.value
        : this.arrowSettings,
    notes: notes.present ? notes.value : this.notes,
    createdAt: createdAt ?? this.createdAt,
  );
  KitSnapshot copyWithCompanion(KitSnapshotsCompanion data) {
    return KitSnapshot(
      id: data.id.present ? data.id.value : this.id,
      sessionId: data.sessionId.present ? data.sessionId.value : this.sessionId,
      bowId: data.bowId.present ? data.bowId.value : this.bowId,
      quiverId: data.quiverId.present ? data.quiverId.value : this.quiverId,
      snapshotDate: data.snapshotDate.present
          ? data.snapshotDate.value
          : this.snapshotDate,
      score: data.score.present ? data.score.value : this.score,
      maxScore: data.maxScore.present ? data.maxScore.value : this.maxScore,
      roundName: data.roundName.present ? data.roundName.value : this.roundName,
      reason: data.reason.present ? data.reason.value : this.reason,
      bowName: data.bowName.present ? data.bowName.value : this.bowName,
      bowType: data.bowType.present ? data.bowType.value : this.bowType,
      bowSettings: data.bowSettings.present
          ? data.bowSettings.value
          : this.bowSettings,
      quiverName: data.quiverName.present
          ? data.quiverName.value
          : this.quiverName,
      arrowSettings: data.arrowSettings.present
          ? data.arrowSettings.value
          : this.arrowSettings,
      notes: data.notes.present ? data.notes.value : this.notes,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('KitSnapshot(')
          ..write('id: $id, ')
          ..write('sessionId: $sessionId, ')
          ..write('bowId: $bowId, ')
          ..write('quiverId: $quiverId, ')
          ..write('snapshotDate: $snapshotDate, ')
          ..write('score: $score, ')
          ..write('maxScore: $maxScore, ')
          ..write('roundName: $roundName, ')
          ..write('reason: $reason, ')
          ..write('bowName: $bowName, ')
          ..write('bowType: $bowType, ')
          ..write('bowSettings: $bowSettings, ')
          ..write('quiverName: $quiverName, ')
          ..write('arrowSettings: $arrowSettings, ')
          ..write('notes: $notes, ')
          ..write('createdAt: $createdAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    sessionId,
    bowId,
    quiverId,
    snapshotDate,
    score,
    maxScore,
    roundName,
    reason,
    bowName,
    bowType,
    bowSettings,
    quiverName,
    arrowSettings,
    notes,
    createdAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is KitSnapshot &&
          other.id == this.id &&
          other.sessionId == this.sessionId &&
          other.bowId == this.bowId &&
          other.quiverId == this.quiverId &&
          other.snapshotDate == this.snapshotDate &&
          other.score == this.score &&
          other.maxScore == this.maxScore &&
          other.roundName == this.roundName &&
          other.reason == this.reason &&
          other.bowName == this.bowName &&
          other.bowType == this.bowType &&
          other.bowSettings == this.bowSettings &&
          other.quiverName == this.quiverName &&
          other.arrowSettings == this.arrowSettings &&
          other.notes == this.notes &&
          other.createdAt == this.createdAt);
}

class KitSnapshotsCompanion extends UpdateCompanion<KitSnapshot> {
  final Value<String> id;
  final Value<String?> sessionId;
  final Value<String?> bowId;
  final Value<String?> quiverId;
  final Value<DateTime> snapshotDate;
  final Value<int?> score;
  final Value<int?> maxScore;
  final Value<String?> roundName;
  final Value<String?> reason;
  final Value<String?> bowName;
  final Value<String?> bowType;
  final Value<String?> bowSettings;
  final Value<String?> quiverName;
  final Value<String?> arrowSettings;
  final Value<String?> notes;
  final Value<DateTime> createdAt;
  final Value<int> rowid;
  const KitSnapshotsCompanion({
    this.id = const Value.absent(),
    this.sessionId = const Value.absent(),
    this.bowId = const Value.absent(),
    this.quiverId = const Value.absent(),
    this.snapshotDate = const Value.absent(),
    this.score = const Value.absent(),
    this.maxScore = const Value.absent(),
    this.roundName = const Value.absent(),
    this.reason = const Value.absent(),
    this.bowName = const Value.absent(),
    this.bowType = const Value.absent(),
    this.bowSettings = const Value.absent(),
    this.quiverName = const Value.absent(),
    this.arrowSettings = const Value.absent(),
    this.notes = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  KitSnapshotsCompanion.insert({
    required String id,
    this.sessionId = const Value.absent(),
    this.bowId = const Value.absent(),
    this.quiverId = const Value.absent(),
    required DateTime snapshotDate,
    this.score = const Value.absent(),
    this.maxScore = const Value.absent(),
    this.roundName = const Value.absent(),
    this.reason = const Value.absent(),
    this.bowName = const Value.absent(),
    this.bowType = const Value.absent(),
    this.bowSettings = const Value.absent(),
    this.quiverName = const Value.absent(),
    this.arrowSettings = const Value.absent(),
    this.notes = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       snapshotDate = Value(snapshotDate);
  static Insertable<KitSnapshot> custom({
    Expression<String>? id,
    Expression<String>? sessionId,
    Expression<String>? bowId,
    Expression<String>? quiverId,
    Expression<DateTime>? snapshotDate,
    Expression<int>? score,
    Expression<int>? maxScore,
    Expression<String>? roundName,
    Expression<String>? reason,
    Expression<String>? bowName,
    Expression<String>? bowType,
    Expression<String>? bowSettings,
    Expression<String>? quiverName,
    Expression<String>? arrowSettings,
    Expression<String>? notes,
    Expression<DateTime>? createdAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (sessionId != null) 'session_id': sessionId,
      if (bowId != null) 'bow_id': bowId,
      if (quiverId != null) 'quiver_id': quiverId,
      if (snapshotDate != null) 'snapshot_date': snapshotDate,
      if (score != null) 'score': score,
      if (maxScore != null) 'max_score': maxScore,
      if (roundName != null) 'round_name': roundName,
      if (reason != null) 'reason': reason,
      if (bowName != null) 'bow_name': bowName,
      if (bowType != null) 'bow_type': bowType,
      if (bowSettings != null) 'bow_settings': bowSettings,
      if (quiverName != null) 'quiver_name': quiverName,
      if (arrowSettings != null) 'arrow_settings': arrowSettings,
      if (notes != null) 'notes': notes,
      if (createdAt != null) 'created_at': createdAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  KitSnapshotsCompanion copyWith({
    Value<String>? id,
    Value<String?>? sessionId,
    Value<String?>? bowId,
    Value<String?>? quiverId,
    Value<DateTime>? snapshotDate,
    Value<int?>? score,
    Value<int?>? maxScore,
    Value<String?>? roundName,
    Value<String?>? reason,
    Value<String?>? bowName,
    Value<String?>? bowType,
    Value<String?>? bowSettings,
    Value<String?>? quiverName,
    Value<String?>? arrowSettings,
    Value<String?>? notes,
    Value<DateTime>? createdAt,
    Value<int>? rowid,
  }) {
    return KitSnapshotsCompanion(
      id: id ?? this.id,
      sessionId: sessionId ?? this.sessionId,
      bowId: bowId ?? this.bowId,
      quiverId: quiverId ?? this.quiverId,
      snapshotDate: snapshotDate ?? this.snapshotDate,
      score: score ?? this.score,
      maxScore: maxScore ?? this.maxScore,
      roundName: roundName ?? this.roundName,
      reason: reason ?? this.reason,
      bowName: bowName ?? this.bowName,
      bowType: bowType ?? this.bowType,
      bowSettings: bowSettings ?? this.bowSettings,
      quiverName: quiverName ?? this.quiverName,
      arrowSettings: arrowSettings ?? this.arrowSettings,
      notes: notes ?? this.notes,
      createdAt: createdAt ?? this.createdAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (sessionId.present) {
      map['session_id'] = Variable<String>(sessionId.value);
    }
    if (bowId.present) {
      map['bow_id'] = Variable<String>(bowId.value);
    }
    if (quiverId.present) {
      map['quiver_id'] = Variable<String>(quiverId.value);
    }
    if (snapshotDate.present) {
      map['snapshot_date'] = Variable<DateTime>(snapshotDate.value);
    }
    if (score.present) {
      map['score'] = Variable<int>(score.value);
    }
    if (maxScore.present) {
      map['max_score'] = Variable<int>(maxScore.value);
    }
    if (roundName.present) {
      map['round_name'] = Variable<String>(roundName.value);
    }
    if (reason.present) {
      map['reason'] = Variable<String>(reason.value);
    }
    if (bowName.present) {
      map['bow_name'] = Variable<String>(bowName.value);
    }
    if (bowType.present) {
      map['bow_type'] = Variable<String>(bowType.value);
    }
    if (bowSettings.present) {
      map['bow_settings'] = Variable<String>(bowSettings.value);
    }
    if (quiverName.present) {
      map['quiver_name'] = Variable<String>(quiverName.value);
    }
    if (arrowSettings.present) {
      map['arrow_settings'] = Variable<String>(arrowSettings.value);
    }
    if (notes.present) {
      map['notes'] = Variable<String>(notes.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('KitSnapshotsCompanion(')
          ..write('id: $id, ')
          ..write('sessionId: $sessionId, ')
          ..write('bowId: $bowId, ')
          ..write('quiverId: $quiverId, ')
          ..write('snapshotDate: $snapshotDate, ')
          ..write('score: $score, ')
          ..write('maxScore: $maxScore, ')
          ..write('roundName: $roundName, ')
          ..write('reason: $reason, ')
          ..write('bowName: $bowName, ')
          ..write('bowType: $bowType, ')
          ..write('bowSettings: $bowSettings, ')
          ..write('quiverName: $quiverName, ')
          ..write('arrowSettings: $arrowSettings, ')
          ..write('notes: $notes, ')
          ..write('createdAt: $createdAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $TuningSessionsTable extends TuningSessions
    with TableInfo<$TuningSessionsTable, TuningSession> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $TuningSessionsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _bowIdMeta = const VerificationMeta('bowId');
  @override
  late final GeneratedColumn<String> bowId = GeneratedColumn<String>(
    'bow_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES bows (id)',
    ),
  );
  static const VerificationMeta _dateMeta = const VerificationMeta('date');
  @override
  late final GeneratedColumn<DateTime> date = GeneratedColumn<DateTime>(
    'date',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _bowTypeMeta = const VerificationMeta(
    'bowType',
  );
  @override
  late final GeneratedColumn<String> bowType = GeneratedColumn<String>(
    'bow_type',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _tuningTypeMeta = const VerificationMeta(
    'tuningType',
  );
  @override
  late final GeneratedColumn<String> tuningType = GeneratedColumn<String>(
    'tuning_type',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _resultsMeta = const VerificationMeta(
    'results',
  );
  @override
  late final GeneratedColumn<String> results = GeneratedColumn<String>(
    'results',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _notesMeta = const VerificationMeta('notes');
  @override
  late final GeneratedColumn<String> notes = GeneratedColumn<String>(
    'notes',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    bowId,
    date,
    bowType,
    tuningType,
    results,
    notes,
    createdAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'tuning_sessions';
  @override
  VerificationContext validateIntegrity(
    Insertable<TuningSession> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('bow_id')) {
      context.handle(
        _bowIdMeta,
        bowId.isAcceptableOrUnknown(data['bow_id']!, _bowIdMeta),
      );
    }
    if (data.containsKey('date')) {
      context.handle(
        _dateMeta,
        date.isAcceptableOrUnknown(data['date']!, _dateMeta),
      );
    } else if (isInserting) {
      context.missing(_dateMeta);
    }
    if (data.containsKey('bow_type')) {
      context.handle(
        _bowTypeMeta,
        bowType.isAcceptableOrUnknown(data['bow_type']!, _bowTypeMeta),
      );
    } else if (isInserting) {
      context.missing(_bowTypeMeta);
    }
    if (data.containsKey('tuning_type')) {
      context.handle(
        _tuningTypeMeta,
        tuningType.isAcceptableOrUnknown(data['tuning_type']!, _tuningTypeMeta),
      );
    } else if (isInserting) {
      context.missing(_tuningTypeMeta);
    }
    if (data.containsKey('results')) {
      context.handle(
        _resultsMeta,
        results.isAcceptableOrUnknown(data['results']!, _resultsMeta),
      );
    }
    if (data.containsKey('notes')) {
      context.handle(
        _notesMeta,
        notes.isAcceptableOrUnknown(data['notes']!, _notesMeta),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  TuningSession map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return TuningSession(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      bowId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}bow_id'],
      ),
      date: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}date'],
      )!,
      bowType: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}bow_type'],
      )!,
      tuningType: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}tuning_type'],
      )!,
      results: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}results'],
      ),
      notes: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}notes'],
      ),
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
    );
  }

  @override
  $TuningSessionsTable createAlias(String alias) {
    return $TuningSessionsTable(attachedDatabase, alias);
  }
}

class TuningSession extends DataClass implements Insertable<TuningSession> {
  final String id;
  final String? bowId;
  final DateTime date;
  final String bowType;
  final String tuningType;
  final String? results;
  final String? notes;
  final DateTime createdAt;
  const TuningSession({
    required this.id,
    this.bowId,
    required this.date,
    required this.bowType,
    required this.tuningType,
    this.results,
    this.notes,
    required this.createdAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    if (!nullToAbsent || bowId != null) {
      map['bow_id'] = Variable<String>(bowId);
    }
    map['date'] = Variable<DateTime>(date);
    map['bow_type'] = Variable<String>(bowType);
    map['tuning_type'] = Variable<String>(tuningType);
    if (!nullToAbsent || results != null) {
      map['results'] = Variable<String>(results);
    }
    if (!nullToAbsent || notes != null) {
      map['notes'] = Variable<String>(notes);
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    return map;
  }

  TuningSessionsCompanion toCompanion(bool nullToAbsent) {
    return TuningSessionsCompanion(
      id: Value(id),
      bowId: bowId == null && nullToAbsent
          ? const Value.absent()
          : Value(bowId),
      date: Value(date),
      bowType: Value(bowType),
      tuningType: Value(tuningType),
      results: results == null && nullToAbsent
          ? const Value.absent()
          : Value(results),
      notes: notes == null && nullToAbsent
          ? const Value.absent()
          : Value(notes),
      createdAt: Value(createdAt),
    );
  }

  factory TuningSession.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return TuningSession(
      id: serializer.fromJson<String>(json['id']),
      bowId: serializer.fromJson<String?>(json['bowId']),
      date: serializer.fromJson<DateTime>(json['date']),
      bowType: serializer.fromJson<String>(json['bowType']),
      tuningType: serializer.fromJson<String>(json['tuningType']),
      results: serializer.fromJson<String?>(json['results']),
      notes: serializer.fromJson<String?>(json['notes']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'bowId': serializer.toJson<String?>(bowId),
      'date': serializer.toJson<DateTime>(date),
      'bowType': serializer.toJson<String>(bowType),
      'tuningType': serializer.toJson<String>(tuningType),
      'results': serializer.toJson<String?>(results),
      'notes': serializer.toJson<String?>(notes),
      'createdAt': serializer.toJson<DateTime>(createdAt),
    };
  }

  TuningSession copyWith({
    String? id,
    Value<String?> bowId = const Value.absent(),
    DateTime? date,
    String? bowType,
    String? tuningType,
    Value<String?> results = const Value.absent(),
    Value<String?> notes = const Value.absent(),
    DateTime? createdAt,
  }) => TuningSession(
    id: id ?? this.id,
    bowId: bowId.present ? bowId.value : this.bowId,
    date: date ?? this.date,
    bowType: bowType ?? this.bowType,
    tuningType: tuningType ?? this.tuningType,
    results: results.present ? results.value : this.results,
    notes: notes.present ? notes.value : this.notes,
    createdAt: createdAt ?? this.createdAt,
  );
  TuningSession copyWithCompanion(TuningSessionsCompanion data) {
    return TuningSession(
      id: data.id.present ? data.id.value : this.id,
      bowId: data.bowId.present ? data.bowId.value : this.bowId,
      date: data.date.present ? data.date.value : this.date,
      bowType: data.bowType.present ? data.bowType.value : this.bowType,
      tuningType: data.tuningType.present
          ? data.tuningType.value
          : this.tuningType,
      results: data.results.present ? data.results.value : this.results,
      notes: data.notes.present ? data.notes.value : this.notes,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('TuningSession(')
          ..write('id: $id, ')
          ..write('bowId: $bowId, ')
          ..write('date: $date, ')
          ..write('bowType: $bowType, ')
          ..write('tuningType: $tuningType, ')
          ..write('results: $results, ')
          ..write('notes: $notes, ')
          ..write('createdAt: $createdAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    bowId,
    date,
    bowType,
    tuningType,
    results,
    notes,
    createdAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is TuningSession &&
          other.id == this.id &&
          other.bowId == this.bowId &&
          other.date == this.date &&
          other.bowType == this.bowType &&
          other.tuningType == this.tuningType &&
          other.results == this.results &&
          other.notes == this.notes &&
          other.createdAt == this.createdAt);
}

class TuningSessionsCompanion extends UpdateCompanion<TuningSession> {
  final Value<String> id;
  final Value<String?> bowId;
  final Value<DateTime> date;
  final Value<String> bowType;
  final Value<String> tuningType;
  final Value<String?> results;
  final Value<String?> notes;
  final Value<DateTime> createdAt;
  final Value<int> rowid;
  const TuningSessionsCompanion({
    this.id = const Value.absent(),
    this.bowId = const Value.absent(),
    this.date = const Value.absent(),
    this.bowType = const Value.absent(),
    this.tuningType = const Value.absent(),
    this.results = const Value.absent(),
    this.notes = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  TuningSessionsCompanion.insert({
    required String id,
    this.bowId = const Value.absent(),
    required DateTime date,
    required String bowType,
    required String tuningType,
    this.results = const Value.absent(),
    this.notes = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       date = Value(date),
       bowType = Value(bowType),
       tuningType = Value(tuningType);
  static Insertable<TuningSession> custom({
    Expression<String>? id,
    Expression<String>? bowId,
    Expression<DateTime>? date,
    Expression<String>? bowType,
    Expression<String>? tuningType,
    Expression<String>? results,
    Expression<String>? notes,
    Expression<DateTime>? createdAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (bowId != null) 'bow_id': bowId,
      if (date != null) 'date': date,
      if (bowType != null) 'bow_type': bowType,
      if (tuningType != null) 'tuning_type': tuningType,
      if (results != null) 'results': results,
      if (notes != null) 'notes': notes,
      if (createdAt != null) 'created_at': createdAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  TuningSessionsCompanion copyWith({
    Value<String>? id,
    Value<String?>? bowId,
    Value<DateTime>? date,
    Value<String>? bowType,
    Value<String>? tuningType,
    Value<String?>? results,
    Value<String?>? notes,
    Value<DateTime>? createdAt,
    Value<int>? rowid,
  }) {
    return TuningSessionsCompanion(
      id: id ?? this.id,
      bowId: bowId ?? this.bowId,
      date: date ?? this.date,
      bowType: bowType ?? this.bowType,
      tuningType: tuningType ?? this.tuningType,
      results: results ?? this.results,
      notes: notes ?? this.notes,
      createdAt: createdAt ?? this.createdAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (bowId.present) {
      map['bow_id'] = Variable<String>(bowId.value);
    }
    if (date.present) {
      map['date'] = Variable<DateTime>(date.value);
    }
    if (bowType.present) {
      map['bow_type'] = Variable<String>(bowType.value);
    }
    if (tuningType.present) {
      map['tuning_type'] = Variable<String>(tuningType.value);
    }
    if (results.present) {
      map['results'] = Variable<String>(results.value);
    }
    if (notes.present) {
      map['notes'] = Variable<String>(notes.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('TuningSessionsCompanion(')
          ..write('id: $id, ')
          ..write('bowId: $bowId, ')
          ..write('date: $date, ')
          ..write('bowType: $bowType, ')
          ..write('tuningType: $tuningType, ')
          ..write('results: $results, ')
          ..write('notes: $notes, ')
          ..write('createdAt: $createdAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $SkillLevelsTable extends SkillLevels
    with TableInfo<$SkillLevelsTable, SkillLevel> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $SkillLevelsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _descriptionMeta = const VerificationMeta(
    'description',
  );
  @override
  late final GeneratedColumn<String> description = GeneratedColumn<String>(
    'description',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _currentLevelMeta = const VerificationMeta(
    'currentLevel',
  );
  @override
  late final GeneratedColumn<int> currentLevel = GeneratedColumn<int>(
    'current_level',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(1),
  );
  static const VerificationMeta _currentXpMeta = const VerificationMeta(
    'currentXp',
  );
  @override
  late final GeneratedColumn<int> currentXp = GeneratedColumn<int>(
    'current_xp',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _lastCelebratedLevelMeta = const VerificationMeta(
    'lastCelebratedLevel',
  );
  @override
  late final GeneratedColumn<int> lastCelebratedLevel = GeneratedColumn<int>(
    'last_celebrated_level',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(1),
  );
  static const VerificationMeta _lastLevelUpAtMeta = const VerificationMeta(
    'lastLevelUpAt',
  );
  @override
  late final GeneratedColumn<DateTime> lastLevelUpAt =
      GeneratedColumn<DateTime>(
        'last_level_up_at',
        aliasedName,
        true,
        type: DriftSqlType.dateTime,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    name,
    description,
    currentLevel,
    currentXp,
    lastCelebratedLevel,
    lastLevelUpAt,
    createdAt,
    updatedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'skill_levels';
  @override
  VerificationContext validateIntegrity(
    Insertable<SkillLevel> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('description')) {
      context.handle(
        _descriptionMeta,
        description.isAcceptableOrUnknown(
          data['description']!,
          _descriptionMeta,
        ),
      );
    }
    if (data.containsKey('current_level')) {
      context.handle(
        _currentLevelMeta,
        currentLevel.isAcceptableOrUnknown(
          data['current_level']!,
          _currentLevelMeta,
        ),
      );
    }
    if (data.containsKey('current_xp')) {
      context.handle(
        _currentXpMeta,
        currentXp.isAcceptableOrUnknown(data['current_xp']!, _currentXpMeta),
      );
    }
    if (data.containsKey('last_celebrated_level')) {
      context.handle(
        _lastCelebratedLevelMeta,
        lastCelebratedLevel.isAcceptableOrUnknown(
          data['last_celebrated_level']!,
          _lastCelebratedLevelMeta,
        ),
      );
    }
    if (data.containsKey('last_level_up_at')) {
      context.handle(
        _lastLevelUpAtMeta,
        lastLevelUpAt.isAcceptableOrUnknown(
          data['last_level_up_at']!,
          _lastLevelUpAtMeta,
        ),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  SkillLevel map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return SkillLevel(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      description: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}description'],
      ),
      currentLevel: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}current_level'],
      )!,
      currentXp: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}current_xp'],
      )!,
      lastCelebratedLevel: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}last_celebrated_level'],
      )!,
      lastLevelUpAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}last_level_up_at'],
      ),
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      )!,
    );
  }

  @override
  $SkillLevelsTable createAlias(String alias) {
    return $SkillLevelsTable(attachedDatabase, alias);
  }
}

class SkillLevel extends DataClass implements Insertable<SkillLevel> {
  final String id;
  final String name;
  final String? description;
  final int currentLevel;
  final int currentXp;
  final int lastCelebratedLevel;
  final DateTime? lastLevelUpAt;
  final DateTime createdAt;
  final DateTime updatedAt;
  const SkillLevel({
    required this.id,
    required this.name,
    this.description,
    required this.currentLevel,
    required this.currentXp,
    required this.lastCelebratedLevel,
    this.lastLevelUpAt,
    required this.createdAt,
    required this.updatedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['name'] = Variable<String>(name);
    if (!nullToAbsent || description != null) {
      map['description'] = Variable<String>(description);
    }
    map['current_level'] = Variable<int>(currentLevel);
    map['current_xp'] = Variable<int>(currentXp);
    map['last_celebrated_level'] = Variable<int>(lastCelebratedLevel);
    if (!nullToAbsent || lastLevelUpAt != null) {
      map['last_level_up_at'] = Variable<DateTime>(lastLevelUpAt);
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    return map;
  }

  SkillLevelsCompanion toCompanion(bool nullToAbsent) {
    return SkillLevelsCompanion(
      id: Value(id),
      name: Value(name),
      description: description == null && nullToAbsent
          ? const Value.absent()
          : Value(description),
      currentLevel: Value(currentLevel),
      currentXp: Value(currentXp),
      lastCelebratedLevel: Value(lastCelebratedLevel),
      lastLevelUpAt: lastLevelUpAt == null && nullToAbsent
          ? const Value.absent()
          : Value(lastLevelUpAt),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory SkillLevel.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return SkillLevel(
      id: serializer.fromJson<String>(json['id']),
      name: serializer.fromJson<String>(json['name']),
      description: serializer.fromJson<String?>(json['description']),
      currentLevel: serializer.fromJson<int>(json['currentLevel']),
      currentXp: serializer.fromJson<int>(json['currentXp']),
      lastCelebratedLevel: serializer.fromJson<int>(json['lastCelebratedLevel']),
      lastLevelUpAt: serializer.fromJson<DateTime?>(json['lastLevelUpAt']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'name': serializer.toJson<String>(name),
      'description': serializer.toJson<String?>(description),
      'currentLevel': serializer.toJson<int>(currentLevel),
      'currentXp': serializer.toJson<int>(currentXp),
      'lastCelebratedLevel': serializer.toJson<int>(lastCelebratedLevel),
      'lastLevelUpAt': serializer.toJson<DateTime?>(lastLevelUpAt),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
    };
  }

  SkillLevel copyWith({
    String? id,
    String? name,
    Value<String?> description = const Value.absent(),
    int? currentLevel,
    int? currentXp,
    int? lastCelebratedLevel,
    Value<DateTime?> lastLevelUpAt = const Value.absent(),
    DateTime? createdAt,
    DateTime? updatedAt,
  }) => SkillLevel(
    id: id ?? this.id,
    name: name ?? this.name,
    description: description.present ? description.value : this.description,
    currentLevel: currentLevel ?? this.currentLevel,
    currentXp: currentXp ?? this.currentXp,
    lastCelebratedLevel: lastCelebratedLevel ?? this.lastCelebratedLevel,
    lastLevelUpAt: lastLevelUpAt.present
        ? lastLevelUpAt.value
        : this.lastLevelUpAt,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
  );
  SkillLevel copyWithCompanion(SkillLevelsCompanion data) {
    return SkillLevel(
      id: data.id.present ? data.id.value : this.id,
      name: data.name.present ? data.name.value : this.name,
      description: data.description.present
          ? data.description.value
          : this.description,
      currentLevel: data.currentLevel.present
          ? data.currentLevel.value
          : this.currentLevel,
      currentXp: data.currentXp.present ? data.currentXp.value : this.currentXp,
      lastCelebratedLevel: data.lastCelebratedLevel.present
          ? data.lastCelebratedLevel.value
          : this.lastCelebratedLevel,
      lastLevelUpAt: data.lastLevelUpAt.present
          ? data.lastLevelUpAt.value
          : this.lastLevelUpAt,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('SkillLevel(')
          ..write('id: $id, ')
          ..write('name: $name, ')
          ..write('description: $description, ')
          ..write('currentLevel: $currentLevel, ')
          ..write('currentXp: $currentXp, ')
          ..write('lastCelebratedLevel: $lastCelebratedLevel, ')
          ..write('lastLevelUpAt: $lastLevelUpAt, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    name,
    description,
    currentLevel,
    currentXp,
    lastCelebratedLevel,
    lastLevelUpAt,
    createdAt,
    updatedAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is SkillLevel &&
          other.id == this.id &&
          other.name == this.name &&
          other.description == this.description &&
          other.currentLevel == this.currentLevel &&
          other.currentXp == this.currentXp &&
          other.lastCelebratedLevel == this.lastCelebratedLevel &&
          other.lastLevelUpAt == this.lastLevelUpAt &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class SkillLevelsCompanion extends UpdateCompanion<SkillLevel> {
  final Value<String> id;
  final Value<String> name;
  final Value<String?> description;
  final Value<int> currentLevel;
  final Value<int> currentXp;
  final Value<int> lastCelebratedLevel;
  final Value<DateTime?> lastLevelUpAt;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  final Value<int> rowid;
  const SkillLevelsCompanion({
    this.id = const Value.absent(),
    this.name = const Value.absent(),
    this.description = const Value.absent(),
    this.currentLevel = const Value.absent(),
    this.currentXp = const Value.absent(),
    this.lastCelebratedLevel = const Value.absent(),
    this.lastLevelUpAt = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  SkillLevelsCompanion.insert({
    required String id,
    required String name,
    this.description = const Value.absent(),
    this.currentLevel = const Value.absent(),
    this.currentXp = const Value.absent(),
    this.lastCelebratedLevel = const Value.absent(),
    this.lastLevelUpAt = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       name = Value(name);
  static Insertable<SkillLevel> custom({
    Expression<String>? id,
    Expression<String>? name,
    Expression<String>? description,
    Expression<int>? currentLevel,
    Expression<int>? currentXp,
    Expression<int>? lastCelebratedLevel,
    Expression<DateTime>? lastLevelUpAt,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (name != null) 'name': name,
      if (description != null) 'description': description,
      if (currentLevel != null) 'current_level': currentLevel,
      if (currentXp != null) 'current_xp': currentXp,
      if (lastCelebratedLevel != null) 'last_celebrated_level': lastCelebratedLevel,
      if (lastLevelUpAt != null) 'last_level_up_at': lastLevelUpAt,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  SkillLevelsCompanion copyWith({
    Value<String>? id,
    Value<String>? name,
    Value<String?>? description,
    Value<int>? currentLevel,
    Value<int>? currentXp,
    Value<int>? lastCelebratedLevel,
    Value<DateTime?>? lastLevelUpAt,
    Value<DateTime>? createdAt,
    Value<DateTime>? updatedAt,
    Value<int>? rowid,
  }) {
    return SkillLevelsCompanion(
      id: id ?? this.id,
      name: name ?? this.name,
      description: description ?? this.description,
      currentLevel: currentLevel ?? this.currentLevel,
      currentXp: currentXp ?? this.currentXp,
      lastCelebratedLevel: lastCelebratedLevel ?? this.lastCelebratedLevel,
      lastLevelUpAt: lastLevelUpAt ?? this.lastLevelUpAt,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (description.present) {
      map['description'] = Variable<String>(description.value);
    }
    if (currentLevel.present) {
      map['current_level'] = Variable<int>(currentLevel.value);
    }
    if (currentXp.present) {
      map['current_xp'] = Variable<int>(currentXp.value);
    }
    if (lastCelebratedLevel.present) {
      map['last_celebrated_level'] = Variable<int>(lastCelebratedLevel.value);
    }
    if (lastLevelUpAt.present) {
      map['last_level_up_at'] = Variable<DateTime>(lastLevelUpAt.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('SkillLevelsCompanion(')
          ..write('id: $id, ')
          ..write('name: $name, ')
          ..write('description: $description, ')
          ..write('currentLevel: $currentLevel, ')
          ..write('currentXp: $currentXp, ')
          ..write('lastCelebratedLevel: $lastCelebratedLevel, ')
          ..write('lastLevelUpAt: $lastLevelUpAt, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $XpHistoryTable extends XpHistory
    with TableInfo<$XpHistoryTable, XpHistoryData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $XpHistoryTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _skillIdMeta = const VerificationMeta(
    'skillId',
  );
  @override
  late final GeneratedColumn<String> skillId = GeneratedColumn<String>(
    'skill_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _xpAmountMeta = const VerificationMeta(
    'xpAmount',
  );
  @override
  late final GeneratedColumn<int> xpAmount = GeneratedColumn<int>(
    'xp_amount',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _sourceMeta = const VerificationMeta('source');
  @override
  late final GeneratedColumn<String> source = GeneratedColumn<String>(
    'source',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _sourceIdMeta = const VerificationMeta(
    'sourceId',
  );
  @override
  late final GeneratedColumn<String> sourceId = GeneratedColumn<String>(
    'source_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _reasonMeta = const VerificationMeta('reason');
  @override
  late final GeneratedColumn<String> reason = GeneratedColumn<String>(
    'reason',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _earnedAtMeta = const VerificationMeta(
    'earnedAt',
  );
  @override
  late final GeneratedColumn<DateTime> earnedAt = GeneratedColumn<DateTime>(
    'earned_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    skillId,
    xpAmount,
    source,
    sourceId,
    reason,
    earnedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'xp_history';
  @override
  VerificationContext validateIntegrity(
    Insertable<XpHistoryData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('skill_id')) {
      context.handle(
        _skillIdMeta,
        skillId.isAcceptableOrUnknown(data['skill_id']!, _skillIdMeta),
      );
    } else if (isInserting) {
      context.missing(_skillIdMeta);
    }
    if (data.containsKey('xp_amount')) {
      context.handle(
        _xpAmountMeta,
        xpAmount.isAcceptableOrUnknown(data['xp_amount']!, _xpAmountMeta),
      );
    } else if (isInserting) {
      context.missing(_xpAmountMeta);
    }
    if (data.containsKey('source')) {
      context.handle(
        _sourceMeta,
        source.isAcceptableOrUnknown(data['source']!, _sourceMeta),
      );
    } else if (isInserting) {
      context.missing(_sourceMeta);
    }
    if (data.containsKey('source_id')) {
      context.handle(
        _sourceIdMeta,
        sourceId.isAcceptableOrUnknown(data['source_id']!, _sourceIdMeta),
      );
    }
    if (data.containsKey('reason')) {
      context.handle(
        _reasonMeta,
        reason.isAcceptableOrUnknown(data['reason']!, _reasonMeta),
      );
    }
    if (data.containsKey('earned_at')) {
      context.handle(
        _earnedAtMeta,
        earnedAt.isAcceptableOrUnknown(data['earned_at']!, _earnedAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  XpHistoryData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return XpHistoryData(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      skillId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}skill_id'],
      )!,
      xpAmount: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}xp_amount'],
      )!,
      source: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}source'],
      )!,
      sourceId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}source_id'],
      ),
      reason: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}reason'],
      ),
      earnedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}earned_at'],
      )!,
    );
  }

  @override
  $XpHistoryTable createAlias(String alias) {
    return $XpHistoryTable(attachedDatabase, alias);
  }
}

class XpHistoryData extends DataClass implements Insertable<XpHistoryData> {
  final String id;
  final String skillId;
  final int xpAmount;
  final String source;
  final String? sourceId;
  final String? reason;
  final DateTime earnedAt;
  const XpHistoryData({
    required this.id,
    required this.skillId,
    required this.xpAmount,
    required this.source,
    this.sourceId,
    this.reason,
    required this.earnedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['skill_id'] = Variable<String>(skillId);
    map['xp_amount'] = Variable<int>(xpAmount);
    map['source'] = Variable<String>(source);
    if (!nullToAbsent || sourceId != null) {
      map['source_id'] = Variable<String>(sourceId);
    }
    if (!nullToAbsent || reason != null) {
      map['reason'] = Variable<String>(reason);
    }
    map['earned_at'] = Variable<DateTime>(earnedAt);
    return map;
  }

  XpHistoryCompanion toCompanion(bool nullToAbsent) {
    return XpHistoryCompanion(
      id: Value(id),
      skillId: Value(skillId),
      xpAmount: Value(xpAmount),
      source: Value(source),
      sourceId: sourceId == null && nullToAbsent
          ? const Value.absent()
          : Value(sourceId),
      reason: reason == null && nullToAbsent
          ? const Value.absent()
          : Value(reason),
      earnedAt: Value(earnedAt),
    );
  }

  factory XpHistoryData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return XpHistoryData(
      id: serializer.fromJson<String>(json['id']),
      skillId: serializer.fromJson<String>(json['skillId']),
      xpAmount: serializer.fromJson<int>(json['xpAmount']),
      source: serializer.fromJson<String>(json['source']),
      sourceId: serializer.fromJson<String?>(json['sourceId']),
      reason: serializer.fromJson<String?>(json['reason']),
      earnedAt: serializer.fromJson<DateTime>(json['earnedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'skillId': serializer.toJson<String>(skillId),
      'xpAmount': serializer.toJson<int>(xpAmount),
      'source': serializer.toJson<String>(source),
      'sourceId': serializer.toJson<String?>(sourceId),
      'reason': serializer.toJson<String?>(reason),
      'earnedAt': serializer.toJson<DateTime>(earnedAt),
    };
  }

  XpHistoryData copyWith({
    String? id,
    String? skillId,
    int? xpAmount,
    String? source,
    Value<String?> sourceId = const Value.absent(),
    Value<String?> reason = const Value.absent(),
    DateTime? earnedAt,
  }) => XpHistoryData(
    id: id ?? this.id,
    skillId: skillId ?? this.skillId,
    xpAmount: xpAmount ?? this.xpAmount,
    source: source ?? this.source,
    sourceId: sourceId.present ? sourceId.value : this.sourceId,
    reason: reason.present ? reason.value : this.reason,
    earnedAt: earnedAt ?? this.earnedAt,
  );
  XpHistoryData copyWithCompanion(XpHistoryCompanion data) {
    return XpHistoryData(
      id: data.id.present ? data.id.value : this.id,
      skillId: data.skillId.present ? data.skillId.value : this.skillId,
      xpAmount: data.xpAmount.present ? data.xpAmount.value : this.xpAmount,
      source: data.source.present ? data.source.value : this.source,
      sourceId: data.sourceId.present ? data.sourceId.value : this.sourceId,
      reason: data.reason.present ? data.reason.value : this.reason,
      earnedAt: data.earnedAt.present ? data.earnedAt.value : this.earnedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('XpHistoryData(')
          ..write('id: $id, ')
          ..write('skillId: $skillId, ')
          ..write('xpAmount: $xpAmount, ')
          ..write('source: $source, ')
          ..write('sourceId: $sourceId, ')
          ..write('reason: $reason, ')
          ..write('earnedAt: $earnedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(id, skillId, xpAmount, source, sourceId, reason, earnedAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is XpHistoryData &&
          other.id == this.id &&
          other.skillId == this.skillId &&
          other.xpAmount == this.xpAmount &&
          other.source == this.source &&
          other.sourceId == this.sourceId &&
          other.reason == this.reason &&
          other.earnedAt == this.earnedAt);
}

class XpHistoryCompanion extends UpdateCompanion<XpHistoryData> {
  final Value<String> id;
  final Value<String> skillId;
  final Value<int> xpAmount;
  final Value<String> source;
  final Value<String?> sourceId;
  final Value<String?> reason;
  final Value<DateTime> earnedAt;
  final Value<int> rowid;
  const XpHistoryCompanion({
    this.id = const Value.absent(),
    this.skillId = const Value.absent(),
    this.xpAmount = const Value.absent(),
    this.source = const Value.absent(),
    this.sourceId = const Value.absent(),
    this.reason = const Value.absent(),
    this.earnedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  XpHistoryCompanion.insert({
    required String id,
    required String skillId,
    required int xpAmount,
    required String source,
    this.sourceId = const Value.absent(),
    this.reason = const Value.absent(),
    this.earnedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       skillId = Value(skillId),
       xpAmount = Value(xpAmount),
       source = Value(source);
  static Insertable<XpHistoryData> custom({
    Expression<String>? id,
    Expression<String>? skillId,
    Expression<int>? xpAmount,
    Expression<String>? source,
    Expression<String>? sourceId,
    Expression<String>? reason,
    Expression<DateTime>? earnedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (skillId != null) 'skill_id': skillId,
      if (xpAmount != null) 'xp_amount': xpAmount,
      if (source != null) 'source': source,
      if (sourceId != null) 'source_id': sourceId,
      if (reason != null) 'reason': reason,
      if (earnedAt != null) 'earned_at': earnedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  XpHistoryCompanion copyWith({
    Value<String>? id,
    Value<String>? skillId,
    Value<int>? xpAmount,
    Value<String>? source,
    Value<String?>? sourceId,
    Value<String?>? reason,
    Value<DateTime>? earnedAt,
    Value<int>? rowid,
  }) {
    return XpHistoryCompanion(
      id: id ?? this.id,
      skillId: skillId ?? this.skillId,
      xpAmount: xpAmount ?? this.xpAmount,
      source: source ?? this.source,
      sourceId: sourceId ?? this.sourceId,
      reason: reason ?? this.reason,
      earnedAt: earnedAt ?? this.earnedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (skillId.present) {
      map['skill_id'] = Variable<String>(skillId.value);
    }
    if (xpAmount.present) {
      map['xp_amount'] = Variable<int>(xpAmount.value);
    }
    if (source.present) {
      map['source'] = Variable<String>(source.value);
    }
    if (sourceId.present) {
      map['source_id'] = Variable<String>(sourceId.value);
    }
    if (reason.present) {
      map['reason'] = Variable<String>(reason.value);
    }
    if (earnedAt.present) {
      map['earned_at'] = Variable<DateTime>(earnedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('XpHistoryCompanion(')
          ..write('id: $id, ')
          ..write('skillId: $skillId, ')
          ..write('xpAmount: $xpAmount, ')
          ..write('source: $source, ')
          ..write('sourceId: $sourceId, ')
          ..write('reason: $reason, ')
          ..write('earnedAt: $earnedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $SightMarksTable extends SightMarks
    with TableInfo<$SightMarksTable, SightMark> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $SightMarksTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _bowIdMeta = const VerificationMeta('bowId');
  @override
  late final GeneratedColumn<String> bowId = GeneratedColumn<String>(
    'bow_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES bows (id)',
    ),
  );
  static const VerificationMeta _distanceMeta = const VerificationMeta(
    'distance',
  );
  @override
  late final GeneratedColumn<double> distance = GeneratedColumn<double>(
    'distance',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _unitMeta = const VerificationMeta('unit');
  @override
  late final GeneratedColumn<String> unit = GeneratedColumn<String>(
    'unit',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('meters'),
  );
  static const VerificationMeta _sightValueMeta = const VerificationMeta(
    'sightValue',
  );
  @override
  late final GeneratedColumn<String> sightValue = GeneratedColumn<String>(
    'sight_value',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _weatherDataMeta = const VerificationMeta(
    'weatherData',
  );
  @override
  late final GeneratedColumn<String> weatherData = GeneratedColumn<String>(
    'weather_data',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _elevationDeltaMeta = const VerificationMeta(
    'elevationDelta',
  );
  @override
  late final GeneratedColumn<double> elevationDelta = GeneratedColumn<double>(
    'elevation_delta',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _slopeAngleMeta = const VerificationMeta(
    'slopeAngle',
  );
  @override
  late final GeneratedColumn<double> slopeAngle = GeneratedColumn<double>(
    'slope_angle',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _sessionIdMeta = const VerificationMeta(
    'sessionId',
  );
  @override
  late final GeneratedColumn<String> sessionId = GeneratedColumn<String>(
    'session_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _endNumberMeta = const VerificationMeta(
    'endNumber',
  );
  @override
  late final GeneratedColumn<int> endNumber = GeneratedColumn<int>(
    'end_number',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _shotCountMeta = const VerificationMeta(
    'shotCount',
  );
  @override
  late final GeneratedColumn<int> shotCount = GeneratedColumn<int>(
    'shot_count',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _confidenceScoreMeta = const VerificationMeta(
    'confidenceScore',
  );
  @override
  late final GeneratedColumn<double> confidenceScore = GeneratedColumn<double>(
    'confidence_score',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _venueIdMeta = const VerificationMeta(
    'venueId',
  );
  @override
  late final GeneratedColumn<String> venueId = GeneratedColumn<String>(
    'venue_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _isIndoorMeta = const VerificationMeta(
    'isIndoor',
  );
  @override
  late final GeneratedColumn<bool> isIndoor = GeneratedColumn<bool>(
    'is_indoor',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_indoor" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _recordedAtMeta = const VerificationMeta(
    'recordedAt',
  );
  @override
  late final GeneratedColumn<DateTime> recordedAt = GeneratedColumn<DateTime>(
    'recorded_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _deletedAtMeta = const VerificationMeta(
    'deletedAt',
  );
  @override
  late final GeneratedColumn<DateTime> deletedAt = GeneratedColumn<DateTime>(
    'deleted_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    bowId,
    distance,
    unit,
    sightValue,
    weatherData,
    elevationDelta,
    slopeAngle,
    sessionId,
    endNumber,
    shotCount,
    confidenceScore,
    venueId,
    isIndoor,
    recordedAt,
    updatedAt,
    deletedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'sight_marks';
  @override
  VerificationContext validateIntegrity(
    Insertable<SightMark> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('bow_id')) {
      context.handle(
        _bowIdMeta,
        bowId.isAcceptableOrUnknown(data['bow_id']!, _bowIdMeta),
      );
    } else if (isInserting) {
      context.missing(_bowIdMeta);
    }
    if (data.containsKey('distance')) {
      context.handle(
        _distanceMeta,
        distance.isAcceptableOrUnknown(data['distance']!, _distanceMeta),
      );
    } else if (isInserting) {
      context.missing(_distanceMeta);
    }
    if (data.containsKey('unit')) {
      context.handle(
        _unitMeta,
        unit.isAcceptableOrUnknown(data['unit']!, _unitMeta),
      );
    }
    if (data.containsKey('sight_value')) {
      context.handle(
        _sightValueMeta,
        sightValue.isAcceptableOrUnknown(data['sight_value']!, _sightValueMeta),
      );
    } else if (isInserting) {
      context.missing(_sightValueMeta);
    }
    if (data.containsKey('weather_data')) {
      context.handle(
        _weatherDataMeta,
        weatherData.isAcceptableOrUnknown(
          data['weather_data']!,
          _weatherDataMeta,
        ),
      );
    }
    if (data.containsKey('elevation_delta')) {
      context.handle(
        _elevationDeltaMeta,
        elevationDelta.isAcceptableOrUnknown(
          data['elevation_delta']!,
          _elevationDeltaMeta,
        ),
      );
    }
    if (data.containsKey('slope_angle')) {
      context.handle(
        _slopeAngleMeta,
        slopeAngle.isAcceptableOrUnknown(data['slope_angle']!, _slopeAngleMeta),
      );
    }
    if (data.containsKey('session_id')) {
      context.handle(
        _sessionIdMeta,
        sessionId.isAcceptableOrUnknown(data['session_id']!, _sessionIdMeta),
      );
    }
    if (data.containsKey('end_number')) {
      context.handle(
        _endNumberMeta,
        endNumber.isAcceptableOrUnknown(data['end_number']!, _endNumberMeta),
      );
    }
    if (data.containsKey('shot_count')) {
      context.handle(
        _shotCountMeta,
        shotCount.isAcceptableOrUnknown(data['shot_count']!, _shotCountMeta),
      );
    }
    if (data.containsKey('confidence_score')) {
      context.handle(
        _confidenceScoreMeta,
        confidenceScore.isAcceptableOrUnknown(
          data['confidence_score']!,
          _confidenceScoreMeta,
        ),
      );
    }
    if (data.containsKey('venue_id')) {
      context.handle(
        _venueIdMeta,
        venueId.isAcceptableOrUnknown(data['venue_id']!, _venueIdMeta),
      );
    }
    if (data.containsKey('is_indoor')) {
      context.handle(
        _isIndoorMeta,
        isIndoor.isAcceptableOrUnknown(data['is_indoor']!, _isIndoorMeta),
      );
    }
    if (data.containsKey('recorded_at')) {
      context.handle(
        _recordedAtMeta,
        recordedAt.isAcceptableOrUnknown(data['recorded_at']!, _recordedAtMeta),
      );
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    }
    if (data.containsKey('deleted_at')) {
      context.handle(
        _deletedAtMeta,
        deletedAt.isAcceptableOrUnknown(data['deleted_at']!, _deletedAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  SightMark map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return SightMark(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      bowId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}bow_id'],
      )!,
      distance: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}distance'],
      )!,
      unit: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}unit'],
      )!,
      sightValue: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}sight_value'],
      )!,
      weatherData: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}weather_data'],
      ),
      elevationDelta: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}elevation_delta'],
      ),
      slopeAngle: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}slope_angle'],
      ),
      sessionId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}session_id'],
      ),
      endNumber: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}end_number'],
      ),
      shotCount: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}shot_count'],
      ),
      confidenceScore: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}confidence_score'],
      ),
      venueId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}venue_id'],
      ),
      isIndoor: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_indoor'],
      )!,
      recordedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}recorded_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      ),
      deletedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}deleted_at'],
      ),
    );
  }

  @override
  $SightMarksTable createAlias(String alias) {
    return $SightMarksTable(attachedDatabase, alias);
  }
}

class SightMark extends DataClass implements Insertable<SightMark> {
  final String id;
  final String bowId;
  final double distance;
  final String unit;
  final String sightValue;
  final String? weatherData;
  final double? elevationDelta;
  final double? slopeAngle;
  final String? sessionId;
  final int? endNumber;
  final int? shotCount;
  final double? confidenceScore;
  final String? venueId;
  final bool isIndoor;
  final DateTime recordedAt;
  final DateTime? updatedAt;
  final DateTime? deletedAt;
  const SightMark({
    required this.id,
    required this.bowId,
    required this.distance,
    required this.unit,
    required this.sightValue,
    this.weatherData,
    this.elevationDelta,
    this.slopeAngle,
    this.sessionId,
    this.endNumber,
    this.shotCount,
    this.confidenceScore,
    this.venueId,
    required this.isIndoor,
    required this.recordedAt,
    this.updatedAt,
    this.deletedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['bow_id'] = Variable<String>(bowId);
    map['distance'] = Variable<double>(distance);
    map['unit'] = Variable<String>(unit);
    map['sight_value'] = Variable<String>(sightValue);
    if (!nullToAbsent || weatherData != null) {
      map['weather_data'] = Variable<String>(weatherData);
    }
    if (!nullToAbsent || elevationDelta != null) {
      map['elevation_delta'] = Variable<double>(elevationDelta);
    }
    if (!nullToAbsent || slopeAngle != null) {
      map['slope_angle'] = Variable<double>(slopeAngle);
    }
    if (!nullToAbsent || sessionId != null) {
      map['session_id'] = Variable<String>(sessionId);
    }
    if (!nullToAbsent || endNumber != null) {
      map['end_number'] = Variable<int>(endNumber);
    }
    if (!nullToAbsent || shotCount != null) {
      map['shot_count'] = Variable<int>(shotCount);
    }
    if (!nullToAbsent || confidenceScore != null) {
      map['confidence_score'] = Variable<double>(confidenceScore);
    }
    if (!nullToAbsent || venueId != null) {
      map['venue_id'] = Variable<String>(venueId);
    }
    map['is_indoor'] = Variable<bool>(isIndoor);
    map['recorded_at'] = Variable<DateTime>(recordedAt);
    if (!nullToAbsent || updatedAt != null) {
      map['updated_at'] = Variable<DateTime>(updatedAt);
    }
    if (!nullToAbsent || deletedAt != null) {
      map['deleted_at'] = Variable<DateTime>(deletedAt);
    }
    return map;
  }

  SightMarksCompanion toCompanion(bool nullToAbsent) {
    return SightMarksCompanion(
      id: Value(id),
      bowId: Value(bowId),
      distance: Value(distance),
      unit: Value(unit),
      sightValue: Value(sightValue),
      weatherData: weatherData == null && nullToAbsent
          ? const Value.absent()
          : Value(weatherData),
      elevationDelta: elevationDelta == null && nullToAbsent
          ? const Value.absent()
          : Value(elevationDelta),
      slopeAngle: slopeAngle == null && nullToAbsent
          ? const Value.absent()
          : Value(slopeAngle),
      sessionId: sessionId == null && nullToAbsent
          ? const Value.absent()
          : Value(sessionId),
      endNumber: endNumber == null && nullToAbsent
          ? const Value.absent()
          : Value(endNumber),
      shotCount: shotCount == null && nullToAbsent
          ? const Value.absent()
          : Value(shotCount),
      confidenceScore: confidenceScore == null && nullToAbsent
          ? const Value.absent()
          : Value(confidenceScore),
      venueId: venueId == null && nullToAbsent
          ? const Value.absent()
          : Value(venueId),
      isIndoor: Value(isIndoor),
      recordedAt: Value(recordedAt),
      updatedAt: updatedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(updatedAt),
      deletedAt: deletedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(deletedAt),
    );
  }

  factory SightMark.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return SightMark(
      id: serializer.fromJson<String>(json['id']),
      bowId: serializer.fromJson<String>(json['bowId']),
      distance: serializer.fromJson<double>(json['distance']),
      unit: serializer.fromJson<String>(json['unit']),
      sightValue: serializer.fromJson<String>(json['sightValue']),
      weatherData: serializer.fromJson<String?>(json['weatherData']),
      elevationDelta: serializer.fromJson<double?>(json['elevationDelta']),
      slopeAngle: serializer.fromJson<double?>(json['slopeAngle']),
      sessionId: serializer.fromJson<String?>(json['sessionId']),
      endNumber: serializer.fromJson<int?>(json['endNumber']),
      shotCount: serializer.fromJson<int?>(json['shotCount']),
      confidenceScore: serializer.fromJson<double?>(json['confidenceScore']),
      venueId: serializer.fromJson<String?>(json['venueId']),
      isIndoor: serializer.fromJson<bool>(json['isIndoor']),
      recordedAt: serializer.fromJson<DateTime>(json['recordedAt']),
      updatedAt: serializer.fromJson<DateTime?>(json['updatedAt']),
      deletedAt: serializer.fromJson<DateTime?>(json['deletedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'bowId': serializer.toJson<String>(bowId),
      'distance': serializer.toJson<double>(distance),
      'unit': serializer.toJson<String>(unit),
      'sightValue': serializer.toJson<String>(sightValue),
      'weatherData': serializer.toJson<String?>(weatherData),
      'elevationDelta': serializer.toJson<double?>(elevationDelta),
      'slopeAngle': serializer.toJson<double?>(slopeAngle),
      'sessionId': serializer.toJson<String?>(sessionId),
      'endNumber': serializer.toJson<int?>(endNumber),
      'shotCount': serializer.toJson<int?>(shotCount),
      'confidenceScore': serializer.toJson<double?>(confidenceScore),
      'venueId': serializer.toJson<String?>(venueId),
      'isIndoor': serializer.toJson<bool>(isIndoor),
      'recordedAt': serializer.toJson<DateTime>(recordedAt),
      'updatedAt': serializer.toJson<DateTime?>(updatedAt),
      'deletedAt': serializer.toJson<DateTime?>(deletedAt),
    };
  }

  SightMark copyWith({
    String? id,
    String? bowId,
    double? distance,
    String? unit,
    String? sightValue,
    Value<String?> weatherData = const Value.absent(),
    Value<double?> elevationDelta = const Value.absent(),
    Value<double?> slopeAngle = const Value.absent(),
    Value<String?> sessionId = const Value.absent(),
    Value<int?> endNumber = const Value.absent(),
    Value<int?> shotCount = const Value.absent(),
    Value<double?> confidenceScore = const Value.absent(),
    Value<String?> venueId = const Value.absent(),
    bool? isIndoor,
    DateTime? recordedAt,
    Value<DateTime?> updatedAt = const Value.absent(),
    Value<DateTime?> deletedAt = const Value.absent(),
  }) => SightMark(
    id: id ?? this.id,
    bowId: bowId ?? this.bowId,
    distance: distance ?? this.distance,
    unit: unit ?? this.unit,
    sightValue: sightValue ?? this.sightValue,
    weatherData: weatherData.present ? weatherData.value : this.weatherData,
    elevationDelta: elevationDelta.present
        ? elevationDelta.value
        : this.elevationDelta,
    slopeAngle: slopeAngle.present ? slopeAngle.value : this.slopeAngle,
    sessionId: sessionId.present ? sessionId.value : this.sessionId,
    endNumber: endNumber.present ? endNumber.value : this.endNumber,
    shotCount: shotCount.present ? shotCount.value : this.shotCount,
    confidenceScore: confidenceScore.present
        ? confidenceScore.value
        : this.confidenceScore,
    venueId: venueId.present ? venueId.value : this.venueId,
    isIndoor: isIndoor ?? this.isIndoor,
    recordedAt: recordedAt ?? this.recordedAt,
    updatedAt: updatedAt.present ? updatedAt.value : this.updatedAt,
    deletedAt: deletedAt.present ? deletedAt.value : this.deletedAt,
  );
  SightMark copyWithCompanion(SightMarksCompanion data) {
    return SightMark(
      id: data.id.present ? data.id.value : this.id,
      bowId: data.bowId.present ? data.bowId.value : this.bowId,
      distance: data.distance.present ? data.distance.value : this.distance,
      unit: data.unit.present ? data.unit.value : this.unit,
      sightValue: data.sightValue.present
          ? data.sightValue.value
          : this.sightValue,
      weatherData: data.weatherData.present
          ? data.weatherData.value
          : this.weatherData,
      elevationDelta: data.elevationDelta.present
          ? data.elevationDelta.value
          : this.elevationDelta,
      slopeAngle: data.slopeAngle.present
          ? data.slopeAngle.value
          : this.slopeAngle,
      sessionId: data.sessionId.present ? data.sessionId.value : this.sessionId,
      endNumber: data.endNumber.present ? data.endNumber.value : this.endNumber,
      shotCount: data.shotCount.present ? data.shotCount.value : this.shotCount,
      confidenceScore: data.confidenceScore.present
          ? data.confidenceScore.value
          : this.confidenceScore,
      venueId: data.venueId.present ? data.venueId.value : this.venueId,
      isIndoor: data.isIndoor.present ? data.isIndoor.value : this.isIndoor,
      recordedAt: data.recordedAt.present
          ? data.recordedAt.value
          : this.recordedAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
      deletedAt: data.deletedAt.present ? data.deletedAt.value : this.deletedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('SightMark(')
          ..write('id: $id, ')
          ..write('bowId: $bowId, ')
          ..write('distance: $distance, ')
          ..write('unit: $unit, ')
          ..write('sightValue: $sightValue, ')
          ..write('weatherData: $weatherData, ')
          ..write('elevationDelta: $elevationDelta, ')
          ..write('slopeAngle: $slopeAngle, ')
          ..write('sessionId: $sessionId, ')
          ..write('endNumber: $endNumber, ')
          ..write('shotCount: $shotCount, ')
          ..write('confidenceScore: $confidenceScore, ')
          ..write('venueId: $venueId, ')
          ..write('isIndoor: $isIndoor, ')
          ..write('recordedAt: $recordedAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('deletedAt: $deletedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    bowId,
    distance,
    unit,
    sightValue,
    weatherData,
    elevationDelta,
    slopeAngle,
    sessionId,
    endNumber,
    shotCount,
    confidenceScore,
    venueId,
    isIndoor,
    recordedAt,
    updatedAt,
    deletedAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is SightMark &&
          other.id == this.id &&
          other.bowId == this.bowId &&
          other.distance == this.distance &&
          other.unit == this.unit &&
          other.sightValue == this.sightValue &&
          other.weatherData == this.weatherData &&
          other.elevationDelta == this.elevationDelta &&
          other.slopeAngle == this.slopeAngle &&
          other.sessionId == this.sessionId &&
          other.endNumber == this.endNumber &&
          other.shotCount == this.shotCount &&
          other.confidenceScore == this.confidenceScore &&
          other.venueId == this.venueId &&
          other.isIndoor == this.isIndoor &&
          other.recordedAt == this.recordedAt &&
          other.updatedAt == this.updatedAt &&
          other.deletedAt == this.deletedAt);
}

class SightMarksCompanion extends UpdateCompanion<SightMark> {
  final Value<String> id;
  final Value<String> bowId;
  final Value<double> distance;
  final Value<String> unit;
  final Value<String> sightValue;
  final Value<String?> weatherData;
  final Value<double?> elevationDelta;
  final Value<double?> slopeAngle;
  final Value<String?> sessionId;
  final Value<int?> endNumber;
  final Value<int?> shotCount;
  final Value<double?> confidenceScore;
  final Value<String?> venueId;
  final Value<bool> isIndoor;
  final Value<DateTime> recordedAt;
  final Value<DateTime?> updatedAt;
  final Value<DateTime?> deletedAt;
  final Value<int> rowid;
  const SightMarksCompanion({
    this.id = const Value.absent(),
    this.bowId = const Value.absent(),
    this.distance = const Value.absent(),
    this.unit = const Value.absent(),
    this.sightValue = const Value.absent(),
    this.weatherData = const Value.absent(),
    this.elevationDelta = const Value.absent(),
    this.slopeAngle = const Value.absent(),
    this.sessionId = const Value.absent(),
    this.endNumber = const Value.absent(),
    this.shotCount = const Value.absent(),
    this.confidenceScore = const Value.absent(),
    this.venueId = const Value.absent(),
    this.isIndoor = const Value.absent(),
    this.recordedAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.deletedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  SightMarksCompanion.insert({
    required String id,
    required String bowId,
    required double distance,
    this.unit = const Value.absent(),
    required String sightValue,
    this.weatherData = const Value.absent(),
    this.elevationDelta = const Value.absent(),
    this.slopeAngle = const Value.absent(),
    this.sessionId = const Value.absent(),
    this.endNumber = const Value.absent(),
    this.shotCount = const Value.absent(),
    this.confidenceScore = const Value.absent(),
    this.venueId = const Value.absent(),
    this.isIndoor = const Value.absent(),
    this.recordedAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.deletedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       bowId = Value(bowId),
       distance = Value(distance),
       sightValue = Value(sightValue);
  static Insertable<SightMark> custom({
    Expression<String>? id,
    Expression<String>? bowId,
    Expression<double>? distance,
    Expression<String>? unit,
    Expression<String>? sightValue,
    Expression<String>? weatherData,
    Expression<double>? elevationDelta,
    Expression<double>? slopeAngle,
    Expression<String>? sessionId,
    Expression<int>? endNumber,
    Expression<int>? shotCount,
    Expression<double>? confidenceScore,
    Expression<String>? venueId,
    Expression<bool>? isIndoor,
    Expression<DateTime>? recordedAt,
    Expression<DateTime>? updatedAt,
    Expression<DateTime>? deletedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (bowId != null) 'bow_id': bowId,
      if (distance != null) 'distance': distance,
      if (unit != null) 'unit': unit,
      if (sightValue != null) 'sight_value': sightValue,
      if (weatherData != null) 'weather_data': weatherData,
      if (elevationDelta != null) 'elevation_delta': elevationDelta,
      if (slopeAngle != null) 'slope_angle': slopeAngle,
      if (sessionId != null) 'session_id': sessionId,
      if (endNumber != null) 'end_number': endNumber,
      if (shotCount != null) 'shot_count': shotCount,
      if (confidenceScore != null) 'confidence_score': confidenceScore,
      if (venueId != null) 'venue_id': venueId,
      if (isIndoor != null) 'is_indoor': isIndoor,
      if (recordedAt != null) 'recorded_at': recordedAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (deletedAt != null) 'deleted_at': deletedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  SightMarksCompanion copyWith({
    Value<String>? id,
    Value<String>? bowId,
    Value<double>? distance,
    Value<String>? unit,
    Value<String>? sightValue,
    Value<String?>? weatherData,
    Value<double?>? elevationDelta,
    Value<double?>? slopeAngle,
    Value<String?>? sessionId,
    Value<int?>? endNumber,
    Value<int?>? shotCount,
    Value<double?>? confidenceScore,
    Value<String?>? venueId,
    Value<bool>? isIndoor,
    Value<DateTime>? recordedAt,
    Value<DateTime?>? updatedAt,
    Value<DateTime?>? deletedAt,
    Value<int>? rowid,
  }) {
    return SightMarksCompanion(
      id: id ?? this.id,
      bowId: bowId ?? this.bowId,
      distance: distance ?? this.distance,
      unit: unit ?? this.unit,
      sightValue: sightValue ?? this.sightValue,
      weatherData: weatherData ?? this.weatherData,
      elevationDelta: elevationDelta ?? this.elevationDelta,
      slopeAngle: slopeAngle ?? this.slopeAngle,
      sessionId: sessionId ?? this.sessionId,
      endNumber: endNumber ?? this.endNumber,
      shotCount: shotCount ?? this.shotCount,
      confidenceScore: confidenceScore ?? this.confidenceScore,
      venueId: venueId ?? this.venueId,
      isIndoor: isIndoor ?? this.isIndoor,
      recordedAt: recordedAt ?? this.recordedAt,
      updatedAt: updatedAt ?? this.updatedAt,
      deletedAt: deletedAt ?? this.deletedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (bowId.present) {
      map['bow_id'] = Variable<String>(bowId.value);
    }
    if (distance.present) {
      map['distance'] = Variable<double>(distance.value);
    }
    if (unit.present) {
      map['unit'] = Variable<String>(unit.value);
    }
    if (sightValue.present) {
      map['sight_value'] = Variable<String>(sightValue.value);
    }
    if (weatherData.present) {
      map['weather_data'] = Variable<String>(weatherData.value);
    }
    if (elevationDelta.present) {
      map['elevation_delta'] = Variable<double>(elevationDelta.value);
    }
    if (slopeAngle.present) {
      map['slope_angle'] = Variable<double>(slopeAngle.value);
    }
    if (sessionId.present) {
      map['session_id'] = Variable<String>(sessionId.value);
    }
    if (endNumber.present) {
      map['end_number'] = Variable<int>(endNumber.value);
    }
    if (shotCount.present) {
      map['shot_count'] = Variable<int>(shotCount.value);
    }
    if (confidenceScore.present) {
      map['confidence_score'] = Variable<double>(confidenceScore.value);
    }
    if (venueId.present) {
      map['venue_id'] = Variable<String>(venueId.value);
    }
    if (isIndoor.present) {
      map['is_indoor'] = Variable<bool>(isIndoor.value);
    }
    if (recordedAt.present) {
      map['recorded_at'] = Variable<DateTime>(recordedAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (deletedAt.present) {
      map['deleted_at'] = Variable<DateTime>(deletedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('SightMarksCompanion(')
          ..write('id: $id, ')
          ..write('bowId: $bowId, ')
          ..write('distance: $distance, ')
          ..write('unit: $unit, ')
          ..write('sightValue: $sightValue, ')
          ..write('weatherData: $weatherData, ')
          ..write('elevationDelta: $elevationDelta, ')
          ..write('slopeAngle: $slopeAngle, ')
          ..write('sessionId: $sessionId, ')
          ..write('endNumber: $endNumber, ')
          ..write('shotCount: $shotCount, ')
          ..write('confidenceScore: $confidenceScore, ')
          ..write('venueId: $venueId, ')
          ..write('isIndoor: $isIndoor, ')
          ..write('recordedAt: $recordedAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('deletedAt: $deletedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $SightMarkPreferencesTableTable extends SightMarkPreferencesTable
    with
        TableInfo<
          $SightMarkPreferencesTableTable,
          SightMarkPreferencesTableData
        > {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $SightMarkPreferencesTableTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _bowIdMeta = const VerificationMeta('bowId');
  @override
  late final GeneratedColumn<String> bowId = GeneratedColumn<String>(
    'bow_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES bows (id)',
    ),
  );
  static const VerificationMeta _notationStyleMeta = const VerificationMeta(
    'notationStyle',
  );
  @override
  late final GeneratedColumn<String> notationStyle = GeneratedColumn<String>(
    'notation_style',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('decimal'),
  );
  static const VerificationMeta _decimalPlacesMeta = const VerificationMeta(
    'decimalPlaces',
  );
  @override
  late final GeneratedColumn<int> decimalPlaces = GeneratedColumn<int>(
    'decimal_places',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(2),
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [
    bowId,
    notationStyle,
    decimalPlaces,
    createdAt,
    updatedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'sight_mark_preferences_table';
  @override
  VerificationContext validateIntegrity(
    Insertable<SightMarkPreferencesTableData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('bow_id')) {
      context.handle(
        _bowIdMeta,
        bowId.isAcceptableOrUnknown(data['bow_id']!, _bowIdMeta),
      );
    } else if (isInserting) {
      context.missing(_bowIdMeta);
    }
    if (data.containsKey('notation_style')) {
      context.handle(
        _notationStyleMeta,
        notationStyle.isAcceptableOrUnknown(
          data['notation_style']!,
          _notationStyleMeta,
        ),
      );
    }
    if (data.containsKey('decimal_places')) {
      context.handle(
        _decimalPlacesMeta,
        decimalPlaces.isAcceptableOrUnknown(
          data['decimal_places']!,
          _decimalPlacesMeta,
        ),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {bowId};
  @override
  SightMarkPreferencesTableData map(
    Map<String, dynamic> data, {
    String? tablePrefix,
  }) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return SightMarkPreferencesTableData(
      bowId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}bow_id'],
      )!,
      notationStyle: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}notation_style'],
      )!,
      decimalPlaces: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}decimal_places'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      ),
    );
  }

  @override
  $SightMarkPreferencesTableTable createAlias(String alias) {
    return $SightMarkPreferencesTableTable(attachedDatabase, alias);
  }
}

class SightMarkPreferencesTableData extends DataClass
    implements Insertable<SightMarkPreferencesTableData> {
  final String bowId;
  final String notationStyle;
  final int decimalPlaces;
  final DateTime createdAt;
  final DateTime? updatedAt;
  const SightMarkPreferencesTableData({
    required this.bowId,
    required this.notationStyle,
    required this.decimalPlaces,
    required this.createdAt,
    this.updatedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['bow_id'] = Variable<String>(bowId);
    map['notation_style'] = Variable<String>(notationStyle);
    map['decimal_places'] = Variable<int>(decimalPlaces);
    map['created_at'] = Variable<DateTime>(createdAt);
    if (!nullToAbsent || updatedAt != null) {
      map['updated_at'] = Variable<DateTime>(updatedAt);
    }
    return map;
  }

  SightMarkPreferencesTableCompanion toCompanion(bool nullToAbsent) {
    return SightMarkPreferencesTableCompanion(
      bowId: Value(bowId),
      notationStyle: Value(notationStyle),
      decimalPlaces: Value(decimalPlaces),
      createdAt: Value(createdAt),
      updatedAt: updatedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(updatedAt),
    );
  }

  factory SightMarkPreferencesTableData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return SightMarkPreferencesTableData(
      bowId: serializer.fromJson<String>(json['bowId']),
      notationStyle: serializer.fromJson<String>(json['notationStyle']),
      decimalPlaces: serializer.fromJson<int>(json['decimalPlaces']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime?>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'bowId': serializer.toJson<String>(bowId),
      'notationStyle': serializer.toJson<String>(notationStyle),
      'decimalPlaces': serializer.toJson<int>(decimalPlaces),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime?>(updatedAt),
    };
  }

  SightMarkPreferencesTableData copyWith({
    String? bowId,
    String? notationStyle,
    int? decimalPlaces,
    DateTime? createdAt,
    Value<DateTime?> updatedAt = const Value.absent(),
  }) => SightMarkPreferencesTableData(
    bowId: bowId ?? this.bowId,
    notationStyle: notationStyle ?? this.notationStyle,
    decimalPlaces: decimalPlaces ?? this.decimalPlaces,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt.present ? updatedAt.value : this.updatedAt,
  );
  SightMarkPreferencesTableData copyWithCompanion(
    SightMarkPreferencesTableCompanion data,
  ) {
    return SightMarkPreferencesTableData(
      bowId: data.bowId.present ? data.bowId.value : this.bowId,
      notationStyle: data.notationStyle.present
          ? data.notationStyle.value
          : this.notationStyle,
      decimalPlaces: data.decimalPlaces.present
          ? data.decimalPlaces.value
          : this.decimalPlaces,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('SightMarkPreferencesTableData(')
          ..write('bowId: $bowId, ')
          ..write('notationStyle: $notationStyle, ')
          ..write('decimalPlaces: $decimalPlaces, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(bowId, notationStyle, decimalPlaces, createdAt, updatedAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is SightMarkPreferencesTableData &&
          other.bowId == this.bowId &&
          other.notationStyle == this.notationStyle &&
          other.decimalPlaces == this.decimalPlaces &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class SightMarkPreferencesTableCompanion
    extends UpdateCompanion<SightMarkPreferencesTableData> {
  final Value<String> bowId;
  final Value<String> notationStyle;
  final Value<int> decimalPlaces;
  final Value<DateTime> createdAt;
  final Value<DateTime?> updatedAt;
  final Value<int> rowid;
  const SightMarkPreferencesTableCompanion({
    this.bowId = const Value.absent(),
    this.notationStyle = const Value.absent(),
    this.decimalPlaces = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  SightMarkPreferencesTableCompanion.insert({
    required String bowId,
    this.notationStyle = const Value.absent(),
    this.decimalPlaces = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : bowId = Value(bowId);
  static Insertable<SightMarkPreferencesTableData> custom({
    Expression<String>? bowId,
    Expression<String>? notationStyle,
    Expression<int>? decimalPlaces,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (bowId != null) 'bow_id': bowId,
      if (notationStyle != null) 'notation_style': notationStyle,
      if (decimalPlaces != null) 'decimal_places': decimalPlaces,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  SightMarkPreferencesTableCompanion copyWith({
    Value<String>? bowId,
    Value<String>? notationStyle,
    Value<int>? decimalPlaces,
    Value<DateTime>? createdAt,
    Value<DateTime?>? updatedAt,
    Value<int>? rowid,
  }) {
    return SightMarkPreferencesTableCompanion(
      bowId: bowId ?? this.bowId,
      notationStyle: notationStyle ?? this.notationStyle,
      decimalPlaces: decimalPlaces ?? this.decimalPlaces,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (bowId.present) {
      map['bow_id'] = Variable<String>(bowId.value);
    }
    if (notationStyle.present) {
      map['notation_style'] = Variable<String>(notationStyle.value);
    }
    if (decimalPlaces.present) {
      map['decimal_places'] = Variable<int>(decimalPlaces.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('SightMarkPreferencesTableCompanion(')
          ..write('bowId: $bowId, ')
          ..write('notationStyle: $notationStyle, ')
          ..write('decimalPlaces: $decimalPlaces, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $AngleCorrectionProfilesTable extends AngleCorrectionProfiles
    with TableInfo<$AngleCorrectionProfilesTable, AngleCorrectionProfile> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $AngleCorrectionProfilesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _bowIdMeta = const VerificationMeta('bowId');
  @override
  late final GeneratedColumn<String> bowId = GeneratedColumn<String>(
    'bow_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES bows (id)',
    ),
  );
  static const VerificationMeta _arrowSpeedFpsMeta = const VerificationMeta(
    'arrowSpeedFps',
  );
  @override
  late final GeneratedColumn<double> arrowSpeedFps = GeneratedColumn<double>(
    'arrow_speed_fps',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _uphillFactorMeta = const VerificationMeta(
    'uphillFactor',
  );
  @override
  late final GeneratedColumn<double> uphillFactor = GeneratedColumn<double>(
    'uphill_factor',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _downhillFactorMeta = const VerificationMeta(
    'downhillFactor',
  );
  @override
  late final GeneratedColumn<double> downhillFactor = GeneratedColumn<double>(
    'downhill_factor',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _uphillDataPointsMeta = const VerificationMeta(
    'uphillDataPoints',
  );
  @override
  late final GeneratedColumn<int> uphillDataPoints = GeneratedColumn<int>(
    'uphill_data_points',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _downhillDataPointsMeta =
      const VerificationMeta('downhillDataPoints');
  @override
  late final GeneratedColumn<int> downhillDataPoints = GeneratedColumn<int>(
    'downhill_data_points',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _confidenceScoreMeta = const VerificationMeta(
    'confidenceScore',
  );
  @override
  late final GeneratedColumn<double> confidenceScore = GeneratedColumn<double>(
    'confidence_score',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
    defaultValue: const Constant(0.3),
  );
  static const VerificationMeta _lastUpdatedMeta = const VerificationMeta(
    'lastUpdated',
  );
  @override
  late final GeneratedColumn<DateTime> lastUpdated = GeneratedColumn<DateTime>(
    'last_updated',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    bowId,
    arrowSpeedFps,
    uphillFactor,
    downhillFactor,
    uphillDataPoints,
    downhillDataPoints,
    confidenceScore,
    lastUpdated,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'angle_correction_profiles';
  @override
  VerificationContext validateIntegrity(
    Insertable<AngleCorrectionProfile> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('bow_id')) {
      context.handle(
        _bowIdMeta,
        bowId.isAcceptableOrUnknown(data['bow_id']!, _bowIdMeta),
      );
    } else if (isInserting) {
      context.missing(_bowIdMeta);
    }
    if (data.containsKey('arrow_speed_fps')) {
      context.handle(
        _arrowSpeedFpsMeta,
        arrowSpeedFps.isAcceptableOrUnknown(
          data['arrow_speed_fps']!,
          _arrowSpeedFpsMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_arrowSpeedFpsMeta);
    }
    if (data.containsKey('uphill_factor')) {
      context.handle(
        _uphillFactorMeta,
        uphillFactor.isAcceptableOrUnknown(
          data['uphill_factor']!,
          _uphillFactorMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_uphillFactorMeta);
    }
    if (data.containsKey('downhill_factor')) {
      context.handle(
        _downhillFactorMeta,
        downhillFactor.isAcceptableOrUnknown(
          data['downhill_factor']!,
          _downhillFactorMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_downhillFactorMeta);
    }
    if (data.containsKey('uphill_data_points')) {
      context.handle(
        _uphillDataPointsMeta,
        uphillDataPoints.isAcceptableOrUnknown(
          data['uphill_data_points']!,
          _uphillDataPointsMeta,
        ),
      );
    }
    if (data.containsKey('downhill_data_points')) {
      context.handle(
        _downhillDataPointsMeta,
        downhillDataPoints.isAcceptableOrUnknown(
          data['downhill_data_points']!,
          _downhillDataPointsMeta,
        ),
      );
    }
    if (data.containsKey('confidence_score')) {
      context.handle(
        _confidenceScoreMeta,
        confidenceScore.isAcceptableOrUnknown(
          data['confidence_score']!,
          _confidenceScoreMeta,
        ),
      );
    }
    if (data.containsKey('last_updated')) {
      context.handle(
        _lastUpdatedMeta,
        lastUpdated.isAcceptableOrUnknown(
          data['last_updated']!,
          _lastUpdatedMeta,
        ),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  AngleCorrectionProfile map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return AngleCorrectionProfile(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      bowId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}bow_id'],
      )!,
      arrowSpeedFps: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}arrow_speed_fps'],
      )!,
      uphillFactor: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}uphill_factor'],
      )!,
      downhillFactor: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}downhill_factor'],
      )!,
      uphillDataPoints: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}uphill_data_points'],
      )!,
      downhillDataPoints: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}downhill_data_points'],
      )!,
      confidenceScore: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}confidence_score'],
      )!,
      lastUpdated: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}last_updated'],
      )!,
    );
  }

  @override
  $AngleCorrectionProfilesTable createAlias(String alias) {
    return $AngleCorrectionProfilesTable(attachedDatabase, alias);
  }
}

class AngleCorrectionProfile extends DataClass
    implements Insertable<AngleCorrectionProfile> {
  final String id;
  final String bowId;
  final double arrowSpeedFps;
  final double uphillFactor;
  final double downhillFactor;
  final int uphillDataPoints;
  final int downhillDataPoints;
  final double confidenceScore;
  final DateTime lastUpdated;
  const AngleCorrectionProfile({
    required this.id,
    required this.bowId,
    required this.arrowSpeedFps,
    required this.uphillFactor,
    required this.downhillFactor,
    required this.uphillDataPoints,
    required this.downhillDataPoints,
    required this.confidenceScore,
    required this.lastUpdated,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['bow_id'] = Variable<String>(bowId);
    map['arrow_speed_fps'] = Variable<double>(arrowSpeedFps);
    map['uphill_factor'] = Variable<double>(uphillFactor);
    map['downhill_factor'] = Variable<double>(downhillFactor);
    map['uphill_data_points'] = Variable<int>(uphillDataPoints);
    map['downhill_data_points'] = Variable<int>(downhillDataPoints);
    map['confidence_score'] = Variable<double>(confidenceScore);
    map['last_updated'] = Variable<DateTime>(lastUpdated);
    return map;
  }

  AngleCorrectionProfilesCompanion toCompanion(bool nullToAbsent) {
    return AngleCorrectionProfilesCompanion(
      id: Value(id),
      bowId: Value(bowId),
      arrowSpeedFps: Value(arrowSpeedFps),
      uphillFactor: Value(uphillFactor),
      downhillFactor: Value(downhillFactor),
      uphillDataPoints: Value(uphillDataPoints),
      downhillDataPoints: Value(downhillDataPoints),
      confidenceScore: Value(confidenceScore),
      lastUpdated: Value(lastUpdated),
    );
  }

  factory AngleCorrectionProfile.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AngleCorrectionProfile(
      id: serializer.fromJson<String>(json['id']),
      bowId: serializer.fromJson<String>(json['bowId']),
      arrowSpeedFps: serializer.fromJson<double>(json['arrowSpeedFps']),
      uphillFactor: serializer.fromJson<double>(json['uphillFactor']),
      downhillFactor: serializer.fromJson<double>(json['downhillFactor']),
      uphillDataPoints: serializer.fromJson<int>(json['uphillDataPoints']),
      downhillDataPoints: serializer.fromJson<int>(json['downhillDataPoints']),
      confidenceScore: serializer.fromJson<double>(json['confidenceScore']),
      lastUpdated: serializer.fromJson<DateTime>(json['lastUpdated']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'bowId': serializer.toJson<String>(bowId),
      'arrowSpeedFps': serializer.toJson<double>(arrowSpeedFps),
      'uphillFactor': serializer.toJson<double>(uphillFactor),
      'downhillFactor': serializer.toJson<double>(downhillFactor),
      'uphillDataPoints': serializer.toJson<int>(uphillDataPoints),
      'downhillDataPoints': serializer.toJson<int>(downhillDataPoints),
      'confidenceScore': serializer.toJson<double>(confidenceScore),
      'lastUpdated': serializer.toJson<DateTime>(lastUpdated),
    };
  }

  AngleCorrectionProfile copyWith({
    String? id,
    String? bowId,
    double? arrowSpeedFps,
    double? uphillFactor,
    double? downhillFactor,
    int? uphillDataPoints,
    int? downhillDataPoints,
    double? confidenceScore,
    DateTime? lastUpdated,
  }) => AngleCorrectionProfile(
    id: id ?? this.id,
    bowId: bowId ?? this.bowId,
    arrowSpeedFps: arrowSpeedFps ?? this.arrowSpeedFps,
    uphillFactor: uphillFactor ?? this.uphillFactor,
    downhillFactor: downhillFactor ?? this.downhillFactor,
    uphillDataPoints: uphillDataPoints ?? this.uphillDataPoints,
    downhillDataPoints: downhillDataPoints ?? this.downhillDataPoints,
    confidenceScore: confidenceScore ?? this.confidenceScore,
    lastUpdated: lastUpdated ?? this.lastUpdated,
  );
  AngleCorrectionProfile copyWithCompanion(
    AngleCorrectionProfilesCompanion data,
  ) {
    return AngleCorrectionProfile(
      id: data.id.present ? data.id.value : this.id,
      bowId: data.bowId.present ? data.bowId.value : this.bowId,
      arrowSpeedFps: data.arrowSpeedFps.present
          ? data.arrowSpeedFps.value
          : this.arrowSpeedFps,
      uphillFactor: data.uphillFactor.present
          ? data.uphillFactor.value
          : this.uphillFactor,
      downhillFactor: data.downhillFactor.present
          ? data.downhillFactor.value
          : this.downhillFactor,
      uphillDataPoints: data.uphillDataPoints.present
          ? data.uphillDataPoints.value
          : this.uphillDataPoints,
      downhillDataPoints: data.downhillDataPoints.present
          ? data.downhillDataPoints.value
          : this.downhillDataPoints,
      confidenceScore: data.confidenceScore.present
          ? data.confidenceScore.value
          : this.confidenceScore,
      lastUpdated: data.lastUpdated.present
          ? data.lastUpdated.value
          : this.lastUpdated,
    );
  }

  @override
  String toString() {
    return (StringBuffer('AngleCorrectionProfile(')
          ..write('id: $id, ')
          ..write('bowId: $bowId, ')
          ..write('arrowSpeedFps: $arrowSpeedFps, ')
          ..write('uphillFactor: $uphillFactor, ')
          ..write('downhillFactor: $downhillFactor, ')
          ..write('uphillDataPoints: $uphillDataPoints, ')
          ..write('downhillDataPoints: $downhillDataPoints, ')
          ..write('confidenceScore: $confidenceScore, ')
          ..write('lastUpdated: $lastUpdated')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    bowId,
    arrowSpeedFps,
    uphillFactor,
    downhillFactor,
    uphillDataPoints,
    downhillDataPoints,
    confidenceScore,
    lastUpdated,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AngleCorrectionProfile &&
          other.id == this.id &&
          other.bowId == this.bowId &&
          other.arrowSpeedFps == this.arrowSpeedFps &&
          other.uphillFactor == this.uphillFactor &&
          other.downhillFactor == this.downhillFactor &&
          other.uphillDataPoints == this.uphillDataPoints &&
          other.downhillDataPoints == this.downhillDataPoints &&
          other.confidenceScore == this.confidenceScore &&
          other.lastUpdated == this.lastUpdated);
}

class AngleCorrectionProfilesCompanion
    extends UpdateCompanion<AngleCorrectionProfile> {
  final Value<String> id;
  final Value<String> bowId;
  final Value<double> arrowSpeedFps;
  final Value<double> uphillFactor;
  final Value<double> downhillFactor;
  final Value<int> uphillDataPoints;
  final Value<int> downhillDataPoints;
  final Value<double> confidenceScore;
  final Value<DateTime> lastUpdated;
  final Value<int> rowid;
  const AngleCorrectionProfilesCompanion({
    this.id = const Value.absent(),
    this.bowId = const Value.absent(),
    this.arrowSpeedFps = const Value.absent(),
    this.uphillFactor = const Value.absent(),
    this.downhillFactor = const Value.absent(),
    this.uphillDataPoints = const Value.absent(),
    this.downhillDataPoints = const Value.absent(),
    this.confidenceScore = const Value.absent(),
    this.lastUpdated = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  AngleCorrectionProfilesCompanion.insert({
    required String id,
    required String bowId,
    required double arrowSpeedFps,
    required double uphillFactor,
    required double downhillFactor,
    this.uphillDataPoints = const Value.absent(),
    this.downhillDataPoints = const Value.absent(),
    this.confidenceScore = const Value.absent(),
    this.lastUpdated = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       bowId = Value(bowId),
       arrowSpeedFps = Value(arrowSpeedFps),
       uphillFactor = Value(uphillFactor),
       downhillFactor = Value(downhillFactor);
  static Insertable<AngleCorrectionProfile> custom({
    Expression<String>? id,
    Expression<String>? bowId,
    Expression<double>? arrowSpeedFps,
    Expression<double>? uphillFactor,
    Expression<double>? downhillFactor,
    Expression<int>? uphillDataPoints,
    Expression<int>? downhillDataPoints,
    Expression<double>? confidenceScore,
    Expression<DateTime>? lastUpdated,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (bowId != null) 'bow_id': bowId,
      if (arrowSpeedFps != null) 'arrow_speed_fps': arrowSpeedFps,
      if (uphillFactor != null) 'uphill_factor': uphillFactor,
      if (downhillFactor != null) 'downhill_factor': downhillFactor,
      if (uphillDataPoints != null) 'uphill_data_points': uphillDataPoints,
      if (downhillDataPoints != null)
        'downhill_data_points': downhillDataPoints,
      if (confidenceScore != null) 'confidence_score': confidenceScore,
      if (lastUpdated != null) 'last_updated': lastUpdated,
      if (rowid != null) 'rowid': rowid,
    });
  }

  AngleCorrectionProfilesCompanion copyWith({
    Value<String>? id,
    Value<String>? bowId,
    Value<double>? arrowSpeedFps,
    Value<double>? uphillFactor,
    Value<double>? downhillFactor,
    Value<int>? uphillDataPoints,
    Value<int>? downhillDataPoints,
    Value<double>? confidenceScore,
    Value<DateTime>? lastUpdated,
    Value<int>? rowid,
  }) {
    return AngleCorrectionProfilesCompanion(
      id: id ?? this.id,
      bowId: bowId ?? this.bowId,
      arrowSpeedFps: arrowSpeedFps ?? this.arrowSpeedFps,
      uphillFactor: uphillFactor ?? this.uphillFactor,
      downhillFactor: downhillFactor ?? this.downhillFactor,
      uphillDataPoints: uphillDataPoints ?? this.uphillDataPoints,
      downhillDataPoints: downhillDataPoints ?? this.downhillDataPoints,
      confidenceScore: confidenceScore ?? this.confidenceScore,
      lastUpdated: lastUpdated ?? this.lastUpdated,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (bowId.present) {
      map['bow_id'] = Variable<String>(bowId.value);
    }
    if (arrowSpeedFps.present) {
      map['arrow_speed_fps'] = Variable<double>(arrowSpeedFps.value);
    }
    if (uphillFactor.present) {
      map['uphill_factor'] = Variable<double>(uphillFactor.value);
    }
    if (downhillFactor.present) {
      map['downhill_factor'] = Variable<double>(downhillFactor.value);
    }
    if (uphillDataPoints.present) {
      map['uphill_data_points'] = Variable<int>(uphillDataPoints.value);
    }
    if (downhillDataPoints.present) {
      map['downhill_data_points'] = Variable<int>(downhillDataPoints.value);
    }
    if (confidenceScore.present) {
      map['confidence_score'] = Variable<double>(confidenceScore.value);
    }
    if (lastUpdated.present) {
      map['last_updated'] = Variable<DateTime>(lastUpdated.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AngleCorrectionProfilesCompanion(')
          ..write('id: $id, ')
          ..write('bowId: $bowId, ')
          ..write('arrowSpeedFps: $arrowSpeedFps, ')
          ..write('uphillFactor: $uphillFactor, ')
          ..write('downhillFactor: $downhillFactor, ')
          ..write('uphillDataPoints: $uphillDataPoints, ')
          ..write('downhillDataPoints: $downhillDataPoints, ')
          ..write('confidenceScore: $confidenceScore, ')
          ..write('lastUpdated: $lastUpdated, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $VenuesTable extends Venues with TableInfo<$VenuesTable, Venue> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $VenuesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _latitudeMeta = const VerificationMeta(
    'latitude',
  );
  @override
  late final GeneratedColumn<double> latitude = GeneratedColumn<double>(
    'latitude',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _longitudeMeta = const VerificationMeta(
    'longitude',
  );
  @override
  late final GeneratedColumn<double> longitude = GeneratedColumn<double>(
    'longitude',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _temperatureRegionMeta = const VerificationMeta(
    'temperatureRegion',
  );
  @override
  late final GeneratedColumn<String> temperatureRegion =
      GeneratedColumn<String>(
        'temperature_region',
        aliasedName,
        false,
        type: DriftSqlType.string,
        requiredDuringInsert: false,
        defaultValue: const Constant('temperate'),
      );
  static const VerificationMeta _notesMeta = const VerificationMeta('notes');
  @override
  late final GeneratedColumn<String> notes = GeneratedColumn<String>(
    'notes',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    name,
    latitude,
    longitude,
    temperatureRegion,
    notes,
    createdAt,
    updatedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'venues';
  @override
  VerificationContext validateIntegrity(
    Insertable<Venue> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('latitude')) {
      context.handle(
        _latitudeMeta,
        latitude.isAcceptableOrUnknown(data['latitude']!, _latitudeMeta),
      );
    }
    if (data.containsKey('longitude')) {
      context.handle(
        _longitudeMeta,
        longitude.isAcceptableOrUnknown(data['longitude']!, _longitudeMeta),
      );
    }
    if (data.containsKey('temperature_region')) {
      context.handle(
        _temperatureRegionMeta,
        temperatureRegion.isAcceptableOrUnknown(
          data['temperature_region']!,
          _temperatureRegionMeta,
        ),
      );
    }
    if (data.containsKey('notes')) {
      context.handle(
        _notesMeta,
        notes.isAcceptableOrUnknown(data['notes']!, _notesMeta),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  Venue map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Venue(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      latitude: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}latitude'],
      ),
      longitude: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}longitude'],
      ),
      temperatureRegion: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}temperature_region'],
      )!,
      notes: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}notes'],
      ),
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      ),
    );
  }

  @override
  $VenuesTable createAlias(String alias) {
    return $VenuesTable(attachedDatabase, alias);
  }
}

class Venue extends DataClass implements Insertable<Venue> {
  final String id;
  final String name;
  final double? latitude;
  final double? longitude;
  final String temperatureRegion;
  final String? notes;
  final DateTime createdAt;
  final DateTime? updatedAt;
  const Venue({
    required this.id,
    required this.name,
    this.latitude,
    this.longitude,
    required this.temperatureRegion,
    this.notes,
    required this.createdAt,
    this.updatedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['name'] = Variable<String>(name);
    if (!nullToAbsent || latitude != null) {
      map['latitude'] = Variable<double>(latitude);
    }
    if (!nullToAbsent || longitude != null) {
      map['longitude'] = Variable<double>(longitude);
    }
    map['temperature_region'] = Variable<String>(temperatureRegion);
    if (!nullToAbsent || notes != null) {
      map['notes'] = Variable<String>(notes);
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    if (!nullToAbsent || updatedAt != null) {
      map['updated_at'] = Variable<DateTime>(updatedAt);
    }
    return map;
  }

  VenuesCompanion toCompanion(bool nullToAbsent) {
    return VenuesCompanion(
      id: Value(id),
      name: Value(name),
      latitude: latitude == null && nullToAbsent
          ? const Value.absent()
          : Value(latitude),
      longitude: longitude == null && nullToAbsent
          ? const Value.absent()
          : Value(longitude),
      temperatureRegion: Value(temperatureRegion),
      notes: notes == null && nullToAbsent
          ? const Value.absent()
          : Value(notes),
      createdAt: Value(createdAt),
      updatedAt: updatedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(updatedAt),
    );
  }

  factory Venue.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Venue(
      id: serializer.fromJson<String>(json['id']),
      name: serializer.fromJson<String>(json['name']),
      latitude: serializer.fromJson<double?>(json['latitude']),
      longitude: serializer.fromJson<double?>(json['longitude']),
      temperatureRegion: serializer.fromJson<String>(json['temperatureRegion']),
      notes: serializer.fromJson<String?>(json['notes']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime?>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'name': serializer.toJson<String>(name),
      'latitude': serializer.toJson<double?>(latitude),
      'longitude': serializer.toJson<double?>(longitude),
      'temperatureRegion': serializer.toJson<String>(temperatureRegion),
      'notes': serializer.toJson<String?>(notes),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime?>(updatedAt),
    };
  }

  Venue copyWith({
    String? id,
    String? name,
    Value<double?> latitude = const Value.absent(),
    Value<double?> longitude = const Value.absent(),
    String? temperatureRegion,
    Value<String?> notes = const Value.absent(),
    DateTime? createdAt,
    Value<DateTime?> updatedAt = const Value.absent(),
  }) => Venue(
    id: id ?? this.id,
    name: name ?? this.name,
    latitude: latitude.present ? latitude.value : this.latitude,
    longitude: longitude.present ? longitude.value : this.longitude,
    temperatureRegion: temperatureRegion ?? this.temperatureRegion,
    notes: notes.present ? notes.value : this.notes,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt.present ? updatedAt.value : this.updatedAt,
  );
  Venue copyWithCompanion(VenuesCompanion data) {
    return Venue(
      id: data.id.present ? data.id.value : this.id,
      name: data.name.present ? data.name.value : this.name,
      latitude: data.latitude.present ? data.latitude.value : this.latitude,
      longitude: data.longitude.present ? data.longitude.value : this.longitude,
      temperatureRegion: data.temperatureRegion.present
          ? data.temperatureRegion.value
          : this.temperatureRegion,
      notes: data.notes.present ? data.notes.value : this.notes,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Venue(')
          ..write('id: $id, ')
          ..write('name: $name, ')
          ..write('latitude: $latitude, ')
          ..write('longitude: $longitude, ')
          ..write('temperatureRegion: $temperatureRegion, ')
          ..write('notes: $notes, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    name,
    latitude,
    longitude,
    temperatureRegion,
    notes,
    createdAt,
    updatedAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Venue &&
          other.id == this.id &&
          other.name == this.name &&
          other.latitude == this.latitude &&
          other.longitude == this.longitude &&
          other.temperatureRegion == this.temperatureRegion &&
          other.notes == this.notes &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class VenuesCompanion extends UpdateCompanion<Venue> {
  final Value<String> id;
  final Value<String> name;
  final Value<double?> latitude;
  final Value<double?> longitude;
  final Value<String> temperatureRegion;
  final Value<String?> notes;
  final Value<DateTime> createdAt;
  final Value<DateTime?> updatedAt;
  final Value<int> rowid;
  const VenuesCompanion({
    this.id = const Value.absent(),
    this.name = const Value.absent(),
    this.latitude = const Value.absent(),
    this.longitude = const Value.absent(),
    this.temperatureRegion = const Value.absent(),
    this.notes = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  VenuesCompanion.insert({
    required String id,
    required String name,
    this.latitude = const Value.absent(),
    this.longitude = const Value.absent(),
    this.temperatureRegion = const Value.absent(),
    this.notes = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       name = Value(name);
  static Insertable<Venue> custom({
    Expression<String>? id,
    Expression<String>? name,
    Expression<double>? latitude,
    Expression<double>? longitude,
    Expression<String>? temperatureRegion,
    Expression<String>? notes,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (name != null) 'name': name,
      if (latitude != null) 'latitude': latitude,
      if (longitude != null) 'longitude': longitude,
      if (temperatureRegion != null) 'temperature_region': temperatureRegion,
      if (notes != null) 'notes': notes,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  VenuesCompanion copyWith({
    Value<String>? id,
    Value<String>? name,
    Value<double?>? latitude,
    Value<double?>? longitude,
    Value<String>? temperatureRegion,
    Value<String?>? notes,
    Value<DateTime>? createdAt,
    Value<DateTime?>? updatedAt,
    Value<int>? rowid,
  }) {
    return VenuesCompanion(
      id: id ?? this.id,
      name: name ?? this.name,
      latitude: latitude ?? this.latitude,
      longitude: longitude ?? this.longitude,
      temperatureRegion: temperatureRegion ?? this.temperatureRegion,
      notes: notes ?? this.notes,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (latitude.present) {
      map['latitude'] = Variable<double>(latitude.value);
    }
    if (longitude.present) {
      map['longitude'] = Variable<double>(longitude.value);
    }
    if (temperatureRegion.present) {
      map['temperature_region'] = Variable<String>(temperatureRegion.value);
    }
    if (notes.present) {
      map['notes'] = Variable<String>(notes.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('VenuesCompanion(')
          ..write('id: $id, ')
          ..write('name: $name, ')
          ..write('latitude: $latitude, ')
          ..write('longitude: $longitude, ')
          ..write('temperatureRegion: $temperatureRegion, ')
          ..write('notes: $notes, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $RegisteredTargetsTable extends RegisteredTargets
    with TableInfo<$RegisteredTargetsTable, RegisteredTarget> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $RegisteredTargetsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _targetTypeMeta = const VerificationMeta(
    'targetType',
  );
  @override
  late final GeneratedColumn<String> targetType = GeneratedColumn<String>(
    'target_type',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _imagePathMeta = const VerificationMeta(
    'imagePath',
  );
  @override
  late final GeneratedColumn<String> imagePath = GeneratedColumn<String>(
    'image_path',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _isTripleSpotMeta = const VerificationMeta(
    'isTripleSpot',
  );
  @override
  late final GeneratedColumn<bool> isTripleSpot = GeneratedColumn<bool>(
    'is_triple_spot',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_triple_spot" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    targetType,
    imagePath,
    isTripleSpot,
    createdAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'registered_targets';
  @override
  VerificationContext validateIntegrity(
    Insertable<RegisteredTarget> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('target_type')) {
      context.handle(
        _targetTypeMeta,
        targetType.isAcceptableOrUnknown(data['target_type']!, _targetTypeMeta),
      );
    } else if (isInserting) {
      context.missing(_targetTypeMeta);
    }
    if (data.containsKey('image_path')) {
      context.handle(
        _imagePathMeta,
        imagePath.isAcceptableOrUnknown(data['image_path']!, _imagePathMeta),
      );
    } else if (isInserting) {
      context.missing(_imagePathMeta);
    }
    if (data.containsKey('is_triple_spot')) {
      context.handle(
        _isTripleSpotMeta,
        isTripleSpot.isAcceptableOrUnknown(
          data['is_triple_spot']!,
          _isTripleSpotMeta,
        ),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  RegisteredTarget map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return RegisteredTarget(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      targetType: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}target_type'],
      )!,
      imagePath: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}image_path'],
      )!,
      isTripleSpot: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_triple_spot'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
    );
  }

  @override
  $RegisteredTargetsTable createAlias(String alias) {
    return $RegisteredTargetsTable(attachedDatabase, alias);
  }
}

class RegisteredTarget extends DataClass
    implements Insertable<RegisteredTarget> {
  final String id;
  final String targetType;
  final String imagePath;
  final bool isTripleSpot;
  final DateTime createdAt;
  const RegisteredTarget({
    required this.id,
    required this.targetType,
    required this.imagePath,
    required this.isTripleSpot,
    required this.createdAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['target_type'] = Variable<String>(targetType);
    map['image_path'] = Variable<String>(imagePath);
    map['is_triple_spot'] = Variable<bool>(isTripleSpot);
    map['created_at'] = Variable<DateTime>(createdAt);
    return map;
  }

  RegisteredTargetsCompanion toCompanion(bool nullToAbsent) {
    return RegisteredTargetsCompanion(
      id: Value(id),
      targetType: Value(targetType),
      imagePath: Value(imagePath),
      isTripleSpot: Value(isTripleSpot),
      createdAt: Value(createdAt),
    );
  }

  factory RegisteredTarget.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return RegisteredTarget(
      id: serializer.fromJson<String>(json['id']),
      targetType: serializer.fromJson<String>(json['targetType']),
      imagePath: serializer.fromJson<String>(json['imagePath']),
      isTripleSpot: serializer.fromJson<bool>(json['isTripleSpot']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'targetType': serializer.toJson<String>(targetType),
      'imagePath': serializer.toJson<String>(imagePath),
      'isTripleSpot': serializer.toJson<bool>(isTripleSpot),
      'createdAt': serializer.toJson<DateTime>(createdAt),
    };
  }

  RegisteredTarget copyWith({
    String? id,
    String? targetType,
    String? imagePath,
    bool? isTripleSpot,
    DateTime? createdAt,
  }) => RegisteredTarget(
    id: id ?? this.id,
    targetType: targetType ?? this.targetType,
    imagePath: imagePath ?? this.imagePath,
    isTripleSpot: isTripleSpot ?? this.isTripleSpot,
    createdAt: createdAt ?? this.createdAt,
  );
  RegisteredTarget copyWithCompanion(RegisteredTargetsCompanion data) {
    return RegisteredTarget(
      id: data.id.present ? data.id.value : this.id,
      targetType: data.targetType.present
          ? data.targetType.value
          : this.targetType,
      imagePath: data.imagePath.present ? data.imagePath.value : this.imagePath,
      isTripleSpot: data.isTripleSpot.present
          ? data.isTripleSpot.value
          : this.isTripleSpot,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('RegisteredTarget(')
          ..write('id: $id, ')
          ..write('targetType: $targetType, ')
          ..write('imagePath: $imagePath, ')
          ..write('isTripleSpot: $isTripleSpot, ')
          ..write('createdAt: $createdAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(id, targetType, imagePath, isTripleSpot, createdAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is RegisteredTarget &&
          other.id == this.id &&
          other.targetType == this.targetType &&
          other.imagePath == this.imagePath &&
          other.isTripleSpot == this.isTripleSpot &&
          other.createdAt == this.createdAt);
}

class RegisteredTargetsCompanion extends UpdateCompanion<RegisteredTarget> {
  final Value<String> id;
  final Value<String> targetType;
  final Value<String> imagePath;
  final Value<bool> isTripleSpot;
  final Value<DateTime> createdAt;
  final Value<int> rowid;
  const RegisteredTargetsCompanion({
    this.id = const Value.absent(),
    this.targetType = const Value.absent(),
    this.imagePath = const Value.absent(),
    this.isTripleSpot = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  RegisteredTargetsCompanion.insert({
    required String id,
    required String targetType,
    required String imagePath,
    this.isTripleSpot = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       targetType = Value(targetType),
       imagePath = Value(imagePath);
  static Insertable<RegisteredTarget> custom({
    Expression<String>? id,
    Expression<String>? targetType,
    Expression<String>? imagePath,
    Expression<bool>? isTripleSpot,
    Expression<DateTime>? createdAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (targetType != null) 'target_type': targetType,
      if (imagePath != null) 'image_path': imagePath,
      if (isTripleSpot != null) 'is_triple_spot': isTripleSpot,
      if (createdAt != null) 'created_at': createdAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  RegisteredTargetsCompanion copyWith({
    Value<String>? id,
    Value<String>? targetType,
    Value<String>? imagePath,
    Value<bool>? isTripleSpot,
    Value<DateTime>? createdAt,
    Value<int>? rowid,
  }) {
    return RegisteredTargetsCompanion(
      id: id ?? this.id,
      targetType: targetType ?? this.targetType,
      imagePath: imagePath ?? this.imagePath,
      isTripleSpot: isTripleSpot ?? this.isTripleSpot,
      createdAt: createdAt ?? this.createdAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (targetType.present) {
      map['target_type'] = Variable<String>(targetType.value);
    }
    if (imagePath.present) {
      map['image_path'] = Variable<String>(imagePath.value);
    }
    if (isTripleSpot.present) {
      map['is_triple_spot'] = Variable<bool>(isTripleSpot.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('RegisteredTargetsCompanion(')
          ..write('id: $id, ')
          ..write('targetType: $targetType, ')
          ..write('imagePath: $imagePath, ')
          ..write('isTripleSpot: $isTripleSpot, ')
          ..write('createdAt: $createdAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $AutoPlotUsageTable extends AutoPlotUsage
    with TableInfo<$AutoPlotUsageTable, AutoPlotUsageData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $AutoPlotUsageTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _yearMonthMeta = const VerificationMeta(
    'yearMonth',
  );
  @override
  late final GeneratedColumn<String> yearMonth = GeneratedColumn<String>(
    'year_month',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _scanCountMeta = const VerificationMeta(
    'scanCount',
  );
  @override
  late final GeneratedColumn<int> scanCount = GeneratedColumn<int>(
    'scan_count',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  @override
  List<GeneratedColumn> get $columns => [id, yearMonth, scanCount];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'auto_plot_usage';
  @override
  VerificationContext validateIntegrity(
    Insertable<AutoPlotUsageData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('year_month')) {
      context.handle(
        _yearMonthMeta,
        yearMonth.isAcceptableOrUnknown(data['year_month']!, _yearMonthMeta),
      );
    } else if (isInserting) {
      context.missing(_yearMonthMeta);
    }
    if (data.containsKey('scan_count')) {
      context.handle(
        _scanCountMeta,
        scanCount.isAcceptableOrUnknown(data['scan_count']!, _scanCountMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  AutoPlotUsageData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return AutoPlotUsageData(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      yearMonth: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}year_month'],
      )!,
      scanCount: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}scan_count'],
      )!,
    );
  }

  @override
  $AutoPlotUsageTable createAlias(String alias) {
    return $AutoPlotUsageTable(attachedDatabase, alias);
  }
}

class AutoPlotUsageData extends DataClass
    implements Insertable<AutoPlotUsageData> {
  final String id;
  final String yearMonth;
  final int scanCount;
  const AutoPlotUsageData({
    required this.id,
    required this.yearMonth,
    required this.scanCount,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['year_month'] = Variable<String>(yearMonth);
    map['scan_count'] = Variable<int>(scanCount);
    return map;
  }

  AutoPlotUsageCompanion toCompanion(bool nullToAbsent) {
    return AutoPlotUsageCompanion(
      id: Value(id),
      yearMonth: Value(yearMonth),
      scanCount: Value(scanCount),
    );
  }

  factory AutoPlotUsageData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AutoPlotUsageData(
      id: serializer.fromJson<String>(json['id']),
      yearMonth: serializer.fromJson<String>(json['yearMonth']),
      scanCount: serializer.fromJson<int>(json['scanCount']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'yearMonth': serializer.toJson<String>(yearMonth),
      'scanCount': serializer.toJson<int>(scanCount),
    };
  }

  AutoPlotUsageData copyWith({String? id, String? yearMonth, int? scanCount}) =>
      AutoPlotUsageData(
        id: id ?? this.id,
        yearMonth: yearMonth ?? this.yearMonth,
        scanCount: scanCount ?? this.scanCount,
      );
  AutoPlotUsageData copyWithCompanion(AutoPlotUsageCompanion data) {
    return AutoPlotUsageData(
      id: data.id.present ? data.id.value : this.id,
      yearMonth: data.yearMonth.present ? data.yearMonth.value : this.yearMonth,
      scanCount: data.scanCount.present ? data.scanCount.value : this.scanCount,
    );
  }

  @override
  String toString() {
    return (StringBuffer('AutoPlotUsageData(')
          ..write('id: $id, ')
          ..write('yearMonth: $yearMonth, ')
          ..write('scanCount: $scanCount')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, yearMonth, scanCount);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AutoPlotUsageData &&
          other.id == this.id &&
          other.yearMonth == this.yearMonth &&
          other.scanCount == this.scanCount);
}

class AutoPlotUsageCompanion extends UpdateCompanion<AutoPlotUsageData> {
  final Value<String> id;
  final Value<String> yearMonth;
  final Value<int> scanCount;
  final Value<int> rowid;
  const AutoPlotUsageCompanion({
    this.id = const Value.absent(),
    this.yearMonth = const Value.absent(),
    this.scanCount = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  AutoPlotUsageCompanion.insert({
    required String id,
    required String yearMonth,
    this.scanCount = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       yearMonth = Value(yearMonth);
  static Insertable<AutoPlotUsageData> custom({
    Expression<String>? id,
    Expression<String>? yearMonth,
    Expression<int>? scanCount,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (yearMonth != null) 'year_month': yearMonth,
      if (scanCount != null) 'scan_count': scanCount,
      if (rowid != null) 'rowid': rowid,
    });
  }

  AutoPlotUsageCompanion copyWith({
    Value<String>? id,
    Value<String>? yearMonth,
    Value<int>? scanCount,
    Value<int>? rowid,
  }) {
    return AutoPlotUsageCompanion(
      id: id ?? this.id,
      yearMonth: yearMonth ?? this.yearMonth,
      scanCount: scanCount ?? this.scanCount,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (yearMonth.present) {
      map['year_month'] = Variable<String>(yearMonth.value);
    }
    if (scanCount.present) {
      map['scan_count'] = Variable<int>(scanCount.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AutoPlotUsageCompanion(')
          ..write('id: $id, ')
          ..write('yearMonth: $yearMonth, ')
          ..write('scanCount: $scanCount, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $UserProfilesTable extends UserProfiles
    with TableInfo<$UserProfilesTable, UserProfile> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $UserProfilesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _primaryBowTypeMeta = const VerificationMeta(
    'primaryBowType',
  );
  @override
  late final GeneratedColumn<String> primaryBowType = GeneratedColumn<String>(
    'primary_bow_type',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('recurve'),
  );
  static const VerificationMeta _handednessMeta = const VerificationMeta(
    'handedness',
  );
  @override
  late final GeneratedColumn<String> handedness = GeneratedColumn<String>(
    'handedness',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('right'),
  );
  static const VerificationMeta _drawLengthMeta = const VerificationMeta(
    'drawLength',
  );
  @override
  late final GeneratedColumn<double> drawLength = GeneratedColumn<double>(
    'draw_length',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _clubNameMeta = const VerificationMeta(
    'clubName',
  );
  @override
  late final GeneratedColumn<String> clubName = GeneratedColumn<String>(
    'club_name',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _yearsShootingStartMeta =
      const VerificationMeta('yearsShootingStart');
  @override
  late final GeneratedColumn<int> yearsShootingStart = GeneratedColumn<int>(
    'years_shooting_start',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _shootingFrequencyMeta = const VerificationMeta(
    'shootingFrequency',
  );
  @override
  late final GeneratedColumn<double> shootingFrequency =
      GeneratedColumn<double>(
        'shooting_frequency',
        aliasedName,
        false,
        type: DriftSqlType.double,
        requiredDuringInsert: false,
        defaultValue: const Constant(3.0),
      );
  static const VerificationMeta _competitionLevelsMeta = const VerificationMeta(
    'competitionLevels',
  );
  @override
  late final GeneratedColumn<String> competitionLevels =
      GeneratedColumn<String>(
        'competition_levels',
        aliasedName,
        false,
        type: DriftSqlType.string,
        requiredDuringInsert: false,
        defaultValue: const Constant('[]'),
      );
  static const VerificationMeta _genderMeta = const VerificationMeta('gender');
  @override
  late final GeneratedColumn<String> gender = GeneratedColumn<String>(
    'gender',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _dateOfBirthMeta = const VerificationMeta(
    'dateOfBirth',
  );
  @override
  late final GeneratedColumn<DateTime> dateOfBirth = GeneratedColumn<DateTime>(
    'date_of_birth',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _notesMeta = const VerificationMeta('notes');
  @override
  late final GeneratedColumn<String> notes = GeneratedColumn<String>(
    'notes',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    primaryBowType,
    handedness,
    drawLength,
    name,
    clubName,
    yearsShootingStart,
    shootingFrequency,
    competitionLevels,
    gender,
    dateOfBirth,
    notes,
    createdAt,
    updatedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'user_profiles';
  @override
  VerificationContext validateIntegrity(
    Insertable<UserProfile> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('primary_bow_type')) {
      context.handle(
        _primaryBowTypeMeta,
        primaryBowType.isAcceptableOrUnknown(
          data['primary_bow_type']!,
          _primaryBowTypeMeta,
        ),
      );
    }
    if (data.containsKey('handedness')) {
      context.handle(
        _handednessMeta,
        handedness.isAcceptableOrUnknown(data['handedness']!, _handednessMeta),
      );
    }
    if (data.containsKey('draw_length')) {
      context.handle(
        _drawLengthMeta,
        drawLength.isAcceptableOrUnknown(data['draw_length']!, _drawLengthMeta),
      );
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    }
    if (data.containsKey('club_name')) {
      context.handle(
        _clubNameMeta,
        clubName.isAcceptableOrUnknown(data['club_name']!, _clubNameMeta),
      );
    }
    if (data.containsKey('years_shooting_start')) {
      context.handle(
        _yearsShootingStartMeta,
        yearsShootingStart.isAcceptableOrUnknown(
          data['years_shooting_start']!,
          _yearsShootingStartMeta,
        ),
      );
    }
    if (data.containsKey('shooting_frequency')) {
      context.handle(
        _shootingFrequencyMeta,
        shootingFrequency.isAcceptableOrUnknown(
          data['shooting_frequency']!,
          _shootingFrequencyMeta,
        ),
      );
    }
    if (data.containsKey('competition_levels')) {
      context.handle(
        _competitionLevelsMeta,
        competitionLevels.isAcceptableOrUnknown(
          data['competition_levels']!,
          _competitionLevelsMeta,
        ),
      );
    }
    if (data.containsKey('gender')) {
      context.handle(
        _genderMeta,
        gender.isAcceptableOrUnknown(data['gender']!, _genderMeta),
      );
    }
    if (data.containsKey('date_of_birth')) {
      context.handle(
        _dateOfBirthMeta,
        dateOfBirth.isAcceptableOrUnknown(
          data['date_of_birth']!,
          _dateOfBirthMeta,
        ),
      );
    }
    if (data.containsKey('notes')) {
      context.handle(
        _notesMeta,
        notes.isAcceptableOrUnknown(data['notes']!, _notesMeta),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  UserProfile map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return UserProfile(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      primaryBowType: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}primary_bow_type'],
      )!,
      handedness: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}handedness'],
      )!,
      drawLength: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}draw_length'],
      ),
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      ),
      clubName: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}club_name'],
      ),
      yearsShootingStart: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}years_shooting_start'],
      ),
      shootingFrequency: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}shooting_frequency'],
      )!,
      competitionLevels: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}competition_levels'],
      )!,
      gender: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}gender'],
      ),
      dateOfBirth: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}date_of_birth'],
      ),
      notes: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}notes'],
      ),
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      )!,
    );
  }

  @override
  $UserProfilesTable createAlias(String alias) {
    return $UserProfilesTable(attachedDatabase, alias);
  }
}

class UserProfile extends DataClass implements Insertable<UserProfile> {
  final String id;
  final String primaryBowType;
  final String handedness;
  final double? drawLength;
  final String? name;
  final String? clubName;
  final int? yearsShootingStart;
  final double shootingFrequency;
  final String competitionLevels;
  final String? gender;
  final DateTime? dateOfBirth;
  final String? notes;
  final DateTime createdAt;
  final DateTime updatedAt;
  const UserProfile({
    required this.id,
    required this.primaryBowType,
    required this.handedness,
    this.drawLength,
    this.name,
    this.clubName,
    this.yearsShootingStart,
    required this.shootingFrequency,
    required this.competitionLevels,
    this.gender,
    this.dateOfBirth,
    this.notes,
    required this.createdAt,
    required this.updatedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['primary_bow_type'] = Variable<String>(primaryBowType);
    map['handedness'] = Variable<String>(handedness);
    if (!nullToAbsent || drawLength != null) {
      map['draw_length'] = Variable<double>(drawLength);
    }
    if (!nullToAbsent || name != null) {
      map['name'] = Variable<String>(name);
    }
    if (!nullToAbsent || clubName != null) {
      map['club_name'] = Variable<String>(clubName);
    }
    if (!nullToAbsent || yearsShootingStart != null) {
      map['years_shooting_start'] = Variable<int>(yearsShootingStart);
    }
    map['shooting_frequency'] = Variable<double>(shootingFrequency);
    map['competition_levels'] = Variable<String>(competitionLevels);
    if (!nullToAbsent || gender != null) {
      map['gender'] = Variable<String>(gender);
    }
    if (!nullToAbsent || dateOfBirth != null) {
      map['date_of_birth'] = Variable<DateTime>(dateOfBirth);
    }
    if (!nullToAbsent || notes != null) {
      map['notes'] = Variable<String>(notes);
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    return map;
  }

  UserProfilesCompanion toCompanion(bool nullToAbsent) {
    return UserProfilesCompanion(
      id: Value(id),
      primaryBowType: Value(primaryBowType),
      handedness: Value(handedness),
      drawLength: drawLength == null && nullToAbsent
          ? const Value.absent()
          : Value(drawLength),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      clubName: clubName == null && nullToAbsent
          ? const Value.absent()
          : Value(clubName),
      yearsShootingStart: yearsShootingStart == null && nullToAbsent
          ? const Value.absent()
          : Value(yearsShootingStart),
      shootingFrequency: Value(shootingFrequency),
      competitionLevels: Value(competitionLevels),
      gender: gender == null && nullToAbsent
          ? const Value.absent()
          : Value(gender),
      dateOfBirth: dateOfBirth == null && nullToAbsent
          ? const Value.absent()
          : Value(dateOfBirth),
      notes: notes == null && nullToAbsent
          ? const Value.absent()
          : Value(notes),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory UserProfile.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return UserProfile(
      id: serializer.fromJson<String>(json['id']),
      primaryBowType: serializer.fromJson<String>(json['primaryBowType']),
      handedness: serializer.fromJson<String>(json['handedness']),
      drawLength: serializer.fromJson<double?>(json['drawLength']),
      name: serializer.fromJson<String?>(json['name']),
      clubName: serializer.fromJson<String?>(json['clubName']),
      yearsShootingStart: serializer.fromJson<int?>(json['yearsShootingStart']),
      shootingFrequency: serializer.fromJson<double>(json['shootingFrequency']),
      competitionLevels: serializer.fromJson<String>(json['competitionLevels']),
      gender: serializer.fromJson<String?>(json['gender']),
      dateOfBirth: serializer.fromJson<DateTime?>(json['dateOfBirth']),
      notes: serializer.fromJson<String?>(json['notes']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'primaryBowType': serializer.toJson<String>(primaryBowType),
      'handedness': serializer.toJson<String>(handedness),
      'drawLength': serializer.toJson<double?>(drawLength),
      'name': serializer.toJson<String?>(name),
      'clubName': serializer.toJson<String?>(clubName),
      'yearsShootingStart': serializer.toJson<int?>(yearsShootingStart),
      'shootingFrequency': serializer.toJson<double>(shootingFrequency),
      'competitionLevels': serializer.toJson<String>(competitionLevels),
      'gender': serializer.toJson<String?>(gender),
      'dateOfBirth': serializer.toJson<DateTime?>(dateOfBirth),
      'notes': serializer.toJson<String?>(notes),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
    };
  }

  UserProfile copyWith({
    String? id,
    String? primaryBowType,
    String? handedness,
    Value<double?> drawLength = const Value.absent(),
    Value<String?> name = const Value.absent(),
    Value<String?> clubName = const Value.absent(),
    Value<int?> yearsShootingStart = const Value.absent(),
    double? shootingFrequency,
    String? competitionLevels,
    Value<String?> gender = const Value.absent(),
    Value<DateTime?> dateOfBirth = const Value.absent(),
    Value<String?> notes = const Value.absent(),
    DateTime? createdAt,
    DateTime? updatedAt,
  }) => UserProfile(
    id: id ?? this.id,
    primaryBowType: primaryBowType ?? this.primaryBowType,
    handedness: handedness ?? this.handedness,
    drawLength: drawLength.present ? drawLength.value : this.drawLength,
    name: name.present ? name.value : this.name,
    clubName: clubName.present ? clubName.value : this.clubName,
    yearsShootingStart: yearsShootingStart.present
        ? yearsShootingStart.value
        : this.yearsShootingStart,
    shootingFrequency: shootingFrequency ?? this.shootingFrequency,
    competitionLevels: competitionLevels ?? this.competitionLevels,
    gender: gender.present ? gender.value : this.gender,
    dateOfBirth: dateOfBirth.present ? dateOfBirth.value : this.dateOfBirth,
    notes: notes.present ? notes.value : this.notes,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
  );
  UserProfile copyWithCompanion(UserProfilesCompanion data) {
    return UserProfile(
      id: data.id.present ? data.id.value : this.id,
      primaryBowType: data.primaryBowType.present
          ? data.primaryBowType.value
          : this.primaryBowType,
      handedness: data.handedness.present
          ? data.handedness.value
          : this.handedness,
      drawLength: data.drawLength.present
          ? data.drawLength.value
          : this.drawLength,
      name: data.name.present ? data.name.value : this.name,
      clubName: data.clubName.present ? data.clubName.value : this.clubName,
      yearsShootingStart: data.yearsShootingStart.present
          ? data.yearsShootingStart.value
          : this.yearsShootingStart,
      shootingFrequency: data.shootingFrequency.present
          ? data.shootingFrequency.value
          : this.shootingFrequency,
      competitionLevels: data.competitionLevels.present
          ? data.competitionLevels.value
          : this.competitionLevels,
      gender: data.gender.present ? data.gender.value : this.gender,
      dateOfBirth: data.dateOfBirth.present
          ? data.dateOfBirth.value
          : this.dateOfBirth,
      notes: data.notes.present ? data.notes.value : this.notes,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('UserProfile(')
          ..write('id: $id, ')
          ..write('primaryBowType: $primaryBowType, ')
          ..write('handedness: $handedness, ')
          ..write('drawLength: $drawLength, ')
          ..write('name: $name, ')
          ..write('clubName: $clubName, ')
          ..write('yearsShootingStart: $yearsShootingStart, ')
          ..write('shootingFrequency: $shootingFrequency, ')
          ..write('competitionLevels: $competitionLevels, ')
          ..write('gender: $gender, ')
          ..write('dateOfBirth: $dateOfBirth, ')
          ..write('notes: $notes, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    primaryBowType,
    handedness,
    drawLength,
    name,
    clubName,
    yearsShootingStart,
    shootingFrequency,
    competitionLevels,
    gender,
    dateOfBirth,
    notes,
    createdAt,
    updatedAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is UserProfile &&
          other.id == this.id &&
          other.primaryBowType == this.primaryBowType &&
          other.handedness == this.handedness &&
          other.drawLength == this.drawLength &&
          other.name == this.name &&
          other.clubName == this.clubName &&
          other.yearsShootingStart == this.yearsShootingStart &&
          other.shootingFrequency == this.shootingFrequency &&
          other.competitionLevels == this.competitionLevels &&
          other.gender == this.gender &&
          other.dateOfBirth == this.dateOfBirth &&
          other.notes == this.notes &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class UserProfilesCompanion extends UpdateCompanion<UserProfile> {
  final Value<String> id;
  final Value<String> primaryBowType;
  final Value<String> handedness;
  final Value<double?> drawLength;
  final Value<String?> name;
  final Value<String?> clubName;
  final Value<int?> yearsShootingStart;
  final Value<double> shootingFrequency;
  final Value<String> competitionLevels;
  final Value<String?> gender;
  final Value<DateTime?> dateOfBirth;
  final Value<String?> notes;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  final Value<int> rowid;
  const UserProfilesCompanion({
    this.id = const Value.absent(),
    this.primaryBowType = const Value.absent(),
    this.handedness = const Value.absent(),
    this.drawLength = const Value.absent(),
    this.name = const Value.absent(),
    this.clubName = const Value.absent(),
    this.yearsShootingStart = const Value.absent(),
    this.shootingFrequency = const Value.absent(),
    this.competitionLevels = const Value.absent(),
    this.gender = const Value.absent(),
    this.dateOfBirth = const Value.absent(),
    this.notes = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  UserProfilesCompanion.insert({
    required String id,
    this.primaryBowType = const Value.absent(),
    this.handedness = const Value.absent(),
    this.drawLength = const Value.absent(),
    this.name = const Value.absent(),
    this.clubName = const Value.absent(),
    this.yearsShootingStart = const Value.absent(),
    this.shootingFrequency = const Value.absent(),
    this.competitionLevels = const Value.absent(),
    this.gender = const Value.absent(),
    this.dateOfBirth = const Value.absent(),
    this.notes = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id);
  static Insertable<UserProfile> custom({
    Expression<String>? id,
    Expression<String>? primaryBowType,
    Expression<String>? handedness,
    Expression<double>? drawLength,
    Expression<String>? name,
    Expression<String>? clubName,
    Expression<int>? yearsShootingStart,
    Expression<double>? shootingFrequency,
    Expression<String>? competitionLevels,
    Expression<String>? gender,
    Expression<DateTime>? dateOfBirth,
    Expression<String>? notes,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (primaryBowType != null) 'primary_bow_type': primaryBowType,
      if (handedness != null) 'handedness': handedness,
      if (drawLength != null) 'draw_length': drawLength,
      if (name != null) 'name': name,
      if (clubName != null) 'club_name': clubName,
      if (yearsShootingStart != null)
        'years_shooting_start': yearsShootingStart,
      if (shootingFrequency != null) 'shooting_frequency': shootingFrequency,
      if (competitionLevels != null) 'competition_levels': competitionLevels,
      if (gender != null) 'gender': gender,
      if (dateOfBirth != null) 'date_of_birth': dateOfBirth,
      if (notes != null) 'notes': notes,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  UserProfilesCompanion copyWith({
    Value<String>? id,
    Value<String>? primaryBowType,
    Value<String>? handedness,
    Value<double?>? drawLength,
    Value<String?>? name,
    Value<String?>? clubName,
    Value<int?>? yearsShootingStart,
    Value<double>? shootingFrequency,
    Value<String>? competitionLevels,
    Value<String?>? gender,
    Value<DateTime?>? dateOfBirth,
    Value<String?>? notes,
    Value<DateTime>? createdAt,
    Value<DateTime>? updatedAt,
    Value<int>? rowid,
  }) {
    return UserProfilesCompanion(
      id: id ?? this.id,
      primaryBowType: primaryBowType ?? this.primaryBowType,
      handedness: handedness ?? this.handedness,
      drawLength: drawLength ?? this.drawLength,
      name: name ?? this.name,
      clubName: clubName ?? this.clubName,
      yearsShootingStart: yearsShootingStart ?? this.yearsShootingStart,
      shootingFrequency: shootingFrequency ?? this.shootingFrequency,
      competitionLevels: competitionLevels ?? this.competitionLevels,
      gender: gender ?? this.gender,
      dateOfBirth: dateOfBirth ?? this.dateOfBirth,
      notes: notes ?? this.notes,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (primaryBowType.present) {
      map['primary_bow_type'] = Variable<String>(primaryBowType.value);
    }
    if (handedness.present) {
      map['handedness'] = Variable<String>(handedness.value);
    }
    if (drawLength.present) {
      map['draw_length'] = Variable<double>(drawLength.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (clubName.present) {
      map['club_name'] = Variable<String>(clubName.value);
    }
    if (yearsShootingStart.present) {
      map['years_shooting_start'] = Variable<int>(yearsShootingStart.value);
    }
    if (shootingFrequency.present) {
      map['shooting_frequency'] = Variable<double>(shootingFrequency.value);
    }
    if (competitionLevels.present) {
      map['competition_levels'] = Variable<String>(competitionLevels.value);
    }
    if (gender.present) {
      map['gender'] = Variable<String>(gender.value);
    }
    if (dateOfBirth.present) {
      map['date_of_birth'] = Variable<DateTime>(dateOfBirth.value);
    }
    if (notes.present) {
      map['notes'] = Variable<String>(notes.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('UserProfilesCompanion(')
          ..write('id: $id, ')
          ..write('primaryBowType: $primaryBowType, ')
          ..write('handedness: $handedness, ')
          ..write('drawLength: $drawLength, ')
          ..write('name: $name, ')
          ..write('clubName: $clubName, ')
          ..write('yearsShootingStart: $yearsShootingStart, ')
          ..write('shootingFrequency: $shootingFrequency, ')
          ..write('competitionLevels: $competitionLevels, ')
          ..write('gender: $gender, ')
          ..write('dateOfBirth: $dateOfBirth, ')
          ..write('notes: $notes, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $FederationsTable extends Federations
    with TableInfo<$FederationsTable, Federation> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $FederationsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _profileIdMeta = const VerificationMeta(
    'profileId',
  );
  @override
  late final GeneratedColumn<String> profileId = GeneratedColumn<String>(
    'profile_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES user_profiles (id)',
    ),
  );
  static const VerificationMeta _federationNameMeta = const VerificationMeta(
    'federationName',
  );
  @override
  late final GeneratedColumn<String> federationName = GeneratedColumn<String>(
    'federation_name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _membershipNumberMeta = const VerificationMeta(
    'membershipNumber',
  );
  @override
  late final GeneratedColumn<String> membershipNumber = GeneratedColumn<String>(
    'membership_number',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _cardImagePathMeta = const VerificationMeta(
    'cardImagePath',
  );
  @override
  late final GeneratedColumn<String> cardImagePath = GeneratedColumn<String>(
    'card_image_path',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _expiryDateMeta = const VerificationMeta(
    'expiryDate',
  );
  @override
  late final GeneratedColumn<DateTime> expiryDate = GeneratedColumn<DateTime>(
    'expiry_date',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _isPrimaryMeta = const VerificationMeta(
    'isPrimary',
  );
  @override
  late final GeneratedColumn<bool> isPrimary = GeneratedColumn<bool>(
    'is_primary',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_primary" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _deletedAtMeta = const VerificationMeta(
    'deletedAt',
  );
  @override
  late final GeneratedColumn<DateTime> deletedAt = GeneratedColumn<DateTime>(
    'deleted_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    profileId,
    federationName,
    membershipNumber,
    cardImagePath,
    expiryDate,
    isPrimary,
    createdAt,
    updatedAt,
    deletedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'federations';
  @override
  VerificationContext validateIntegrity(
    Insertable<Federation> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('profile_id')) {
      context.handle(
        _profileIdMeta,
        profileId.isAcceptableOrUnknown(data['profile_id']!, _profileIdMeta),
      );
    } else if (isInserting) {
      context.missing(_profileIdMeta);
    }
    if (data.containsKey('federation_name')) {
      context.handle(
        _federationNameMeta,
        federationName.isAcceptableOrUnknown(
          data['federation_name']!,
          _federationNameMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_federationNameMeta);
    }
    if (data.containsKey('membership_number')) {
      context.handle(
        _membershipNumberMeta,
        membershipNumber.isAcceptableOrUnknown(
          data['membership_number']!,
          _membershipNumberMeta,
        ),
      );
    }
    if (data.containsKey('card_image_path')) {
      context.handle(
        _cardImagePathMeta,
        cardImagePath.isAcceptableOrUnknown(
          data['card_image_path']!,
          _cardImagePathMeta,
        ),
      );
    }
    if (data.containsKey('expiry_date')) {
      context.handle(
        _expiryDateMeta,
        expiryDate.isAcceptableOrUnknown(data['expiry_date']!, _expiryDateMeta),
      );
    }
    if (data.containsKey('is_primary')) {
      context.handle(
        _isPrimaryMeta,
        isPrimary.isAcceptableOrUnknown(data['is_primary']!, _isPrimaryMeta),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    }
    if (data.containsKey('deleted_at')) {
      context.handle(
        _deletedAtMeta,
        deletedAt.isAcceptableOrUnknown(data['deleted_at']!, _deletedAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  Federation map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Federation(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      profileId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}profile_id'],
      )!,
      federationName: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}federation_name'],
      )!,
      membershipNumber: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}membership_number'],
      ),
      cardImagePath: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}card_image_path'],
      ),
      expiryDate: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}expiry_date'],
      ),
      isPrimary: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_primary'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      )!,
      deletedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}deleted_at'],
      ),
    );
  }

  @override
  $FederationsTable createAlias(String alias) {
    return $FederationsTable(attachedDatabase, alias);
  }
}

class Federation extends DataClass implements Insertable<Federation> {
  final String id;
  final String profileId;
  final String federationName;
  final String? membershipNumber;
  final String? cardImagePath;
  final DateTime? expiryDate;
  final bool isPrimary;
  final DateTime createdAt;
  final DateTime updatedAt;
  final DateTime? deletedAt;
  const Federation({
    required this.id,
    required this.profileId,
    required this.federationName,
    this.membershipNumber,
    this.cardImagePath,
    this.expiryDate,
    required this.isPrimary,
    required this.createdAt,
    required this.updatedAt,
    this.deletedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['profile_id'] = Variable<String>(profileId);
    map['federation_name'] = Variable<String>(federationName);
    if (!nullToAbsent || membershipNumber != null) {
      map['membership_number'] = Variable<String>(membershipNumber);
    }
    if (!nullToAbsent || cardImagePath != null) {
      map['card_image_path'] = Variable<String>(cardImagePath);
    }
    if (!nullToAbsent || expiryDate != null) {
      map['expiry_date'] = Variable<DateTime>(expiryDate);
    }
    map['is_primary'] = Variable<bool>(isPrimary);
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    if (!nullToAbsent || deletedAt != null) {
      map['deleted_at'] = Variable<DateTime>(deletedAt);
    }
    return map;
  }

  FederationsCompanion toCompanion(bool nullToAbsent) {
    return FederationsCompanion(
      id: Value(id),
      profileId: Value(profileId),
      federationName: Value(federationName),
      membershipNumber: membershipNumber == null && nullToAbsent
          ? const Value.absent()
          : Value(membershipNumber),
      cardImagePath: cardImagePath == null && nullToAbsent
          ? const Value.absent()
          : Value(cardImagePath),
      expiryDate: expiryDate == null && nullToAbsent
          ? const Value.absent()
          : Value(expiryDate),
      isPrimary: Value(isPrimary),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
      deletedAt: deletedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(deletedAt),
    );
  }

  factory Federation.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Federation(
      id: serializer.fromJson<String>(json['id']),
      profileId: serializer.fromJson<String>(json['profileId']),
      federationName: serializer.fromJson<String>(json['federationName']),
      membershipNumber: serializer.fromJson<String?>(json['membershipNumber']),
      cardImagePath: serializer.fromJson<String?>(json['cardImagePath']),
      expiryDate: serializer.fromJson<DateTime?>(json['expiryDate']),
      isPrimary: serializer.fromJson<bool>(json['isPrimary']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
      deletedAt: serializer.fromJson<DateTime?>(json['deletedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'profileId': serializer.toJson<String>(profileId),
      'federationName': serializer.toJson<String>(federationName),
      'membershipNumber': serializer.toJson<String?>(membershipNumber),
      'cardImagePath': serializer.toJson<String?>(cardImagePath),
      'expiryDate': serializer.toJson<DateTime?>(expiryDate),
      'isPrimary': serializer.toJson<bool>(isPrimary),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
      'deletedAt': serializer.toJson<DateTime?>(deletedAt),
    };
  }

  Federation copyWith({
    String? id,
    String? profileId,
    String? federationName,
    Value<String?> membershipNumber = const Value.absent(),
    Value<String?> cardImagePath = const Value.absent(),
    Value<DateTime?> expiryDate = const Value.absent(),
    bool? isPrimary,
    DateTime? createdAt,
    DateTime? updatedAt,
    Value<DateTime?> deletedAt = const Value.absent(),
  }) => Federation(
    id: id ?? this.id,
    profileId: profileId ?? this.profileId,
    federationName: federationName ?? this.federationName,
    membershipNumber: membershipNumber.present
        ? membershipNumber.value
        : this.membershipNumber,
    cardImagePath: cardImagePath.present
        ? cardImagePath.value
        : this.cardImagePath,
    expiryDate: expiryDate.present ? expiryDate.value : this.expiryDate,
    isPrimary: isPrimary ?? this.isPrimary,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
    deletedAt: deletedAt.present ? deletedAt.value : this.deletedAt,
  );
  Federation copyWithCompanion(FederationsCompanion data) {
    return Federation(
      id: data.id.present ? data.id.value : this.id,
      profileId: data.profileId.present ? data.profileId.value : this.profileId,
      federationName: data.federationName.present
          ? data.federationName.value
          : this.federationName,
      membershipNumber: data.membershipNumber.present
          ? data.membershipNumber.value
          : this.membershipNumber,
      cardImagePath: data.cardImagePath.present
          ? data.cardImagePath.value
          : this.cardImagePath,
      expiryDate: data.expiryDate.present
          ? data.expiryDate.value
          : this.expiryDate,
      isPrimary: data.isPrimary.present ? data.isPrimary.value : this.isPrimary,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
      deletedAt: data.deletedAt.present ? data.deletedAt.value : this.deletedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Federation(')
          ..write('id: $id, ')
          ..write('profileId: $profileId, ')
          ..write('federationName: $federationName, ')
          ..write('membershipNumber: $membershipNumber, ')
          ..write('cardImagePath: $cardImagePath, ')
          ..write('expiryDate: $expiryDate, ')
          ..write('isPrimary: $isPrimary, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('deletedAt: $deletedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    profileId,
    federationName,
    membershipNumber,
    cardImagePath,
    expiryDate,
    isPrimary,
    createdAt,
    updatedAt,
    deletedAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Federation &&
          other.id == this.id &&
          other.profileId == this.profileId &&
          other.federationName == this.federationName &&
          other.membershipNumber == this.membershipNumber &&
          other.cardImagePath == this.cardImagePath &&
          other.expiryDate == this.expiryDate &&
          other.isPrimary == this.isPrimary &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt &&
          other.deletedAt == this.deletedAt);
}

class FederationsCompanion extends UpdateCompanion<Federation> {
  final Value<String> id;
  final Value<String> profileId;
  final Value<String> federationName;
  final Value<String?> membershipNumber;
  final Value<String?> cardImagePath;
  final Value<DateTime?> expiryDate;
  final Value<bool> isPrimary;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  final Value<DateTime?> deletedAt;
  final Value<int> rowid;
  const FederationsCompanion({
    this.id = const Value.absent(),
    this.profileId = const Value.absent(),
    this.federationName = const Value.absent(),
    this.membershipNumber = const Value.absent(),
    this.cardImagePath = const Value.absent(),
    this.expiryDate = const Value.absent(),
    this.isPrimary = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.deletedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  FederationsCompanion.insert({
    required String id,
    required String profileId,
    required String federationName,
    this.membershipNumber = const Value.absent(),
    this.cardImagePath = const Value.absent(),
    this.expiryDate = const Value.absent(),
    this.isPrimary = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.deletedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       profileId = Value(profileId),
       federationName = Value(federationName);
  static Insertable<Federation> custom({
    Expression<String>? id,
    Expression<String>? profileId,
    Expression<String>? federationName,
    Expression<String>? membershipNumber,
    Expression<String>? cardImagePath,
    Expression<DateTime>? expiryDate,
    Expression<bool>? isPrimary,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
    Expression<DateTime>? deletedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (profileId != null) 'profile_id': profileId,
      if (federationName != null) 'federation_name': federationName,
      if (membershipNumber != null) 'membership_number': membershipNumber,
      if (cardImagePath != null) 'card_image_path': cardImagePath,
      if (expiryDate != null) 'expiry_date': expiryDate,
      if (isPrimary != null) 'is_primary': isPrimary,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (deletedAt != null) 'deleted_at': deletedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  FederationsCompanion copyWith({
    Value<String>? id,
    Value<String>? profileId,
    Value<String>? federationName,
    Value<String?>? membershipNumber,
    Value<String?>? cardImagePath,
    Value<DateTime?>? expiryDate,
    Value<bool>? isPrimary,
    Value<DateTime>? createdAt,
    Value<DateTime>? updatedAt,
    Value<DateTime?>? deletedAt,
    Value<int>? rowid,
  }) {
    return FederationsCompanion(
      id: id ?? this.id,
      profileId: profileId ?? this.profileId,
      federationName: federationName ?? this.federationName,
      membershipNumber: membershipNumber ?? this.membershipNumber,
      cardImagePath: cardImagePath ?? this.cardImagePath,
      expiryDate: expiryDate ?? this.expiryDate,
      isPrimary: isPrimary ?? this.isPrimary,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      deletedAt: deletedAt ?? this.deletedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (profileId.present) {
      map['profile_id'] = Variable<String>(profileId.value);
    }
    if (federationName.present) {
      map['federation_name'] = Variable<String>(federationName.value);
    }
    if (membershipNumber.present) {
      map['membership_number'] = Variable<String>(membershipNumber.value);
    }
    if (cardImagePath.present) {
      map['card_image_path'] = Variable<String>(cardImagePath.value);
    }
    if (expiryDate.present) {
      map['expiry_date'] = Variable<DateTime>(expiryDate.value);
    }
    if (isPrimary.present) {
      map['is_primary'] = Variable<bool>(isPrimary.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (deletedAt.present) {
      map['deleted_at'] = Variable<DateTime>(deletedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('FederationsCompanion(')
          ..write('id: $id, ')
          ..write('profileId: $profileId, ')
          ..write('federationName: $federationName, ')
          ..write('membershipNumber: $membershipNumber, ')
          ..write('cardImagePath: $cardImagePath, ')
          ..write('expiryDate: $expiryDate, ')
          ..write('isPrimary: $isPrimary, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('deletedAt: $deletedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $ClassificationsTable extends Classifications
    with TableInfo<$ClassificationsTable, Classification> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ClassificationsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _profileIdMeta = const VerificationMeta(
    'profileId',
  );
  @override
  late final GeneratedColumn<String> profileId = GeneratedColumn<String>(
    'profile_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES user_profiles (id)',
    ),
  );
  static const VerificationMeta _classificationMeta = const VerificationMeta(
    'classification',
  );
  @override
  late final GeneratedColumn<String> classification = GeneratedColumn<String>(
    'classification',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _classificationScopeMeta =
      const VerificationMeta('classificationScope');
  @override
  late final GeneratedColumn<String> classificationScope =
      GeneratedColumn<String>(
        'classification_scope',
        aliasedName,
        false,
        type: DriftSqlType.string,
        requiredDuringInsert: true,
      );
  static const VerificationMeta _bowstyleMeta = const VerificationMeta(
    'bowstyle',
  );
  @override
  late final GeneratedColumn<String> bowstyle = GeneratedColumn<String>(
    'bowstyle',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _firstSessionIdMeta = const VerificationMeta(
    'firstSessionId',
  );
  @override
  late final GeneratedColumn<String> firstSessionId = GeneratedColumn<String>(
    'first_session_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES sessions (id)',
    ),
  );
  static const VerificationMeta _firstAchievedAtMeta = const VerificationMeta(
    'firstAchievedAt',
  );
  @override
  late final GeneratedColumn<DateTime> firstAchievedAt =
      GeneratedColumn<DateTime>(
        'first_achieved_at',
        aliasedName,
        true,
        type: DriftSqlType.dateTime,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _firstScoreMeta = const VerificationMeta(
    'firstScore',
  );
  @override
  late final GeneratedColumn<int> firstScore = GeneratedColumn<int>(
    'first_score',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _firstRoundIdMeta = const VerificationMeta(
    'firstRoundId',
  );
  @override
  late final GeneratedColumn<String> firstRoundId = GeneratedColumn<String>(
    'first_round_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _secondSessionIdMeta = const VerificationMeta(
    'secondSessionId',
  );
  @override
  late final GeneratedColumn<String> secondSessionId = GeneratedColumn<String>(
    'second_session_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES sessions (id)',
    ),
  );
  static const VerificationMeta _secondAchievedAtMeta = const VerificationMeta(
    'secondAchievedAt',
  );
  @override
  late final GeneratedColumn<DateTime> secondAchievedAt =
      GeneratedColumn<DateTime>(
        'second_achieved_at',
        aliasedName,
        true,
        type: DriftSqlType.dateTime,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _secondScoreMeta = const VerificationMeta(
    'secondScore',
  );
  @override
  late final GeneratedColumn<int> secondScore = GeneratedColumn<int>(
    'second_score',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _secondRoundIdMeta = const VerificationMeta(
    'secondRoundId',
  );
  @override
  late final GeneratedColumn<String> secondRoundId = GeneratedColumn<String>(
    'second_round_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _isClaimedMeta = const VerificationMeta(
    'isClaimed',
  );
  @override
  late final GeneratedColumn<bool> isClaimed = GeneratedColumn<bool>(
    'is_claimed',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_claimed" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _claimedAtMeta = const VerificationMeta(
    'claimedAt',
  );
  @override
  late final GeneratedColumn<DateTime> claimedAt = GeneratedColumn<DateTime>(
    'claimed_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    profileId,
    classification,
    classificationScope,
    bowstyle,
    firstSessionId,
    firstAchievedAt,
    firstScore,
    firstRoundId,
    secondSessionId,
    secondAchievedAt,
    secondScore,
    secondRoundId,
    isClaimed,
    claimedAt,
    createdAt,
    updatedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'classifications';
  @override
  VerificationContext validateIntegrity(
    Insertable<Classification> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('profile_id')) {
      context.handle(
        _profileIdMeta,
        profileId.isAcceptableOrUnknown(data['profile_id']!, _profileIdMeta),
      );
    } else if (isInserting) {
      context.missing(_profileIdMeta);
    }
    if (data.containsKey('classification')) {
      context.handle(
        _classificationMeta,
        classification.isAcceptableOrUnknown(
          data['classification']!,
          _classificationMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_classificationMeta);
    }
    if (data.containsKey('classification_scope')) {
      context.handle(
        _classificationScopeMeta,
        classificationScope.isAcceptableOrUnknown(
          data['classification_scope']!,
          _classificationScopeMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_classificationScopeMeta);
    }
    if (data.containsKey('bowstyle')) {
      context.handle(
        _bowstyleMeta,
        bowstyle.isAcceptableOrUnknown(data['bowstyle']!, _bowstyleMeta),
      );
    } else if (isInserting) {
      context.missing(_bowstyleMeta);
    }
    if (data.containsKey('first_session_id')) {
      context.handle(
        _firstSessionIdMeta,
        firstSessionId.isAcceptableOrUnknown(
          data['first_session_id']!,
          _firstSessionIdMeta,
        ),
      );
    }
    if (data.containsKey('first_achieved_at')) {
      context.handle(
        _firstAchievedAtMeta,
        firstAchievedAt.isAcceptableOrUnknown(
          data['first_achieved_at']!,
          _firstAchievedAtMeta,
        ),
      );
    }
    if (data.containsKey('first_score')) {
      context.handle(
        _firstScoreMeta,
        firstScore.isAcceptableOrUnknown(data['first_score']!, _firstScoreMeta),
      );
    }
    if (data.containsKey('first_round_id')) {
      context.handle(
        _firstRoundIdMeta,
        firstRoundId.isAcceptableOrUnknown(
          data['first_round_id']!,
          _firstRoundIdMeta,
        ),
      );
    }
    if (data.containsKey('second_session_id')) {
      context.handle(
        _secondSessionIdMeta,
        secondSessionId.isAcceptableOrUnknown(
          data['second_session_id']!,
          _secondSessionIdMeta,
        ),
      );
    }
    if (data.containsKey('second_achieved_at')) {
      context.handle(
        _secondAchievedAtMeta,
        secondAchievedAt.isAcceptableOrUnknown(
          data['second_achieved_at']!,
          _secondAchievedAtMeta,
        ),
      );
    }
    if (data.containsKey('second_score')) {
      context.handle(
        _secondScoreMeta,
        secondScore.isAcceptableOrUnknown(
          data['second_score']!,
          _secondScoreMeta,
        ),
      );
    }
    if (data.containsKey('second_round_id')) {
      context.handle(
        _secondRoundIdMeta,
        secondRoundId.isAcceptableOrUnknown(
          data['second_round_id']!,
          _secondRoundIdMeta,
        ),
      );
    }
    if (data.containsKey('is_claimed')) {
      context.handle(
        _isClaimedMeta,
        isClaimed.isAcceptableOrUnknown(data['is_claimed']!, _isClaimedMeta),
      );
    }
    if (data.containsKey('claimed_at')) {
      context.handle(
        _claimedAtMeta,
        claimedAt.isAcceptableOrUnknown(data['claimed_at']!, _claimedAtMeta),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  Classification map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Classification(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      profileId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}profile_id'],
      )!,
      classification: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}classification'],
      )!,
      classificationScope: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}classification_scope'],
      )!,
      bowstyle: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}bowstyle'],
      )!,
      firstSessionId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}first_session_id'],
      ),
      firstAchievedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}first_achieved_at'],
      ),
      firstScore: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}first_score'],
      ),
      firstRoundId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}first_round_id'],
      ),
      secondSessionId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}second_session_id'],
      ),
      secondAchievedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}second_achieved_at'],
      ),
      secondScore: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}second_score'],
      ),
      secondRoundId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}second_round_id'],
      ),
      isClaimed: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_claimed'],
      )!,
      claimedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}claimed_at'],
      ),
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      )!,
    );
  }

  @override
  $ClassificationsTable createAlias(String alias) {
    return $ClassificationsTable(attachedDatabase, alias);
  }
}

class Classification extends DataClass implements Insertable<Classification> {
  final String id;
  final String profileId;
  final String classification;
  final String classificationScope;
  final String bowstyle;
  final String? firstSessionId;
  final DateTime? firstAchievedAt;
  final int? firstScore;
  final String? firstRoundId;
  final String? secondSessionId;
  final DateTime? secondAchievedAt;
  final int? secondScore;
  final String? secondRoundId;
  final bool isClaimed;
  final DateTime? claimedAt;
  final DateTime createdAt;
  final DateTime updatedAt;
  const Classification({
    required this.id,
    required this.profileId,
    required this.classification,
    required this.classificationScope,
    required this.bowstyle,
    this.firstSessionId,
    this.firstAchievedAt,
    this.firstScore,
    this.firstRoundId,
    this.secondSessionId,
    this.secondAchievedAt,
    this.secondScore,
    this.secondRoundId,
    required this.isClaimed,
    this.claimedAt,
    required this.createdAt,
    required this.updatedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['profile_id'] = Variable<String>(profileId);
    map['classification'] = Variable<String>(classification);
    map['classification_scope'] = Variable<String>(classificationScope);
    map['bowstyle'] = Variable<String>(bowstyle);
    if (!nullToAbsent || firstSessionId != null) {
      map['first_session_id'] = Variable<String>(firstSessionId);
    }
    if (!nullToAbsent || firstAchievedAt != null) {
      map['first_achieved_at'] = Variable<DateTime>(firstAchievedAt);
    }
    if (!nullToAbsent || firstScore != null) {
      map['first_score'] = Variable<int>(firstScore);
    }
    if (!nullToAbsent || firstRoundId != null) {
      map['first_round_id'] = Variable<String>(firstRoundId);
    }
    if (!nullToAbsent || secondSessionId != null) {
      map['second_session_id'] = Variable<String>(secondSessionId);
    }
    if (!nullToAbsent || secondAchievedAt != null) {
      map['second_achieved_at'] = Variable<DateTime>(secondAchievedAt);
    }
    if (!nullToAbsent || secondScore != null) {
      map['second_score'] = Variable<int>(secondScore);
    }
    if (!nullToAbsent || secondRoundId != null) {
      map['second_round_id'] = Variable<String>(secondRoundId);
    }
    map['is_claimed'] = Variable<bool>(isClaimed);
    if (!nullToAbsent || claimedAt != null) {
      map['claimed_at'] = Variable<DateTime>(claimedAt);
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    return map;
  }

  ClassificationsCompanion toCompanion(bool nullToAbsent) {
    return ClassificationsCompanion(
      id: Value(id),
      profileId: Value(profileId),
      classification: Value(classification),
      classificationScope: Value(classificationScope),
      bowstyle: Value(bowstyle),
      firstSessionId: firstSessionId == null && nullToAbsent
          ? const Value.absent()
          : Value(firstSessionId),
      firstAchievedAt: firstAchievedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(firstAchievedAt),
      firstScore: firstScore == null && nullToAbsent
          ? const Value.absent()
          : Value(firstScore),
      firstRoundId: firstRoundId == null && nullToAbsent
          ? const Value.absent()
          : Value(firstRoundId),
      secondSessionId: secondSessionId == null && nullToAbsent
          ? const Value.absent()
          : Value(secondSessionId),
      secondAchievedAt: secondAchievedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(secondAchievedAt),
      secondScore: secondScore == null && nullToAbsent
          ? const Value.absent()
          : Value(secondScore),
      secondRoundId: secondRoundId == null && nullToAbsent
          ? const Value.absent()
          : Value(secondRoundId),
      isClaimed: Value(isClaimed),
      claimedAt: claimedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(claimedAt),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory Classification.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Classification(
      id: serializer.fromJson<String>(json['id']),
      profileId: serializer.fromJson<String>(json['profileId']),
      classification: serializer.fromJson<String>(json['classification']),
      classificationScope: serializer.fromJson<String>(
        json['classificationScope'],
      ),
      bowstyle: serializer.fromJson<String>(json['bowstyle']),
      firstSessionId: serializer.fromJson<String?>(json['firstSessionId']),
      firstAchievedAt: serializer.fromJson<DateTime?>(json['firstAchievedAt']),
      firstScore: serializer.fromJson<int?>(json['firstScore']),
      firstRoundId: serializer.fromJson<String?>(json['firstRoundId']),
      secondSessionId: serializer.fromJson<String?>(json['secondSessionId']),
      secondAchievedAt: serializer.fromJson<DateTime?>(
        json['secondAchievedAt'],
      ),
      secondScore: serializer.fromJson<int?>(json['secondScore']),
      secondRoundId: serializer.fromJson<String?>(json['secondRoundId']),
      isClaimed: serializer.fromJson<bool>(json['isClaimed']),
      claimedAt: serializer.fromJson<DateTime?>(json['claimedAt']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'profileId': serializer.toJson<String>(profileId),
      'classification': serializer.toJson<String>(classification),
      'classificationScope': serializer.toJson<String>(classificationScope),
      'bowstyle': serializer.toJson<String>(bowstyle),
      'firstSessionId': serializer.toJson<String?>(firstSessionId),
      'firstAchievedAt': serializer.toJson<DateTime?>(firstAchievedAt),
      'firstScore': serializer.toJson<int?>(firstScore),
      'firstRoundId': serializer.toJson<String?>(firstRoundId),
      'secondSessionId': serializer.toJson<String?>(secondSessionId),
      'secondAchievedAt': serializer.toJson<DateTime?>(secondAchievedAt),
      'secondScore': serializer.toJson<int?>(secondScore),
      'secondRoundId': serializer.toJson<String?>(secondRoundId),
      'isClaimed': serializer.toJson<bool>(isClaimed),
      'claimedAt': serializer.toJson<DateTime?>(claimedAt),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
    };
  }

  Classification copyWith({
    String? id,
    String? profileId,
    String? classification,
    String? classificationScope,
    String? bowstyle,
    Value<String?> firstSessionId = const Value.absent(),
    Value<DateTime?> firstAchievedAt = const Value.absent(),
    Value<int?> firstScore = const Value.absent(),
    Value<String?> firstRoundId = const Value.absent(),
    Value<String?> secondSessionId = const Value.absent(),
    Value<DateTime?> secondAchievedAt = const Value.absent(),
    Value<int?> secondScore = const Value.absent(),
    Value<String?> secondRoundId = const Value.absent(),
    bool? isClaimed,
    Value<DateTime?> claimedAt = const Value.absent(),
    DateTime? createdAt,
    DateTime? updatedAt,
  }) => Classification(
    id: id ?? this.id,
    profileId: profileId ?? this.profileId,
    classification: classification ?? this.classification,
    classificationScope: classificationScope ?? this.classificationScope,
    bowstyle: bowstyle ?? this.bowstyle,
    firstSessionId: firstSessionId.present
        ? firstSessionId.value
        : this.firstSessionId,
    firstAchievedAt: firstAchievedAt.present
        ? firstAchievedAt.value
        : this.firstAchievedAt,
    firstScore: firstScore.present ? firstScore.value : this.firstScore,
    firstRoundId: firstRoundId.present ? firstRoundId.value : this.firstRoundId,
    secondSessionId: secondSessionId.present
        ? secondSessionId.value
        : this.secondSessionId,
    secondAchievedAt: secondAchievedAt.present
        ? secondAchievedAt.value
        : this.secondAchievedAt,
    secondScore: secondScore.present ? secondScore.value : this.secondScore,
    secondRoundId: secondRoundId.present
        ? secondRoundId.value
        : this.secondRoundId,
    isClaimed: isClaimed ?? this.isClaimed,
    claimedAt: claimedAt.present ? claimedAt.value : this.claimedAt,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
  );
  Classification copyWithCompanion(ClassificationsCompanion data) {
    return Classification(
      id: data.id.present ? data.id.value : this.id,
      profileId: data.profileId.present ? data.profileId.value : this.profileId,
      classification: data.classification.present
          ? data.classification.value
          : this.classification,
      classificationScope: data.classificationScope.present
          ? data.classificationScope.value
          : this.classificationScope,
      bowstyle: data.bowstyle.present ? data.bowstyle.value : this.bowstyle,
      firstSessionId: data.firstSessionId.present
          ? data.firstSessionId.value
          : this.firstSessionId,
      firstAchievedAt: data.firstAchievedAt.present
          ? data.firstAchievedAt.value
          : this.firstAchievedAt,
      firstScore: data.firstScore.present
          ? data.firstScore.value
          : this.firstScore,
      firstRoundId: data.firstRoundId.present
          ? data.firstRoundId.value
          : this.firstRoundId,
      secondSessionId: data.secondSessionId.present
          ? data.secondSessionId.value
          : this.secondSessionId,
      secondAchievedAt: data.secondAchievedAt.present
          ? data.secondAchievedAt.value
          : this.secondAchievedAt,
      secondScore: data.secondScore.present
          ? data.secondScore.value
          : this.secondScore,
      secondRoundId: data.secondRoundId.present
          ? data.secondRoundId.value
          : this.secondRoundId,
      isClaimed: data.isClaimed.present ? data.isClaimed.value : this.isClaimed,
      claimedAt: data.claimedAt.present ? data.claimedAt.value : this.claimedAt,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Classification(')
          ..write('id: $id, ')
          ..write('profileId: $profileId, ')
          ..write('classification: $classification, ')
          ..write('classificationScope: $classificationScope, ')
          ..write('bowstyle: $bowstyle, ')
          ..write('firstSessionId: $firstSessionId, ')
          ..write('firstAchievedAt: $firstAchievedAt, ')
          ..write('firstScore: $firstScore, ')
          ..write('firstRoundId: $firstRoundId, ')
          ..write('secondSessionId: $secondSessionId, ')
          ..write('secondAchievedAt: $secondAchievedAt, ')
          ..write('secondScore: $secondScore, ')
          ..write('secondRoundId: $secondRoundId, ')
          ..write('isClaimed: $isClaimed, ')
          ..write('claimedAt: $claimedAt, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    profileId,
    classification,
    classificationScope,
    bowstyle,
    firstSessionId,
    firstAchievedAt,
    firstScore,
    firstRoundId,
    secondSessionId,
    secondAchievedAt,
    secondScore,
    secondRoundId,
    isClaimed,
    claimedAt,
    createdAt,
    updatedAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Classification &&
          other.id == this.id &&
          other.profileId == this.profileId &&
          other.classification == this.classification &&
          other.classificationScope == this.classificationScope &&
          other.bowstyle == this.bowstyle &&
          other.firstSessionId == this.firstSessionId &&
          other.firstAchievedAt == this.firstAchievedAt &&
          other.firstScore == this.firstScore &&
          other.firstRoundId == this.firstRoundId &&
          other.secondSessionId == this.secondSessionId &&
          other.secondAchievedAt == this.secondAchievedAt &&
          other.secondScore == this.secondScore &&
          other.secondRoundId == this.secondRoundId &&
          other.isClaimed == this.isClaimed &&
          other.claimedAt == this.claimedAt &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class ClassificationsCompanion extends UpdateCompanion<Classification> {
  final Value<String> id;
  final Value<String> profileId;
  final Value<String> classification;
  final Value<String> classificationScope;
  final Value<String> bowstyle;
  final Value<String?> firstSessionId;
  final Value<DateTime?> firstAchievedAt;
  final Value<int?> firstScore;
  final Value<String?> firstRoundId;
  final Value<String?> secondSessionId;
  final Value<DateTime?> secondAchievedAt;
  final Value<int?> secondScore;
  final Value<String?> secondRoundId;
  final Value<bool> isClaimed;
  final Value<DateTime?> claimedAt;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  final Value<int> rowid;
  const ClassificationsCompanion({
    this.id = const Value.absent(),
    this.profileId = const Value.absent(),
    this.classification = const Value.absent(),
    this.classificationScope = const Value.absent(),
    this.bowstyle = const Value.absent(),
    this.firstSessionId = const Value.absent(),
    this.firstAchievedAt = const Value.absent(),
    this.firstScore = const Value.absent(),
    this.firstRoundId = const Value.absent(),
    this.secondSessionId = const Value.absent(),
    this.secondAchievedAt = const Value.absent(),
    this.secondScore = const Value.absent(),
    this.secondRoundId = const Value.absent(),
    this.isClaimed = const Value.absent(),
    this.claimedAt = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  ClassificationsCompanion.insert({
    required String id,
    required String profileId,
    required String classification,
    required String classificationScope,
    required String bowstyle,
    this.firstSessionId = const Value.absent(),
    this.firstAchievedAt = const Value.absent(),
    this.firstScore = const Value.absent(),
    this.firstRoundId = const Value.absent(),
    this.secondSessionId = const Value.absent(),
    this.secondAchievedAt = const Value.absent(),
    this.secondScore = const Value.absent(),
    this.secondRoundId = const Value.absent(),
    this.isClaimed = const Value.absent(),
    this.claimedAt = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       profileId = Value(profileId),
       classification = Value(classification),
       classificationScope = Value(classificationScope),
       bowstyle = Value(bowstyle);
  static Insertable<Classification> custom({
    Expression<String>? id,
    Expression<String>? profileId,
    Expression<String>? classification,
    Expression<String>? classificationScope,
    Expression<String>? bowstyle,
    Expression<String>? firstSessionId,
    Expression<DateTime>? firstAchievedAt,
    Expression<int>? firstScore,
    Expression<String>? firstRoundId,
    Expression<String>? secondSessionId,
    Expression<DateTime>? secondAchievedAt,
    Expression<int>? secondScore,
    Expression<String>? secondRoundId,
    Expression<bool>? isClaimed,
    Expression<DateTime>? claimedAt,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (profileId != null) 'profile_id': profileId,
      if (classification != null) 'classification': classification,
      if (classificationScope != null)
        'classification_scope': classificationScope,
      if (bowstyle != null) 'bowstyle': bowstyle,
      if (firstSessionId != null) 'first_session_id': firstSessionId,
      if (firstAchievedAt != null) 'first_achieved_at': firstAchievedAt,
      if (firstScore != null) 'first_score': firstScore,
      if (firstRoundId != null) 'first_round_id': firstRoundId,
      if (secondSessionId != null) 'second_session_id': secondSessionId,
      if (secondAchievedAt != null) 'second_achieved_at': secondAchievedAt,
      if (secondScore != null) 'second_score': secondScore,
      if (secondRoundId != null) 'second_round_id': secondRoundId,
      if (isClaimed != null) 'is_claimed': isClaimed,
      if (claimedAt != null) 'claimed_at': claimedAt,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  ClassificationsCompanion copyWith({
    Value<String>? id,
    Value<String>? profileId,
    Value<String>? classification,
    Value<String>? classificationScope,
    Value<String>? bowstyle,
    Value<String?>? firstSessionId,
    Value<DateTime?>? firstAchievedAt,
    Value<int?>? firstScore,
    Value<String?>? firstRoundId,
    Value<String?>? secondSessionId,
    Value<DateTime?>? secondAchievedAt,
    Value<int?>? secondScore,
    Value<String?>? secondRoundId,
    Value<bool>? isClaimed,
    Value<DateTime?>? claimedAt,
    Value<DateTime>? createdAt,
    Value<DateTime>? updatedAt,
    Value<int>? rowid,
  }) {
    return ClassificationsCompanion(
      id: id ?? this.id,
      profileId: profileId ?? this.profileId,
      classification: classification ?? this.classification,
      classificationScope: classificationScope ?? this.classificationScope,
      bowstyle: bowstyle ?? this.bowstyle,
      firstSessionId: firstSessionId ?? this.firstSessionId,
      firstAchievedAt: firstAchievedAt ?? this.firstAchievedAt,
      firstScore: firstScore ?? this.firstScore,
      firstRoundId: firstRoundId ?? this.firstRoundId,
      secondSessionId: secondSessionId ?? this.secondSessionId,
      secondAchievedAt: secondAchievedAt ?? this.secondAchievedAt,
      secondScore: secondScore ?? this.secondScore,
      secondRoundId: secondRoundId ?? this.secondRoundId,
      isClaimed: isClaimed ?? this.isClaimed,
      claimedAt: claimedAt ?? this.claimedAt,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (profileId.present) {
      map['profile_id'] = Variable<String>(profileId.value);
    }
    if (classification.present) {
      map['classification'] = Variable<String>(classification.value);
    }
    if (classificationScope.present) {
      map['classification_scope'] = Variable<String>(classificationScope.value);
    }
    if (bowstyle.present) {
      map['bowstyle'] = Variable<String>(bowstyle.value);
    }
    if (firstSessionId.present) {
      map['first_session_id'] = Variable<String>(firstSessionId.value);
    }
    if (firstAchievedAt.present) {
      map['first_achieved_at'] = Variable<DateTime>(firstAchievedAt.value);
    }
    if (firstScore.present) {
      map['first_score'] = Variable<int>(firstScore.value);
    }
    if (firstRoundId.present) {
      map['first_round_id'] = Variable<String>(firstRoundId.value);
    }
    if (secondSessionId.present) {
      map['second_session_id'] = Variable<String>(secondSessionId.value);
    }
    if (secondAchievedAt.present) {
      map['second_achieved_at'] = Variable<DateTime>(secondAchievedAt.value);
    }
    if (secondScore.present) {
      map['second_score'] = Variable<int>(secondScore.value);
    }
    if (secondRoundId.present) {
      map['second_round_id'] = Variable<String>(secondRoundId.value);
    }
    if (isClaimed.present) {
      map['is_claimed'] = Variable<bool>(isClaimed.value);
    }
    if (claimedAt.present) {
      map['claimed_at'] = Variable<DateTime>(claimedAt.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ClassificationsCompanion(')
          ..write('id: $id, ')
          ..write('profileId: $profileId, ')
          ..write('classification: $classification, ')
          ..write('classificationScope: $classificationScope, ')
          ..write('bowstyle: $bowstyle, ')
          ..write('firstSessionId: $firstSessionId, ')
          ..write('firstAchievedAt: $firstAchievedAt, ')
          ..write('firstScore: $firstScore, ')
          ..write('firstRoundId: $firstRoundId, ')
          ..write('secondSessionId: $secondSessionId, ')
          ..write('secondAchievedAt: $secondAchievedAt, ')
          ..write('secondScore: $secondScore, ')
          ..write('secondRoundId: $secondRoundId, ')
          ..write('isClaimed: $isClaimed, ')
          ..write('claimedAt: $claimedAt, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $AchievementsTable extends Achievements
    with TableInfo<$AchievementsTable, Achievement> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $AchievementsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _achievementTypeMeta = const VerificationMeta(
    'achievementType',
  );
  @override
  late final GeneratedColumn<String> achievementType = GeneratedColumn<String>(
    'achievement_type',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _skillIdMeta = const VerificationMeta(
    'skillId',
  );
  @override
  late final GeneratedColumn<String> skillId = GeneratedColumn<String>(
    'skill_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _roundTypeIdMeta = const VerificationMeta(
    'roundTypeId',
  );
  @override
  late final GeneratedColumn<String> roundTypeId = GeneratedColumn<String>(
    'round_type_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _scoreMeta = const VerificationMeta('score');
  @override
  late final GeneratedColumn<int> score = GeneratedColumn<int>(
    'score',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _titleMeta = const VerificationMeta('title');
  @override
  late final GeneratedColumn<String> title = GeneratedColumn<String>(
    'title',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _descriptionMeta = const VerificationMeta(
    'description',
  );
  @override
  late final GeneratedColumn<String> description = GeneratedColumn<String>(
    'description',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _isCompetitionPbMeta = const VerificationMeta(
    'isCompetitionPb',
  );
  @override
  late final GeneratedColumn<bool> isCompetitionPb = GeneratedColumn<bool>(
    'is_competition_pb',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_competition_pb" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _earnedAtMeta = const VerificationMeta(
    'earnedAt',
  );
  @override
  late final GeneratedColumn<DateTime> earnedAt = GeneratedColumn<DateTime>(
    'earned_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    achievementType,
    skillId,
    roundTypeId,
    score,
    title,
    description,
    isCompetitionPb,
    earnedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'achievements';
  @override
  VerificationContext validateIntegrity(
    Insertable<Achievement> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('achievement_type')) {
      context.handle(
        _achievementTypeMeta,
        achievementType.isAcceptableOrUnknown(
          data['achievement_type']!,
          _achievementTypeMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_achievementTypeMeta);
    }
    if (data.containsKey('skill_id')) {
      context.handle(
        _skillIdMeta,
        skillId.isAcceptableOrUnknown(data['skill_id']!, _skillIdMeta),
      );
    }
    if (data.containsKey('round_type_id')) {
      context.handle(
        _roundTypeIdMeta,
        roundTypeId.isAcceptableOrUnknown(
          data['round_type_id']!,
          _roundTypeIdMeta,
        ),
      );
    }
    if (data.containsKey('score')) {
      context.handle(
        _scoreMeta,
        score.isAcceptableOrUnknown(data['score']!, _scoreMeta),
      );
    }
    if (data.containsKey('title')) {
      context.handle(
        _titleMeta,
        title.isAcceptableOrUnknown(data['title']!, _titleMeta),
      );
    } else if (isInserting) {
      context.missing(_titleMeta);
    }
    if (data.containsKey('description')) {
      context.handle(
        _descriptionMeta,
        description.isAcceptableOrUnknown(
          data['description']!,
          _descriptionMeta,
        ),
      );
    }
    if (data.containsKey('is_competition_pb')) {
      context.handle(
        _isCompetitionPbMeta,
        isCompetitionPb.isAcceptableOrUnknown(
          data['is_competition_pb']!,
          _isCompetitionPbMeta,
        ),
      );
    }
    if (data.containsKey('earned_at')) {
      context.handle(
        _earnedAtMeta,
        earnedAt.isAcceptableOrUnknown(data['earned_at']!, _earnedAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  Achievement map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Achievement(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      achievementType: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}achievement_type'],
      )!,
      skillId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}skill_id'],
      ),
      roundTypeId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}round_type_id'],
      ),
      score: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}score'],
      ),
      title: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}title'],
      )!,
      description: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}description'],
      ),
      isCompetitionPb: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_competition_pb'],
      )!,
      earnedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}earned_at'],
      )!,
    );
  }

  @override
  $AchievementsTable createAlias(String alias) {
    return $AchievementsTable(attachedDatabase, alias);
  }
}

class Achievement extends DataClass implements Insertable<Achievement> {
  final String id;
  final String achievementType;
  final String? skillId;
  final String? roundTypeId;
  final int? score;
  final String title;
  final String? description;
  final bool isCompetitionPb;
  final DateTime earnedAt;
  const Achievement({
    required this.id,
    required this.achievementType,
    this.skillId,
    this.roundTypeId,
    this.score,
    required this.title,
    this.description,
    required this.isCompetitionPb,
    required this.earnedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['achievement_type'] = Variable<String>(achievementType);
    if (!nullToAbsent || skillId != null) {
      map['skill_id'] = Variable<String>(skillId);
    }
    if (!nullToAbsent || roundTypeId != null) {
      map['round_type_id'] = Variable<String>(roundTypeId);
    }
    if (!nullToAbsent || score != null) {
      map['score'] = Variable<int>(score);
    }
    map['title'] = Variable<String>(title);
    if (!nullToAbsent || description != null) {
      map['description'] = Variable<String>(description);
    }
    map['is_competition_pb'] = Variable<bool>(isCompetitionPb);
    map['earned_at'] = Variable<DateTime>(earnedAt);
    return map;
  }

  AchievementsCompanion toCompanion(bool nullToAbsent) {
    return AchievementsCompanion(
      id: Value(id),
      achievementType: Value(achievementType),
      skillId: skillId == null && nullToAbsent
          ? const Value.absent()
          : Value(skillId),
      roundTypeId: roundTypeId == null && nullToAbsent
          ? const Value.absent()
          : Value(roundTypeId),
      score: score == null && nullToAbsent
          ? const Value.absent()
          : Value(score),
      title: Value(title),
      description: description == null && nullToAbsent
          ? const Value.absent()
          : Value(description),
      isCompetitionPb: Value(isCompetitionPb),
      earnedAt: Value(earnedAt),
    );
  }

  factory Achievement.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Achievement(
      id: serializer.fromJson<String>(json['id']),
      achievementType: serializer.fromJson<String>(json['achievementType']),
      skillId: serializer.fromJson<String?>(json['skillId']),
      roundTypeId: serializer.fromJson<String?>(json['roundTypeId']),
      score: serializer.fromJson<int?>(json['score']),
      title: serializer.fromJson<String>(json['title']),
      description: serializer.fromJson<String?>(json['description']),
      isCompetitionPb: serializer.fromJson<bool>(json['isCompetitionPb']),
      earnedAt: serializer.fromJson<DateTime>(json['earnedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'achievementType': serializer.toJson<String>(achievementType),
      'skillId': serializer.toJson<String?>(skillId),
      'roundTypeId': serializer.toJson<String?>(roundTypeId),
      'score': serializer.toJson<int?>(score),
      'title': serializer.toJson<String>(title),
      'description': serializer.toJson<String?>(description),
      'isCompetitionPb': serializer.toJson<bool>(isCompetitionPb),
      'earnedAt': serializer.toJson<DateTime>(earnedAt),
    };
  }

  Achievement copyWith({
    String? id,
    String? achievementType,
    Value<String?> skillId = const Value.absent(),
    Value<String?> roundTypeId = const Value.absent(),
    Value<int?> score = const Value.absent(),
    String? title,
    Value<String?> description = const Value.absent(),
    bool? isCompetitionPb,
    DateTime? earnedAt,
  }) => Achievement(
    id: id ?? this.id,
    achievementType: achievementType ?? this.achievementType,
    skillId: skillId.present ? skillId.value : this.skillId,
    roundTypeId: roundTypeId.present ? roundTypeId.value : this.roundTypeId,
    score: score.present ? score.value : this.score,
    title: title ?? this.title,
    description: description.present ? description.value : this.description,
    isCompetitionPb: isCompetitionPb ?? this.isCompetitionPb,
    earnedAt: earnedAt ?? this.earnedAt,
  );
  Achievement copyWithCompanion(AchievementsCompanion data) {
    return Achievement(
      id: data.id.present ? data.id.value : this.id,
      achievementType: data.achievementType.present
          ? data.achievementType.value
          : this.achievementType,
      skillId: data.skillId.present ? data.skillId.value : this.skillId,
      roundTypeId: data.roundTypeId.present
          ? data.roundTypeId.value
          : this.roundTypeId,
      score: data.score.present ? data.score.value : this.score,
      title: data.title.present ? data.title.value : this.title,
      description: data.description.present
          ? data.description.value
          : this.description,
      isCompetitionPb: data.isCompetitionPb.present
          ? data.isCompetitionPb.value
          : this.isCompetitionPb,
      earnedAt: data.earnedAt.present ? data.earnedAt.value : this.earnedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Achievement(')
          ..write('id: $id, ')
          ..write('achievementType: $achievementType, ')
          ..write('skillId: $skillId, ')
          ..write('roundTypeId: $roundTypeId, ')
          ..write('score: $score, ')
          ..write('title: $title, ')
          ..write('description: $description, ')
          ..write('isCompetitionPb: $isCompetitionPb, ')
          ..write('earnedAt: $earnedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    achievementType,
    skillId,
    roundTypeId,
    score,
    title,
    description,
    isCompetitionPb,
    earnedAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Achievement &&
          other.id == this.id &&
          other.achievementType == this.achievementType &&
          other.skillId == this.skillId &&
          other.roundTypeId == this.roundTypeId &&
          other.score == this.score &&
          other.title == this.title &&
          other.description == this.description &&
          other.isCompetitionPb == this.isCompetitionPb &&
          other.earnedAt == this.earnedAt);
}

class AchievementsCompanion extends UpdateCompanion<Achievement> {
  final Value<String> id;
  final Value<String> achievementType;
  final Value<String?> skillId;
  final Value<String?> roundTypeId;
  final Value<int?> score;
  final Value<String> title;
  final Value<String?> description;
  final Value<bool> isCompetitionPb;
  final Value<DateTime> earnedAt;
  final Value<int> rowid;
  const AchievementsCompanion({
    this.id = const Value.absent(),
    this.achievementType = const Value.absent(),
    this.skillId = const Value.absent(),
    this.roundTypeId = const Value.absent(),
    this.score = const Value.absent(),
    this.title = const Value.absent(),
    this.description = const Value.absent(),
    this.isCompetitionPb = const Value.absent(),
    this.earnedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  AchievementsCompanion.insert({
    required String id,
    required String achievementType,
    this.skillId = const Value.absent(),
    this.roundTypeId = const Value.absent(),
    this.score = const Value.absent(),
    required String title,
    this.description = const Value.absent(),
    this.isCompetitionPb = const Value.absent(),
    this.earnedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       achievementType = Value(achievementType),
       title = Value(title);
  static Insertable<Achievement> custom({
    Expression<String>? id,
    Expression<String>? achievementType,
    Expression<String>? skillId,
    Expression<String>? roundTypeId,
    Expression<int>? score,
    Expression<String>? title,
    Expression<String>? description,
    Expression<bool>? isCompetitionPb,
    Expression<DateTime>? earnedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (achievementType != null) 'achievement_type': achievementType,
      if (skillId != null) 'skill_id': skillId,
      if (roundTypeId != null) 'round_type_id': roundTypeId,
      if (score != null) 'score': score,
      if (title != null) 'title': title,
      if (description != null) 'description': description,
      if (isCompetitionPb != null) 'is_competition_pb': isCompetitionPb,
      if (earnedAt != null) 'earned_at': earnedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  AchievementsCompanion copyWith({
    Value<String>? id,
    Value<String>? achievementType,
    Value<String?>? skillId,
    Value<String?>? roundTypeId,
    Value<int?>? score,
    Value<String>? title,
    Value<String?>? description,
    Value<bool>? isCompetitionPb,
    Value<DateTime>? earnedAt,
    Value<int>? rowid,
  }) {
    return AchievementsCompanion(
      id: id ?? this.id,
      achievementType: achievementType ?? this.achievementType,
      skillId: skillId ?? this.skillId,
      roundTypeId: roundTypeId ?? this.roundTypeId,
      score: score ?? this.score,
      title: title ?? this.title,
      description: description ?? this.description,
      isCompetitionPb: isCompetitionPb ?? this.isCompetitionPb,
      earnedAt: earnedAt ?? this.earnedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (achievementType.present) {
      map['achievement_type'] = Variable<String>(achievementType.value);
    }
    if (skillId.present) {
      map['skill_id'] = Variable<String>(skillId.value);
    }
    if (roundTypeId.present) {
      map['round_type_id'] = Variable<String>(roundTypeId.value);
    }
    if (score.present) {
      map['score'] = Variable<int>(score.value);
    }
    if (title.present) {
      map['title'] = Variable<String>(title.value);
    }
    if (description.present) {
      map['description'] = Variable<String>(description.value);
    }
    if (isCompetitionPb.present) {
      map['is_competition_pb'] = Variable<bool>(isCompetitionPb.value);
    }
    if (earnedAt.present) {
      map['earned_at'] = Variable<DateTime>(earnedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AchievementsCompanion(')
          ..write('id: $id, ')
          ..write('achievementType: $achievementType, ')
          ..write('skillId: $skillId, ')
          ..write('roundTypeId: $roundTypeId, ')
          ..write('score: $score, ')
          ..write('title: $title, ')
          ..write('description: $description, ')
          ..write('isCompetitionPb: $isCompetitionPb, ')
          ..write('earnedAt: $earnedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $EntitlementsTable extends Entitlements
    with TableInfo<$EntitlementsTable, Entitlement> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $EntitlementsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _tierMeta = const VerificationMeta('tier');
  @override
  late final GeneratedColumn<String> tier = GeneratedColumn<String>(
    'tier',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('archer'),
  );
  static const VerificationMeta _stripeCustomerIdMeta = const VerificationMeta(
    'stripeCustomerId',
  );
  @override
  late final GeneratedColumn<String> stripeCustomerId = GeneratedColumn<String>(
    'stripe_customer_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _stripeSubscriptionIdMeta =
      const VerificationMeta('stripeSubscriptionId');
  @override
  late final GeneratedColumn<String> stripeSubscriptionId =
      GeneratedColumn<String>(
        'stripe_subscription_id',
        aliasedName,
        true,
        type: DriftSqlType.string,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _expiresAtMeta = const VerificationMeta(
    'expiresAt',
  );
  @override
  late final GeneratedColumn<DateTime> expiresAt = GeneratedColumn<DateTime>(
    'expires_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _graceEndsAtMeta = const VerificationMeta(
    'graceEndsAt',
  );
  @override
  late final GeneratedColumn<DateTime> graceEndsAt = GeneratedColumn<DateTime>(
    'grace_ends_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _isLegacy3dAimingMeta = const VerificationMeta(
    'isLegacy3dAiming',
  );
  @override
  late final GeneratedColumn<bool> isLegacy3dAiming = GeneratedColumn<bool>(
    'is_legacy3d_aiming',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_legacy3d_aiming" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _legacyEmailMeta = const VerificationMeta(
    'legacyEmail',
  );
  @override
  late final GeneratedColumn<String> legacyEmail = GeneratedColumn<String>(
    'legacy_email',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    tier,
    stripeCustomerId,
    stripeSubscriptionId,
    expiresAt,
    graceEndsAt,
    isLegacy3dAiming,
    legacyEmail,
    createdAt,
    updatedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'entitlements';
  @override
  VerificationContext validateIntegrity(
    Insertable<Entitlement> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('tier')) {
      context.handle(
        _tierMeta,
        tier.isAcceptableOrUnknown(data['tier']!, _tierMeta),
      );
    }
    if (data.containsKey('stripe_customer_id')) {
      context.handle(
        _stripeCustomerIdMeta,
        stripeCustomerId.isAcceptableOrUnknown(
          data['stripe_customer_id']!,
          _stripeCustomerIdMeta,
        ),
      );
    }
    if (data.containsKey('stripe_subscription_id')) {
      context.handle(
        _stripeSubscriptionIdMeta,
        stripeSubscriptionId.isAcceptableOrUnknown(
          data['stripe_subscription_id']!,
          _stripeSubscriptionIdMeta,
        ),
      );
    }
    if (data.containsKey('expires_at')) {
      context.handle(
        _expiresAtMeta,
        expiresAt.isAcceptableOrUnknown(data['expires_at']!, _expiresAtMeta),
      );
    }
    if (data.containsKey('grace_ends_at')) {
      context.handle(
        _graceEndsAtMeta,
        graceEndsAt.isAcceptableOrUnknown(
          data['grace_ends_at']!,
          _graceEndsAtMeta,
        ),
      );
    }
    if (data.containsKey('is_legacy3d_aiming')) {
      context.handle(
        _isLegacy3dAimingMeta,
        isLegacy3dAiming.isAcceptableOrUnknown(
          data['is_legacy3d_aiming']!,
          _isLegacy3dAimingMeta,
        ),
      );
    }
    if (data.containsKey('legacy_email')) {
      context.handle(
        _legacyEmailMeta,
        legacyEmail.isAcceptableOrUnknown(
          data['legacy_email']!,
          _legacyEmailMeta,
        ),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  Entitlement map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Entitlement(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      tier: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}tier'],
      )!,
      stripeCustomerId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}stripe_customer_id'],
      ),
      stripeSubscriptionId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}stripe_subscription_id'],
      ),
      expiresAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}expires_at'],
      ),
      graceEndsAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}grace_ends_at'],
      ),
      isLegacy3dAiming: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_legacy3d_aiming'],
      )!,
      legacyEmail: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}legacy_email'],
      ),
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      )!,
    );
  }

  @override
  $EntitlementsTable createAlias(String alias) {
    return $EntitlementsTable(attachedDatabase, alias);
  }
}

class Entitlement extends DataClass implements Insertable<Entitlement> {
  final String id;
  final String tier;
  final String? stripeCustomerId;
  final String? stripeSubscriptionId;
  final DateTime? expiresAt;
  final DateTime? graceEndsAt;
  final bool isLegacy3dAiming;
  final String? legacyEmail;
  final DateTime createdAt;
  final DateTime updatedAt;
  const Entitlement({
    required this.id,
    required this.tier,
    this.stripeCustomerId,
    this.stripeSubscriptionId,
    this.expiresAt,
    this.graceEndsAt,
    required this.isLegacy3dAiming,
    this.legacyEmail,
    required this.createdAt,
    required this.updatedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['tier'] = Variable<String>(tier);
    if (!nullToAbsent || stripeCustomerId != null) {
      map['stripe_customer_id'] = Variable<String>(stripeCustomerId);
    }
    if (!nullToAbsent || stripeSubscriptionId != null) {
      map['stripe_subscription_id'] = Variable<String>(stripeSubscriptionId);
    }
    if (!nullToAbsent || expiresAt != null) {
      map['expires_at'] = Variable<DateTime>(expiresAt);
    }
    if (!nullToAbsent || graceEndsAt != null) {
      map['grace_ends_at'] = Variable<DateTime>(graceEndsAt);
    }
    map['is_legacy3d_aiming'] = Variable<bool>(isLegacy3dAiming);
    if (!nullToAbsent || legacyEmail != null) {
      map['legacy_email'] = Variable<String>(legacyEmail);
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    return map;
  }

  EntitlementsCompanion toCompanion(bool nullToAbsent) {
    return EntitlementsCompanion(
      id: Value(id),
      tier: Value(tier),
      stripeCustomerId: stripeCustomerId == null && nullToAbsent
          ? const Value.absent()
          : Value(stripeCustomerId),
      stripeSubscriptionId: stripeSubscriptionId == null && nullToAbsent
          ? const Value.absent()
          : Value(stripeSubscriptionId),
      expiresAt: expiresAt == null && nullToAbsent
          ? const Value.absent()
          : Value(expiresAt),
      graceEndsAt: graceEndsAt == null && nullToAbsent
          ? const Value.absent()
          : Value(graceEndsAt),
      isLegacy3dAiming: Value(isLegacy3dAiming),
      legacyEmail: legacyEmail == null && nullToAbsent
          ? const Value.absent()
          : Value(legacyEmail),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory Entitlement.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Entitlement(
      id: serializer.fromJson<String>(json['id']),
      tier: serializer.fromJson<String>(json['tier']),
      stripeCustomerId: serializer.fromJson<String?>(json['stripeCustomerId']),
      stripeSubscriptionId: serializer.fromJson<String?>(
        json['stripeSubscriptionId'],
      ),
      expiresAt: serializer.fromJson<DateTime?>(json['expiresAt']),
      graceEndsAt: serializer.fromJson<DateTime?>(json['graceEndsAt']),
      isLegacy3dAiming: serializer.fromJson<bool>(json['isLegacy3dAiming']),
      legacyEmail: serializer.fromJson<String?>(json['legacyEmail']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'tier': serializer.toJson<String>(tier),
      'stripeCustomerId': serializer.toJson<String?>(stripeCustomerId),
      'stripeSubscriptionId': serializer.toJson<String?>(stripeSubscriptionId),
      'expiresAt': serializer.toJson<DateTime?>(expiresAt),
      'graceEndsAt': serializer.toJson<DateTime?>(graceEndsAt),
      'isLegacy3dAiming': serializer.toJson<bool>(isLegacy3dAiming),
      'legacyEmail': serializer.toJson<String?>(legacyEmail),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
    };
  }

  Entitlement copyWith({
    String? id,
    String? tier,
    Value<String?> stripeCustomerId = const Value.absent(),
    Value<String?> stripeSubscriptionId = const Value.absent(),
    Value<DateTime?> expiresAt = const Value.absent(),
    Value<DateTime?> graceEndsAt = const Value.absent(),
    bool? isLegacy3dAiming,
    Value<String?> legacyEmail = const Value.absent(),
    DateTime? createdAt,
    DateTime? updatedAt,
  }) => Entitlement(
    id: id ?? this.id,
    tier: tier ?? this.tier,
    stripeCustomerId: stripeCustomerId.present
        ? stripeCustomerId.value
        : this.stripeCustomerId,
    stripeSubscriptionId: stripeSubscriptionId.present
        ? stripeSubscriptionId.value
        : this.stripeSubscriptionId,
    expiresAt: expiresAt.present ? expiresAt.value : this.expiresAt,
    graceEndsAt: graceEndsAt.present ? graceEndsAt.value : this.graceEndsAt,
    isLegacy3dAiming: isLegacy3dAiming ?? this.isLegacy3dAiming,
    legacyEmail: legacyEmail.present ? legacyEmail.value : this.legacyEmail,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
  );
  Entitlement copyWithCompanion(EntitlementsCompanion data) {
    return Entitlement(
      id: data.id.present ? data.id.value : this.id,
      tier: data.tier.present ? data.tier.value : this.tier,
      stripeCustomerId: data.stripeCustomerId.present
          ? data.stripeCustomerId.value
          : this.stripeCustomerId,
      stripeSubscriptionId: data.stripeSubscriptionId.present
          ? data.stripeSubscriptionId.value
          : this.stripeSubscriptionId,
      expiresAt: data.expiresAt.present ? data.expiresAt.value : this.expiresAt,
      graceEndsAt: data.graceEndsAt.present
          ? data.graceEndsAt.value
          : this.graceEndsAt,
      isLegacy3dAiming: data.isLegacy3dAiming.present
          ? data.isLegacy3dAiming.value
          : this.isLegacy3dAiming,
      legacyEmail: data.legacyEmail.present
          ? data.legacyEmail.value
          : this.legacyEmail,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Entitlement(')
          ..write('id: $id, ')
          ..write('tier: $tier, ')
          ..write('stripeCustomerId: $stripeCustomerId, ')
          ..write('stripeSubscriptionId: $stripeSubscriptionId, ')
          ..write('expiresAt: $expiresAt, ')
          ..write('graceEndsAt: $graceEndsAt, ')
          ..write('isLegacy3dAiming: $isLegacy3dAiming, ')
          ..write('legacyEmail: $legacyEmail, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    tier,
    stripeCustomerId,
    stripeSubscriptionId,
    expiresAt,
    graceEndsAt,
    isLegacy3dAiming,
    legacyEmail,
    createdAt,
    updatedAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Entitlement &&
          other.id == this.id &&
          other.tier == this.tier &&
          other.stripeCustomerId == this.stripeCustomerId &&
          other.stripeSubscriptionId == this.stripeSubscriptionId &&
          other.expiresAt == this.expiresAt &&
          other.graceEndsAt == this.graceEndsAt &&
          other.isLegacy3dAiming == this.isLegacy3dAiming &&
          other.legacyEmail == this.legacyEmail &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class EntitlementsCompanion extends UpdateCompanion<Entitlement> {
  final Value<String> id;
  final Value<String> tier;
  final Value<String?> stripeCustomerId;
  final Value<String?> stripeSubscriptionId;
  final Value<DateTime?> expiresAt;
  final Value<DateTime?> graceEndsAt;
  final Value<bool> isLegacy3dAiming;
  final Value<String?> legacyEmail;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  final Value<int> rowid;
  const EntitlementsCompanion({
    this.id = const Value.absent(),
    this.tier = const Value.absent(),
    this.stripeCustomerId = const Value.absent(),
    this.stripeSubscriptionId = const Value.absent(),
    this.expiresAt = const Value.absent(),
    this.graceEndsAt = const Value.absent(),
    this.isLegacy3dAiming = const Value.absent(),
    this.legacyEmail = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  EntitlementsCompanion.insert({
    required String id,
    this.tier = const Value.absent(),
    this.stripeCustomerId = const Value.absent(),
    this.stripeSubscriptionId = const Value.absent(),
    this.expiresAt = const Value.absent(),
    this.graceEndsAt = const Value.absent(),
    this.isLegacy3dAiming = const Value.absent(),
    this.legacyEmail = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id);
  static Insertable<Entitlement> custom({
    Expression<String>? id,
    Expression<String>? tier,
    Expression<String>? stripeCustomerId,
    Expression<String>? stripeSubscriptionId,
    Expression<DateTime>? expiresAt,
    Expression<DateTime>? graceEndsAt,
    Expression<bool>? isLegacy3dAiming,
    Expression<String>? legacyEmail,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (tier != null) 'tier': tier,
      if (stripeCustomerId != null) 'stripe_customer_id': stripeCustomerId,
      if (stripeSubscriptionId != null)
        'stripe_subscription_id': stripeSubscriptionId,
      if (expiresAt != null) 'expires_at': expiresAt,
      if (graceEndsAt != null) 'grace_ends_at': graceEndsAt,
      if (isLegacy3dAiming != null) 'is_legacy3d_aiming': isLegacy3dAiming,
      if (legacyEmail != null) 'legacy_email': legacyEmail,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  EntitlementsCompanion copyWith({
    Value<String>? id,
    Value<String>? tier,
    Value<String?>? stripeCustomerId,
    Value<String?>? stripeSubscriptionId,
    Value<DateTime?>? expiresAt,
    Value<DateTime?>? graceEndsAt,
    Value<bool>? isLegacy3dAiming,
    Value<String?>? legacyEmail,
    Value<DateTime>? createdAt,
    Value<DateTime>? updatedAt,
    Value<int>? rowid,
  }) {
    return EntitlementsCompanion(
      id: id ?? this.id,
      tier: tier ?? this.tier,
      stripeCustomerId: stripeCustomerId ?? this.stripeCustomerId,
      stripeSubscriptionId: stripeSubscriptionId ?? this.stripeSubscriptionId,
      expiresAt: expiresAt ?? this.expiresAt,
      graceEndsAt: graceEndsAt ?? this.graceEndsAt,
      isLegacy3dAiming: isLegacy3dAiming ?? this.isLegacy3dAiming,
      legacyEmail: legacyEmail ?? this.legacyEmail,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (tier.present) {
      map['tier'] = Variable<String>(tier.value);
    }
    if (stripeCustomerId.present) {
      map['stripe_customer_id'] = Variable<String>(stripeCustomerId.value);
    }
    if (stripeSubscriptionId.present) {
      map['stripe_subscription_id'] = Variable<String>(
        stripeSubscriptionId.value,
      );
    }
    if (expiresAt.present) {
      map['expires_at'] = Variable<DateTime>(expiresAt.value);
    }
    if (graceEndsAt.present) {
      map['grace_ends_at'] = Variable<DateTime>(graceEndsAt.value);
    }
    if (isLegacy3dAiming.present) {
      map['is_legacy3d_aiming'] = Variable<bool>(isLegacy3dAiming.value);
    }
    if (legacyEmail.present) {
      map['legacy_email'] = Variable<String>(legacyEmail.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('EntitlementsCompanion(')
          ..write('id: $id, ')
          ..write('tier: $tier, ')
          ..write('stripeCustomerId: $stripeCustomerId, ')
          ..write('stripeSubscriptionId: $stripeSubscriptionId, ')
          ..write('expiresAt: $expiresAt, ')
          ..write('graceEndsAt: $graceEndsAt, ')
          ..write('isLegacy3dAiming: $isLegacy3dAiming, ')
          ..write('legacyEmail: $legacyEmail, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $CourseProgressTable extends CourseProgress
    with TableInfo<$CourseProgressTable, CourseProgressData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $CourseProgressTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _courseIdMeta = const VerificationMeta(
    'courseId',
  );
  @override
  late final GeneratedColumn<String> courseId = GeneratedColumn<String>(
    'course_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _lessonIdMeta = const VerificationMeta(
    'lessonId',
  );
  @override
  late final GeneratedColumn<String> lessonId = GeneratedColumn<String>(
    'lesson_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _progressSecondsMeta = const VerificationMeta(
    'progressSeconds',
  );
  @override
  late final GeneratedColumn<int> progressSeconds = GeneratedColumn<int>(
    'progress_seconds',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _durationSecondsMeta = const VerificationMeta(
    'durationSeconds',
  );
  @override
  late final GeneratedColumn<int> durationSeconds = GeneratedColumn<int>(
    'duration_seconds',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _isCompletedMeta = const VerificationMeta(
    'isCompleted',
  );
  @override
  late final GeneratedColumn<bool> isCompleted = GeneratedColumn<bool>(
    'is_completed',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_completed" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _lastWatchedAtMeta = const VerificationMeta(
    'lastWatchedAt',
  );
  @override
  late final GeneratedColumn<DateTime> lastWatchedAt =
      GeneratedColumn<DateTime>(
        'last_watched_at',
        aliasedName,
        true,
        type: DriftSqlType.dateTime,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _completedAtMeta = const VerificationMeta(
    'completedAt',
  );
  @override
  late final GeneratedColumn<DateTime> completedAt = GeneratedColumn<DateTime>(
    'completed_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    courseId,
    lessonId,
    progressSeconds,
    durationSeconds,
    isCompleted,
    lastWatchedAt,
    completedAt,
    createdAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'course_progress';
  @override
  VerificationContext validateIntegrity(
    Insertable<CourseProgressData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('course_id')) {
      context.handle(
        _courseIdMeta,
        courseId.isAcceptableOrUnknown(data['course_id']!, _courseIdMeta),
      );
    } else if (isInserting) {
      context.missing(_courseIdMeta);
    }
    if (data.containsKey('lesson_id')) {
      context.handle(
        _lessonIdMeta,
        lessonId.isAcceptableOrUnknown(data['lesson_id']!, _lessonIdMeta),
      );
    } else if (isInserting) {
      context.missing(_lessonIdMeta);
    }
    if (data.containsKey('progress_seconds')) {
      context.handle(
        _progressSecondsMeta,
        progressSeconds.isAcceptableOrUnknown(
          data['progress_seconds']!,
          _progressSecondsMeta,
        ),
      );
    }
    if (data.containsKey('duration_seconds')) {
      context.handle(
        _durationSecondsMeta,
        durationSeconds.isAcceptableOrUnknown(
          data['duration_seconds']!,
          _durationSecondsMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_durationSecondsMeta);
    }
    if (data.containsKey('is_completed')) {
      context.handle(
        _isCompletedMeta,
        isCompleted.isAcceptableOrUnknown(
          data['is_completed']!,
          _isCompletedMeta,
        ),
      );
    }
    if (data.containsKey('last_watched_at')) {
      context.handle(
        _lastWatchedAtMeta,
        lastWatchedAt.isAcceptableOrUnknown(
          data['last_watched_at']!,
          _lastWatchedAtMeta,
        ),
      );
    }
    if (data.containsKey('completed_at')) {
      context.handle(
        _completedAtMeta,
        completedAt.isAcceptableOrUnknown(
          data['completed_at']!,
          _completedAtMeta,
        ),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  CourseProgressData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return CourseProgressData(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      courseId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}course_id'],
      )!,
      lessonId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}lesson_id'],
      )!,
      progressSeconds: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}progress_seconds'],
      )!,
      durationSeconds: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}duration_seconds'],
      )!,
      isCompleted: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_completed'],
      )!,
      lastWatchedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}last_watched_at'],
      ),
      completedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}completed_at'],
      ),
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
    );
  }

  @override
  $CourseProgressTable createAlias(String alias) {
    return $CourseProgressTable(attachedDatabase, alias);
  }
}

class CourseProgressData extends DataClass
    implements Insertable<CourseProgressData> {
  final String id;
  final String courseId;
  final String lessonId;
  final int progressSeconds;
  final int durationSeconds;
  final bool isCompleted;
  final DateTime? lastWatchedAt;
  final DateTime? completedAt;
  final DateTime createdAt;
  const CourseProgressData({
    required this.id,
    required this.courseId,
    required this.lessonId,
    required this.progressSeconds,
    required this.durationSeconds,
    required this.isCompleted,
    this.lastWatchedAt,
    this.completedAt,
    required this.createdAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['course_id'] = Variable<String>(courseId);
    map['lesson_id'] = Variable<String>(lessonId);
    map['progress_seconds'] = Variable<int>(progressSeconds);
    map['duration_seconds'] = Variable<int>(durationSeconds);
    map['is_completed'] = Variable<bool>(isCompleted);
    if (!nullToAbsent || lastWatchedAt != null) {
      map['last_watched_at'] = Variable<DateTime>(lastWatchedAt);
    }
    if (!nullToAbsent || completedAt != null) {
      map['completed_at'] = Variable<DateTime>(completedAt);
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    return map;
  }

  CourseProgressCompanion toCompanion(bool nullToAbsent) {
    return CourseProgressCompanion(
      id: Value(id),
      courseId: Value(courseId),
      lessonId: Value(lessonId),
      progressSeconds: Value(progressSeconds),
      durationSeconds: Value(durationSeconds),
      isCompleted: Value(isCompleted),
      lastWatchedAt: lastWatchedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(lastWatchedAt),
      completedAt: completedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(completedAt),
      createdAt: Value(createdAt),
    );
  }

  factory CourseProgressData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return CourseProgressData(
      id: serializer.fromJson<String>(json['id']),
      courseId: serializer.fromJson<String>(json['courseId']),
      lessonId: serializer.fromJson<String>(json['lessonId']),
      progressSeconds: serializer.fromJson<int>(json['progressSeconds']),
      durationSeconds: serializer.fromJson<int>(json['durationSeconds']),
      isCompleted: serializer.fromJson<bool>(json['isCompleted']),
      lastWatchedAt: serializer.fromJson<DateTime?>(json['lastWatchedAt']),
      completedAt: serializer.fromJson<DateTime?>(json['completedAt']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'courseId': serializer.toJson<String>(courseId),
      'lessonId': serializer.toJson<String>(lessonId),
      'progressSeconds': serializer.toJson<int>(progressSeconds),
      'durationSeconds': serializer.toJson<int>(durationSeconds),
      'isCompleted': serializer.toJson<bool>(isCompleted),
      'lastWatchedAt': serializer.toJson<DateTime?>(lastWatchedAt),
      'completedAt': serializer.toJson<DateTime?>(completedAt),
      'createdAt': serializer.toJson<DateTime>(createdAt),
    };
  }

  CourseProgressData copyWith({
    String? id,
    String? courseId,
    String? lessonId,
    int? progressSeconds,
    int? durationSeconds,
    bool? isCompleted,
    Value<DateTime?> lastWatchedAt = const Value.absent(),
    Value<DateTime?> completedAt = const Value.absent(),
    DateTime? createdAt,
  }) => CourseProgressData(
    id: id ?? this.id,
    courseId: courseId ?? this.courseId,
    lessonId: lessonId ?? this.lessonId,
    progressSeconds: progressSeconds ?? this.progressSeconds,
    durationSeconds: durationSeconds ?? this.durationSeconds,
    isCompleted: isCompleted ?? this.isCompleted,
    lastWatchedAt: lastWatchedAt.present
        ? lastWatchedAt.value
        : this.lastWatchedAt,
    completedAt: completedAt.present ? completedAt.value : this.completedAt,
    createdAt: createdAt ?? this.createdAt,
  );
  CourseProgressData copyWithCompanion(CourseProgressCompanion data) {
    return CourseProgressData(
      id: data.id.present ? data.id.value : this.id,
      courseId: data.courseId.present ? data.courseId.value : this.courseId,
      lessonId: data.lessonId.present ? data.lessonId.value : this.lessonId,
      progressSeconds: data.progressSeconds.present
          ? data.progressSeconds.value
          : this.progressSeconds,
      durationSeconds: data.durationSeconds.present
          ? data.durationSeconds.value
          : this.durationSeconds,
      isCompleted: data.isCompleted.present
          ? data.isCompleted.value
          : this.isCompleted,
      lastWatchedAt: data.lastWatchedAt.present
          ? data.lastWatchedAt.value
          : this.lastWatchedAt,
      completedAt: data.completedAt.present
          ? data.completedAt.value
          : this.completedAt,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('CourseProgressData(')
          ..write('id: $id, ')
          ..write('courseId: $courseId, ')
          ..write('lessonId: $lessonId, ')
          ..write('progressSeconds: $progressSeconds, ')
          ..write('durationSeconds: $durationSeconds, ')
          ..write('isCompleted: $isCompleted, ')
          ..write('lastWatchedAt: $lastWatchedAt, ')
          ..write('completedAt: $completedAt, ')
          ..write('createdAt: $createdAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    courseId,
    lessonId,
    progressSeconds,
    durationSeconds,
    isCompleted,
    lastWatchedAt,
    completedAt,
    createdAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is CourseProgressData &&
          other.id == this.id &&
          other.courseId == this.courseId &&
          other.lessonId == this.lessonId &&
          other.progressSeconds == this.progressSeconds &&
          other.durationSeconds == this.durationSeconds &&
          other.isCompleted == this.isCompleted &&
          other.lastWatchedAt == this.lastWatchedAt &&
          other.completedAt == this.completedAt &&
          other.createdAt == this.createdAt);
}

class CourseProgressCompanion extends UpdateCompanion<CourseProgressData> {
  final Value<String> id;
  final Value<String> courseId;
  final Value<String> lessonId;
  final Value<int> progressSeconds;
  final Value<int> durationSeconds;
  final Value<bool> isCompleted;
  final Value<DateTime?> lastWatchedAt;
  final Value<DateTime?> completedAt;
  final Value<DateTime> createdAt;
  final Value<int> rowid;
  const CourseProgressCompanion({
    this.id = const Value.absent(),
    this.courseId = const Value.absent(),
    this.lessonId = const Value.absent(),
    this.progressSeconds = const Value.absent(),
    this.durationSeconds = const Value.absent(),
    this.isCompleted = const Value.absent(),
    this.lastWatchedAt = const Value.absent(),
    this.completedAt = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  CourseProgressCompanion.insert({
    required String id,
    required String courseId,
    required String lessonId,
    this.progressSeconds = const Value.absent(),
    required int durationSeconds,
    this.isCompleted = const Value.absent(),
    this.lastWatchedAt = const Value.absent(),
    this.completedAt = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       courseId = Value(courseId),
       lessonId = Value(lessonId),
       durationSeconds = Value(durationSeconds);
  static Insertable<CourseProgressData> custom({
    Expression<String>? id,
    Expression<String>? courseId,
    Expression<String>? lessonId,
    Expression<int>? progressSeconds,
    Expression<int>? durationSeconds,
    Expression<bool>? isCompleted,
    Expression<DateTime>? lastWatchedAt,
    Expression<DateTime>? completedAt,
    Expression<DateTime>? createdAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (courseId != null) 'course_id': courseId,
      if (lessonId != null) 'lesson_id': lessonId,
      if (progressSeconds != null) 'progress_seconds': progressSeconds,
      if (durationSeconds != null) 'duration_seconds': durationSeconds,
      if (isCompleted != null) 'is_completed': isCompleted,
      if (lastWatchedAt != null) 'last_watched_at': lastWatchedAt,
      if (completedAt != null) 'completed_at': completedAt,
      if (createdAt != null) 'created_at': createdAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  CourseProgressCompanion copyWith({
    Value<String>? id,
    Value<String>? courseId,
    Value<String>? lessonId,
    Value<int>? progressSeconds,
    Value<int>? durationSeconds,
    Value<bool>? isCompleted,
    Value<DateTime?>? lastWatchedAt,
    Value<DateTime?>? completedAt,
    Value<DateTime>? createdAt,
    Value<int>? rowid,
  }) {
    return CourseProgressCompanion(
      id: id ?? this.id,
      courseId: courseId ?? this.courseId,
      lessonId: lessonId ?? this.lessonId,
      progressSeconds: progressSeconds ?? this.progressSeconds,
      durationSeconds: durationSeconds ?? this.durationSeconds,
      isCompleted: isCompleted ?? this.isCompleted,
      lastWatchedAt: lastWatchedAt ?? this.lastWatchedAt,
      completedAt: completedAt ?? this.completedAt,
      createdAt: createdAt ?? this.createdAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (courseId.present) {
      map['course_id'] = Variable<String>(courseId.value);
    }
    if (lessonId.present) {
      map['lesson_id'] = Variable<String>(lessonId.value);
    }
    if (progressSeconds.present) {
      map['progress_seconds'] = Variable<int>(progressSeconds.value);
    }
    if (durationSeconds.present) {
      map['duration_seconds'] = Variable<int>(durationSeconds.value);
    }
    if (isCompleted.present) {
      map['is_completed'] = Variable<bool>(isCompleted.value);
    }
    if (lastWatchedAt.present) {
      map['last_watched_at'] = Variable<DateTime>(lastWatchedAt.value);
    }
    if (completedAt.present) {
      map['completed_at'] = Variable<DateTime>(completedAt.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('CourseProgressCompanion(')
          ..write('id: $id, ')
          ..write('courseId: $courseId, ')
          ..write('lessonId: $lessonId, ')
          ..write('progressSeconds: $progressSeconds, ')
          ..write('durationSeconds: $durationSeconds, ')
          ..write('isCompleted: $isCompleted, ')
          ..write('lastWatchedAt: $lastWatchedAt, ')
          ..write('completedAt: $completedAt, ')
          ..write('createdAt: $createdAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $PurchasesTable extends Purchases
    with TableInfo<$PurchasesTable, Purchase> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $PurchasesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _productIdMeta = const VerificationMeta(
    'productId',
  );
  @override
  late final GeneratedColumn<String> productId = GeneratedColumn<String>(
    'product_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _stripePaymentIdMeta = const VerificationMeta(
    'stripePaymentId',
  );
  @override
  late final GeneratedColumn<String> stripePaymentId = GeneratedColumn<String>(
    'stripe_payment_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _amountPaidMeta = const VerificationMeta(
    'amountPaid',
  );
  @override
  late final GeneratedColumn<double> amountPaid = GeneratedColumn<double>(
    'amount_paid',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _sourceMeta = const VerificationMeta('source');
  @override
  late final GeneratedColumn<String> source = GeneratedColumn<String>(
    'source',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('stripe'),
  );
  static const VerificationMeta _purchasedAtMeta = const VerificationMeta(
    'purchasedAt',
  );
  @override
  late final GeneratedColumn<DateTime> purchasedAt = GeneratedColumn<DateTime>(
    'purchased_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    productId,
    stripePaymentId,
    amountPaid,
    source,
    purchasedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'purchases';
  @override
  VerificationContext validateIntegrity(
    Insertable<Purchase> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('product_id')) {
      context.handle(
        _productIdMeta,
        productId.isAcceptableOrUnknown(data['product_id']!, _productIdMeta),
      );
    } else if (isInserting) {
      context.missing(_productIdMeta);
    }
    if (data.containsKey('stripe_payment_id')) {
      context.handle(
        _stripePaymentIdMeta,
        stripePaymentId.isAcceptableOrUnknown(
          data['stripe_payment_id']!,
          _stripePaymentIdMeta,
        ),
      );
    }
    if (data.containsKey('amount_paid')) {
      context.handle(
        _amountPaidMeta,
        amountPaid.isAcceptableOrUnknown(data['amount_paid']!, _amountPaidMeta),
      );
    }
    if (data.containsKey('source')) {
      context.handle(
        _sourceMeta,
        source.isAcceptableOrUnknown(data['source']!, _sourceMeta),
      );
    }
    if (data.containsKey('purchased_at')) {
      context.handle(
        _purchasedAtMeta,
        purchasedAt.isAcceptableOrUnknown(
          data['purchased_at']!,
          _purchasedAtMeta,
        ),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  Purchase map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Purchase(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      productId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}product_id'],
      )!,
      stripePaymentId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}stripe_payment_id'],
      ),
      amountPaid: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}amount_paid'],
      ),
      source: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}source'],
      )!,
      purchasedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}purchased_at'],
      )!,
    );
  }

  @override
  $PurchasesTable createAlias(String alias) {
    return $PurchasesTable(attachedDatabase, alias);
  }
}

class Purchase extends DataClass implements Insertable<Purchase> {
  final String id;
  final String productId;
  final String? stripePaymentId;
  final double? amountPaid;
  final String source;
  final DateTime purchasedAt;
  const Purchase({
    required this.id,
    required this.productId,
    this.stripePaymentId,
    this.amountPaid,
    required this.source,
    required this.purchasedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['product_id'] = Variable<String>(productId);
    if (!nullToAbsent || stripePaymentId != null) {
      map['stripe_payment_id'] = Variable<String>(stripePaymentId);
    }
    if (!nullToAbsent || amountPaid != null) {
      map['amount_paid'] = Variable<double>(amountPaid);
    }
    map['source'] = Variable<String>(source);
    map['purchased_at'] = Variable<DateTime>(purchasedAt);
    return map;
  }

  PurchasesCompanion toCompanion(bool nullToAbsent) {
    return PurchasesCompanion(
      id: Value(id),
      productId: Value(productId),
      stripePaymentId: stripePaymentId == null && nullToAbsent
          ? const Value.absent()
          : Value(stripePaymentId),
      amountPaid: amountPaid == null && nullToAbsent
          ? const Value.absent()
          : Value(amountPaid),
      source: Value(source),
      purchasedAt: Value(purchasedAt),
    );
  }

  factory Purchase.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Purchase(
      id: serializer.fromJson<String>(json['id']),
      productId: serializer.fromJson<String>(json['productId']),
      stripePaymentId: serializer.fromJson<String?>(json['stripePaymentId']),
      amountPaid: serializer.fromJson<double?>(json['amountPaid']),
      source: serializer.fromJson<String>(json['source']),
      purchasedAt: serializer.fromJson<DateTime>(json['purchasedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'productId': serializer.toJson<String>(productId),
      'stripePaymentId': serializer.toJson<String?>(stripePaymentId),
      'amountPaid': serializer.toJson<double?>(amountPaid),
      'source': serializer.toJson<String>(source),
      'purchasedAt': serializer.toJson<DateTime>(purchasedAt),
    };
  }

  Purchase copyWith({
    String? id,
    String? productId,
    Value<String?> stripePaymentId = const Value.absent(),
    Value<double?> amountPaid = const Value.absent(),
    String? source,
    DateTime? purchasedAt,
  }) => Purchase(
    id: id ?? this.id,
    productId: productId ?? this.productId,
    stripePaymentId: stripePaymentId.present
        ? stripePaymentId.value
        : this.stripePaymentId,
    amountPaid: amountPaid.present ? amountPaid.value : this.amountPaid,
    source: source ?? this.source,
    purchasedAt: purchasedAt ?? this.purchasedAt,
  );
  Purchase copyWithCompanion(PurchasesCompanion data) {
    return Purchase(
      id: data.id.present ? data.id.value : this.id,
      productId: data.productId.present ? data.productId.value : this.productId,
      stripePaymentId: data.stripePaymentId.present
          ? data.stripePaymentId.value
          : this.stripePaymentId,
      amountPaid: data.amountPaid.present
          ? data.amountPaid.value
          : this.amountPaid,
      source: data.source.present ? data.source.value : this.source,
      purchasedAt: data.purchasedAt.present
          ? data.purchasedAt.value
          : this.purchasedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Purchase(')
          ..write('id: $id, ')
          ..write('productId: $productId, ')
          ..write('stripePaymentId: $stripePaymentId, ')
          ..write('amountPaid: $amountPaid, ')
          ..write('source: $source, ')
          ..write('purchasedAt: $purchasedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    productId,
    stripePaymentId,
    amountPaid,
    source,
    purchasedAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Purchase &&
          other.id == this.id &&
          other.productId == this.productId &&
          other.stripePaymentId == this.stripePaymentId &&
          other.amountPaid == this.amountPaid &&
          other.source == this.source &&
          other.purchasedAt == this.purchasedAt);
}

class PurchasesCompanion extends UpdateCompanion<Purchase> {
  final Value<String> id;
  final Value<String> productId;
  final Value<String?> stripePaymentId;
  final Value<double?> amountPaid;
  final Value<String> source;
  final Value<DateTime> purchasedAt;
  final Value<int> rowid;
  const PurchasesCompanion({
    this.id = const Value.absent(),
    this.productId = const Value.absent(),
    this.stripePaymentId = const Value.absent(),
    this.amountPaid = const Value.absent(),
    this.source = const Value.absent(),
    this.purchasedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  PurchasesCompanion.insert({
    required String id,
    required String productId,
    this.stripePaymentId = const Value.absent(),
    this.amountPaid = const Value.absent(),
    this.source = const Value.absent(),
    this.purchasedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       productId = Value(productId);
  static Insertable<Purchase> custom({
    Expression<String>? id,
    Expression<String>? productId,
    Expression<String>? stripePaymentId,
    Expression<double>? amountPaid,
    Expression<String>? source,
    Expression<DateTime>? purchasedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (productId != null) 'product_id': productId,
      if (stripePaymentId != null) 'stripe_payment_id': stripePaymentId,
      if (amountPaid != null) 'amount_paid': amountPaid,
      if (source != null) 'source': source,
      if (purchasedAt != null) 'purchased_at': purchasedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  PurchasesCompanion copyWith({
    Value<String>? id,
    Value<String>? productId,
    Value<String?>? stripePaymentId,
    Value<double?>? amountPaid,
    Value<String>? source,
    Value<DateTime>? purchasedAt,
    Value<int>? rowid,
  }) {
    return PurchasesCompanion(
      id: id ?? this.id,
      productId: productId ?? this.productId,
      stripePaymentId: stripePaymentId ?? this.stripePaymentId,
      amountPaid: amountPaid ?? this.amountPaid,
      source: source ?? this.source,
      purchasedAt: purchasedAt ?? this.purchasedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (productId.present) {
      map['product_id'] = Variable<String>(productId.value);
    }
    if (stripePaymentId.present) {
      map['stripe_payment_id'] = Variable<String>(stripePaymentId.value);
    }
    if (amountPaid.present) {
      map['amount_paid'] = Variable<double>(amountPaid.value);
    }
    if (source.present) {
      map['source'] = Variable<String>(source.value);
    }
    if (purchasedAt.present) {
      map['purchased_at'] = Variable<DateTime>(purchasedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('PurchasesCompanion(')
          ..write('id: $id, ')
          ..write('productId: $productId, ')
          ..write('stripePaymentId: $stripePaymentId, ')
          ..write('amountPaid: $amountPaid, ')
          ..write('source: $source, ')
          ..write('purchasedAt: $purchasedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $SyncQueueTable extends SyncQueue
    with TableInfo<$SyncQueueTable, SyncQueueData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $SyncQueueTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _entityTypeMeta = const VerificationMeta(
    'entityType',
  );
  @override
  late final GeneratedColumn<String> entityType = GeneratedColumn<String>(
    'entity_type',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _entityIdMeta = const VerificationMeta(
    'entityId',
  );
  @override
  late final GeneratedColumn<String> entityId = GeneratedColumn<String>(
    'entity_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _operationMeta = const VerificationMeta(
    'operation',
  );
  @override
  late final GeneratedColumn<String> operation = GeneratedColumn<String>(
    'operation',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _payloadMeta = const VerificationMeta(
    'payload',
  );
  @override
  late final GeneratedColumn<String> payload = GeneratedColumn<String>(
    'payload',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _retryCountMeta = const VerificationMeta(
    'retryCount',
  );
  @override
  late final GeneratedColumn<int> retryCount = GeneratedColumn<int>(
    'retry_count',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _lastAttemptAtMeta = const VerificationMeta(
    'lastAttemptAt',
  );
  @override
  late final GeneratedColumn<DateTime> lastAttemptAt =
      GeneratedColumn<DateTime>(
        'last_attempt_at',
        aliasedName,
        true,
        type: DriftSqlType.dateTime,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _lastErrorMeta = const VerificationMeta(
    'lastError',
  );
  @override
  late final GeneratedColumn<String> lastError = GeneratedColumn<String>(
    'last_error',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    entityType,
    entityId,
    operation,
    payload,
    retryCount,
    createdAt,
    lastAttemptAt,
    lastError,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'sync_queue';
  @override
  VerificationContext validateIntegrity(
    Insertable<SyncQueueData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('entity_type')) {
      context.handle(
        _entityTypeMeta,
        entityType.isAcceptableOrUnknown(data['entity_type']!, _entityTypeMeta),
      );
    } else if (isInserting) {
      context.missing(_entityTypeMeta);
    }
    if (data.containsKey('entity_id')) {
      context.handle(
        _entityIdMeta,
        entityId.isAcceptableOrUnknown(data['entity_id']!, _entityIdMeta),
      );
    } else if (isInserting) {
      context.missing(_entityIdMeta);
    }
    if (data.containsKey('operation')) {
      context.handle(
        _operationMeta,
        operation.isAcceptableOrUnknown(data['operation']!, _operationMeta),
      );
    } else if (isInserting) {
      context.missing(_operationMeta);
    }
    if (data.containsKey('payload')) {
      context.handle(
        _payloadMeta,
        payload.isAcceptableOrUnknown(data['payload']!, _payloadMeta),
      );
    } else if (isInserting) {
      context.missing(_payloadMeta);
    }
    if (data.containsKey('retry_count')) {
      context.handle(
        _retryCountMeta,
        retryCount.isAcceptableOrUnknown(data['retry_count']!, _retryCountMeta),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    if (data.containsKey('last_attempt_at')) {
      context.handle(
        _lastAttemptAtMeta,
        lastAttemptAt.isAcceptableOrUnknown(
          data['last_attempt_at']!,
          _lastAttemptAtMeta,
        ),
      );
    }
    if (data.containsKey('last_error')) {
      context.handle(
        _lastErrorMeta,
        lastError.isAcceptableOrUnknown(data['last_error']!, _lastErrorMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  SyncQueueData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return SyncQueueData(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      entityType: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}entity_type'],
      )!,
      entityId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}entity_id'],
      )!,
      operation: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}operation'],
      )!,
      payload: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}payload'],
      )!,
      retryCount: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}retry_count'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      lastAttemptAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}last_attempt_at'],
      ),
      lastError: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}last_error'],
      ),
    );
  }

  @override
  $SyncQueueTable createAlias(String alias) {
    return $SyncQueueTable(attachedDatabase, alias);
  }
}

class SyncQueueData extends DataClass implements Insertable<SyncQueueData> {
  final String id;
  final String entityType;
  final String entityId;
  final String operation;
  final String payload;
  final int retryCount;
  final DateTime createdAt;
  final DateTime? lastAttemptAt;
  final String? lastError;
  const SyncQueueData({
    required this.id,
    required this.entityType,
    required this.entityId,
    required this.operation,
    required this.payload,
    required this.retryCount,
    required this.createdAt,
    this.lastAttemptAt,
    this.lastError,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['entity_type'] = Variable<String>(entityType);
    map['entity_id'] = Variable<String>(entityId);
    map['operation'] = Variable<String>(operation);
    map['payload'] = Variable<String>(payload);
    map['retry_count'] = Variable<int>(retryCount);
    map['created_at'] = Variable<DateTime>(createdAt);
    if (!nullToAbsent || lastAttemptAt != null) {
      map['last_attempt_at'] = Variable<DateTime>(lastAttemptAt);
    }
    if (!nullToAbsent || lastError != null) {
      map['last_error'] = Variable<String>(lastError);
    }
    return map;
  }

  SyncQueueCompanion toCompanion(bool nullToAbsent) {
    return SyncQueueCompanion(
      id: Value(id),
      entityType: Value(entityType),
      entityId: Value(entityId),
      operation: Value(operation),
      payload: Value(payload),
      retryCount: Value(retryCount),
      createdAt: Value(createdAt),
      lastAttemptAt: lastAttemptAt == null && nullToAbsent
          ? const Value.absent()
          : Value(lastAttemptAt),
      lastError: lastError == null && nullToAbsent
          ? const Value.absent()
          : Value(lastError),
    );
  }

  factory SyncQueueData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return SyncQueueData(
      id: serializer.fromJson<String>(json['id']),
      entityType: serializer.fromJson<String>(json['entityType']),
      entityId: serializer.fromJson<String>(json['entityId']),
      operation: serializer.fromJson<String>(json['operation']),
      payload: serializer.fromJson<String>(json['payload']),
      retryCount: serializer.fromJson<int>(json['retryCount']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      lastAttemptAt: serializer.fromJson<DateTime?>(json['lastAttemptAt']),
      lastError: serializer.fromJson<String?>(json['lastError']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'entityType': serializer.toJson<String>(entityType),
      'entityId': serializer.toJson<String>(entityId),
      'operation': serializer.toJson<String>(operation),
      'payload': serializer.toJson<String>(payload),
      'retryCount': serializer.toJson<int>(retryCount),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'lastAttemptAt': serializer.toJson<DateTime?>(lastAttemptAt),
      'lastError': serializer.toJson<String?>(lastError),
    };
  }

  SyncQueueData copyWith({
    String? id,
    String? entityType,
    String? entityId,
    String? operation,
    String? payload,
    int? retryCount,
    DateTime? createdAt,
    Value<DateTime?> lastAttemptAt = const Value.absent(),
    Value<String?> lastError = const Value.absent(),
  }) => SyncQueueData(
    id: id ?? this.id,
    entityType: entityType ?? this.entityType,
    entityId: entityId ?? this.entityId,
    operation: operation ?? this.operation,
    payload: payload ?? this.payload,
    retryCount: retryCount ?? this.retryCount,
    createdAt: createdAt ?? this.createdAt,
    lastAttemptAt: lastAttemptAt.present
        ? lastAttemptAt.value
        : this.lastAttemptAt,
    lastError: lastError.present ? lastError.value : this.lastError,
  );
  SyncQueueData copyWithCompanion(SyncQueueCompanion data) {
    return SyncQueueData(
      id: data.id.present ? data.id.value : this.id,
      entityType: data.entityType.present
          ? data.entityType.value
          : this.entityType,
      entityId: data.entityId.present ? data.entityId.value : this.entityId,
      operation: data.operation.present ? data.operation.value : this.operation,
      payload: data.payload.present ? data.payload.value : this.payload,
      retryCount: data.retryCount.present
          ? data.retryCount.value
          : this.retryCount,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      lastAttemptAt: data.lastAttemptAt.present
          ? data.lastAttemptAt.value
          : this.lastAttemptAt,
      lastError: data.lastError.present ? data.lastError.value : this.lastError,
    );
  }

  @override
  String toString() {
    return (StringBuffer('SyncQueueData(')
          ..write('id: $id, ')
          ..write('entityType: $entityType, ')
          ..write('entityId: $entityId, ')
          ..write('operation: $operation, ')
          ..write('payload: $payload, ')
          ..write('retryCount: $retryCount, ')
          ..write('createdAt: $createdAt, ')
          ..write('lastAttemptAt: $lastAttemptAt, ')
          ..write('lastError: $lastError')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    entityType,
    entityId,
    operation,
    payload,
    retryCount,
    createdAt,
    lastAttemptAt,
    lastError,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is SyncQueueData &&
          other.id == this.id &&
          other.entityType == this.entityType &&
          other.entityId == this.entityId &&
          other.operation == this.operation &&
          other.payload == this.payload &&
          other.retryCount == this.retryCount &&
          other.createdAt == this.createdAt &&
          other.lastAttemptAt == this.lastAttemptAt &&
          other.lastError == this.lastError);
}

class SyncQueueCompanion extends UpdateCompanion<SyncQueueData> {
  final Value<String> id;
  final Value<String> entityType;
  final Value<String> entityId;
  final Value<String> operation;
  final Value<String> payload;
  final Value<int> retryCount;
  final Value<DateTime> createdAt;
  final Value<DateTime?> lastAttemptAt;
  final Value<String?> lastError;
  final Value<int> rowid;
  const SyncQueueCompanion({
    this.id = const Value.absent(),
    this.entityType = const Value.absent(),
    this.entityId = const Value.absent(),
    this.operation = const Value.absent(),
    this.payload = const Value.absent(),
    this.retryCount = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.lastAttemptAt = const Value.absent(),
    this.lastError = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  SyncQueueCompanion.insert({
    required String id,
    required String entityType,
    required String entityId,
    required String operation,
    required String payload,
    this.retryCount = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.lastAttemptAt = const Value.absent(),
    this.lastError = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       entityType = Value(entityType),
       entityId = Value(entityId),
       operation = Value(operation),
       payload = Value(payload);
  static Insertable<SyncQueueData> custom({
    Expression<String>? id,
    Expression<String>? entityType,
    Expression<String>? entityId,
    Expression<String>? operation,
    Expression<String>? payload,
    Expression<int>? retryCount,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? lastAttemptAt,
    Expression<String>? lastError,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (entityType != null) 'entity_type': entityType,
      if (entityId != null) 'entity_id': entityId,
      if (operation != null) 'operation': operation,
      if (payload != null) 'payload': payload,
      if (retryCount != null) 'retry_count': retryCount,
      if (createdAt != null) 'created_at': createdAt,
      if (lastAttemptAt != null) 'last_attempt_at': lastAttemptAt,
      if (lastError != null) 'last_error': lastError,
      if (rowid != null) 'rowid': rowid,
    });
  }

  SyncQueueCompanion copyWith({
    Value<String>? id,
    Value<String>? entityType,
    Value<String>? entityId,
    Value<String>? operation,
    Value<String>? payload,
    Value<int>? retryCount,
    Value<DateTime>? createdAt,
    Value<DateTime?>? lastAttemptAt,
    Value<String?>? lastError,
    Value<int>? rowid,
  }) {
    return SyncQueueCompanion(
      id: id ?? this.id,
      entityType: entityType ?? this.entityType,
      entityId: entityId ?? this.entityId,
      operation: operation ?? this.operation,
      payload: payload ?? this.payload,
      retryCount: retryCount ?? this.retryCount,
      createdAt: createdAt ?? this.createdAt,
      lastAttemptAt: lastAttemptAt ?? this.lastAttemptAt,
      lastError: lastError ?? this.lastError,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (entityType.present) {
      map['entity_type'] = Variable<String>(entityType.value);
    }
    if (entityId.present) {
      map['entity_id'] = Variable<String>(entityId.value);
    }
    if (operation.present) {
      map['operation'] = Variable<String>(operation.value);
    }
    if (payload.present) {
      map['payload'] = Variable<String>(payload.value);
    }
    if (retryCount.present) {
      map['retry_count'] = Variable<int>(retryCount.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (lastAttemptAt.present) {
      map['last_attempt_at'] = Variable<DateTime>(lastAttemptAt.value);
    }
    if (lastError.present) {
      map['last_error'] = Variable<String>(lastError.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('SyncQueueCompanion(')
          ..write('id: $id, ')
          ..write('entityType: $entityType, ')
          ..write('entityId: $entityId, ')
          ..write('operation: $operation, ')
          ..write('payload: $payload, ')
          ..write('retryCount: $retryCount, ')
          ..write('createdAt: $createdAt, ')
          ..write('lastAttemptAt: $lastAttemptAt, ')
          ..write('lastError: $lastError, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $SyncMetadataTable extends SyncMetadata
    with TableInfo<$SyncMetadataTable, SyncMetadataData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $SyncMetadataTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _entityTypeMeta = const VerificationMeta(
    'entityType',
  );
  @override
  late final GeneratedColumn<String> entityType = GeneratedColumn<String>(
    'entity_type',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _lastSyncedAtMeta = const VerificationMeta(
    'lastSyncedAt',
  );
  @override
  late final GeneratedColumn<DateTime> lastSyncedAt = GeneratedColumn<DateTime>(
    'last_synced_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [entityType, lastSyncedAt];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'sync_metadata';
  @override
  VerificationContext validateIntegrity(
    Insertable<SyncMetadataData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('entity_type')) {
      context.handle(
        _entityTypeMeta,
        entityType.isAcceptableOrUnknown(data['entity_type']!, _entityTypeMeta),
      );
    } else if (isInserting) {
      context.missing(_entityTypeMeta);
    }
    if (data.containsKey('last_synced_at')) {
      context.handle(
        _lastSyncedAtMeta,
        lastSyncedAt.isAcceptableOrUnknown(
          data['last_synced_at']!,
          _lastSyncedAtMeta,
        ),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {entityType};
  @override
  SyncMetadataData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return SyncMetadataData(
      entityType: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}entity_type'],
      )!,
      lastSyncedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}last_synced_at'],
      ),
    );
  }

  @override
  $SyncMetadataTable createAlias(String alias) {
    return $SyncMetadataTable(attachedDatabase, alias);
  }
}

class SyncMetadataData extends DataClass
    implements Insertable<SyncMetadataData> {
  final String entityType;
  final DateTime? lastSyncedAt;
  const SyncMetadataData({required this.entityType, this.lastSyncedAt});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['entity_type'] = Variable<String>(entityType);
    if (!nullToAbsent || lastSyncedAt != null) {
      map['last_synced_at'] = Variable<DateTime>(lastSyncedAt);
    }
    return map;
  }

  SyncMetadataCompanion toCompanion(bool nullToAbsent) {
    return SyncMetadataCompanion(
      entityType: Value(entityType),
      lastSyncedAt: lastSyncedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(lastSyncedAt),
    );
  }

  factory SyncMetadataData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return SyncMetadataData(
      entityType: serializer.fromJson<String>(json['entityType']),
      lastSyncedAt: serializer.fromJson<DateTime?>(json['lastSyncedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'entityType': serializer.toJson<String>(entityType),
      'lastSyncedAt': serializer.toJson<DateTime?>(lastSyncedAt),
    };
  }

  SyncMetadataData copyWith({
    String? entityType,
    Value<DateTime?> lastSyncedAt = const Value.absent(),
  }) => SyncMetadataData(
    entityType: entityType ?? this.entityType,
    lastSyncedAt: lastSyncedAt.present ? lastSyncedAt.value : this.lastSyncedAt,
  );
  SyncMetadataData copyWithCompanion(SyncMetadataCompanion data) {
    return SyncMetadataData(
      entityType: data.entityType.present
          ? data.entityType.value
          : this.entityType,
      lastSyncedAt: data.lastSyncedAt.present
          ? data.lastSyncedAt.value
          : this.lastSyncedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('SyncMetadataData(')
          ..write('entityType: $entityType, ')
          ..write('lastSyncedAt: $lastSyncedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(entityType, lastSyncedAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is SyncMetadataData &&
          other.entityType == this.entityType &&
          other.lastSyncedAt == this.lastSyncedAt);
}

class SyncMetadataCompanion extends UpdateCompanion<SyncMetadataData> {
  final Value<String> entityType;
  final Value<DateTime?> lastSyncedAt;
  final Value<int> rowid;
  const SyncMetadataCompanion({
    this.entityType = const Value.absent(),
    this.lastSyncedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  SyncMetadataCompanion.insert({
    required String entityType,
    this.lastSyncedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : entityType = Value(entityType);
  static Insertable<SyncMetadataData> custom({
    Expression<String>? entityType,
    Expression<DateTime>? lastSyncedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (entityType != null) 'entity_type': entityType,
      if (lastSyncedAt != null) 'last_synced_at': lastSyncedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  SyncMetadataCompanion copyWith({
    Value<String>? entityType,
    Value<DateTime?>? lastSyncedAt,
    Value<int>? rowid,
  }) {
    return SyncMetadataCompanion(
      entityType: entityType ?? this.entityType,
      lastSyncedAt: lastSyncedAt ?? this.lastSyncedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (entityType.present) {
      map['entity_type'] = Variable<String>(entityType.value);
    }
    if (lastSyncedAt.present) {
      map['last_synced_at'] = Variable<DateTime>(lastSyncedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('SyncMetadataCompanion(')
          ..write('entityType: $entityType, ')
          ..write('lastSyncedAt: $lastSyncedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $FieldCoursesTable extends FieldCourses
    with TableInfo<$FieldCoursesTable, FieldCourse> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $FieldCoursesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _venueIdMeta = const VerificationMeta(
    'venueId',
  );
  @override
  late final GeneratedColumn<String> venueId = GeneratedColumn<String>(
    'venue_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES venues (id)',
    ),
  );
  static const VerificationMeta _roundTypeMeta = const VerificationMeta(
    'roundType',
  );
  @override
  late final GeneratedColumn<String> roundType = GeneratedColumn<String>(
    'round_type',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _targetCountMeta = const VerificationMeta(
    'targetCount',
  );
  @override
  late final GeneratedColumn<int> targetCount = GeneratedColumn<int>(
    'target_count',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(28),
  );
  static const VerificationMeta _notesMeta = const VerificationMeta('notes');
  @override
  late final GeneratedColumn<String> notes = GeneratedColumn<String>(
    'notes',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _deletedAtMeta = const VerificationMeta(
    'deletedAt',
  );
  @override
  late final GeneratedColumn<DateTime> deletedAt = GeneratedColumn<DateTime>(
    'deleted_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    name,
    venueId,
    roundType,
    targetCount,
    notes,
    createdAt,
    updatedAt,
    deletedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'field_courses';
  @override
  VerificationContext validateIntegrity(
    Insertable<FieldCourse> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('venue_id')) {
      context.handle(
        _venueIdMeta,
        venueId.isAcceptableOrUnknown(data['venue_id']!, _venueIdMeta),
      );
    }
    if (data.containsKey('round_type')) {
      context.handle(
        _roundTypeMeta,
        roundType.isAcceptableOrUnknown(data['round_type']!, _roundTypeMeta),
      );
    } else if (isInserting) {
      context.missing(_roundTypeMeta);
    }
    if (data.containsKey('target_count')) {
      context.handle(
        _targetCountMeta,
        targetCount.isAcceptableOrUnknown(
          data['target_count']!,
          _targetCountMeta,
        ),
      );
    }
    if (data.containsKey('notes')) {
      context.handle(
        _notesMeta,
        notes.isAcceptableOrUnknown(data['notes']!, _notesMeta),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    }
    if (data.containsKey('deleted_at')) {
      context.handle(
        _deletedAtMeta,
        deletedAt.isAcceptableOrUnknown(data['deleted_at']!, _deletedAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  FieldCourse map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return FieldCourse(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      venueId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}venue_id'],
      ),
      roundType: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}round_type'],
      )!,
      targetCount: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}target_count'],
      )!,
      notes: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}notes'],
      ),
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      ),
      deletedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}deleted_at'],
      ),
    );
  }

  @override
  $FieldCoursesTable createAlias(String alias) {
    return $FieldCoursesTable(attachedDatabase, alias);
  }
}

class FieldCourse extends DataClass implements Insertable<FieldCourse> {
  final String id;
  final String name;
  final String? venueId;
  final String roundType;
  final int targetCount;
  final String? notes;
  final DateTime createdAt;
  final DateTime? updatedAt;
  final DateTime? deletedAt;
  const FieldCourse({
    required this.id,
    required this.name,
    this.venueId,
    required this.roundType,
    required this.targetCount,
    this.notes,
    required this.createdAt,
    this.updatedAt,
    this.deletedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['name'] = Variable<String>(name);
    if (!nullToAbsent || venueId != null) {
      map['venue_id'] = Variable<String>(venueId);
    }
    map['round_type'] = Variable<String>(roundType);
    map['target_count'] = Variable<int>(targetCount);
    if (!nullToAbsent || notes != null) {
      map['notes'] = Variable<String>(notes);
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    if (!nullToAbsent || updatedAt != null) {
      map['updated_at'] = Variable<DateTime>(updatedAt);
    }
    if (!nullToAbsent || deletedAt != null) {
      map['deleted_at'] = Variable<DateTime>(deletedAt);
    }
    return map;
  }

  FieldCoursesCompanion toCompanion(bool nullToAbsent) {
    return FieldCoursesCompanion(
      id: Value(id),
      name: Value(name),
      venueId: venueId == null && nullToAbsent
          ? const Value.absent()
          : Value(venueId),
      roundType: Value(roundType),
      targetCount: Value(targetCount),
      notes: notes == null && nullToAbsent
          ? const Value.absent()
          : Value(notes),
      createdAt: Value(createdAt),
      updatedAt: updatedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(updatedAt),
      deletedAt: deletedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(deletedAt),
    );
  }

  factory FieldCourse.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return FieldCourse(
      id: serializer.fromJson<String>(json['id']),
      name: serializer.fromJson<String>(json['name']),
      venueId: serializer.fromJson<String?>(json['venueId']),
      roundType: serializer.fromJson<String>(json['roundType']),
      targetCount: serializer.fromJson<int>(json['targetCount']),
      notes: serializer.fromJson<String?>(json['notes']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime?>(json['updatedAt']),
      deletedAt: serializer.fromJson<DateTime?>(json['deletedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'name': serializer.toJson<String>(name),
      'venueId': serializer.toJson<String?>(venueId),
      'roundType': serializer.toJson<String>(roundType),
      'targetCount': serializer.toJson<int>(targetCount),
      'notes': serializer.toJson<String?>(notes),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime?>(updatedAt),
      'deletedAt': serializer.toJson<DateTime?>(deletedAt),
    };
  }

  FieldCourse copyWith({
    String? id,
    String? name,
    Value<String?> venueId = const Value.absent(),
    String? roundType,
    int? targetCount,
    Value<String?> notes = const Value.absent(),
    DateTime? createdAt,
    Value<DateTime?> updatedAt = const Value.absent(),
    Value<DateTime?> deletedAt = const Value.absent(),
  }) => FieldCourse(
    id: id ?? this.id,
    name: name ?? this.name,
    venueId: venueId.present ? venueId.value : this.venueId,
    roundType: roundType ?? this.roundType,
    targetCount: targetCount ?? this.targetCount,
    notes: notes.present ? notes.value : this.notes,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt.present ? updatedAt.value : this.updatedAt,
    deletedAt: deletedAt.present ? deletedAt.value : this.deletedAt,
  );
  FieldCourse copyWithCompanion(FieldCoursesCompanion data) {
    return FieldCourse(
      id: data.id.present ? data.id.value : this.id,
      name: data.name.present ? data.name.value : this.name,
      venueId: data.venueId.present ? data.venueId.value : this.venueId,
      roundType: data.roundType.present ? data.roundType.value : this.roundType,
      targetCount: data.targetCount.present
          ? data.targetCount.value
          : this.targetCount,
      notes: data.notes.present ? data.notes.value : this.notes,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
      deletedAt: data.deletedAt.present ? data.deletedAt.value : this.deletedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('FieldCourse(')
          ..write('id: $id, ')
          ..write('name: $name, ')
          ..write('venueId: $venueId, ')
          ..write('roundType: $roundType, ')
          ..write('targetCount: $targetCount, ')
          ..write('notes: $notes, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('deletedAt: $deletedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    name,
    venueId,
    roundType,
    targetCount,
    notes,
    createdAt,
    updatedAt,
    deletedAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is FieldCourse &&
          other.id == this.id &&
          other.name == this.name &&
          other.venueId == this.venueId &&
          other.roundType == this.roundType &&
          other.targetCount == this.targetCount &&
          other.notes == this.notes &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt &&
          other.deletedAt == this.deletedAt);
}

class FieldCoursesCompanion extends UpdateCompanion<FieldCourse> {
  final Value<String> id;
  final Value<String> name;
  final Value<String?> venueId;
  final Value<String> roundType;
  final Value<int> targetCount;
  final Value<String?> notes;
  final Value<DateTime> createdAt;
  final Value<DateTime?> updatedAt;
  final Value<DateTime?> deletedAt;
  final Value<int> rowid;
  const FieldCoursesCompanion({
    this.id = const Value.absent(),
    this.name = const Value.absent(),
    this.venueId = const Value.absent(),
    this.roundType = const Value.absent(),
    this.targetCount = const Value.absent(),
    this.notes = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.deletedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  FieldCoursesCompanion.insert({
    required String id,
    required String name,
    this.venueId = const Value.absent(),
    required String roundType,
    this.targetCount = const Value.absent(),
    this.notes = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.deletedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       name = Value(name),
       roundType = Value(roundType);
  static Insertable<FieldCourse> custom({
    Expression<String>? id,
    Expression<String>? name,
    Expression<String>? venueId,
    Expression<String>? roundType,
    Expression<int>? targetCount,
    Expression<String>? notes,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
    Expression<DateTime>? deletedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (name != null) 'name': name,
      if (venueId != null) 'venue_id': venueId,
      if (roundType != null) 'round_type': roundType,
      if (targetCount != null) 'target_count': targetCount,
      if (notes != null) 'notes': notes,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (deletedAt != null) 'deleted_at': deletedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  FieldCoursesCompanion copyWith({
    Value<String>? id,
    Value<String>? name,
    Value<String?>? venueId,
    Value<String>? roundType,
    Value<int>? targetCount,
    Value<String?>? notes,
    Value<DateTime>? createdAt,
    Value<DateTime?>? updatedAt,
    Value<DateTime?>? deletedAt,
    Value<int>? rowid,
  }) {
    return FieldCoursesCompanion(
      id: id ?? this.id,
      name: name ?? this.name,
      venueId: venueId ?? this.venueId,
      roundType: roundType ?? this.roundType,
      targetCount: targetCount ?? this.targetCount,
      notes: notes ?? this.notes,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      deletedAt: deletedAt ?? this.deletedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (venueId.present) {
      map['venue_id'] = Variable<String>(venueId.value);
    }
    if (roundType.present) {
      map['round_type'] = Variable<String>(roundType.value);
    }
    if (targetCount.present) {
      map['target_count'] = Variable<int>(targetCount.value);
    }
    if (notes.present) {
      map['notes'] = Variable<String>(notes.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (deletedAt.present) {
      map['deleted_at'] = Variable<DateTime>(deletedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('FieldCoursesCompanion(')
          ..write('id: $id, ')
          ..write('name: $name, ')
          ..write('venueId: $venueId, ')
          ..write('roundType: $roundType, ')
          ..write('targetCount: $targetCount, ')
          ..write('notes: $notes, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('deletedAt: $deletedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $FieldCourseTargetsTable extends FieldCourseTargets
    with TableInfo<$FieldCourseTargetsTable, FieldCourseTarget> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $FieldCourseTargetsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _courseIdMeta = const VerificationMeta(
    'courseId',
  );
  @override
  late final GeneratedColumn<String> courseId = GeneratedColumn<String>(
    'course_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES field_courses (id)',
    ),
  );
  static const VerificationMeta _targetNumberMeta = const VerificationMeta(
    'targetNumber',
  );
  @override
  late final GeneratedColumn<int> targetNumber = GeneratedColumn<int>(
    'target_number',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _pegConfigMeta = const VerificationMeta(
    'pegConfig',
  );
  @override
  late final GeneratedColumn<String> pegConfig = GeneratedColumn<String>(
    'peg_config',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _faceSizeMeta = const VerificationMeta(
    'faceSize',
  );
  @override
  late final GeneratedColumn<int> faceSize = GeneratedColumn<int>(
    'face_size',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _primaryDistanceMeta = const VerificationMeta(
    'primaryDistance',
  );
  @override
  late final GeneratedColumn<double> primaryDistance = GeneratedColumn<double>(
    'primary_distance',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _unitMeta = const VerificationMeta('unit');
  @override
  late final GeneratedColumn<String> unit = GeneratedColumn<String>(
    'unit',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('yards'),
  );
  static const VerificationMeta _isWalkUpMeta = const VerificationMeta(
    'isWalkUp',
  );
  @override
  late final GeneratedColumn<bool> isWalkUp = GeneratedColumn<bool>(
    'is_walk_up',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_walk_up" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _isWalkDownMeta = const VerificationMeta(
    'isWalkDown',
  );
  @override
  late final GeneratedColumn<bool> isWalkDown = GeneratedColumn<bool>(
    'is_walk_down',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_walk_down" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _arrowsRequiredMeta = const VerificationMeta(
    'arrowsRequired',
  );
  @override
  late final GeneratedColumn<int> arrowsRequired = GeneratedColumn<int>(
    'arrows_required',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(4),
  );
  static const VerificationMeta _notesMeta = const VerificationMeta('notes');
  @override
  late final GeneratedColumn<String> notes = GeneratedColumn<String>(
    'notes',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    courseId,
    targetNumber,
    pegConfig,
    faceSize,
    primaryDistance,
    unit,
    isWalkUp,
    isWalkDown,
    arrowsRequired,
    notes,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'field_course_targets';
  @override
  VerificationContext validateIntegrity(
    Insertable<FieldCourseTarget> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('course_id')) {
      context.handle(
        _courseIdMeta,
        courseId.isAcceptableOrUnknown(data['course_id']!, _courseIdMeta),
      );
    } else if (isInserting) {
      context.missing(_courseIdMeta);
    }
    if (data.containsKey('target_number')) {
      context.handle(
        _targetNumberMeta,
        targetNumber.isAcceptableOrUnknown(
          data['target_number']!,
          _targetNumberMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_targetNumberMeta);
    }
    if (data.containsKey('peg_config')) {
      context.handle(
        _pegConfigMeta,
        pegConfig.isAcceptableOrUnknown(data['peg_config']!, _pegConfigMeta),
      );
    } else if (isInserting) {
      context.missing(_pegConfigMeta);
    }
    if (data.containsKey('face_size')) {
      context.handle(
        _faceSizeMeta,
        faceSize.isAcceptableOrUnknown(data['face_size']!, _faceSizeMeta),
      );
    } else if (isInserting) {
      context.missing(_faceSizeMeta);
    }
    if (data.containsKey('primary_distance')) {
      context.handle(
        _primaryDistanceMeta,
        primaryDistance.isAcceptableOrUnknown(
          data['primary_distance']!,
          _primaryDistanceMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_primaryDistanceMeta);
    }
    if (data.containsKey('unit')) {
      context.handle(
        _unitMeta,
        unit.isAcceptableOrUnknown(data['unit']!, _unitMeta),
      );
    }
    if (data.containsKey('is_walk_up')) {
      context.handle(
        _isWalkUpMeta,
        isWalkUp.isAcceptableOrUnknown(data['is_walk_up']!, _isWalkUpMeta),
      );
    }
    if (data.containsKey('is_walk_down')) {
      context.handle(
        _isWalkDownMeta,
        isWalkDown.isAcceptableOrUnknown(
          data['is_walk_down']!,
          _isWalkDownMeta,
        ),
      );
    }
    if (data.containsKey('arrows_required')) {
      context.handle(
        _arrowsRequiredMeta,
        arrowsRequired.isAcceptableOrUnknown(
          data['arrows_required']!,
          _arrowsRequiredMeta,
        ),
      );
    }
    if (data.containsKey('notes')) {
      context.handle(
        _notesMeta,
        notes.isAcceptableOrUnknown(data['notes']!, _notesMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  FieldCourseTarget map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return FieldCourseTarget(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      courseId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}course_id'],
      )!,
      targetNumber: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}target_number'],
      )!,
      pegConfig: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}peg_config'],
      )!,
      faceSize: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}face_size'],
      )!,
      primaryDistance: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}primary_distance'],
      )!,
      unit: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}unit'],
      )!,
      isWalkUp: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_walk_up'],
      )!,
      isWalkDown: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_walk_down'],
      )!,
      arrowsRequired: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}arrows_required'],
      )!,
      notes: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}notes'],
      ),
    );
  }

  @override
  $FieldCourseTargetsTable createAlias(String alias) {
    return $FieldCourseTargetsTable(attachedDatabase, alias);
  }
}

class FieldCourseTarget extends DataClass
    implements Insertable<FieldCourseTarget> {
  final String id;
  final String courseId;
  final int targetNumber;
  final String pegConfig;
  final int faceSize;
  final double primaryDistance;
  final String unit;
  final bool isWalkUp;
  final bool isWalkDown;
  final int arrowsRequired;
  final String? notes;
  const FieldCourseTarget({
    required this.id,
    required this.courseId,
    required this.targetNumber,
    required this.pegConfig,
    required this.faceSize,
    required this.primaryDistance,
    required this.unit,
    required this.isWalkUp,
    required this.isWalkDown,
    required this.arrowsRequired,
    this.notes,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['course_id'] = Variable<String>(courseId);
    map['target_number'] = Variable<int>(targetNumber);
    map['peg_config'] = Variable<String>(pegConfig);
    map['face_size'] = Variable<int>(faceSize);
    map['primary_distance'] = Variable<double>(primaryDistance);
    map['unit'] = Variable<String>(unit);
    map['is_walk_up'] = Variable<bool>(isWalkUp);
    map['is_walk_down'] = Variable<bool>(isWalkDown);
    map['arrows_required'] = Variable<int>(arrowsRequired);
    if (!nullToAbsent || notes != null) {
      map['notes'] = Variable<String>(notes);
    }
    return map;
  }

  FieldCourseTargetsCompanion toCompanion(bool nullToAbsent) {
    return FieldCourseTargetsCompanion(
      id: Value(id),
      courseId: Value(courseId),
      targetNumber: Value(targetNumber),
      pegConfig: Value(pegConfig),
      faceSize: Value(faceSize),
      primaryDistance: Value(primaryDistance),
      unit: Value(unit),
      isWalkUp: Value(isWalkUp),
      isWalkDown: Value(isWalkDown),
      arrowsRequired: Value(arrowsRequired),
      notes: notes == null && nullToAbsent
          ? const Value.absent()
          : Value(notes),
    );
  }

  factory FieldCourseTarget.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return FieldCourseTarget(
      id: serializer.fromJson<String>(json['id']),
      courseId: serializer.fromJson<String>(json['courseId']),
      targetNumber: serializer.fromJson<int>(json['targetNumber']),
      pegConfig: serializer.fromJson<String>(json['pegConfig']),
      faceSize: serializer.fromJson<int>(json['faceSize']),
      primaryDistance: serializer.fromJson<double>(json['primaryDistance']),
      unit: serializer.fromJson<String>(json['unit']),
      isWalkUp: serializer.fromJson<bool>(json['isWalkUp']),
      isWalkDown: serializer.fromJson<bool>(json['isWalkDown']),
      arrowsRequired: serializer.fromJson<int>(json['arrowsRequired']),
      notes: serializer.fromJson<String?>(json['notes']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'courseId': serializer.toJson<String>(courseId),
      'targetNumber': serializer.toJson<int>(targetNumber),
      'pegConfig': serializer.toJson<String>(pegConfig),
      'faceSize': serializer.toJson<int>(faceSize),
      'primaryDistance': serializer.toJson<double>(primaryDistance),
      'unit': serializer.toJson<String>(unit),
      'isWalkUp': serializer.toJson<bool>(isWalkUp),
      'isWalkDown': serializer.toJson<bool>(isWalkDown),
      'arrowsRequired': serializer.toJson<int>(arrowsRequired),
      'notes': serializer.toJson<String?>(notes),
    };
  }

  FieldCourseTarget copyWith({
    String? id,
    String? courseId,
    int? targetNumber,
    String? pegConfig,
    int? faceSize,
    double? primaryDistance,
    String? unit,
    bool? isWalkUp,
    bool? isWalkDown,
    int? arrowsRequired,
    Value<String?> notes = const Value.absent(),
  }) => FieldCourseTarget(
    id: id ?? this.id,
    courseId: courseId ?? this.courseId,
    targetNumber: targetNumber ?? this.targetNumber,
    pegConfig: pegConfig ?? this.pegConfig,
    faceSize: faceSize ?? this.faceSize,
    primaryDistance: primaryDistance ?? this.primaryDistance,
    unit: unit ?? this.unit,
    isWalkUp: isWalkUp ?? this.isWalkUp,
    isWalkDown: isWalkDown ?? this.isWalkDown,
    arrowsRequired: arrowsRequired ?? this.arrowsRequired,
    notes: notes.present ? notes.value : this.notes,
  );
  FieldCourseTarget copyWithCompanion(FieldCourseTargetsCompanion data) {
    return FieldCourseTarget(
      id: data.id.present ? data.id.value : this.id,
      courseId: data.courseId.present ? data.courseId.value : this.courseId,
      targetNumber: data.targetNumber.present
          ? data.targetNumber.value
          : this.targetNumber,
      pegConfig: data.pegConfig.present ? data.pegConfig.value : this.pegConfig,
      faceSize: data.faceSize.present ? data.faceSize.value : this.faceSize,
      primaryDistance: data.primaryDistance.present
          ? data.primaryDistance.value
          : this.primaryDistance,
      unit: data.unit.present ? data.unit.value : this.unit,
      isWalkUp: data.isWalkUp.present ? data.isWalkUp.value : this.isWalkUp,
      isWalkDown: data.isWalkDown.present
          ? data.isWalkDown.value
          : this.isWalkDown,
      arrowsRequired: data.arrowsRequired.present
          ? data.arrowsRequired.value
          : this.arrowsRequired,
      notes: data.notes.present ? data.notes.value : this.notes,
    );
  }

  @override
  String toString() {
    return (StringBuffer('FieldCourseTarget(')
          ..write('id: $id, ')
          ..write('courseId: $courseId, ')
          ..write('targetNumber: $targetNumber, ')
          ..write('pegConfig: $pegConfig, ')
          ..write('faceSize: $faceSize, ')
          ..write('primaryDistance: $primaryDistance, ')
          ..write('unit: $unit, ')
          ..write('isWalkUp: $isWalkUp, ')
          ..write('isWalkDown: $isWalkDown, ')
          ..write('arrowsRequired: $arrowsRequired, ')
          ..write('notes: $notes')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    courseId,
    targetNumber,
    pegConfig,
    faceSize,
    primaryDistance,
    unit,
    isWalkUp,
    isWalkDown,
    arrowsRequired,
    notes,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is FieldCourseTarget &&
          other.id == this.id &&
          other.courseId == this.courseId &&
          other.targetNumber == this.targetNumber &&
          other.pegConfig == this.pegConfig &&
          other.faceSize == this.faceSize &&
          other.primaryDistance == this.primaryDistance &&
          other.unit == this.unit &&
          other.isWalkUp == this.isWalkUp &&
          other.isWalkDown == this.isWalkDown &&
          other.arrowsRequired == this.arrowsRequired &&
          other.notes == this.notes);
}

class FieldCourseTargetsCompanion extends UpdateCompanion<FieldCourseTarget> {
  final Value<String> id;
  final Value<String> courseId;
  final Value<int> targetNumber;
  final Value<String> pegConfig;
  final Value<int> faceSize;
  final Value<double> primaryDistance;
  final Value<String> unit;
  final Value<bool> isWalkUp;
  final Value<bool> isWalkDown;
  final Value<int> arrowsRequired;
  final Value<String?> notes;
  final Value<int> rowid;
  const FieldCourseTargetsCompanion({
    this.id = const Value.absent(),
    this.courseId = const Value.absent(),
    this.targetNumber = const Value.absent(),
    this.pegConfig = const Value.absent(),
    this.faceSize = const Value.absent(),
    this.primaryDistance = const Value.absent(),
    this.unit = const Value.absent(),
    this.isWalkUp = const Value.absent(),
    this.isWalkDown = const Value.absent(),
    this.arrowsRequired = const Value.absent(),
    this.notes = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  FieldCourseTargetsCompanion.insert({
    required String id,
    required String courseId,
    required int targetNumber,
    required String pegConfig,
    required int faceSize,
    required double primaryDistance,
    this.unit = const Value.absent(),
    this.isWalkUp = const Value.absent(),
    this.isWalkDown = const Value.absent(),
    this.arrowsRequired = const Value.absent(),
    this.notes = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       courseId = Value(courseId),
       targetNumber = Value(targetNumber),
       pegConfig = Value(pegConfig),
       faceSize = Value(faceSize),
       primaryDistance = Value(primaryDistance);
  static Insertable<FieldCourseTarget> custom({
    Expression<String>? id,
    Expression<String>? courseId,
    Expression<int>? targetNumber,
    Expression<String>? pegConfig,
    Expression<int>? faceSize,
    Expression<double>? primaryDistance,
    Expression<String>? unit,
    Expression<bool>? isWalkUp,
    Expression<bool>? isWalkDown,
    Expression<int>? arrowsRequired,
    Expression<String>? notes,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (courseId != null) 'course_id': courseId,
      if (targetNumber != null) 'target_number': targetNumber,
      if (pegConfig != null) 'peg_config': pegConfig,
      if (faceSize != null) 'face_size': faceSize,
      if (primaryDistance != null) 'primary_distance': primaryDistance,
      if (unit != null) 'unit': unit,
      if (isWalkUp != null) 'is_walk_up': isWalkUp,
      if (isWalkDown != null) 'is_walk_down': isWalkDown,
      if (arrowsRequired != null) 'arrows_required': arrowsRequired,
      if (notes != null) 'notes': notes,
      if (rowid != null) 'rowid': rowid,
    });
  }

  FieldCourseTargetsCompanion copyWith({
    Value<String>? id,
    Value<String>? courseId,
    Value<int>? targetNumber,
    Value<String>? pegConfig,
    Value<int>? faceSize,
    Value<double>? primaryDistance,
    Value<String>? unit,
    Value<bool>? isWalkUp,
    Value<bool>? isWalkDown,
    Value<int>? arrowsRequired,
    Value<String?>? notes,
    Value<int>? rowid,
  }) {
    return FieldCourseTargetsCompanion(
      id: id ?? this.id,
      courseId: courseId ?? this.courseId,
      targetNumber: targetNumber ?? this.targetNumber,
      pegConfig: pegConfig ?? this.pegConfig,
      faceSize: faceSize ?? this.faceSize,
      primaryDistance: primaryDistance ?? this.primaryDistance,
      unit: unit ?? this.unit,
      isWalkUp: isWalkUp ?? this.isWalkUp,
      isWalkDown: isWalkDown ?? this.isWalkDown,
      arrowsRequired: arrowsRequired ?? this.arrowsRequired,
      notes: notes ?? this.notes,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (courseId.present) {
      map['course_id'] = Variable<String>(courseId.value);
    }
    if (targetNumber.present) {
      map['target_number'] = Variable<int>(targetNumber.value);
    }
    if (pegConfig.present) {
      map['peg_config'] = Variable<String>(pegConfig.value);
    }
    if (faceSize.present) {
      map['face_size'] = Variable<int>(faceSize.value);
    }
    if (primaryDistance.present) {
      map['primary_distance'] = Variable<double>(primaryDistance.value);
    }
    if (unit.present) {
      map['unit'] = Variable<String>(unit.value);
    }
    if (isWalkUp.present) {
      map['is_walk_up'] = Variable<bool>(isWalkUp.value);
    }
    if (isWalkDown.present) {
      map['is_walk_down'] = Variable<bool>(isWalkDown.value);
    }
    if (arrowsRequired.present) {
      map['arrows_required'] = Variable<int>(arrowsRequired.value);
    }
    if (notes.present) {
      map['notes'] = Variable<String>(notes.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('FieldCourseTargetsCompanion(')
          ..write('id: $id, ')
          ..write('courseId: $courseId, ')
          ..write('targetNumber: $targetNumber, ')
          ..write('pegConfig: $pegConfig, ')
          ..write('faceSize: $faceSize, ')
          ..write('primaryDistance: $primaryDistance, ')
          ..write('unit: $unit, ')
          ..write('isWalkUp: $isWalkUp, ')
          ..write('isWalkDown: $isWalkDown, ')
          ..write('arrowsRequired: $arrowsRequired, ')
          ..write('notes: $notes, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $FieldCourseSightMarksTable extends FieldCourseSightMarks
    with TableInfo<$FieldCourseSightMarksTable, FieldCourseSightMark> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $FieldCourseSightMarksTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _courseTargetIdMeta = const VerificationMeta(
    'courseTargetId',
  );
  @override
  late final GeneratedColumn<String> courseTargetId = GeneratedColumn<String>(
    'course_target_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES field_course_targets (id)',
    ),
  );
  static const VerificationMeta _bowIdMeta = const VerificationMeta('bowId');
  @override
  late final GeneratedColumn<String> bowId = GeneratedColumn<String>(
    'bow_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES bows (id)',
    ),
  );
  static const VerificationMeta _calculatedMarkMeta = const VerificationMeta(
    'calculatedMark',
  );
  @override
  late final GeneratedColumn<double> calculatedMark = GeneratedColumn<double>(
    'calculated_mark',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _actualMarkMeta = const VerificationMeta(
    'actualMark',
  );
  @override
  late final GeneratedColumn<double> actualMark = GeneratedColumn<double>(
    'actual_mark',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _differentialMeta = const VerificationMeta(
    'differential',
  );
  @override
  late final GeneratedColumn<double> differential = GeneratedColumn<double>(
    'differential',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _confidenceScoreMeta = const VerificationMeta(
    'confidenceScore',
  );
  @override
  late final GeneratedColumn<double> confidenceScore = GeneratedColumn<double>(
    'confidence_score',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _weatherDataMeta = const VerificationMeta(
    'weatherData',
  );
  @override
  late final GeneratedColumn<String> weatherData = GeneratedColumn<String>(
    'weather_data',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _shotCountMeta = const VerificationMeta(
    'shotCount',
  );
  @override
  late final GeneratedColumn<int> shotCount = GeneratedColumn<int>(
    'shot_count',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _recordedAtMeta = const VerificationMeta(
    'recordedAt',
  );
  @override
  late final GeneratedColumn<DateTime> recordedAt = GeneratedColumn<DateTime>(
    'recorded_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    courseTargetId,
    bowId,
    calculatedMark,
    actualMark,
    differential,
    confidenceScore,
    weatherData,
    shotCount,
    recordedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'field_course_sight_marks';
  @override
  VerificationContext validateIntegrity(
    Insertable<FieldCourseSightMark> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('course_target_id')) {
      context.handle(
        _courseTargetIdMeta,
        courseTargetId.isAcceptableOrUnknown(
          data['course_target_id']!,
          _courseTargetIdMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_courseTargetIdMeta);
    }
    if (data.containsKey('bow_id')) {
      context.handle(
        _bowIdMeta,
        bowId.isAcceptableOrUnknown(data['bow_id']!, _bowIdMeta),
      );
    } else if (isInserting) {
      context.missing(_bowIdMeta);
    }
    if (data.containsKey('calculated_mark')) {
      context.handle(
        _calculatedMarkMeta,
        calculatedMark.isAcceptableOrUnknown(
          data['calculated_mark']!,
          _calculatedMarkMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_calculatedMarkMeta);
    }
    if (data.containsKey('actual_mark')) {
      context.handle(
        _actualMarkMeta,
        actualMark.isAcceptableOrUnknown(data['actual_mark']!, _actualMarkMeta),
      );
    } else if (isInserting) {
      context.missing(_actualMarkMeta);
    }
    if (data.containsKey('differential')) {
      context.handle(
        _differentialMeta,
        differential.isAcceptableOrUnknown(
          data['differential']!,
          _differentialMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_differentialMeta);
    }
    if (data.containsKey('confidence_score')) {
      context.handle(
        _confidenceScoreMeta,
        confidenceScore.isAcceptableOrUnknown(
          data['confidence_score']!,
          _confidenceScoreMeta,
        ),
      );
    }
    if (data.containsKey('weather_data')) {
      context.handle(
        _weatherDataMeta,
        weatherData.isAcceptableOrUnknown(
          data['weather_data']!,
          _weatherDataMeta,
        ),
      );
    }
    if (data.containsKey('shot_count')) {
      context.handle(
        _shotCountMeta,
        shotCount.isAcceptableOrUnknown(data['shot_count']!, _shotCountMeta),
      );
    }
    if (data.containsKey('recorded_at')) {
      context.handle(
        _recordedAtMeta,
        recordedAt.isAcceptableOrUnknown(data['recorded_at']!, _recordedAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  FieldCourseSightMark map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return FieldCourseSightMark(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      courseTargetId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}course_target_id'],
      )!,
      bowId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}bow_id'],
      )!,
      calculatedMark: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}calculated_mark'],
      )!,
      actualMark: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}actual_mark'],
      )!,
      differential: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}differential'],
      )!,
      confidenceScore: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}confidence_score'],
      ),
      weatherData: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}weather_data'],
      ),
      shotCount: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}shot_count'],
      )!,
      recordedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}recorded_at'],
      )!,
    );
  }

  @override
  $FieldCourseSightMarksTable createAlias(String alias) {
    return $FieldCourseSightMarksTable(attachedDatabase, alias);
  }
}

class FieldCourseSightMark extends DataClass
    implements Insertable<FieldCourseSightMark> {
  final String id;
  final String courseTargetId;
  final String bowId;
  final double calculatedMark;
  final double actualMark;
  final double differential;
  final double? confidenceScore;
  final String? weatherData;
  final int shotCount;
  final DateTime recordedAt;
  const FieldCourseSightMark({
    required this.id,
    required this.courseTargetId,
    required this.bowId,
    required this.calculatedMark,
    required this.actualMark,
    required this.differential,
    this.confidenceScore,
    this.weatherData,
    required this.shotCount,
    required this.recordedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['course_target_id'] = Variable<String>(courseTargetId);
    map['bow_id'] = Variable<String>(bowId);
    map['calculated_mark'] = Variable<double>(calculatedMark);
    map['actual_mark'] = Variable<double>(actualMark);
    map['differential'] = Variable<double>(differential);
    if (!nullToAbsent || confidenceScore != null) {
      map['confidence_score'] = Variable<double>(confidenceScore);
    }
    if (!nullToAbsent || weatherData != null) {
      map['weather_data'] = Variable<String>(weatherData);
    }
    map['shot_count'] = Variable<int>(shotCount);
    map['recorded_at'] = Variable<DateTime>(recordedAt);
    return map;
  }

  FieldCourseSightMarksCompanion toCompanion(bool nullToAbsent) {
    return FieldCourseSightMarksCompanion(
      id: Value(id),
      courseTargetId: Value(courseTargetId),
      bowId: Value(bowId),
      calculatedMark: Value(calculatedMark),
      actualMark: Value(actualMark),
      differential: Value(differential),
      confidenceScore: confidenceScore == null && nullToAbsent
          ? const Value.absent()
          : Value(confidenceScore),
      weatherData: weatherData == null && nullToAbsent
          ? const Value.absent()
          : Value(weatherData),
      shotCount: Value(shotCount),
      recordedAt: Value(recordedAt),
    );
  }

  factory FieldCourseSightMark.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return FieldCourseSightMark(
      id: serializer.fromJson<String>(json['id']),
      courseTargetId: serializer.fromJson<String>(json['courseTargetId']),
      bowId: serializer.fromJson<String>(json['bowId']),
      calculatedMark: serializer.fromJson<double>(json['calculatedMark']),
      actualMark: serializer.fromJson<double>(json['actualMark']),
      differential: serializer.fromJson<double>(json['differential']),
      confidenceScore: serializer.fromJson<double?>(json['confidenceScore']),
      weatherData: serializer.fromJson<String?>(json['weatherData']),
      shotCount: serializer.fromJson<int>(json['shotCount']),
      recordedAt: serializer.fromJson<DateTime>(json['recordedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'courseTargetId': serializer.toJson<String>(courseTargetId),
      'bowId': serializer.toJson<String>(bowId),
      'calculatedMark': serializer.toJson<double>(calculatedMark),
      'actualMark': serializer.toJson<double>(actualMark),
      'differential': serializer.toJson<double>(differential),
      'confidenceScore': serializer.toJson<double?>(confidenceScore),
      'weatherData': serializer.toJson<String?>(weatherData),
      'shotCount': serializer.toJson<int>(shotCount),
      'recordedAt': serializer.toJson<DateTime>(recordedAt),
    };
  }

  FieldCourseSightMark copyWith({
    String? id,
    String? courseTargetId,
    String? bowId,
    double? calculatedMark,
    double? actualMark,
    double? differential,
    Value<double?> confidenceScore = const Value.absent(),
    Value<String?> weatherData = const Value.absent(),
    int? shotCount,
    DateTime? recordedAt,
  }) => FieldCourseSightMark(
    id: id ?? this.id,
    courseTargetId: courseTargetId ?? this.courseTargetId,
    bowId: bowId ?? this.bowId,
    calculatedMark: calculatedMark ?? this.calculatedMark,
    actualMark: actualMark ?? this.actualMark,
    differential: differential ?? this.differential,
    confidenceScore: confidenceScore.present
        ? confidenceScore.value
        : this.confidenceScore,
    weatherData: weatherData.present ? weatherData.value : this.weatherData,
    shotCount: shotCount ?? this.shotCount,
    recordedAt: recordedAt ?? this.recordedAt,
  );
  FieldCourseSightMark copyWithCompanion(FieldCourseSightMarksCompanion data) {
    return FieldCourseSightMark(
      id: data.id.present ? data.id.value : this.id,
      courseTargetId: data.courseTargetId.present
          ? data.courseTargetId.value
          : this.courseTargetId,
      bowId: data.bowId.present ? data.bowId.value : this.bowId,
      calculatedMark: data.calculatedMark.present
          ? data.calculatedMark.value
          : this.calculatedMark,
      actualMark: data.actualMark.present
          ? data.actualMark.value
          : this.actualMark,
      differential: data.differential.present
          ? data.differential.value
          : this.differential,
      confidenceScore: data.confidenceScore.present
          ? data.confidenceScore.value
          : this.confidenceScore,
      weatherData: data.weatherData.present
          ? data.weatherData.value
          : this.weatherData,
      shotCount: data.shotCount.present ? data.shotCount.value : this.shotCount,
      recordedAt: data.recordedAt.present
          ? data.recordedAt.value
          : this.recordedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('FieldCourseSightMark(')
          ..write('id: $id, ')
          ..write('courseTargetId: $courseTargetId, ')
          ..write('bowId: $bowId, ')
          ..write('calculatedMark: $calculatedMark, ')
          ..write('actualMark: $actualMark, ')
          ..write('differential: $differential, ')
          ..write('confidenceScore: $confidenceScore, ')
          ..write('weatherData: $weatherData, ')
          ..write('shotCount: $shotCount, ')
          ..write('recordedAt: $recordedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    courseTargetId,
    bowId,
    calculatedMark,
    actualMark,
    differential,
    confidenceScore,
    weatherData,
    shotCount,
    recordedAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is FieldCourseSightMark &&
          other.id == this.id &&
          other.courseTargetId == this.courseTargetId &&
          other.bowId == this.bowId &&
          other.calculatedMark == this.calculatedMark &&
          other.actualMark == this.actualMark &&
          other.differential == this.differential &&
          other.confidenceScore == this.confidenceScore &&
          other.weatherData == this.weatherData &&
          other.shotCount == this.shotCount &&
          other.recordedAt == this.recordedAt);
}

class FieldCourseSightMarksCompanion
    extends UpdateCompanion<FieldCourseSightMark> {
  final Value<String> id;
  final Value<String> courseTargetId;
  final Value<String> bowId;
  final Value<double> calculatedMark;
  final Value<double> actualMark;
  final Value<double> differential;
  final Value<double?> confidenceScore;
  final Value<String?> weatherData;
  final Value<int> shotCount;
  final Value<DateTime> recordedAt;
  final Value<int> rowid;
  const FieldCourseSightMarksCompanion({
    this.id = const Value.absent(),
    this.courseTargetId = const Value.absent(),
    this.bowId = const Value.absent(),
    this.calculatedMark = const Value.absent(),
    this.actualMark = const Value.absent(),
    this.differential = const Value.absent(),
    this.confidenceScore = const Value.absent(),
    this.weatherData = const Value.absent(),
    this.shotCount = const Value.absent(),
    this.recordedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  FieldCourseSightMarksCompanion.insert({
    required String id,
    required String courseTargetId,
    required String bowId,
    required double calculatedMark,
    required double actualMark,
    required double differential,
    this.confidenceScore = const Value.absent(),
    this.weatherData = const Value.absent(),
    this.shotCount = const Value.absent(),
    this.recordedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       courseTargetId = Value(courseTargetId),
       bowId = Value(bowId),
       calculatedMark = Value(calculatedMark),
       actualMark = Value(actualMark),
       differential = Value(differential);
  static Insertable<FieldCourseSightMark> custom({
    Expression<String>? id,
    Expression<String>? courseTargetId,
    Expression<String>? bowId,
    Expression<double>? calculatedMark,
    Expression<double>? actualMark,
    Expression<double>? differential,
    Expression<double>? confidenceScore,
    Expression<String>? weatherData,
    Expression<int>? shotCount,
    Expression<DateTime>? recordedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (courseTargetId != null) 'course_target_id': courseTargetId,
      if (bowId != null) 'bow_id': bowId,
      if (calculatedMark != null) 'calculated_mark': calculatedMark,
      if (actualMark != null) 'actual_mark': actualMark,
      if (differential != null) 'differential': differential,
      if (confidenceScore != null) 'confidence_score': confidenceScore,
      if (weatherData != null) 'weather_data': weatherData,
      if (shotCount != null) 'shot_count': shotCount,
      if (recordedAt != null) 'recorded_at': recordedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  FieldCourseSightMarksCompanion copyWith({
    Value<String>? id,
    Value<String>? courseTargetId,
    Value<String>? bowId,
    Value<double>? calculatedMark,
    Value<double>? actualMark,
    Value<double>? differential,
    Value<double?>? confidenceScore,
    Value<String?>? weatherData,
    Value<int>? shotCount,
    Value<DateTime>? recordedAt,
    Value<int>? rowid,
  }) {
    return FieldCourseSightMarksCompanion(
      id: id ?? this.id,
      courseTargetId: courseTargetId ?? this.courseTargetId,
      bowId: bowId ?? this.bowId,
      calculatedMark: calculatedMark ?? this.calculatedMark,
      actualMark: actualMark ?? this.actualMark,
      differential: differential ?? this.differential,
      confidenceScore: confidenceScore ?? this.confidenceScore,
      weatherData: weatherData ?? this.weatherData,
      shotCount: shotCount ?? this.shotCount,
      recordedAt: recordedAt ?? this.recordedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (courseTargetId.present) {
      map['course_target_id'] = Variable<String>(courseTargetId.value);
    }
    if (bowId.present) {
      map['bow_id'] = Variable<String>(bowId.value);
    }
    if (calculatedMark.present) {
      map['calculated_mark'] = Variable<double>(calculatedMark.value);
    }
    if (actualMark.present) {
      map['actual_mark'] = Variable<double>(actualMark.value);
    }
    if (differential.present) {
      map['differential'] = Variable<double>(differential.value);
    }
    if (confidenceScore.present) {
      map['confidence_score'] = Variable<double>(confidenceScore.value);
    }
    if (weatherData.present) {
      map['weather_data'] = Variable<String>(weatherData.value);
    }
    if (shotCount.present) {
      map['shot_count'] = Variable<int>(shotCount.value);
    }
    if (recordedAt.present) {
      map['recorded_at'] = Variable<DateTime>(recordedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('FieldCourseSightMarksCompanion(')
          ..write('id: $id, ')
          ..write('courseTargetId: $courseTargetId, ')
          ..write('bowId: $bowId, ')
          ..write('calculatedMark: $calculatedMark, ')
          ..write('actualMark: $actualMark, ')
          ..write('differential: $differential, ')
          ..write('confidenceScore: $confidenceScore, ')
          ..write('weatherData: $weatherData, ')
          ..write('shotCount: $shotCount, ')
          ..write('recordedAt: $recordedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $FieldSessionTargetsTable extends FieldSessionTargets
    with TableInfo<$FieldSessionTargetsTable, FieldSessionTarget> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $FieldSessionTargetsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _sessionIdMeta = const VerificationMeta(
    'sessionId',
  );
  @override
  late final GeneratedColumn<String> sessionId = GeneratedColumn<String>(
    'session_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES sessions (id)',
    ),
  );
  static const VerificationMeta _courseTargetIdMeta = const VerificationMeta(
    'courseTargetId',
  );
  @override
  late final GeneratedColumn<String> courseTargetId = GeneratedColumn<String>(
    'course_target_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES field_course_targets (id)',
    ),
  );
  static const VerificationMeta _targetNumberMeta = const VerificationMeta(
    'targetNumber',
  );
  @override
  late final GeneratedColumn<int> targetNumber = GeneratedColumn<int>(
    'target_number',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _totalScoreMeta = const VerificationMeta(
    'totalScore',
  );
  @override
  late final GeneratedColumn<int> totalScore = GeneratedColumn<int>(
    'total_score',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _xCountMeta = const VerificationMeta('xCount');
  @override
  late final GeneratedColumn<int> xCount = GeneratedColumn<int>(
    'x_count',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _arrowScoresMeta = const VerificationMeta(
    'arrowScores',
  );
  @override
  late final GeneratedColumn<String> arrowScores = GeneratedColumn<String>(
    'arrow_scores',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _sightMarkUsedMeta = const VerificationMeta(
    'sightMarkUsed',
  );
  @override
  late final GeneratedColumn<String> sightMarkUsed = GeneratedColumn<String>(
    'sight_mark_used',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _stationMeta = const VerificationMeta(
    'station',
  );
  @override
  late final GeneratedColumn<int> station = GeneratedColumn<int>(
    'station',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _wasHitMeta = const VerificationMeta('wasHit');
  @override
  late final GeneratedColumn<bool> wasHit = GeneratedColumn<bool>(
    'was_hit',
    aliasedName,
    true,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("was_hit" IN (0, 1))',
    ),
  );
  static const VerificationMeta _completedAtMeta = const VerificationMeta(
    'completedAt',
  );
  @override
  late final GeneratedColumn<DateTime> completedAt = GeneratedColumn<DateTime>(
    'completed_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    sessionId,
    courseTargetId,
    targetNumber,
    totalScore,
    xCount,
    arrowScores,
    sightMarkUsed,
    station,
    wasHit,
    completedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'field_session_targets';
  @override
  VerificationContext validateIntegrity(
    Insertable<FieldSessionTarget> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('session_id')) {
      context.handle(
        _sessionIdMeta,
        sessionId.isAcceptableOrUnknown(data['session_id']!, _sessionIdMeta),
      );
    } else if (isInserting) {
      context.missing(_sessionIdMeta);
    }
    if (data.containsKey('course_target_id')) {
      context.handle(
        _courseTargetIdMeta,
        courseTargetId.isAcceptableOrUnknown(
          data['course_target_id']!,
          _courseTargetIdMeta,
        ),
      );
    }
    if (data.containsKey('target_number')) {
      context.handle(
        _targetNumberMeta,
        targetNumber.isAcceptableOrUnknown(
          data['target_number']!,
          _targetNumberMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_targetNumberMeta);
    }
    if (data.containsKey('total_score')) {
      context.handle(
        _totalScoreMeta,
        totalScore.isAcceptableOrUnknown(data['total_score']!, _totalScoreMeta),
      );
    }
    if (data.containsKey('x_count')) {
      context.handle(
        _xCountMeta,
        xCount.isAcceptableOrUnknown(data['x_count']!, _xCountMeta),
      );
    }
    if (data.containsKey('arrow_scores')) {
      context.handle(
        _arrowScoresMeta,
        arrowScores.isAcceptableOrUnknown(
          data['arrow_scores']!,
          _arrowScoresMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_arrowScoresMeta);
    }
    if (data.containsKey('sight_mark_used')) {
      context.handle(
        _sightMarkUsedMeta,
        sightMarkUsed.isAcceptableOrUnknown(
          data['sight_mark_used']!,
          _sightMarkUsedMeta,
        ),
      );
    }
    if (data.containsKey('station')) {
      context.handle(
        _stationMeta,
        station.isAcceptableOrUnknown(data['station']!, _stationMeta),
      );
    }
    if (data.containsKey('was_hit')) {
      context.handle(
        _wasHitMeta,
        wasHit.isAcceptableOrUnknown(data['was_hit']!, _wasHitMeta),
      );
    }
    if (data.containsKey('completed_at')) {
      context.handle(
        _completedAtMeta,
        completedAt.isAcceptableOrUnknown(
          data['completed_at']!,
          _completedAtMeta,
        ),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  FieldSessionTarget map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return FieldSessionTarget(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      sessionId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}session_id'],
      )!,
      courseTargetId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}course_target_id'],
      ),
      targetNumber: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}target_number'],
      )!,
      totalScore: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}total_score'],
      )!,
      xCount: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}x_count'],
      )!,
      arrowScores: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}arrow_scores'],
      )!,
      sightMarkUsed: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}sight_mark_used'],
      ),
      station: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}station'],
      ),
      wasHit: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}was_hit'],
      ),
      completedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}completed_at'],
      ),
    );
  }

  @override
  $FieldSessionTargetsTable createAlias(String alias) {
    return $FieldSessionTargetsTable(attachedDatabase, alias);
  }
}

class FieldSessionTarget extends DataClass
    implements Insertable<FieldSessionTarget> {
  final String id;
  final String sessionId;
  final String? courseTargetId;
  final int targetNumber;
  final int totalScore;
  final int xCount;
  final String arrowScores;
  final String? sightMarkUsed;
  final int? station;
  final bool? wasHit;
  final DateTime? completedAt;
  const FieldSessionTarget({
    required this.id,
    required this.sessionId,
    this.courseTargetId,
    required this.targetNumber,
    required this.totalScore,
    required this.xCount,
    required this.arrowScores,
    this.sightMarkUsed,
    this.station,
    this.wasHit,
    this.completedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['session_id'] = Variable<String>(sessionId);
    if (!nullToAbsent || courseTargetId != null) {
      map['course_target_id'] = Variable<String>(courseTargetId);
    }
    map['target_number'] = Variable<int>(targetNumber);
    map['total_score'] = Variable<int>(totalScore);
    map['x_count'] = Variable<int>(xCount);
    map['arrow_scores'] = Variable<String>(arrowScores);
    if (!nullToAbsent || sightMarkUsed != null) {
      map['sight_mark_used'] = Variable<String>(sightMarkUsed);
    }
    if (!nullToAbsent || station != null) {
      map['station'] = Variable<int>(station);
    }
    if (!nullToAbsent || wasHit != null) {
      map['was_hit'] = Variable<bool>(wasHit);
    }
    if (!nullToAbsent || completedAt != null) {
      map['completed_at'] = Variable<DateTime>(completedAt);
    }
    return map;
  }

  FieldSessionTargetsCompanion toCompanion(bool nullToAbsent) {
    return FieldSessionTargetsCompanion(
      id: Value(id),
      sessionId: Value(sessionId),
      courseTargetId: courseTargetId == null && nullToAbsent
          ? const Value.absent()
          : Value(courseTargetId),
      targetNumber: Value(targetNumber),
      totalScore: Value(totalScore),
      xCount: Value(xCount),
      arrowScores: Value(arrowScores),
      sightMarkUsed: sightMarkUsed == null && nullToAbsent
          ? const Value.absent()
          : Value(sightMarkUsed),
      station: station == null && nullToAbsent
          ? const Value.absent()
          : Value(station),
      wasHit: wasHit == null && nullToAbsent
          ? const Value.absent()
          : Value(wasHit),
      completedAt: completedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(completedAt),
    );
  }

  factory FieldSessionTarget.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return FieldSessionTarget(
      id: serializer.fromJson<String>(json['id']),
      sessionId: serializer.fromJson<String>(json['sessionId']),
      courseTargetId: serializer.fromJson<String?>(json['courseTargetId']),
      targetNumber: serializer.fromJson<int>(json['targetNumber']),
      totalScore: serializer.fromJson<int>(json['totalScore']),
      xCount: serializer.fromJson<int>(json['xCount']),
      arrowScores: serializer.fromJson<String>(json['arrowScores']),
      sightMarkUsed: serializer.fromJson<String?>(json['sightMarkUsed']),
      station: serializer.fromJson<int?>(json['station']),
      wasHit: serializer.fromJson<bool?>(json['wasHit']),
      completedAt: serializer.fromJson<DateTime?>(json['completedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'sessionId': serializer.toJson<String>(sessionId),
      'courseTargetId': serializer.toJson<String?>(courseTargetId),
      'targetNumber': serializer.toJson<int>(targetNumber),
      'totalScore': serializer.toJson<int>(totalScore),
      'xCount': serializer.toJson<int>(xCount),
      'arrowScores': serializer.toJson<String>(arrowScores),
      'sightMarkUsed': serializer.toJson<String?>(sightMarkUsed),
      'station': serializer.toJson<int?>(station),
      'wasHit': serializer.toJson<bool?>(wasHit),
      'completedAt': serializer.toJson<DateTime?>(completedAt),
    };
  }

  FieldSessionTarget copyWith({
    String? id,
    String? sessionId,
    Value<String?> courseTargetId = const Value.absent(),
    int? targetNumber,
    int? totalScore,
    int? xCount,
    String? arrowScores,
    Value<String?> sightMarkUsed = const Value.absent(),
    Value<int?> station = const Value.absent(),
    Value<bool?> wasHit = const Value.absent(),
    Value<DateTime?> completedAt = const Value.absent(),
  }) => FieldSessionTarget(
    id: id ?? this.id,
    sessionId: sessionId ?? this.sessionId,
    courseTargetId: courseTargetId.present
        ? courseTargetId.value
        : this.courseTargetId,
    targetNumber: targetNumber ?? this.targetNumber,
    totalScore: totalScore ?? this.totalScore,
    xCount: xCount ?? this.xCount,
    arrowScores: arrowScores ?? this.arrowScores,
    sightMarkUsed: sightMarkUsed.present
        ? sightMarkUsed.value
        : this.sightMarkUsed,
    station: station.present ? station.value : this.station,
    wasHit: wasHit.present ? wasHit.value : this.wasHit,
    completedAt: completedAt.present ? completedAt.value : this.completedAt,
  );
  FieldSessionTarget copyWithCompanion(FieldSessionTargetsCompanion data) {
    return FieldSessionTarget(
      id: data.id.present ? data.id.value : this.id,
      sessionId: data.sessionId.present ? data.sessionId.value : this.sessionId,
      courseTargetId: data.courseTargetId.present
          ? data.courseTargetId.value
          : this.courseTargetId,
      targetNumber: data.targetNumber.present
          ? data.targetNumber.value
          : this.targetNumber,
      totalScore: data.totalScore.present
          ? data.totalScore.value
          : this.totalScore,
      xCount: data.xCount.present ? data.xCount.value : this.xCount,
      arrowScores: data.arrowScores.present
          ? data.arrowScores.value
          : this.arrowScores,
      sightMarkUsed: data.sightMarkUsed.present
          ? data.sightMarkUsed.value
          : this.sightMarkUsed,
      station: data.station.present ? data.station.value : this.station,
      wasHit: data.wasHit.present ? data.wasHit.value : this.wasHit,
      completedAt: data.completedAt.present
          ? data.completedAt.value
          : this.completedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('FieldSessionTarget(')
          ..write('id: $id, ')
          ..write('sessionId: $sessionId, ')
          ..write('courseTargetId: $courseTargetId, ')
          ..write('targetNumber: $targetNumber, ')
          ..write('totalScore: $totalScore, ')
          ..write('xCount: $xCount, ')
          ..write('arrowScores: $arrowScores, ')
          ..write('sightMarkUsed: $sightMarkUsed, ')
          ..write('station: $station, ')
          ..write('wasHit: $wasHit, ')
          ..write('completedAt: $completedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    sessionId,
    courseTargetId,
    targetNumber,
    totalScore,
    xCount,
    arrowScores,
    sightMarkUsed,
    station,
    wasHit,
    completedAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is FieldSessionTarget &&
          other.id == this.id &&
          other.sessionId == this.sessionId &&
          other.courseTargetId == this.courseTargetId &&
          other.targetNumber == this.targetNumber &&
          other.totalScore == this.totalScore &&
          other.xCount == this.xCount &&
          other.arrowScores == this.arrowScores &&
          other.sightMarkUsed == this.sightMarkUsed &&
          other.station == this.station &&
          other.wasHit == this.wasHit &&
          other.completedAt == this.completedAt);
}

class FieldSessionTargetsCompanion extends UpdateCompanion<FieldSessionTarget> {
  final Value<String> id;
  final Value<String> sessionId;
  final Value<String?> courseTargetId;
  final Value<int> targetNumber;
  final Value<int> totalScore;
  final Value<int> xCount;
  final Value<String> arrowScores;
  final Value<String?> sightMarkUsed;
  final Value<int?> station;
  final Value<bool?> wasHit;
  final Value<DateTime?> completedAt;
  final Value<int> rowid;
  const FieldSessionTargetsCompanion({
    this.id = const Value.absent(),
    this.sessionId = const Value.absent(),
    this.courseTargetId = const Value.absent(),
    this.targetNumber = const Value.absent(),
    this.totalScore = const Value.absent(),
    this.xCount = const Value.absent(),
    this.arrowScores = const Value.absent(),
    this.sightMarkUsed = const Value.absent(),
    this.station = const Value.absent(),
    this.wasHit = const Value.absent(),
    this.completedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  FieldSessionTargetsCompanion.insert({
    required String id,
    required String sessionId,
    this.courseTargetId = const Value.absent(),
    required int targetNumber,
    this.totalScore = const Value.absent(),
    this.xCount = const Value.absent(),
    required String arrowScores,
    this.sightMarkUsed = const Value.absent(),
    this.station = const Value.absent(),
    this.wasHit = const Value.absent(),
    this.completedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       sessionId = Value(sessionId),
       targetNumber = Value(targetNumber),
       arrowScores = Value(arrowScores);
  static Insertable<FieldSessionTarget> custom({
    Expression<String>? id,
    Expression<String>? sessionId,
    Expression<String>? courseTargetId,
    Expression<int>? targetNumber,
    Expression<int>? totalScore,
    Expression<int>? xCount,
    Expression<String>? arrowScores,
    Expression<String>? sightMarkUsed,
    Expression<int>? station,
    Expression<bool>? wasHit,
    Expression<DateTime>? completedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (sessionId != null) 'session_id': sessionId,
      if (courseTargetId != null) 'course_target_id': courseTargetId,
      if (targetNumber != null) 'target_number': targetNumber,
      if (totalScore != null) 'total_score': totalScore,
      if (xCount != null) 'x_count': xCount,
      if (arrowScores != null) 'arrow_scores': arrowScores,
      if (sightMarkUsed != null) 'sight_mark_used': sightMarkUsed,
      if (station != null) 'station': station,
      if (wasHit != null) 'was_hit': wasHit,
      if (completedAt != null) 'completed_at': completedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  FieldSessionTargetsCompanion copyWith({
    Value<String>? id,
    Value<String>? sessionId,
    Value<String?>? courseTargetId,
    Value<int>? targetNumber,
    Value<int>? totalScore,
    Value<int>? xCount,
    Value<String>? arrowScores,
    Value<String?>? sightMarkUsed,
    Value<int?>? station,
    Value<bool?>? wasHit,
    Value<DateTime?>? completedAt,
    Value<int>? rowid,
  }) {
    return FieldSessionTargetsCompanion(
      id: id ?? this.id,
      sessionId: sessionId ?? this.sessionId,
      courseTargetId: courseTargetId ?? this.courseTargetId,
      targetNumber: targetNumber ?? this.targetNumber,
      totalScore: totalScore ?? this.totalScore,
      xCount: xCount ?? this.xCount,
      arrowScores: arrowScores ?? this.arrowScores,
      sightMarkUsed: sightMarkUsed ?? this.sightMarkUsed,
      station: station ?? this.station,
      wasHit: wasHit ?? this.wasHit,
      completedAt: completedAt ?? this.completedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (sessionId.present) {
      map['session_id'] = Variable<String>(sessionId.value);
    }
    if (courseTargetId.present) {
      map['course_target_id'] = Variable<String>(courseTargetId.value);
    }
    if (targetNumber.present) {
      map['target_number'] = Variable<int>(targetNumber.value);
    }
    if (totalScore.present) {
      map['total_score'] = Variable<int>(totalScore.value);
    }
    if (xCount.present) {
      map['x_count'] = Variable<int>(xCount.value);
    }
    if (arrowScores.present) {
      map['arrow_scores'] = Variable<String>(arrowScores.value);
    }
    if (sightMarkUsed.present) {
      map['sight_mark_used'] = Variable<String>(sightMarkUsed.value);
    }
    if (station.present) {
      map['station'] = Variable<int>(station.value);
    }
    if (wasHit.present) {
      map['was_hit'] = Variable<bool>(wasHit.value);
    }
    if (completedAt.present) {
      map['completed_at'] = Variable<DateTime>(completedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('FieldSessionTargetsCompanion(')
          ..write('id: $id, ')
          ..write('sessionId: $sessionId, ')
          ..write('courseTargetId: $courseTargetId, ')
          ..write('targetNumber: $targetNumber, ')
          ..write('totalScore: $totalScore, ')
          ..write('xCount: $xCount, ')
          ..write('arrowScores: $arrowScores, ')
          ..write('sightMarkUsed: $sightMarkUsed, ')
          ..write('station: $station, ')
          ..write('wasHit: $wasHit, ')
          ..write('completedAt: $completedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $FieldSessionMetaTable extends FieldSessionMeta
    with TableInfo<$FieldSessionMetaTable, FieldSessionMetaData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $FieldSessionMetaTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _sessionIdMeta = const VerificationMeta(
    'sessionId',
  );
  @override
  late final GeneratedColumn<String> sessionId = GeneratedColumn<String>(
    'session_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES sessions (id)',
    ),
  );
  static const VerificationMeta _courseIdMeta = const VerificationMeta(
    'courseId',
  );
  @override
  late final GeneratedColumn<String> courseId = GeneratedColumn<String>(
    'course_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES field_courses (id)',
    ),
  );
  static const VerificationMeta _roundTypeMeta = const VerificationMeta(
    'roundType',
  );
  @override
  late final GeneratedColumn<String> roundType = GeneratedColumn<String>(
    'round_type',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _isNewCourseCreationMeta =
      const VerificationMeta('isNewCourseCreation');
  @override
  late final GeneratedColumn<bool> isNewCourseCreation = GeneratedColumn<bool>(
    'is_new_course_creation',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_new_course_creation" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _currentTargetNumberMeta =
      const VerificationMeta('currentTargetNumber');
  @override
  late final GeneratedColumn<int> currentTargetNumber = GeneratedColumn<int>(
    'current_target_number',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(1),
  );
  static const VerificationMeta _usedPegsMeta = const VerificationMeta(
    'usedPegs',
  );
  @override
  late final GeneratedColumn<String> usedPegs = GeneratedColumn<String>(
    'used_pegs',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('[]'),
  );
  @override
  List<GeneratedColumn> get $columns => [
    sessionId,
    courseId,
    roundType,
    isNewCourseCreation,
    currentTargetNumber,
    usedPegs,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'field_session_meta';
  @override
  VerificationContext validateIntegrity(
    Insertable<FieldSessionMetaData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('session_id')) {
      context.handle(
        _sessionIdMeta,
        sessionId.isAcceptableOrUnknown(data['session_id']!, _sessionIdMeta),
      );
    } else if (isInserting) {
      context.missing(_sessionIdMeta);
    }
    if (data.containsKey('course_id')) {
      context.handle(
        _courseIdMeta,
        courseId.isAcceptableOrUnknown(data['course_id']!, _courseIdMeta),
      );
    }
    if (data.containsKey('round_type')) {
      context.handle(
        _roundTypeMeta,
        roundType.isAcceptableOrUnknown(data['round_type']!, _roundTypeMeta),
      );
    } else if (isInserting) {
      context.missing(_roundTypeMeta);
    }
    if (data.containsKey('is_new_course_creation')) {
      context.handle(
        _isNewCourseCreationMeta,
        isNewCourseCreation.isAcceptableOrUnknown(
          data['is_new_course_creation']!,
          _isNewCourseCreationMeta,
        ),
      );
    }
    if (data.containsKey('current_target_number')) {
      context.handle(
        _currentTargetNumberMeta,
        currentTargetNumber.isAcceptableOrUnknown(
          data['current_target_number']!,
          _currentTargetNumberMeta,
        ),
      );
    }
    if (data.containsKey('used_pegs')) {
      context.handle(
        _usedPegsMeta,
        usedPegs.isAcceptableOrUnknown(data['used_pegs']!, _usedPegsMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {sessionId};
  @override
  FieldSessionMetaData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return FieldSessionMetaData(
      sessionId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}session_id'],
      )!,
      courseId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}course_id'],
      ),
      roundType: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}round_type'],
      )!,
      isNewCourseCreation: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_new_course_creation'],
      )!,
      currentTargetNumber: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}current_target_number'],
      )!,
      usedPegs: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}used_pegs'],
      )!,
    );
  }

  @override
  $FieldSessionMetaTable createAlias(String alias) {
    return $FieldSessionMetaTable(attachedDatabase, alias);
  }
}

class FieldSessionMetaData extends DataClass
    implements Insertable<FieldSessionMetaData> {
  final String sessionId;
  final String? courseId;
  final String roundType;
  final bool isNewCourseCreation;
  final int currentTargetNumber;
  final String usedPegs;
  const FieldSessionMetaData({
    required this.sessionId,
    this.courseId,
    required this.roundType,
    required this.isNewCourseCreation,
    required this.currentTargetNumber,
    required this.usedPegs,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['session_id'] = Variable<String>(sessionId);
    if (!nullToAbsent || courseId != null) {
      map['course_id'] = Variable<String>(courseId);
    }
    map['round_type'] = Variable<String>(roundType);
    map['is_new_course_creation'] = Variable<bool>(isNewCourseCreation);
    map['current_target_number'] = Variable<int>(currentTargetNumber);
    map['used_pegs'] = Variable<String>(usedPegs);
    return map;
  }

  FieldSessionMetaCompanion toCompanion(bool nullToAbsent) {
    return FieldSessionMetaCompanion(
      sessionId: Value(sessionId),
      courseId: courseId == null && nullToAbsent
          ? const Value.absent()
          : Value(courseId),
      roundType: Value(roundType),
      isNewCourseCreation: Value(isNewCourseCreation),
      currentTargetNumber: Value(currentTargetNumber),
      usedPegs: Value(usedPegs),
    );
  }

  factory FieldSessionMetaData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return FieldSessionMetaData(
      sessionId: serializer.fromJson<String>(json['sessionId']),
      courseId: serializer.fromJson<String?>(json['courseId']),
      roundType: serializer.fromJson<String>(json['roundType']),
      isNewCourseCreation: serializer.fromJson<bool>(
        json['isNewCourseCreation'],
      ),
      currentTargetNumber: serializer.fromJson<int>(
        json['currentTargetNumber'],
      ),
      usedPegs: serializer.fromJson<String>(json['usedPegs']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'sessionId': serializer.toJson<String>(sessionId),
      'courseId': serializer.toJson<String?>(courseId),
      'roundType': serializer.toJson<String>(roundType),
      'isNewCourseCreation': serializer.toJson<bool>(isNewCourseCreation),
      'currentTargetNumber': serializer.toJson<int>(currentTargetNumber),
      'usedPegs': serializer.toJson<String>(usedPegs),
    };
  }

  FieldSessionMetaData copyWith({
    String? sessionId,
    Value<String?> courseId = const Value.absent(),
    String? roundType,
    bool? isNewCourseCreation,
    int? currentTargetNumber,
    String? usedPegs,
  }) => FieldSessionMetaData(
    sessionId: sessionId ?? this.sessionId,
    courseId: courseId.present ? courseId.value : this.courseId,
    roundType: roundType ?? this.roundType,
    isNewCourseCreation: isNewCourseCreation ?? this.isNewCourseCreation,
    currentTargetNumber: currentTargetNumber ?? this.currentTargetNumber,
    usedPegs: usedPegs ?? this.usedPegs,
  );
  FieldSessionMetaData copyWithCompanion(FieldSessionMetaCompanion data) {
    return FieldSessionMetaData(
      sessionId: data.sessionId.present ? data.sessionId.value : this.sessionId,
      courseId: data.courseId.present ? data.courseId.value : this.courseId,
      roundType: data.roundType.present ? data.roundType.value : this.roundType,
      isNewCourseCreation: data.isNewCourseCreation.present
          ? data.isNewCourseCreation.value
          : this.isNewCourseCreation,
      currentTargetNumber: data.currentTargetNumber.present
          ? data.currentTargetNumber.value
          : this.currentTargetNumber,
      usedPegs: data.usedPegs.present ? data.usedPegs.value : this.usedPegs,
    );
  }

  @override
  String toString() {
    return (StringBuffer('FieldSessionMetaData(')
          ..write('sessionId: $sessionId, ')
          ..write('courseId: $courseId, ')
          ..write('roundType: $roundType, ')
          ..write('isNewCourseCreation: $isNewCourseCreation, ')
          ..write('currentTargetNumber: $currentTargetNumber, ')
          ..write('usedPegs: $usedPegs')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    sessionId,
    courseId,
    roundType,
    isNewCourseCreation,
    currentTargetNumber,
    usedPegs,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is FieldSessionMetaData &&
          other.sessionId == this.sessionId &&
          other.courseId == this.courseId &&
          other.roundType == this.roundType &&
          other.isNewCourseCreation == this.isNewCourseCreation &&
          other.currentTargetNumber == this.currentTargetNumber &&
          other.usedPegs == this.usedPegs);
}

class FieldSessionMetaCompanion extends UpdateCompanion<FieldSessionMetaData> {
  final Value<String> sessionId;
  final Value<String?> courseId;
  final Value<String> roundType;
  final Value<bool> isNewCourseCreation;
  final Value<int> currentTargetNumber;
  final Value<String> usedPegs;
  final Value<int> rowid;
  const FieldSessionMetaCompanion({
    this.sessionId = const Value.absent(),
    this.courseId = const Value.absent(),
    this.roundType = const Value.absent(),
    this.isNewCourseCreation = const Value.absent(),
    this.currentTargetNumber = const Value.absent(),
    this.usedPegs = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  FieldSessionMetaCompanion.insert({
    required String sessionId,
    this.courseId = const Value.absent(),
    required String roundType,
    this.isNewCourseCreation = const Value.absent(),
    this.currentTargetNumber = const Value.absent(),
    this.usedPegs = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : sessionId = Value(sessionId),
       roundType = Value(roundType);
  static Insertable<FieldSessionMetaData> custom({
    Expression<String>? sessionId,
    Expression<String>? courseId,
    Expression<String>? roundType,
    Expression<bool>? isNewCourseCreation,
    Expression<int>? currentTargetNumber,
    Expression<String>? usedPegs,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (sessionId != null) 'session_id': sessionId,
      if (courseId != null) 'course_id': courseId,
      if (roundType != null) 'round_type': roundType,
      if (isNewCourseCreation != null)
        'is_new_course_creation': isNewCourseCreation,
      if (currentTargetNumber != null)
        'current_target_number': currentTargetNumber,
      if (usedPegs != null) 'used_pegs': usedPegs,
      if (rowid != null) 'rowid': rowid,
    });
  }

  FieldSessionMetaCompanion copyWith({
    Value<String>? sessionId,
    Value<String?>? courseId,
    Value<String>? roundType,
    Value<bool>? isNewCourseCreation,
    Value<int>? currentTargetNumber,
    Value<String>? usedPegs,
    Value<int>? rowid,
  }) {
    return FieldSessionMetaCompanion(
      sessionId: sessionId ?? this.sessionId,
      courseId: courseId ?? this.courseId,
      roundType: roundType ?? this.roundType,
      isNewCourseCreation: isNewCourseCreation ?? this.isNewCourseCreation,
      currentTargetNumber: currentTargetNumber ?? this.currentTargetNumber,
      usedPegs: usedPegs ?? this.usedPegs,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (sessionId.present) {
      map['session_id'] = Variable<String>(sessionId.value);
    }
    if (courseId.present) {
      map['course_id'] = Variable<String>(courseId.value);
    }
    if (roundType.present) {
      map['round_type'] = Variable<String>(roundType.value);
    }
    if (isNewCourseCreation.present) {
      map['is_new_course_creation'] = Variable<bool>(isNewCourseCreation.value);
    }
    if (currentTargetNumber.present) {
      map['current_target_number'] = Variable<int>(currentTargetNumber.value);
    }
    if (usedPegs.present) {
      map['used_pegs'] = Variable<String>(usedPegs.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('FieldSessionMetaCompanion(')
          ..write('sessionId: $sessionId, ')
          ..write('courseId: $courseId, ')
          ..write('roundType: $roundType, ')
          ..write('isNewCourseCreation: $isNewCourseCreation, ')
          ..write('currentTargetNumber: $currentTargetNumber, ')
          ..write('usedPegs: $usedPegs, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

abstract class _$AppDatabase extends GeneratedDatabase {
  _$AppDatabase(QueryExecutor e) : super(e);
  $AppDatabaseManager get managers => $AppDatabaseManager(this);
  late final $RoundTypesTable roundTypes = $RoundTypesTable(this);
  late final $BowsTable bows = $BowsTable(this);
  late final $QuiversTable quivers = $QuiversTable(this);
  late final $SessionsTable sessions = $SessionsTable(this);
  late final $EndsTable ends = $EndsTable(this);
  late final $ShaftsTable shafts = $ShaftsTable(this);
  late final $ArrowsTable arrows = $ArrowsTable(this);
  late final $ImportedScoresTable importedScores = $ImportedScoresTable(this);
  late final $UserPreferencesTable userPreferences = $UserPreferencesTable(
    this,
  );
  late final $FingerTabsTable fingerTabs = $FingerTabsTable(this);
  late final $StabilizersTable stabilizers = $StabilizersTable(this);
  late final $BowStringsTable bowStrings = $BowStringsTable(this);
  late final $VolumeEntriesTable volumeEntries = $VolumeEntriesTable(this);
  late final $OlyExerciseTypesTable olyExerciseTypes = $OlyExerciseTypesTable(
    this,
  );
  late final $OlySessionTemplatesTable olySessionTemplates =
      $OlySessionTemplatesTable(this);
  late final $OlySessionExercisesTable olySessionExercises =
      $OlySessionExercisesTable(this);
  late final $OlyTrainingLogsTable olyTrainingLogs = $OlyTrainingLogsTable(
    this,
  );
  late final $UserTrainingProgressTable userTrainingProgress =
      $UserTrainingProgressTable(this);
  late final $BreathTrainingLogsTable breathTrainingLogs =
      $BreathTrainingLogsTable(this);
  late final $BreathHoldAwardsTable breathHoldAwards = $BreathHoldAwardsTable(
    this,
  );
  late final $MilestonesTable milestones = $MilestonesTable(this);
  late final $VolumeImportsTable volumeImports = $VolumeImportsTable(this);
  late final $KitSnapshotsTable kitSnapshots = $KitSnapshotsTable(this);
  late final $TuningSessionsTable tuningSessions = $TuningSessionsTable(this);
  late final $SkillLevelsTable skillLevels = $SkillLevelsTable(this);
  late final $XpHistoryTable xpHistory = $XpHistoryTable(this);
  late final $SightMarksTable sightMarks = $SightMarksTable(this);
  late final $SightMarkPreferencesTableTable sightMarkPreferencesTable =
      $SightMarkPreferencesTableTable(this);
  late final $AngleCorrectionProfilesTable angleCorrectionProfiles =
      $AngleCorrectionProfilesTable(this);
  late final $VenuesTable venues = $VenuesTable(this);
  late final $RegisteredTargetsTable registeredTargets =
      $RegisteredTargetsTable(this);
  late final $AutoPlotUsageTable autoPlotUsage = $AutoPlotUsageTable(this);
  late final $UserProfilesTable userProfiles = $UserProfilesTable(this);
  late final $FederationsTable federations = $FederationsTable(this);
  late final $ClassificationsTable classifications = $ClassificationsTable(
    this,
  );
  late final $AchievementsTable achievements = $AchievementsTable(this);
  late final $EntitlementsTable entitlements = $EntitlementsTable(this);
  late final $CourseProgressTable courseProgress = $CourseProgressTable(this);
  late final $PurchasesTable purchases = $PurchasesTable(this);
  late final $SyncQueueTable syncQueue = $SyncQueueTable(this);
  late final $SyncMetadataTable syncMetadata = $SyncMetadataTable(this);
  late final $FieldCoursesTable fieldCourses = $FieldCoursesTable(this);
  late final $FieldCourseTargetsTable fieldCourseTargets =
      $FieldCourseTargetsTable(this);
  late final $FieldCourseSightMarksTable fieldCourseSightMarks =
      $FieldCourseSightMarksTable(this);
  late final $FieldSessionTargetsTable fieldSessionTargets =
      $FieldSessionTargetsTable(this);
  late final $FieldSessionMetaTable fieldSessionMeta = $FieldSessionMetaTable(
    this,
  );
  @override
  Iterable<TableInfo<Table, Object?>> get allTables =>
      allSchemaEntities.whereType<TableInfo<Table, Object?>>();
  @override
  List<DatabaseSchemaEntity> get allSchemaEntities => [
    roundTypes,
    bows,
    quivers,
    sessions,
    ends,
    shafts,
    arrows,
    importedScores,
    userPreferences,
    fingerTabs,
    stabilizers,
    bowStrings,
    volumeEntries,
    olyExerciseTypes,
    olySessionTemplates,
    olySessionExercises,
    olyTrainingLogs,
    userTrainingProgress,
    breathTrainingLogs,
    breathHoldAwards,
    milestones,
    volumeImports,
    kitSnapshots,
    tuningSessions,
    skillLevels,
    xpHistory,
    sightMarks,
    sightMarkPreferencesTable,
    angleCorrectionProfiles,
    venues,
    registeredTargets,
    autoPlotUsage,
    userProfiles,
    federations,
    classifications,
    achievements,
    entitlements,
    courseProgress,
    purchases,
    syncQueue,
    syncMetadata,
    fieldCourses,
    fieldCourseTargets,
    fieldCourseSightMarks,
    fieldSessionTargets,
    fieldSessionMeta,
  ];
}

typedef $$RoundTypesTableCreateCompanionBuilder =
    RoundTypesCompanion Function({
      required String id,
      required String name,
      required String category,
      required int distance,
      required int faceSize,
      required int arrowsPerEnd,
      required int totalEnds,
      required int maxScore,
      required bool isIndoor,
      Value<int> faceCount,
      Value<String> scoringType,
      Value<String?> distanceLegs,
      Value<int> rowid,
    });
typedef $$RoundTypesTableUpdateCompanionBuilder =
    RoundTypesCompanion Function({
      Value<String> id,
      Value<String> name,
      Value<String> category,
      Value<int> distance,
      Value<int> faceSize,
      Value<int> arrowsPerEnd,
      Value<int> totalEnds,
      Value<int> maxScore,
      Value<bool> isIndoor,
      Value<int> faceCount,
      Value<String> scoringType,
      Value<String?> distanceLegs,
      Value<int> rowid,
    });

final class $$RoundTypesTableReferences
    extends BaseReferences<_$AppDatabase, $RoundTypesTable, RoundType> {
  $$RoundTypesTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static MultiTypedResultKey<$SessionsTable, List<Session>> _sessionsRefsTable(
    _$AppDatabase db,
  ) => MultiTypedResultKey.fromTable(
    db.sessions,
    aliasName: $_aliasNameGenerator(db.roundTypes.id, db.sessions.roundTypeId),
  );

  $$SessionsTableProcessedTableManager get sessionsRefs {
    final manager = $$SessionsTableTableManager(
      $_db,
      $_db.sessions,
    ).filter((f) => f.roundTypeId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_sessionsRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$RoundTypesTableFilterComposer
    extends Composer<_$AppDatabase, $RoundTypesTable> {
  $$RoundTypesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get category => $composableBuilder(
    column: $table.category,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get distance => $composableBuilder(
    column: $table.distance,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get faceSize => $composableBuilder(
    column: $table.faceSize,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get arrowsPerEnd => $composableBuilder(
    column: $table.arrowsPerEnd,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get totalEnds => $composableBuilder(
    column: $table.totalEnds,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get maxScore => $composableBuilder(
    column: $table.maxScore,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isIndoor => $composableBuilder(
    column: $table.isIndoor,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get faceCount => $composableBuilder(
    column: $table.faceCount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get scoringType => $composableBuilder(
    column: $table.scoringType,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get distanceLegs => $composableBuilder(
    column: $table.distanceLegs,
    builder: (column) => ColumnFilters(column),
  );

  Expression<bool> sessionsRefs(
    Expression<bool> Function($$SessionsTableFilterComposer f) f,
  ) {
    final $$SessionsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.sessions,
      getReferencedColumn: (t) => t.roundTypeId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SessionsTableFilterComposer(
            $db: $db,
            $table: $db.sessions,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$RoundTypesTableOrderingComposer
    extends Composer<_$AppDatabase, $RoundTypesTable> {
  $$RoundTypesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get category => $composableBuilder(
    column: $table.category,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get distance => $composableBuilder(
    column: $table.distance,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get faceSize => $composableBuilder(
    column: $table.faceSize,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get arrowsPerEnd => $composableBuilder(
    column: $table.arrowsPerEnd,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get totalEnds => $composableBuilder(
    column: $table.totalEnds,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get maxScore => $composableBuilder(
    column: $table.maxScore,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isIndoor => $composableBuilder(
    column: $table.isIndoor,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get faceCount => $composableBuilder(
    column: $table.faceCount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get scoringType => $composableBuilder(
    column: $table.scoringType,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get distanceLegs => $composableBuilder(
    column: $table.distanceLegs,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$RoundTypesTableAnnotationComposer
    extends Composer<_$AppDatabase, $RoundTypesTable> {
  $$RoundTypesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get category =>
      $composableBuilder(column: $table.category, builder: (column) => column);

  GeneratedColumn<int> get distance =>
      $composableBuilder(column: $table.distance, builder: (column) => column);

  GeneratedColumn<int> get faceSize =>
      $composableBuilder(column: $table.faceSize, builder: (column) => column);

  GeneratedColumn<int> get arrowsPerEnd => $composableBuilder(
    column: $table.arrowsPerEnd,
    builder: (column) => column,
  );

  GeneratedColumn<int> get totalEnds =>
      $composableBuilder(column: $table.totalEnds, builder: (column) => column);

  GeneratedColumn<int> get maxScore =>
      $composableBuilder(column: $table.maxScore, builder: (column) => column);

  GeneratedColumn<bool> get isIndoor =>
      $composableBuilder(column: $table.isIndoor, builder: (column) => column);

  GeneratedColumn<int> get faceCount =>
      $composableBuilder(column: $table.faceCount, builder: (column) => column);

  GeneratedColumn<String> get scoringType => $composableBuilder(
    column: $table.scoringType,
    builder: (column) => column,
  );

  GeneratedColumn<String> get distanceLegs => $composableBuilder(
    column: $table.distanceLegs,
    builder: (column) => column,
  );

  Expression<T> sessionsRefs<T extends Object>(
    Expression<T> Function($$SessionsTableAnnotationComposer a) f,
  ) {
    final $$SessionsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.sessions,
      getReferencedColumn: (t) => t.roundTypeId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SessionsTableAnnotationComposer(
            $db: $db,
            $table: $db.sessions,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$RoundTypesTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $RoundTypesTable,
          RoundType,
          $$RoundTypesTableFilterComposer,
          $$RoundTypesTableOrderingComposer,
          $$RoundTypesTableAnnotationComposer,
          $$RoundTypesTableCreateCompanionBuilder,
          $$RoundTypesTableUpdateCompanionBuilder,
          (RoundType, $$RoundTypesTableReferences),
          RoundType,
          PrefetchHooks Function({bool sessionsRefs})
        > {
  $$RoundTypesTableTableManager(_$AppDatabase db, $RoundTypesTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$RoundTypesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$RoundTypesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$RoundTypesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<String> category = const Value.absent(),
                Value<int> distance = const Value.absent(),
                Value<int> faceSize = const Value.absent(),
                Value<int> arrowsPerEnd = const Value.absent(),
                Value<int> totalEnds = const Value.absent(),
                Value<int> maxScore = const Value.absent(),
                Value<bool> isIndoor = const Value.absent(),
                Value<int> faceCount = const Value.absent(),
                Value<String> scoringType = const Value.absent(),
                Value<String?> distanceLegs = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => RoundTypesCompanion(
                id: id,
                name: name,
                category: category,
                distance: distance,
                faceSize: faceSize,
                arrowsPerEnd: arrowsPerEnd,
                totalEnds: totalEnds,
                maxScore: maxScore,
                isIndoor: isIndoor,
                faceCount: faceCount,
                scoringType: scoringType,
                distanceLegs: distanceLegs,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String name,
                required String category,
                required int distance,
                required int faceSize,
                required int arrowsPerEnd,
                required int totalEnds,
                required int maxScore,
                required bool isIndoor,
                Value<int> faceCount = const Value.absent(),
                Value<String> scoringType = const Value.absent(),
                Value<String?> distanceLegs = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => RoundTypesCompanion.insert(
                id: id,
                name: name,
                category: category,
                distance: distance,
                faceSize: faceSize,
                arrowsPerEnd: arrowsPerEnd,
                totalEnds: totalEnds,
                maxScore: maxScore,
                isIndoor: isIndoor,
                faceCount: faceCount,
                scoringType: scoringType,
                distanceLegs: distanceLegs,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$RoundTypesTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback: ({sessionsRefs = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [if (sessionsRefs) db.sessions],
              addJoins: null,
              getPrefetchedDataCallback: (items) async {
                return [
                  if (sessionsRefs)
                    await $_getPrefetchedData<
                      RoundType,
                      $RoundTypesTable,
                      Session
                    >(
                      currentTable: table,
                      referencedTable: $$RoundTypesTableReferences
                          ._sessionsRefsTable(db),
                      managerFromTypedResult: (p0) =>
                          $$RoundTypesTableReferences(
                            db,
                            table,
                            p0,
                          ).sessionsRefs,
                      referencedItemsForCurrentItem: (item, referencedItems) =>
                          referencedItems.where(
                            (e) => e.roundTypeId == item.id,
                          ),
                      typedResults: items,
                    ),
                ];
              },
            );
          },
        ),
      );
}

typedef $$RoundTypesTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $RoundTypesTable,
      RoundType,
      $$RoundTypesTableFilterComposer,
      $$RoundTypesTableOrderingComposer,
      $$RoundTypesTableAnnotationComposer,
      $$RoundTypesTableCreateCompanionBuilder,
      $$RoundTypesTableUpdateCompanionBuilder,
      (RoundType, $$RoundTypesTableReferences),
      RoundType,
      PrefetchHooks Function({bool sessionsRefs})
    >;
typedef $$BowsTableCreateCompanionBuilder =
    BowsCompanion Function({
      required String id,
      required String name,
      required String bowType,
      Value<String?> settings,
      Value<bool> isDefault,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<DateTime?> deletedAt,
      Value<String?> riserModel,
      Value<DateTime?> riserPurchaseDate,
      Value<String?> limbModel,
      Value<DateTime?> limbPurchaseDate,
      Value<double?> poundage,
      Value<double?> drawLength,
      Value<double?> tillerTop,
      Value<double?> tillerBottom,
      Value<double?> braceHeight,
      Value<double?> nockingPointHeight,
      Value<double?> buttonPosition,
      Value<String?> buttonTension,
      Value<double?> clickerPosition,
      Value<double?> eyeToArrowDistance,
      Value<int> rowid,
    });
typedef $$BowsTableUpdateCompanionBuilder =
    BowsCompanion Function({
      Value<String> id,
      Value<String> name,
      Value<String> bowType,
      Value<String?> settings,
      Value<bool> isDefault,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<DateTime?> deletedAt,
      Value<String?> riserModel,
      Value<DateTime?> riserPurchaseDate,
      Value<String?> limbModel,
      Value<DateTime?> limbPurchaseDate,
      Value<double?> poundage,
      Value<double?> drawLength,
      Value<double?> tillerTop,
      Value<double?> tillerBottom,
      Value<double?> braceHeight,
      Value<double?> nockingPointHeight,
      Value<double?> buttonPosition,
      Value<String?> buttonTension,
      Value<double?> clickerPosition,
      Value<double?> eyeToArrowDistance,
      Value<int> rowid,
    });

final class $$BowsTableReferences
    extends BaseReferences<_$AppDatabase, $BowsTable, Bow> {
  $$BowsTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static MultiTypedResultKey<$QuiversTable, List<Quiver>> _quiversRefsTable(
    _$AppDatabase db,
  ) => MultiTypedResultKey.fromTable(
    db.quivers,
    aliasName: $_aliasNameGenerator(db.bows.id, db.quivers.bowId),
  );

  $$QuiversTableProcessedTableManager get quiversRefs {
    final manager = $$QuiversTableTableManager(
      $_db,
      $_db.quivers,
    ).filter((f) => f.bowId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_quiversRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$SessionsTable, List<Session>> _sessionsRefsTable(
    _$AppDatabase db,
  ) => MultiTypedResultKey.fromTable(
    db.sessions,
    aliasName: $_aliasNameGenerator(db.bows.id, db.sessions.bowId),
  );

  $$SessionsTableProcessedTableManager get sessionsRefs {
    final manager = $$SessionsTableTableManager(
      $_db,
      $_db.sessions,
    ).filter((f) => f.bowId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_sessionsRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$StabilizersTable, List<Stabilizer>>
  _stabilizersRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.stabilizers,
    aliasName: $_aliasNameGenerator(db.bows.id, db.stabilizers.bowId),
  );

  $$StabilizersTableProcessedTableManager get stabilizersRefs {
    final manager = $$StabilizersTableTableManager(
      $_db,
      $_db.stabilizers,
    ).filter((f) => f.bowId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_stabilizersRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$BowStringsTable, List<BowString>>
  _bowStringsRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.bowStrings,
    aliasName: $_aliasNameGenerator(db.bows.id, db.bowStrings.bowId),
  );

  $$BowStringsTableProcessedTableManager get bowStringsRefs {
    final manager = $$BowStringsTableTableManager(
      $_db,
      $_db.bowStrings,
    ).filter((f) => f.bowId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_bowStringsRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$TuningSessionsTable, List<TuningSession>>
  _tuningSessionsRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.tuningSessions,
    aliasName: $_aliasNameGenerator(db.bows.id, db.tuningSessions.bowId),
  );

  $$TuningSessionsTableProcessedTableManager get tuningSessionsRefs {
    final manager = $$TuningSessionsTableTableManager(
      $_db,
      $_db.tuningSessions,
    ).filter((f) => f.bowId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_tuningSessionsRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$SightMarksTable, List<SightMark>>
  _sightMarksRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.sightMarks,
    aliasName: $_aliasNameGenerator(db.bows.id, db.sightMarks.bowId),
  );

  $$SightMarksTableProcessedTableManager get sightMarksRefs {
    final manager = $$SightMarksTableTableManager(
      $_db,
      $_db.sightMarks,
    ).filter((f) => f.bowId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_sightMarksRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<
    $SightMarkPreferencesTableTable,
    List<SightMarkPreferencesTableData>
  >
  _sightMarkPreferencesTableRefsTable(_$AppDatabase db) =>
      MultiTypedResultKey.fromTable(
        db.sightMarkPreferencesTable,
        aliasName: $_aliasNameGenerator(
          db.bows.id,
          db.sightMarkPreferencesTable.bowId,
        ),
      );

  $$SightMarkPreferencesTableTableProcessedTableManager
  get sightMarkPreferencesTableRefs {
    final manager = $$SightMarkPreferencesTableTableTableManager(
      $_db,
      $_db.sightMarkPreferencesTable,
    ).filter((f) => f.bowId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(
      _sightMarkPreferencesTableRefsTable($_db),
    );
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<
    $AngleCorrectionProfilesTable,
    List<AngleCorrectionProfile>
  >
  _angleCorrectionProfilesRefsTable(_$AppDatabase db) =>
      MultiTypedResultKey.fromTable(
        db.angleCorrectionProfiles,
        aliasName: $_aliasNameGenerator(
          db.bows.id,
          db.angleCorrectionProfiles.bowId,
        ),
      );

  $$AngleCorrectionProfilesTableProcessedTableManager
  get angleCorrectionProfilesRefs {
    final manager = $$AngleCorrectionProfilesTableTableManager(
      $_db,
      $_db.angleCorrectionProfiles,
    ).filter((f) => f.bowId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(
      _angleCorrectionProfilesRefsTable($_db),
    );
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<
    $FieldCourseSightMarksTable,
    List<FieldCourseSightMark>
  >
  _fieldCourseSightMarksRefsTable(_$AppDatabase db) =>
      MultiTypedResultKey.fromTable(
        db.fieldCourseSightMarks,
        aliasName: $_aliasNameGenerator(
          db.bows.id,
          db.fieldCourseSightMarks.bowId,
        ),
      );

  $$FieldCourseSightMarksTableProcessedTableManager
  get fieldCourseSightMarksRefs {
    final manager = $$FieldCourseSightMarksTableTableManager(
      $_db,
      $_db.fieldCourseSightMarks,
    ).filter((f) => f.bowId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(
      _fieldCourseSightMarksRefsTable($_db),
    );
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$BowsTableFilterComposer extends Composer<_$AppDatabase, $BowsTable> {
  $$BowsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get bowType => $composableBuilder(
    column: $table.bowType,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get settings => $composableBuilder(
    column: $table.settings,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isDefault => $composableBuilder(
    column: $table.isDefault,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get deletedAt => $composableBuilder(
    column: $table.deletedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get riserModel => $composableBuilder(
    column: $table.riserModel,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get riserPurchaseDate => $composableBuilder(
    column: $table.riserPurchaseDate,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get limbModel => $composableBuilder(
    column: $table.limbModel,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get limbPurchaseDate => $composableBuilder(
    column: $table.limbPurchaseDate,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get poundage => $composableBuilder(
    column: $table.poundage,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get drawLength => $composableBuilder(
    column: $table.drawLength,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get tillerTop => $composableBuilder(
    column: $table.tillerTop,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get tillerBottom => $composableBuilder(
    column: $table.tillerBottom,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get braceHeight => $composableBuilder(
    column: $table.braceHeight,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get nockingPointHeight => $composableBuilder(
    column: $table.nockingPointHeight,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get buttonPosition => $composableBuilder(
    column: $table.buttonPosition,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get buttonTension => $composableBuilder(
    column: $table.buttonTension,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get clickerPosition => $composableBuilder(
    column: $table.clickerPosition,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get eyeToArrowDistance => $composableBuilder(
    column: $table.eyeToArrowDistance,
    builder: (column) => ColumnFilters(column),
  );

  Expression<bool> quiversRefs(
    Expression<bool> Function($$QuiversTableFilterComposer f) f,
  ) {
    final $$QuiversTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.quivers,
      getReferencedColumn: (t) => t.bowId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$QuiversTableFilterComposer(
            $db: $db,
            $table: $db.quivers,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> sessionsRefs(
    Expression<bool> Function($$SessionsTableFilterComposer f) f,
  ) {
    final $$SessionsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.sessions,
      getReferencedColumn: (t) => t.bowId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SessionsTableFilterComposer(
            $db: $db,
            $table: $db.sessions,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> stabilizersRefs(
    Expression<bool> Function($$StabilizersTableFilterComposer f) f,
  ) {
    final $$StabilizersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.stabilizers,
      getReferencedColumn: (t) => t.bowId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$StabilizersTableFilterComposer(
            $db: $db,
            $table: $db.stabilizers,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> bowStringsRefs(
    Expression<bool> Function($$BowStringsTableFilterComposer f) f,
  ) {
    final $$BowStringsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.bowStrings,
      getReferencedColumn: (t) => t.bowId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$BowStringsTableFilterComposer(
            $db: $db,
            $table: $db.bowStrings,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> tuningSessionsRefs(
    Expression<bool> Function($$TuningSessionsTableFilterComposer f) f,
  ) {
    final $$TuningSessionsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.tuningSessions,
      getReferencedColumn: (t) => t.bowId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$TuningSessionsTableFilterComposer(
            $db: $db,
            $table: $db.tuningSessions,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> sightMarksRefs(
    Expression<bool> Function($$SightMarksTableFilterComposer f) f,
  ) {
    final $$SightMarksTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.sightMarks,
      getReferencedColumn: (t) => t.bowId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SightMarksTableFilterComposer(
            $db: $db,
            $table: $db.sightMarks,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> sightMarkPreferencesTableRefs(
    Expression<bool> Function($$SightMarkPreferencesTableTableFilterComposer f)
    f,
  ) {
    final $$SightMarkPreferencesTableTableFilterComposer composer =
        $composerBuilder(
          composer: this,
          getCurrentColumn: (t) => t.id,
          referencedTable: $db.sightMarkPreferencesTable,
          getReferencedColumn: (t) => t.bowId,
          builder:
              (
                joinBuilder, {
                $addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer,
              }) => $$SightMarkPreferencesTableTableFilterComposer(
                $db: $db,
                $table: $db.sightMarkPreferencesTable,
                $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                joinBuilder: joinBuilder,
                $removeJoinBuilderFromRootComposer:
                    $removeJoinBuilderFromRootComposer,
              ),
        );
    return f(composer);
  }

  Expression<bool> angleCorrectionProfilesRefs(
    Expression<bool> Function($$AngleCorrectionProfilesTableFilterComposer f) f,
  ) {
    final $$AngleCorrectionProfilesTableFilterComposer composer =
        $composerBuilder(
          composer: this,
          getCurrentColumn: (t) => t.id,
          referencedTable: $db.angleCorrectionProfiles,
          getReferencedColumn: (t) => t.bowId,
          builder:
              (
                joinBuilder, {
                $addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer,
              }) => $$AngleCorrectionProfilesTableFilterComposer(
                $db: $db,
                $table: $db.angleCorrectionProfiles,
                $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                joinBuilder: joinBuilder,
                $removeJoinBuilderFromRootComposer:
                    $removeJoinBuilderFromRootComposer,
              ),
        );
    return f(composer);
  }

  Expression<bool> fieldCourseSightMarksRefs(
    Expression<bool> Function($$FieldCourseSightMarksTableFilterComposer f) f,
  ) {
    final $$FieldCourseSightMarksTableFilterComposer composer =
        $composerBuilder(
          composer: this,
          getCurrentColumn: (t) => t.id,
          referencedTable: $db.fieldCourseSightMarks,
          getReferencedColumn: (t) => t.bowId,
          builder:
              (
                joinBuilder, {
                $addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer,
              }) => $$FieldCourseSightMarksTableFilterComposer(
                $db: $db,
                $table: $db.fieldCourseSightMarks,
                $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                joinBuilder: joinBuilder,
                $removeJoinBuilderFromRootComposer:
                    $removeJoinBuilderFromRootComposer,
              ),
        );
    return f(composer);
  }
}

class $$BowsTableOrderingComposer extends Composer<_$AppDatabase, $BowsTable> {
  $$BowsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get bowType => $composableBuilder(
    column: $table.bowType,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get settings => $composableBuilder(
    column: $table.settings,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isDefault => $composableBuilder(
    column: $table.isDefault,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get deletedAt => $composableBuilder(
    column: $table.deletedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get riserModel => $composableBuilder(
    column: $table.riserModel,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get riserPurchaseDate => $composableBuilder(
    column: $table.riserPurchaseDate,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get limbModel => $composableBuilder(
    column: $table.limbModel,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get limbPurchaseDate => $composableBuilder(
    column: $table.limbPurchaseDate,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get poundage => $composableBuilder(
    column: $table.poundage,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get drawLength => $composableBuilder(
    column: $table.drawLength,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get tillerTop => $composableBuilder(
    column: $table.tillerTop,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get tillerBottom => $composableBuilder(
    column: $table.tillerBottom,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get braceHeight => $composableBuilder(
    column: $table.braceHeight,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get nockingPointHeight => $composableBuilder(
    column: $table.nockingPointHeight,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get buttonPosition => $composableBuilder(
    column: $table.buttonPosition,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get buttonTension => $composableBuilder(
    column: $table.buttonTension,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get clickerPosition => $composableBuilder(
    column: $table.clickerPosition,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get eyeToArrowDistance => $composableBuilder(
    column: $table.eyeToArrowDistance,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$BowsTableAnnotationComposer
    extends Composer<_$AppDatabase, $BowsTable> {
  $$BowsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get bowType =>
      $composableBuilder(column: $table.bowType, builder: (column) => column);

  GeneratedColumn<String> get settings =>
      $composableBuilder(column: $table.settings, builder: (column) => column);

  GeneratedColumn<bool> get isDefault =>
      $composableBuilder(column: $table.isDefault, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  GeneratedColumn<DateTime> get deletedAt =>
      $composableBuilder(column: $table.deletedAt, builder: (column) => column);

  GeneratedColumn<String> get riserModel => $composableBuilder(
    column: $table.riserModel,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get riserPurchaseDate => $composableBuilder(
    column: $table.riserPurchaseDate,
    builder: (column) => column,
  );

  GeneratedColumn<String> get limbModel =>
      $composableBuilder(column: $table.limbModel, builder: (column) => column);

  GeneratedColumn<DateTime> get limbPurchaseDate => $composableBuilder(
    column: $table.limbPurchaseDate,
    builder: (column) => column,
  );

  GeneratedColumn<double> get poundage =>
      $composableBuilder(column: $table.poundage, builder: (column) => column);

  GeneratedColumn<double> get drawLength => $composableBuilder(
    column: $table.drawLength,
    builder: (column) => column,
  );

  GeneratedColumn<double> get tillerTop =>
      $composableBuilder(column: $table.tillerTop, builder: (column) => column);

  GeneratedColumn<double> get tillerBottom => $composableBuilder(
    column: $table.tillerBottom,
    builder: (column) => column,
  );

  GeneratedColumn<double> get braceHeight => $composableBuilder(
    column: $table.braceHeight,
    builder: (column) => column,
  );

  GeneratedColumn<double> get nockingPointHeight => $composableBuilder(
    column: $table.nockingPointHeight,
    builder: (column) => column,
  );

  GeneratedColumn<double> get buttonPosition => $composableBuilder(
    column: $table.buttonPosition,
    builder: (column) => column,
  );

  GeneratedColumn<String> get buttonTension => $composableBuilder(
    column: $table.buttonTension,
    builder: (column) => column,
  );

  GeneratedColumn<double> get clickerPosition => $composableBuilder(
    column: $table.clickerPosition,
    builder: (column) => column,
  );

  GeneratedColumn<double> get eyeToArrowDistance => $composableBuilder(
    column: $table.eyeToArrowDistance,
    builder: (column) => column,
  );

  Expression<T> quiversRefs<T extends Object>(
    Expression<T> Function($$QuiversTableAnnotationComposer a) f,
  ) {
    final $$QuiversTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.quivers,
      getReferencedColumn: (t) => t.bowId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$QuiversTableAnnotationComposer(
            $db: $db,
            $table: $db.quivers,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> sessionsRefs<T extends Object>(
    Expression<T> Function($$SessionsTableAnnotationComposer a) f,
  ) {
    final $$SessionsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.sessions,
      getReferencedColumn: (t) => t.bowId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SessionsTableAnnotationComposer(
            $db: $db,
            $table: $db.sessions,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> stabilizersRefs<T extends Object>(
    Expression<T> Function($$StabilizersTableAnnotationComposer a) f,
  ) {
    final $$StabilizersTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.stabilizers,
      getReferencedColumn: (t) => t.bowId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$StabilizersTableAnnotationComposer(
            $db: $db,
            $table: $db.stabilizers,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> bowStringsRefs<T extends Object>(
    Expression<T> Function($$BowStringsTableAnnotationComposer a) f,
  ) {
    final $$BowStringsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.bowStrings,
      getReferencedColumn: (t) => t.bowId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$BowStringsTableAnnotationComposer(
            $db: $db,
            $table: $db.bowStrings,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> tuningSessionsRefs<T extends Object>(
    Expression<T> Function($$TuningSessionsTableAnnotationComposer a) f,
  ) {
    final $$TuningSessionsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.tuningSessions,
      getReferencedColumn: (t) => t.bowId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$TuningSessionsTableAnnotationComposer(
            $db: $db,
            $table: $db.tuningSessions,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> sightMarksRefs<T extends Object>(
    Expression<T> Function($$SightMarksTableAnnotationComposer a) f,
  ) {
    final $$SightMarksTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.sightMarks,
      getReferencedColumn: (t) => t.bowId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SightMarksTableAnnotationComposer(
            $db: $db,
            $table: $db.sightMarks,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> sightMarkPreferencesTableRefs<T extends Object>(
    Expression<T> Function($$SightMarkPreferencesTableTableAnnotationComposer a)
    f,
  ) {
    final $$SightMarkPreferencesTableTableAnnotationComposer composer =
        $composerBuilder(
          composer: this,
          getCurrentColumn: (t) => t.id,
          referencedTable: $db.sightMarkPreferencesTable,
          getReferencedColumn: (t) => t.bowId,
          builder:
              (
                joinBuilder, {
                $addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer,
              }) => $$SightMarkPreferencesTableTableAnnotationComposer(
                $db: $db,
                $table: $db.sightMarkPreferencesTable,
                $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                joinBuilder: joinBuilder,
                $removeJoinBuilderFromRootComposer:
                    $removeJoinBuilderFromRootComposer,
              ),
        );
    return f(composer);
  }

  Expression<T> angleCorrectionProfilesRefs<T extends Object>(
    Expression<T> Function($$AngleCorrectionProfilesTableAnnotationComposer a)
    f,
  ) {
    final $$AngleCorrectionProfilesTableAnnotationComposer composer =
        $composerBuilder(
          composer: this,
          getCurrentColumn: (t) => t.id,
          referencedTable: $db.angleCorrectionProfiles,
          getReferencedColumn: (t) => t.bowId,
          builder:
              (
                joinBuilder, {
                $addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer,
              }) => $$AngleCorrectionProfilesTableAnnotationComposer(
                $db: $db,
                $table: $db.angleCorrectionProfiles,
                $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                joinBuilder: joinBuilder,
                $removeJoinBuilderFromRootComposer:
                    $removeJoinBuilderFromRootComposer,
              ),
        );
    return f(composer);
  }

  Expression<T> fieldCourseSightMarksRefs<T extends Object>(
    Expression<T> Function($$FieldCourseSightMarksTableAnnotationComposer a) f,
  ) {
    final $$FieldCourseSightMarksTableAnnotationComposer composer =
        $composerBuilder(
          composer: this,
          getCurrentColumn: (t) => t.id,
          referencedTable: $db.fieldCourseSightMarks,
          getReferencedColumn: (t) => t.bowId,
          builder:
              (
                joinBuilder, {
                $addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer,
              }) => $$FieldCourseSightMarksTableAnnotationComposer(
                $db: $db,
                $table: $db.fieldCourseSightMarks,
                $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                joinBuilder: joinBuilder,
                $removeJoinBuilderFromRootComposer:
                    $removeJoinBuilderFromRootComposer,
              ),
        );
    return f(composer);
  }
}

class $$BowsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $BowsTable,
          Bow,
          $$BowsTableFilterComposer,
          $$BowsTableOrderingComposer,
          $$BowsTableAnnotationComposer,
          $$BowsTableCreateCompanionBuilder,
          $$BowsTableUpdateCompanionBuilder,
          (Bow, $$BowsTableReferences),
          Bow,
          PrefetchHooks Function({
            bool quiversRefs,
            bool sessionsRefs,
            bool stabilizersRefs,
            bool bowStringsRefs,
            bool tuningSessionsRefs,
            bool sightMarksRefs,
            bool sightMarkPreferencesTableRefs,
            bool angleCorrectionProfilesRefs,
            bool fieldCourseSightMarksRefs,
          })
        > {
  $$BowsTableTableManager(_$AppDatabase db, $BowsTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$BowsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$BowsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$BowsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<String> bowType = const Value.absent(),
                Value<String?> settings = const Value.absent(),
                Value<bool> isDefault = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<DateTime?> deletedAt = const Value.absent(),
                Value<String?> riserModel = const Value.absent(),
                Value<DateTime?> riserPurchaseDate = const Value.absent(),
                Value<String?> limbModel = const Value.absent(),
                Value<DateTime?> limbPurchaseDate = const Value.absent(),
                Value<double?> poundage = const Value.absent(),
                Value<double?> drawLength = const Value.absent(),
                Value<double?> tillerTop = const Value.absent(),
                Value<double?> tillerBottom = const Value.absent(),
                Value<double?> braceHeight = const Value.absent(),
                Value<double?> nockingPointHeight = const Value.absent(),
                Value<double?> buttonPosition = const Value.absent(),
                Value<String?> buttonTension = const Value.absent(),
                Value<double?> clickerPosition = const Value.absent(),
                Value<double?> eyeToArrowDistance = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => BowsCompanion(
                id: id,
                name: name,
                bowType: bowType,
                settings: settings,
                isDefault: isDefault,
                createdAt: createdAt,
                updatedAt: updatedAt,
                deletedAt: deletedAt,
                riserModel: riserModel,
                riserPurchaseDate: riserPurchaseDate,
                limbModel: limbModel,
                limbPurchaseDate: limbPurchaseDate,
                poundage: poundage,
                drawLength: drawLength,
                tillerTop: tillerTop,
                tillerBottom: tillerBottom,
                braceHeight: braceHeight,
                nockingPointHeight: nockingPointHeight,
                buttonPosition: buttonPosition,
                buttonTension: buttonTension,
                clickerPosition: clickerPosition,
                eyeToArrowDistance: eyeToArrowDistance,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String name,
                required String bowType,
                Value<String?> settings = const Value.absent(),
                Value<bool> isDefault = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<DateTime?> deletedAt = const Value.absent(),
                Value<String?> riserModel = const Value.absent(),
                Value<DateTime?> riserPurchaseDate = const Value.absent(),
                Value<String?> limbModel = const Value.absent(),
                Value<DateTime?> limbPurchaseDate = const Value.absent(),
                Value<double?> poundage = const Value.absent(),
                Value<double?> drawLength = const Value.absent(),
                Value<double?> tillerTop = const Value.absent(),
                Value<double?> tillerBottom = const Value.absent(),
                Value<double?> braceHeight = const Value.absent(),
                Value<double?> nockingPointHeight = const Value.absent(),
                Value<double?> buttonPosition = const Value.absent(),
                Value<String?> buttonTension = const Value.absent(),
                Value<double?> clickerPosition = const Value.absent(),
                Value<double?> eyeToArrowDistance = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => BowsCompanion.insert(
                id: id,
                name: name,
                bowType: bowType,
                settings: settings,
                isDefault: isDefault,
                createdAt: createdAt,
                updatedAt: updatedAt,
                deletedAt: deletedAt,
                riserModel: riserModel,
                riserPurchaseDate: riserPurchaseDate,
                limbModel: limbModel,
                limbPurchaseDate: limbPurchaseDate,
                poundage: poundage,
                drawLength: drawLength,
                tillerTop: tillerTop,
                tillerBottom: tillerBottom,
                braceHeight: braceHeight,
                nockingPointHeight: nockingPointHeight,
                buttonPosition: buttonPosition,
                buttonTension: buttonTension,
                clickerPosition: clickerPosition,
                eyeToArrowDistance: eyeToArrowDistance,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) =>
                    (e.readTable(table), $$BowsTableReferences(db, table, e)),
              )
              .toList(),
          prefetchHooksCallback:
              ({
                quiversRefs = false,
                sessionsRefs = false,
                stabilizersRefs = false,
                bowStringsRefs = false,
                tuningSessionsRefs = false,
                sightMarksRefs = false,
                sightMarkPreferencesTableRefs = false,
                angleCorrectionProfilesRefs = false,
                fieldCourseSightMarksRefs = false,
              }) {
                return PrefetchHooks(
                  db: db,
                  explicitlyWatchedTables: [
                    if (quiversRefs) db.quivers,
                    if (sessionsRefs) db.sessions,
                    if (stabilizersRefs) db.stabilizers,
                    if (bowStringsRefs) db.bowStrings,
                    if (tuningSessionsRefs) db.tuningSessions,
                    if (sightMarksRefs) db.sightMarks,
                    if (sightMarkPreferencesTableRefs)
                      db.sightMarkPreferencesTable,
                    if (angleCorrectionProfilesRefs) db.angleCorrectionProfiles,
                    if (fieldCourseSightMarksRefs) db.fieldCourseSightMarks,
                  ],
                  addJoins: null,
                  getPrefetchedDataCallback: (items) async {
                    return [
                      if (quiversRefs)
                        await $_getPrefetchedData<Bow, $BowsTable, Quiver>(
                          currentTable: table,
                          referencedTable: $$BowsTableReferences
                              ._quiversRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$BowsTableReferences(db, table, p0).quiversRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.bowId == item.id,
                              ),
                          typedResults: items,
                        ),
                      if (sessionsRefs)
                        await $_getPrefetchedData<Bow, $BowsTable, Session>(
                          currentTable: table,
                          referencedTable: $$BowsTableReferences
                              ._sessionsRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$BowsTableReferences(db, table, p0).sessionsRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.bowId == item.id,
                              ),
                          typedResults: items,
                        ),
                      if (stabilizersRefs)
                        await $_getPrefetchedData<Bow, $BowsTable, Stabilizer>(
                          currentTable: table,
                          referencedTable: $$BowsTableReferences
                              ._stabilizersRefsTable(db),
                          managerFromTypedResult: (p0) => $$BowsTableReferences(
                            db,
                            table,
                            p0,
                          ).stabilizersRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.bowId == item.id,
                              ),
                          typedResults: items,
                        ),
                      if (bowStringsRefs)
                        await $_getPrefetchedData<Bow, $BowsTable, BowString>(
                          currentTable: table,
                          referencedTable: $$BowsTableReferences
                              ._bowStringsRefsTable(db),
                          managerFromTypedResult: (p0) => $$BowsTableReferences(
                            db,
                            table,
                            p0,
                          ).bowStringsRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.bowId == item.id,
                              ),
                          typedResults: items,
                        ),
                      if (tuningSessionsRefs)
                        await $_getPrefetchedData<
                          Bow,
                          $BowsTable,
                          TuningSession
                        >(
                          currentTable: table,
                          referencedTable: $$BowsTableReferences
                              ._tuningSessionsRefsTable(db),
                          managerFromTypedResult: (p0) => $$BowsTableReferences(
                            db,
                            table,
                            p0,
                          ).tuningSessionsRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.bowId == item.id,
                              ),
                          typedResults: items,
                        ),
                      if (sightMarksRefs)
                        await $_getPrefetchedData<Bow, $BowsTable, SightMark>(
                          currentTable: table,
                          referencedTable: $$BowsTableReferences
                              ._sightMarksRefsTable(db),
                          managerFromTypedResult: (p0) => $$BowsTableReferences(
                            db,
                            table,
                            p0,
                          ).sightMarksRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.bowId == item.id,
                              ),
                          typedResults: items,
                        ),
                      if (sightMarkPreferencesTableRefs)
                        await $_getPrefetchedData<
                          Bow,
                          $BowsTable,
                          SightMarkPreferencesTableData
                        >(
                          currentTable: table,
                          referencedTable: $$BowsTableReferences
                              ._sightMarkPreferencesTableRefsTable(db),
                          managerFromTypedResult: (p0) => $$BowsTableReferences(
                            db,
                            table,
                            p0,
                          ).sightMarkPreferencesTableRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.bowId == item.id,
                              ),
                          typedResults: items,
                        ),
                      if (angleCorrectionProfilesRefs)
                        await $_getPrefetchedData<
                          Bow,
                          $BowsTable,
                          AngleCorrectionProfile
                        >(
                          currentTable: table,
                          referencedTable: $$BowsTableReferences
                              ._angleCorrectionProfilesRefsTable(db),
                          managerFromTypedResult: (p0) => $$BowsTableReferences(
                            db,
                            table,
                            p0,
                          ).angleCorrectionProfilesRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.bowId == item.id,
                              ),
                          typedResults: items,
                        ),
                      if (fieldCourseSightMarksRefs)
                        await $_getPrefetchedData<
                          Bow,
                          $BowsTable,
                          FieldCourseSightMark
                        >(
                          currentTable: table,
                          referencedTable: $$BowsTableReferences
                              ._fieldCourseSightMarksRefsTable(db),
                          managerFromTypedResult: (p0) => $$BowsTableReferences(
                            db,
                            table,
                            p0,
                          ).fieldCourseSightMarksRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.bowId == item.id,
                              ),
                          typedResults: items,
                        ),
                    ];
                  },
                );
              },
        ),
      );
}

typedef $$BowsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $BowsTable,
      Bow,
      $$BowsTableFilterComposer,
      $$BowsTableOrderingComposer,
      $$BowsTableAnnotationComposer,
      $$BowsTableCreateCompanionBuilder,
      $$BowsTableUpdateCompanionBuilder,
      (Bow, $$BowsTableReferences),
      Bow,
      PrefetchHooks Function({
        bool quiversRefs,
        bool sessionsRefs,
        bool stabilizersRefs,
        bool bowStringsRefs,
        bool tuningSessionsRefs,
        bool sightMarksRefs,
        bool sightMarkPreferencesTableRefs,
        bool angleCorrectionProfilesRefs,
        bool fieldCourseSightMarksRefs,
      })
    >;
typedef $$QuiversTableCreateCompanionBuilder =
    QuiversCompanion Function({
      required String id,
      Value<String?> bowId,
      required String name,
      Value<int> shaftCount,
      Value<String?> settings,
      Value<bool> isDefault,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<DateTime?> deletedAt,
      Value<int> rowid,
    });
typedef $$QuiversTableUpdateCompanionBuilder =
    QuiversCompanion Function({
      Value<String> id,
      Value<String?> bowId,
      Value<String> name,
      Value<int> shaftCount,
      Value<String?> settings,
      Value<bool> isDefault,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<DateTime?> deletedAt,
      Value<int> rowid,
    });

final class $$QuiversTableReferences
    extends BaseReferences<_$AppDatabase, $QuiversTable, Quiver> {
  $$QuiversTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $BowsTable _bowIdTable(_$AppDatabase db) =>
      db.bows.createAlias($_aliasNameGenerator(db.quivers.bowId, db.bows.id));

  $$BowsTableProcessedTableManager? get bowId {
    final $_column = $_itemColumn<String>('bow_id');
    if ($_column == null) return null;
    final manager = $$BowsTableTableManager(
      $_db,
      $_db.bows,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_bowIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static MultiTypedResultKey<$SessionsTable, List<Session>> _sessionsRefsTable(
    _$AppDatabase db,
  ) => MultiTypedResultKey.fromTable(
    db.sessions,
    aliasName: $_aliasNameGenerator(db.quivers.id, db.sessions.quiverId),
  );

  $$SessionsTableProcessedTableManager get sessionsRefs {
    final manager = $$SessionsTableTableManager(
      $_db,
      $_db.sessions,
    ).filter((f) => f.quiverId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_sessionsRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$ShaftsTable, List<Shaft>> _shaftsRefsTable(
    _$AppDatabase db,
  ) => MultiTypedResultKey.fromTable(
    db.shafts,
    aliasName: $_aliasNameGenerator(db.quivers.id, db.shafts.quiverId),
  );

  $$ShaftsTableProcessedTableManager get shaftsRefs {
    final manager = $$ShaftsTableTableManager(
      $_db,
      $_db.shafts,
    ).filter((f) => f.quiverId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_shaftsRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$QuiversTableFilterComposer
    extends Composer<_$AppDatabase, $QuiversTable> {
  $$QuiversTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get shaftCount => $composableBuilder(
    column: $table.shaftCount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get settings => $composableBuilder(
    column: $table.settings,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isDefault => $composableBuilder(
    column: $table.isDefault,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get deletedAt => $composableBuilder(
    column: $table.deletedAt,
    builder: (column) => ColumnFilters(column),
  );

  $$BowsTableFilterComposer get bowId {
    final $$BowsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.bowId,
      referencedTable: $db.bows,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$BowsTableFilterComposer(
            $db: $db,
            $table: $db.bows,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<bool> sessionsRefs(
    Expression<bool> Function($$SessionsTableFilterComposer f) f,
  ) {
    final $$SessionsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.sessions,
      getReferencedColumn: (t) => t.quiverId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SessionsTableFilterComposer(
            $db: $db,
            $table: $db.sessions,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> shaftsRefs(
    Expression<bool> Function($$ShaftsTableFilterComposer f) f,
  ) {
    final $$ShaftsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.shafts,
      getReferencedColumn: (t) => t.quiverId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ShaftsTableFilterComposer(
            $db: $db,
            $table: $db.shafts,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$QuiversTableOrderingComposer
    extends Composer<_$AppDatabase, $QuiversTable> {
  $$QuiversTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get shaftCount => $composableBuilder(
    column: $table.shaftCount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get settings => $composableBuilder(
    column: $table.settings,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isDefault => $composableBuilder(
    column: $table.isDefault,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get deletedAt => $composableBuilder(
    column: $table.deletedAt,
    builder: (column) => ColumnOrderings(column),
  );

  $$BowsTableOrderingComposer get bowId {
    final $$BowsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.bowId,
      referencedTable: $db.bows,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$BowsTableOrderingComposer(
            $db: $db,
            $table: $db.bows,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$QuiversTableAnnotationComposer
    extends Composer<_$AppDatabase, $QuiversTable> {
  $$QuiversTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<int> get shaftCount => $composableBuilder(
    column: $table.shaftCount,
    builder: (column) => column,
  );

  GeneratedColumn<String> get settings =>
      $composableBuilder(column: $table.settings, builder: (column) => column);

  GeneratedColumn<bool> get isDefault =>
      $composableBuilder(column: $table.isDefault, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  GeneratedColumn<DateTime> get deletedAt =>
      $composableBuilder(column: $table.deletedAt, builder: (column) => column);

  $$BowsTableAnnotationComposer get bowId {
    final $$BowsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.bowId,
      referencedTable: $db.bows,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$BowsTableAnnotationComposer(
            $db: $db,
            $table: $db.bows,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<T> sessionsRefs<T extends Object>(
    Expression<T> Function($$SessionsTableAnnotationComposer a) f,
  ) {
    final $$SessionsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.sessions,
      getReferencedColumn: (t) => t.quiverId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SessionsTableAnnotationComposer(
            $db: $db,
            $table: $db.sessions,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> shaftsRefs<T extends Object>(
    Expression<T> Function($$ShaftsTableAnnotationComposer a) f,
  ) {
    final $$ShaftsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.shafts,
      getReferencedColumn: (t) => t.quiverId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ShaftsTableAnnotationComposer(
            $db: $db,
            $table: $db.shafts,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$QuiversTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $QuiversTable,
          Quiver,
          $$QuiversTableFilterComposer,
          $$QuiversTableOrderingComposer,
          $$QuiversTableAnnotationComposer,
          $$QuiversTableCreateCompanionBuilder,
          $$QuiversTableUpdateCompanionBuilder,
          (Quiver, $$QuiversTableReferences),
          Quiver,
          PrefetchHooks Function({
            bool bowId,
            bool sessionsRefs,
            bool shaftsRefs,
          })
        > {
  $$QuiversTableTableManager(_$AppDatabase db, $QuiversTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$QuiversTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$QuiversTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$QuiversTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String?> bowId = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<int> shaftCount = const Value.absent(),
                Value<String?> settings = const Value.absent(),
                Value<bool> isDefault = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<DateTime?> deletedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => QuiversCompanion(
                id: id,
                bowId: bowId,
                name: name,
                shaftCount: shaftCount,
                settings: settings,
                isDefault: isDefault,
                createdAt: createdAt,
                updatedAt: updatedAt,
                deletedAt: deletedAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                Value<String?> bowId = const Value.absent(),
                required String name,
                Value<int> shaftCount = const Value.absent(),
                Value<String?> settings = const Value.absent(),
                Value<bool> isDefault = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<DateTime?> deletedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => QuiversCompanion.insert(
                id: id,
                bowId: bowId,
                name: name,
                shaftCount: shaftCount,
                settings: settings,
                isDefault: isDefault,
                createdAt: createdAt,
                updatedAt: updatedAt,
                deletedAt: deletedAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$QuiversTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback:
              ({bowId = false, sessionsRefs = false, shaftsRefs = false}) {
                return PrefetchHooks(
                  db: db,
                  explicitlyWatchedTables: [
                    if (sessionsRefs) db.sessions,
                    if (shaftsRefs) db.shafts,
                  ],
                  addJoins:
                      <
                        T extends TableManagerState<
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic
                        >
                      >(state) {
                        if (bowId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.bowId,
                                    referencedTable: $$QuiversTableReferences
                                        ._bowIdTable(db),
                                    referencedColumn: $$QuiversTableReferences
                                        ._bowIdTable(db)
                                        .id,
                                  )
                                  as T;
                        }

                        return state;
                      },
                  getPrefetchedDataCallback: (items) async {
                    return [
                      if (sessionsRefs)
                        await $_getPrefetchedData<
                          Quiver,
                          $QuiversTable,
                          Session
                        >(
                          currentTable: table,
                          referencedTable: $$QuiversTableReferences
                              ._sessionsRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$QuiversTableReferences(
                                db,
                                table,
                                p0,
                              ).sessionsRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.quiverId == item.id,
                              ),
                          typedResults: items,
                        ),
                      if (shaftsRefs)
                        await $_getPrefetchedData<Quiver, $QuiversTable, Shaft>(
                          currentTable: table,
                          referencedTable: $$QuiversTableReferences
                              ._shaftsRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$QuiversTableReferences(
                                db,
                                table,
                                p0,
                              ).shaftsRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.quiverId == item.id,
                              ),
                          typedResults: items,
                        ),
                    ];
                  },
                );
              },
        ),
      );
}

typedef $$QuiversTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $QuiversTable,
      Quiver,
      $$QuiversTableFilterComposer,
      $$QuiversTableOrderingComposer,
      $$QuiversTableAnnotationComposer,
      $$QuiversTableCreateCompanionBuilder,
      $$QuiversTableUpdateCompanionBuilder,
      (Quiver, $$QuiversTableReferences),
      Quiver,
      PrefetchHooks Function({bool bowId, bool sessionsRefs, bool shaftsRefs})
    >;
typedef $$SessionsTableCreateCompanionBuilder =
    SessionsCompanion Function({
      required String id,
      required String roundTypeId,
      Value<String> sessionType,
      Value<String?> title,
      Value<String?> locationName,
      Value<String?> location,
      Value<double?> latitude,
      Value<double?> longitude,
      Value<String?> notes,
      Value<DateTime> startedAt,
      Value<DateTime?> completedAt,
      Value<int> totalScore,
      Value<int> totalXs,
      Value<String?> bowId,
      Value<String?> quiverId,
      Value<bool> shaftTaggingEnabled,
      Value<DateTime?> deletedAt,
      Value<int> rowid,
    });
typedef $$SessionsTableUpdateCompanionBuilder =
    SessionsCompanion Function({
      Value<String> id,
      Value<String> roundTypeId,
      Value<String> sessionType,
      Value<String?> title,
      Value<String?> locationName,
      Value<String?> location,
      Value<double?> latitude,
      Value<double?> longitude,
      Value<String?> notes,
      Value<DateTime> startedAt,
      Value<DateTime?> completedAt,
      Value<int> totalScore,
      Value<int> totalXs,
      Value<String?> bowId,
      Value<String?> quiverId,
      Value<bool> shaftTaggingEnabled,
      Value<DateTime?> deletedAt,
      Value<int> rowid,
    });

final class $$SessionsTableReferences
    extends BaseReferences<_$AppDatabase, $SessionsTable, Session> {
  $$SessionsTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $RoundTypesTable _roundTypeIdTable(_$AppDatabase db) =>
      db.roundTypes.createAlias(
        $_aliasNameGenerator(db.sessions.roundTypeId, db.roundTypes.id),
      );

  $$RoundTypesTableProcessedTableManager get roundTypeId {
    final $_column = $_itemColumn<String>('round_type_id')!;

    final manager = $$RoundTypesTableTableManager(
      $_db,
      $_db.roundTypes,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_roundTypeIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $BowsTable _bowIdTable(_$AppDatabase db) =>
      db.bows.createAlias($_aliasNameGenerator(db.sessions.bowId, db.bows.id));

  $$BowsTableProcessedTableManager? get bowId {
    final $_column = $_itemColumn<String>('bow_id');
    if ($_column == null) return null;
    final manager = $$BowsTableTableManager(
      $_db,
      $_db.bows,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_bowIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $QuiversTable _quiverIdTable(_$AppDatabase db) => db.quivers
      .createAlias($_aliasNameGenerator(db.sessions.quiverId, db.quivers.id));

  $$QuiversTableProcessedTableManager? get quiverId {
    final $_column = $_itemColumn<String>('quiver_id');
    if ($_column == null) return null;
    final manager = $$QuiversTableTableManager(
      $_db,
      $_db.quivers,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_quiverIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static MultiTypedResultKey<$EndsTable, List<End>> _endsRefsTable(
    _$AppDatabase db,
  ) => MultiTypedResultKey.fromTable(
    db.ends,
    aliasName: $_aliasNameGenerator(db.sessions.id, db.ends.sessionId),
  );

  $$EndsTableProcessedTableManager get endsRefs {
    final manager = $$EndsTableTableManager(
      $_db,
      $_db.ends,
    ).filter((f) => f.sessionId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_endsRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<
    $FieldSessionTargetsTable,
    List<FieldSessionTarget>
  >
  _fieldSessionTargetsRefsTable(_$AppDatabase db) =>
      MultiTypedResultKey.fromTable(
        db.fieldSessionTargets,
        aliasName: $_aliasNameGenerator(
          db.sessions.id,
          db.fieldSessionTargets.sessionId,
        ),
      );

  $$FieldSessionTargetsTableProcessedTableManager get fieldSessionTargetsRefs {
    final manager = $$FieldSessionTargetsTableTableManager(
      $_db,
      $_db.fieldSessionTargets,
    ).filter((f) => f.sessionId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(
      _fieldSessionTargetsRefsTable($_db),
    );
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$FieldSessionMetaTable, List<FieldSessionMetaData>>
  _fieldSessionMetaRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.fieldSessionMeta,
    aliasName: $_aliasNameGenerator(
      db.sessions.id,
      db.fieldSessionMeta.sessionId,
    ),
  );

  $$FieldSessionMetaTableProcessedTableManager get fieldSessionMetaRefs {
    final manager = $$FieldSessionMetaTableTableManager(
      $_db,
      $_db.fieldSessionMeta,
    ).filter((f) => f.sessionId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(
      _fieldSessionMetaRefsTable($_db),
    );
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$SessionsTableFilterComposer
    extends Composer<_$AppDatabase, $SessionsTable> {
  $$SessionsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get sessionType => $composableBuilder(
    column: $table.sessionType,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get title => $composableBuilder(
    column: $table.title,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get locationName => $composableBuilder(
    column: $table.locationName,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get location => $composableBuilder(
    column: $table.location,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get latitude => $composableBuilder(
    column: $table.latitude,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get longitude => $composableBuilder(
    column: $table.longitude,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get startedAt => $composableBuilder(
    column: $table.startedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get completedAt => $composableBuilder(
    column: $table.completedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get totalScore => $composableBuilder(
    column: $table.totalScore,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get totalXs => $composableBuilder(
    column: $table.totalXs,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get shaftTaggingEnabled => $composableBuilder(
    column: $table.shaftTaggingEnabled,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get deletedAt => $composableBuilder(
    column: $table.deletedAt,
    builder: (column) => ColumnFilters(column),
  );

  $$RoundTypesTableFilterComposer get roundTypeId {
    final $$RoundTypesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.roundTypeId,
      referencedTable: $db.roundTypes,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$RoundTypesTableFilterComposer(
            $db: $db,
            $table: $db.roundTypes,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$BowsTableFilterComposer get bowId {
    final $$BowsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.bowId,
      referencedTable: $db.bows,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$BowsTableFilterComposer(
            $db: $db,
            $table: $db.bows,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$QuiversTableFilterComposer get quiverId {
    final $$QuiversTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.quiverId,
      referencedTable: $db.quivers,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$QuiversTableFilterComposer(
            $db: $db,
            $table: $db.quivers,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<bool> endsRefs(
    Expression<bool> Function($$EndsTableFilterComposer f) f,
  ) {
    final $$EndsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.ends,
      getReferencedColumn: (t) => t.sessionId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$EndsTableFilterComposer(
            $db: $db,
            $table: $db.ends,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> fieldSessionTargetsRefs(
    Expression<bool> Function($$FieldSessionTargetsTableFilterComposer f) f,
  ) {
    final $$FieldSessionTargetsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.fieldSessionTargets,
      getReferencedColumn: (t) => t.sessionId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$FieldSessionTargetsTableFilterComposer(
            $db: $db,
            $table: $db.fieldSessionTargets,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> fieldSessionMetaRefs(
    Expression<bool> Function($$FieldSessionMetaTableFilterComposer f) f,
  ) {
    final $$FieldSessionMetaTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.fieldSessionMeta,
      getReferencedColumn: (t) => t.sessionId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$FieldSessionMetaTableFilterComposer(
            $db: $db,
            $table: $db.fieldSessionMeta,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$SessionsTableOrderingComposer
    extends Composer<_$AppDatabase, $SessionsTable> {
  $$SessionsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get sessionType => $composableBuilder(
    column: $table.sessionType,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get title => $composableBuilder(
    column: $table.title,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get locationName => $composableBuilder(
    column: $table.locationName,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get location => $composableBuilder(
    column: $table.location,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get latitude => $composableBuilder(
    column: $table.latitude,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get longitude => $composableBuilder(
    column: $table.longitude,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get startedAt => $composableBuilder(
    column: $table.startedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get completedAt => $composableBuilder(
    column: $table.completedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get totalScore => $composableBuilder(
    column: $table.totalScore,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get totalXs => $composableBuilder(
    column: $table.totalXs,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get shaftTaggingEnabled => $composableBuilder(
    column: $table.shaftTaggingEnabled,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get deletedAt => $composableBuilder(
    column: $table.deletedAt,
    builder: (column) => ColumnOrderings(column),
  );

  $$RoundTypesTableOrderingComposer get roundTypeId {
    final $$RoundTypesTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.roundTypeId,
      referencedTable: $db.roundTypes,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$RoundTypesTableOrderingComposer(
            $db: $db,
            $table: $db.roundTypes,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$BowsTableOrderingComposer get bowId {
    final $$BowsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.bowId,
      referencedTable: $db.bows,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$BowsTableOrderingComposer(
            $db: $db,
            $table: $db.bows,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$QuiversTableOrderingComposer get quiverId {
    final $$QuiversTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.quiverId,
      referencedTable: $db.quivers,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$QuiversTableOrderingComposer(
            $db: $db,
            $table: $db.quivers,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$SessionsTableAnnotationComposer
    extends Composer<_$AppDatabase, $SessionsTable> {
  $$SessionsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get sessionType => $composableBuilder(
    column: $table.sessionType,
    builder: (column) => column,
  );

  GeneratedColumn<String> get title =>
      $composableBuilder(column: $table.title, builder: (column) => column);

  GeneratedColumn<String> get locationName => $composableBuilder(
    column: $table.locationName,
    builder: (column) => column,
  );

  GeneratedColumn<String> get location =>
      $composableBuilder(column: $table.location, builder: (column) => column);

  GeneratedColumn<double> get latitude =>
      $composableBuilder(column: $table.latitude, builder: (column) => column);

  GeneratedColumn<double> get longitude =>
      $composableBuilder(column: $table.longitude, builder: (column) => column);

  GeneratedColumn<String> get notes =>
      $composableBuilder(column: $table.notes, builder: (column) => column);

  GeneratedColumn<DateTime> get startedAt =>
      $composableBuilder(column: $table.startedAt, builder: (column) => column);

  GeneratedColumn<DateTime> get completedAt => $composableBuilder(
    column: $table.completedAt,
    builder: (column) => column,
  );

  GeneratedColumn<int> get totalScore => $composableBuilder(
    column: $table.totalScore,
    builder: (column) => column,
  );

  GeneratedColumn<int> get totalXs =>
      $composableBuilder(column: $table.totalXs, builder: (column) => column);

  GeneratedColumn<bool> get shaftTaggingEnabled => $composableBuilder(
    column: $table.shaftTaggingEnabled,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get deletedAt =>
      $composableBuilder(column: $table.deletedAt, builder: (column) => column);

  $$RoundTypesTableAnnotationComposer get roundTypeId {
    final $$RoundTypesTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.roundTypeId,
      referencedTable: $db.roundTypes,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$RoundTypesTableAnnotationComposer(
            $db: $db,
            $table: $db.roundTypes,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$BowsTableAnnotationComposer get bowId {
    final $$BowsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.bowId,
      referencedTable: $db.bows,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$BowsTableAnnotationComposer(
            $db: $db,
            $table: $db.bows,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$QuiversTableAnnotationComposer get quiverId {
    final $$QuiversTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.quiverId,
      referencedTable: $db.quivers,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$QuiversTableAnnotationComposer(
            $db: $db,
            $table: $db.quivers,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<T> endsRefs<T extends Object>(
    Expression<T> Function($$EndsTableAnnotationComposer a) f,
  ) {
    final $$EndsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.ends,
      getReferencedColumn: (t) => t.sessionId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$EndsTableAnnotationComposer(
            $db: $db,
            $table: $db.ends,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> fieldSessionTargetsRefs<T extends Object>(
    Expression<T> Function($$FieldSessionTargetsTableAnnotationComposer a) f,
  ) {
    final $$FieldSessionTargetsTableAnnotationComposer composer =
        $composerBuilder(
          composer: this,
          getCurrentColumn: (t) => t.id,
          referencedTable: $db.fieldSessionTargets,
          getReferencedColumn: (t) => t.sessionId,
          builder:
              (
                joinBuilder, {
                $addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer,
              }) => $$FieldSessionTargetsTableAnnotationComposer(
                $db: $db,
                $table: $db.fieldSessionTargets,
                $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                joinBuilder: joinBuilder,
                $removeJoinBuilderFromRootComposer:
                    $removeJoinBuilderFromRootComposer,
              ),
        );
    return f(composer);
  }

  Expression<T> fieldSessionMetaRefs<T extends Object>(
    Expression<T> Function($$FieldSessionMetaTableAnnotationComposer a) f,
  ) {
    final $$FieldSessionMetaTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.fieldSessionMeta,
      getReferencedColumn: (t) => t.sessionId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$FieldSessionMetaTableAnnotationComposer(
            $db: $db,
            $table: $db.fieldSessionMeta,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$SessionsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $SessionsTable,
          Session,
          $$SessionsTableFilterComposer,
          $$SessionsTableOrderingComposer,
          $$SessionsTableAnnotationComposer,
          $$SessionsTableCreateCompanionBuilder,
          $$SessionsTableUpdateCompanionBuilder,
          (Session, $$SessionsTableReferences),
          Session,
          PrefetchHooks Function({
            bool roundTypeId,
            bool bowId,
            bool quiverId,
            bool endsRefs,
            bool fieldSessionTargetsRefs,
            bool fieldSessionMetaRefs,
          })
        > {
  $$SessionsTableTableManager(_$AppDatabase db, $SessionsTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$SessionsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$SessionsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$SessionsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> roundTypeId = const Value.absent(),
                Value<String> sessionType = const Value.absent(),
                Value<String?> title = const Value.absent(),
                Value<String?> locationName = const Value.absent(),
                Value<String?> location = const Value.absent(),
                Value<double?> latitude = const Value.absent(),
                Value<double?> longitude = const Value.absent(),
                Value<String?> notes = const Value.absent(),
                Value<DateTime> startedAt = const Value.absent(),
                Value<DateTime?> completedAt = const Value.absent(),
                Value<int> totalScore = const Value.absent(),
                Value<int> totalXs = const Value.absent(),
                Value<String?> bowId = const Value.absent(),
                Value<String?> quiverId = const Value.absent(),
                Value<bool> shaftTaggingEnabled = const Value.absent(),
                Value<DateTime?> deletedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => SessionsCompanion(
                id: id,
                roundTypeId: roundTypeId,
                sessionType: sessionType,
                title: title,
                locationName: locationName,
                location: location,
                latitude: latitude,
                longitude: longitude,
                notes: notes,
                startedAt: startedAt,
                completedAt: completedAt,
                totalScore: totalScore,
                totalXs: totalXs,
                bowId: bowId,
                quiverId: quiverId,
                shaftTaggingEnabled: shaftTaggingEnabled,
                deletedAt: deletedAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String roundTypeId,
                Value<String> sessionType = const Value.absent(),
                Value<String?> title = const Value.absent(),
                Value<String?> locationName = const Value.absent(),
                Value<String?> location = const Value.absent(),
                Value<double?> latitude = const Value.absent(),
                Value<double?> longitude = const Value.absent(),
                Value<String?> notes = const Value.absent(),
                Value<DateTime> startedAt = const Value.absent(),
                Value<DateTime?> completedAt = const Value.absent(),
                Value<int> totalScore = const Value.absent(),
                Value<int> totalXs = const Value.absent(),
                Value<String?> bowId = const Value.absent(),
                Value<String?> quiverId = const Value.absent(),
                Value<bool> shaftTaggingEnabled = const Value.absent(),
                Value<DateTime?> deletedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => SessionsCompanion.insert(
                id: id,
                roundTypeId: roundTypeId,
                sessionType: sessionType,
                title: title,
                locationName: locationName,
                location: location,
                latitude: latitude,
                longitude: longitude,
                notes: notes,
                startedAt: startedAt,
                completedAt: completedAt,
                totalScore: totalScore,
                totalXs: totalXs,
                bowId: bowId,
                quiverId: quiverId,
                shaftTaggingEnabled: shaftTaggingEnabled,
                deletedAt: deletedAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$SessionsTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback:
              ({
                roundTypeId = false,
                bowId = false,
                quiverId = false,
                endsRefs = false,
                fieldSessionTargetsRefs = false,
                fieldSessionMetaRefs = false,
              }) {
                return PrefetchHooks(
                  db: db,
                  explicitlyWatchedTables: [
                    if (endsRefs) db.ends,
                    if (fieldSessionTargetsRefs) db.fieldSessionTargets,
                    if (fieldSessionMetaRefs) db.fieldSessionMeta,
                  ],
                  addJoins:
                      <
                        T extends TableManagerState<
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic
                        >
                      >(state) {
                        if (roundTypeId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.roundTypeId,
                                    referencedTable: $$SessionsTableReferences
                                        ._roundTypeIdTable(db),
                                    referencedColumn: $$SessionsTableReferences
                                        ._roundTypeIdTable(db)
                                        .id,
                                  )
                                  as T;
                        }
                        if (bowId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.bowId,
                                    referencedTable: $$SessionsTableReferences
                                        ._bowIdTable(db),
                                    referencedColumn: $$SessionsTableReferences
                                        ._bowIdTable(db)
                                        .id,
                                  )
                                  as T;
                        }
                        if (quiverId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.quiverId,
                                    referencedTable: $$SessionsTableReferences
                                        ._quiverIdTable(db),
                                    referencedColumn: $$SessionsTableReferences
                                        ._quiverIdTable(db)
                                        .id,
                                  )
                                  as T;
                        }

                        return state;
                      },
                  getPrefetchedDataCallback: (items) async {
                    return [
                      if (endsRefs)
                        await $_getPrefetchedData<Session, $SessionsTable, End>(
                          currentTable: table,
                          referencedTable: $$SessionsTableReferences
                              ._endsRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$SessionsTableReferences(db, table, p0).endsRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.sessionId == item.id,
                              ),
                          typedResults: items,
                        ),
                      if (fieldSessionTargetsRefs)
                        await $_getPrefetchedData<
                          Session,
                          $SessionsTable,
                          FieldSessionTarget
                        >(
                          currentTable: table,
                          referencedTable: $$SessionsTableReferences
                              ._fieldSessionTargetsRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$SessionsTableReferences(
                                db,
                                table,
                                p0,
                              ).fieldSessionTargetsRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.sessionId == item.id,
                              ),
                          typedResults: items,
                        ),
                      if (fieldSessionMetaRefs)
                        await $_getPrefetchedData<
                          Session,
                          $SessionsTable,
                          FieldSessionMetaData
                        >(
                          currentTable: table,
                          referencedTable: $$SessionsTableReferences
                              ._fieldSessionMetaRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$SessionsTableReferences(
                                db,
                                table,
                                p0,
                              ).fieldSessionMetaRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.sessionId == item.id,
                              ),
                          typedResults: items,
                        ),
                    ];
                  },
                );
              },
        ),
      );
}

typedef $$SessionsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $SessionsTable,
      Session,
      $$SessionsTableFilterComposer,
      $$SessionsTableOrderingComposer,
      $$SessionsTableAnnotationComposer,
      $$SessionsTableCreateCompanionBuilder,
      $$SessionsTableUpdateCompanionBuilder,
      (Session, $$SessionsTableReferences),
      Session,
      PrefetchHooks Function({
        bool roundTypeId,
        bool bowId,
        bool quiverId,
        bool endsRefs,
        bool fieldSessionTargetsRefs,
        bool fieldSessionMetaRefs,
      })
    >;
typedef $$EndsTableCreateCompanionBuilder =
    EndsCompanion Function({
      required String id,
      required String sessionId,
      required int endNumber,
      Value<int> endScore,
      Value<int> endXs,
      Value<String> status,
      Value<DateTime?> committedAt,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<DateTime?> deletedAt,
      Value<int> rowid,
    });
typedef $$EndsTableUpdateCompanionBuilder =
    EndsCompanion Function({
      Value<String> id,
      Value<String> sessionId,
      Value<int> endNumber,
      Value<int> endScore,
      Value<int> endXs,
      Value<String> status,
      Value<DateTime?> committedAt,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<DateTime?> deletedAt,
      Value<int> rowid,
    });

final class $$EndsTableReferences
    extends BaseReferences<_$AppDatabase, $EndsTable, End> {
  $$EndsTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $SessionsTable _sessionIdTable(_$AppDatabase db) => db.sessions
      .createAlias($_aliasNameGenerator(db.ends.sessionId, db.sessions.id));

  $$SessionsTableProcessedTableManager get sessionId {
    final $_column = $_itemColumn<String>('session_id')!;

    final manager = $$SessionsTableTableManager(
      $_db,
      $_db.sessions,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_sessionIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static MultiTypedResultKey<$ArrowsTable, List<Arrow>> _arrowsRefsTable(
    _$AppDatabase db,
  ) => MultiTypedResultKey.fromTable(
    db.arrows,
    aliasName: $_aliasNameGenerator(db.ends.id, db.arrows.endId),
  );

  $$ArrowsTableProcessedTableManager get arrowsRefs {
    final manager = $$ArrowsTableTableManager(
      $_db,
      $_db.arrows,
    ).filter((f) => f.endId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_arrowsRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$EndsTableFilterComposer extends Composer<_$AppDatabase, $EndsTable> {
  $$EndsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get endNumber => $composableBuilder(
    column: $table.endNumber,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get endScore => $composableBuilder(
    column: $table.endScore,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get endXs => $composableBuilder(
    column: $table.endXs,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get status => $composableBuilder(
    column: $table.status,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get committedAt => $composableBuilder(
    column: $table.committedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get deletedAt => $composableBuilder(
    column: $table.deletedAt,
    builder: (column) => ColumnFilters(column),
  );

  $$SessionsTableFilterComposer get sessionId {
    final $$SessionsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.sessionId,
      referencedTable: $db.sessions,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SessionsTableFilterComposer(
            $db: $db,
            $table: $db.sessions,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<bool> arrowsRefs(
    Expression<bool> Function($$ArrowsTableFilterComposer f) f,
  ) {
    final $$ArrowsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.arrows,
      getReferencedColumn: (t) => t.endId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ArrowsTableFilterComposer(
            $db: $db,
            $table: $db.arrows,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$EndsTableOrderingComposer extends Composer<_$AppDatabase, $EndsTable> {
  $$EndsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get endNumber => $composableBuilder(
    column: $table.endNumber,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get endScore => $composableBuilder(
    column: $table.endScore,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get endXs => $composableBuilder(
    column: $table.endXs,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get status => $composableBuilder(
    column: $table.status,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get committedAt => $composableBuilder(
    column: $table.committedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get deletedAt => $composableBuilder(
    column: $table.deletedAt,
    builder: (column) => ColumnOrderings(column),
  );

  $$SessionsTableOrderingComposer get sessionId {
    final $$SessionsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.sessionId,
      referencedTable: $db.sessions,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SessionsTableOrderingComposer(
            $db: $db,
            $table: $db.sessions,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$EndsTableAnnotationComposer
    extends Composer<_$AppDatabase, $EndsTable> {
  $$EndsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<int> get endNumber =>
      $composableBuilder(column: $table.endNumber, builder: (column) => column);

  GeneratedColumn<int> get endScore =>
      $composableBuilder(column: $table.endScore, builder: (column) => column);

  GeneratedColumn<int> get endXs =>
      $composableBuilder(column: $table.endXs, builder: (column) => column);

  GeneratedColumn<String> get status =>
      $composableBuilder(column: $table.status, builder: (column) => column);

  GeneratedColumn<DateTime> get committedAt => $composableBuilder(
    column: $table.committedAt,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  GeneratedColumn<DateTime> get deletedAt =>
      $composableBuilder(column: $table.deletedAt, builder: (column) => column);

  $$SessionsTableAnnotationComposer get sessionId {
    final $$SessionsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.sessionId,
      referencedTable: $db.sessions,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SessionsTableAnnotationComposer(
            $db: $db,
            $table: $db.sessions,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<T> arrowsRefs<T extends Object>(
    Expression<T> Function($$ArrowsTableAnnotationComposer a) f,
  ) {
    final $$ArrowsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.arrows,
      getReferencedColumn: (t) => t.endId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ArrowsTableAnnotationComposer(
            $db: $db,
            $table: $db.arrows,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$EndsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $EndsTable,
          End,
          $$EndsTableFilterComposer,
          $$EndsTableOrderingComposer,
          $$EndsTableAnnotationComposer,
          $$EndsTableCreateCompanionBuilder,
          $$EndsTableUpdateCompanionBuilder,
          (End, $$EndsTableReferences),
          End,
          PrefetchHooks Function({bool sessionId, bool arrowsRefs})
        > {
  $$EndsTableTableManager(_$AppDatabase db, $EndsTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$EndsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$EndsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$EndsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> sessionId = const Value.absent(),
                Value<int> endNumber = const Value.absent(),
                Value<int> endScore = const Value.absent(),
                Value<int> endXs = const Value.absent(),
                Value<String> status = const Value.absent(),
                Value<DateTime?> committedAt = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<DateTime?> deletedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => EndsCompanion(
                id: id,
                sessionId: sessionId,
                endNumber: endNumber,
                endScore: endScore,
                endXs: endXs,
                status: status,
                committedAt: committedAt,
                createdAt: createdAt,
                updatedAt: updatedAt,
                deletedAt: deletedAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String sessionId,
                required int endNumber,
                Value<int> endScore = const Value.absent(),
                Value<int> endXs = const Value.absent(),
                Value<String> status = const Value.absent(),
                Value<DateTime?> committedAt = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<DateTime?> deletedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => EndsCompanion.insert(
                id: id,
                sessionId: sessionId,
                endNumber: endNumber,
                endScore: endScore,
                endXs: endXs,
                status: status,
                committedAt: committedAt,
                createdAt: createdAt,
                updatedAt: updatedAt,
                deletedAt: deletedAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) =>
                    (e.readTable(table), $$EndsTableReferences(db, table, e)),
              )
              .toList(),
          prefetchHooksCallback: ({sessionId = false, arrowsRefs = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [if (arrowsRefs) db.arrows],
              addJoins:
                  <
                    T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic
                    >
                  >(state) {
                    if (sessionId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.sessionId,
                                referencedTable: $$EndsTableReferences
                                    ._sessionIdTable(db),
                                referencedColumn: $$EndsTableReferences
                                    ._sessionIdTable(db)
                                    .id,
                              )
                              as T;
                    }

                    return state;
                  },
              getPrefetchedDataCallback: (items) async {
                return [
                  if (arrowsRefs)
                    await $_getPrefetchedData<End, $EndsTable, Arrow>(
                      currentTable: table,
                      referencedTable: $$EndsTableReferences._arrowsRefsTable(
                        db,
                      ),
                      managerFromTypedResult: (p0) =>
                          $$EndsTableReferences(db, table, p0).arrowsRefs,
                      referencedItemsForCurrentItem: (item, referencedItems) =>
                          referencedItems.where((e) => e.endId == item.id),
                      typedResults: items,
                    ),
                ];
              },
            );
          },
        ),
      );
}

typedef $$EndsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $EndsTable,
      End,
      $$EndsTableFilterComposer,
      $$EndsTableOrderingComposer,
      $$EndsTableAnnotationComposer,
      $$EndsTableCreateCompanionBuilder,
      $$EndsTableUpdateCompanionBuilder,
      (End, $$EndsTableReferences),
      End,
      PrefetchHooks Function({bool sessionId, bool arrowsRefs})
    >;
typedef $$ShaftsTableCreateCompanionBuilder =
    ShaftsCompanion Function({
      required String id,
      required String quiverId,
      required int number,
      Value<String?> diameter,
      Value<int?> spine,
      Value<double?> lengthInches,
      Value<int?> pointWeight,
      Value<String?> fletchingType,
      Value<String?> fletchingColor,
      Value<String?> nockColor,
      Value<String?> notes,
      Value<DateTime> createdAt,
      Value<DateTime?> retiredAt,
      Value<double?> totalWeight,
      Value<String?> pointType,
      Value<String?> nockBrand,
      Value<String?> fletchingSize,
      Value<double?> fletchingAngle,
      Value<bool?> hasWrap,
      Value<String?> wrapColor,
      Value<DateTime?> purchaseDate,
      Value<int> rowid,
    });
typedef $$ShaftsTableUpdateCompanionBuilder =
    ShaftsCompanion Function({
      Value<String> id,
      Value<String> quiverId,
      Value<int> number,
      Value<String?> diameter,
      Value<int?> spine,
      Value<double?> lengthInches,
      Value<int?> pointWeight,
      Value<String?> fletchingType,
      Value<String?> fletchingColor,
      Value<String?> nockColor,
      Value<String?> notes,
      Value<DateTime> createdAt,
      Value<DateTime?> retiredAt,
      Value<double?> totalWeight,
      Value<String?> pointType,
      Value<String?> nockBrand,
      Value<String?> fletchingSize,
      Value<double?> fletchingAngle,
      Value<bool?> hasWrap,
      Value<String?> wrapColor,
      Value<DateTime?> purchaseDate,
      Value<int> rowid,
    });

final class $$ShaftsTableReferences
    extends BaseReferences<_$AppDatabase, $ShaftsTable, Shaft> {
  $$ShaftsTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $QuiversTable _quiverIdTable(_$AppDatabase db) => db.quivers
      .createAlias($_aliasNameGenerator(db.shafts.quiverId, db.quivers.id));

  $$QuiversTableProcessedTableManager get quiverId {
    final $_column = $_itemColumn<String>('quiver_id')!;

    final manager = $$QuiversTableTableManager(
      $_db,
      $_db.quivers,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_quiverIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static MultiTypedResultKey<$ArrowsTable, List<Arrow>> _arrowsRefsTable(
    _$AppDatabase db,
  ) => MultiTypedResultKey.fromTable(
    db.arrows,
    aliasName: $_aliasNameGenerator(db.shafts.id, db.arrows.shaftId),
  );

  $$ArrowsTableProcessedTableManager get arrowsRefs {
    final manager = $$ArrowsTableTableManager(
      $_db,
      $_db.arrows,
    ).filter((f) => f.shaftId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_arrowsRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$ShaftsTableFilterComposer
    extends Composer<_$AppDatabase, $ShaftsTable> {
  $$ShaftsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get number => $composableBuilder(
    column: $table.number,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get diameter => $composableBuilder(
    column: $table.diameter,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get spine => $composableBuilder(
    column: $table.spine,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get lengthInches => $composableBuilder(
    column: $table.lengthInches,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get pointWeight => $composableBuilder(
    column: $table.pointWeight,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get fletchingType => $composableBuilder(
    column: $table.fletchingType,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get fletchingColor => $composableBuilder(
    column: $table.fletchingColor,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get nockColor => $composableBuilder(
    column: $table.nockColor,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get retiredAt => $composableBuilder(
    column: $table.retiredAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get totalWeight => $composableBuilder(
    column: $table.totalWeight,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get pointType => $composableBuilder(
    column: $table.pointType,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get nockBrand => $composableBuilder(
    column: $table.nockBrand,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get fletchingSize => $composableBuilder(
    column: $table.fletchingSize,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get fletchingAngle => $composableBuilder(
    column: $table.fletchingAngle,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get hasWrap => $composableBuilder(
    column: $table.hasWrap,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get wrapColor => $composableBuilder(
    column: $table.wrapColor,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get purchaseDate => $composableBuilder(
    column: $table.purchaseDate,
    builder: (column) => ColumnFilters(column),
  );

  $$QuiversTableFilterComposer get quiverId {
    final $$QuiversTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.quiverId,
      referencedTable: $db.quivers,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$QuiversTableFilterComposer(
            $db: $db,
            $table: $db.quivers,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<bool> arrowsRefs(
    Expression<bool> Function($$ArrowsTableFilterComposer f) f,
  ) {
    final $$ArrowsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.arrows,
      getReferencedColumn: (t) => t.shaftId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ArrowsTableFilterComposer(
            $db: $db,
            $table: $db.arrows,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$ShaftsTableOrderingComposer
    extends Composer<_$AppDatabase, $ShaftsTable> {
  $$ShaftsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get number => $composableBuilder(
    column: $table.number,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get diameter => $composableBuilder(
    column: $table.diameter,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get spine => $composableBuilder(
    column: $table.spine,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get lengthInches => $composableBuilder(
    column: $table.lengthInches,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get pointWeight => $composableBuilder(
    column: $table.pointWeight,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get fletchingType => $composableBuilder(
    column: $table.fletchingType,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get fletchingColor => $composableBuilder(
    column: $table.fletchingColor,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get nockColor => $composableBuilder(
    column: $table.nockColor,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get retiredAt => $composableBuilder(
    column: $table.retiredAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get totalWeight => $composableBuilder(
    column: $table.totalWeight,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get pointType => $composableBuilder(
    column: $table.pointType,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get nockBrand => $composableBuilder(
    column: $table.nockBrand,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get fletchingSize => $composableBuilder(
    column: $table.fletchingSize,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get fletchingAngle => $composableBuilder(
    column: $table.fletchingAngle,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get hasWrap => $composableBuilder(
    column: $table.hasWrap,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get wrapColor => $composableBuilder(
    column: $table.wrapColor,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get purchaseDate => $composableBuilder(
    column: $table.purchaseDate,
    builder: (column) => ColumnOrderings(column),
  );

  $$QuiversTableOrderingComposer get quiverId {
    final $$QuiversTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.quiverId,
      referencedTable: $db.quivers,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$QuiversTableOrderingComposer(
            $db: $db,
            $table: $db.quivers,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$ShaftsTableAnnotationComposer
    extends Composer<_$AppDatabase, $ShaftsTable> {
  $$ShaftsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<int> get number =>
      $composableBuilder(column: $table.number, builder: (column) => column);

  GeneratedColumn<String> get diameter =>
      $composableBuilder(column: $table.diameter, builder: (column) => column);

  GeneratedColumn<int> get spine =>
      $composableBuilder(column: $table.spine, builder: (column) => column);

  GeneratedColumn<double> get lengthInches => $composableBuilder(
    column: $table.lengthInches,
    builder: (column) => column,
  );

  GeneratedColumn<int> get pointWeight => $composableBuilder(
    column: $table.pointWeight,
    builder: (column) => column,
  );

  GeneratedColumn<String> get fletchingType => $composableBuilder(
    column: $table.fletchingType,
    builder: (column) => column,
  );

  GeneratedColumn<String> get fletchingColor => $composableBuilder(
    column: $table.fletchingColor,
    builder: (column) => column,
  );

  GeneratedColumn<String> get nockColor =>
      $composableBuilder(column: $table.nockColor, builder: (column) => column);

  GeneratedColumn<String> get notes =>
      $composableBuilder(column: $table.notes, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get retiredAt =>
      $composableBuilder(column: $table.retiredAt, builder: (column) => column);

  GeneratedColumn<double> get totalWeight => $composableBuilder(
    column: $table.totalWeight,
    builder: (column) => column,
  );

  GeneratedColumn<String> get pointType =>
      $composableBuilder(column: $table.pointType, builder: (column) => column);

  GeneratedColumn<String> get nockBrand =>
      $composableBuilder(column: $table.nockBrand, builder: (column) => column);

  GeneratedColumn<String> get fletchingSize => $composableBuilder(
    column: $table.fletchingSize,
    builder: (column) => column,
  );

  GeneratedColumn<double> get fletchingAngle => $composableBuilder(
    column: $table.fletchingAngle,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get hasWrap =>
      $composableBuilder(column: $table.hasWrap, builder: (column) => column);

  GeneratedColumn<String> get wrapColor =>
      $composableBuilder(column: $table.wrapColor, builder: (column) => column);

  GeneratedColumn<DateTime> get purchaseDate => $composableBuilder(
    column: $table.purchaseDate,
    builder: (column) => column,
  );

  $$QuiversTableAnnotationComposer get quiverId {
    final $$QuiversTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.quiverId,
      referencedTable: $db.quivers,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$QuiversTableAnnotationComposer(
            $db: $db,
            $table: $db.quivers,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<T> arrowsRefs<T extends Object>(
    Expression<T> Function($$ArrowsTableAnnotationComposer a) f,
  ) {
    final $$ArrowsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.arrows,
      getReferencedColumn: (t) => t.shaftId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ArrowsTableAnnotationComposer(
            $db: $db,
            $table: $db.arrows,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$ShaftsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $ShaftsTable,
          Shaft,
          $$ShaftsTableFilterComposer,
          $$ShaftsTableOrderingComposer,
          $$ShaftsTableAnnotationComposer,
          $$ShaftsTableCreateCompanionBuilder,
          $$ShaftsTableUpdateCompanionBuilder,
          (Shaft, $$ShaftsTableReferences),
          Shaft,
          PrefetchHooks Function({bool quiverId, bool arrowsRefs})
        > {
  $$ShaftsTableTableManager(_$AppDatabase db, $ShaftsTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$ShaftsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$ShaftsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$ShaftsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> quiverId = const Value.absent(),
                Value<int> number = const Value.absent(),
                Value<String?> diameter = const Value.absent(),
                Value<int?> spine = const Value.absent(),
                Value<double?> lengthInches = const Value.absent(),
                Value<int?> pointWeight = const Value.absent(),
                Value<String?> fletchingType = const Value.absent(),
                Value<String?> fletchingColor = const Value.absent(),
                Value<String?> nockColor = const Value.absent(),
                Value<String?> notes = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime?> retiredAt = const Value.absent(),
                Value<double?> totalWeight = const Value.absent(),
                Value<String?> pointType = const Value.absent(),
                Value<String?> nockBrand = const Value.absent(),
                Value<String?> fletchingSize = const Value.absent(),
                Value<double?> fletchingAngle = const Value.absent(),
                Value<bool?> hasWrap = const Value.absent(),
                Value<String?> wrapColor = const Value.absent(),
                Value<DateTime?> purchaseDate = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => ShaftsCompanion(
                id: id,
                quiverId: quiverId,
                number: number,
                diameter: diameter,
                spine: spine,
                lengthInches: lengthInches,
                pointWeight: pointWeight,
                fletchingType: fletchingType,
                fletchingColor: fletchingColor,
                nockColor: nockColor,
                notes: notes,
                createdAt: createdAt,
                retiredAt: retiredAt,
                totalWeight: totalWeight,
                pointType: pointType,
                nockBrand: nockBrand,
                fletchingSize: fletchingSize,
                fletchingAngle: fletchingAngle,
                hasWrap: hasWrap,
                wrapColor: wrapColor,
                purchaseDate: purchaseDate,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String quiverId,
                required int number,
                Value<String?> diameter = const Value.absent(),
                Value<int?> spine = const Value.absent(),
                Value<double?> lengthInches = const Value.absent(),
                Value<int?> pointWeight = const Value.absent(),
                Value<String?> fletchingType = const Value.absent(),
                Value<String?> fletchingColor = const Value.absent(),
                Value<String?> nockColor = const Value.absent(),
                Value<String?> notes = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime?> retiredAt = const Value.absent(),
                Value<double?> totalWeight = const Value.absent(),
                Value<String?> pointType = const Value.absent(),
                Value<String?> nockBrand = const Value.absent(),
                Value<String?> fletchingSize = const Value.absent(),
                Value<double?> fletchingAngle = const Value.absent(),
                Value<bool?> hasWrap = const Value.absent(),
                Value<String?> wrapColor = const Value.absent(),
                Value<DateTime?> purchaseDate = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => ShaftsCompanion.insert(
                id: id,
                quiverId: quiverId,
                number: number,
                diameter: diameter,
                spine: spine,
                lengthInches: lengthInches,
                pointWeight: pointWeight,
                fletchingType: fletchingType,
                fletchingColor: fletchingColor,
                nockColor: nockColor,
                notes: notes,
                createdAt: createdAt,
                retiredAt: retiredAt,
                totalWeight: totalWeight,
                pointType: pointType,
                nockBrand: nockBrand,
                fletchingSize: fletchingSize,
                fletchingAngle: fletchingAngle,
                hasWrap: hasWrap,
                wrapColor: wrapColor,
                purchaseDate: purchaseDate,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) =>
                    (e.readTable(table), $$ShaftsTableReferences(db, table, e)),
              )
              .toList(),
          prefetchHooksCallback: ({quiverId = false, arrowsRefs = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [if (arrowsRefs) db.arrows],
              addJoins:
                  <
                    T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic
                    >
                  >(state) {
                    if (quiverId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.quiverId,
                                referencedTable: $$ShaftsTableReferences
                                    ._quiverIdTable(db),
                                referencedColumn: $$ShaftsTableReferences
                                    ._quiverIdTable(db)
                                    .id,
                              )
                              as T;
                    }

                    return state;
                  },
              getPrefetchedDataCallback: (items) async {
                return [
                  if (arrowsRefs)
                    await $_getPrefetchedData<Shaft, $ShaftsTable, Arrow>(
                      currentTable: table,
                      referencedTable: $$ShaftsTableReferences._arrowsRefsTable(
                        db,
                      ),
                      managerFromTypedResult: (p0) =>
                          $$ShaftsTableReferences(db, table, p0).arrowsRefs,
                      referencedItemsForCurrentItem: (item, referencedItems) =>
                          referencedItems.where((e) => e.shaftId == item.id),
                      typedResults: items,
                    ),
                ];
              },
            );
          },
        ),
      );
}

typedef $$ShaftsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $ShaftsTable,
      Shaft,
      $$ShaftsTableFilterComposer,
      $$ShaftsTableOrderingComposer,
      $$ShaftsTableAnnotationComposer,
      $$ShaftsTableCreateCompanionBuilder,
      $$ShaftsTableUpdateCompanionBuilder,
      (Shaft, $$ShaftsTableReferences),
      Shaft,
      PrefetchHooks Function({bool quiverId, bool arrowsRefs})
    >;
typedef $$ArrowsTableCreateCompanionBuilder =
    ArrowsCompanion Function({
      required String id,
      required String endId,
      Value<int> faceIndex,
      required double x,
      required double y,
      Value<double> xMm,
      Value<double> yMm,
      required int score,
      Value<bool> isX,
      required int sequence,
      Value<int?> shaftNumber,
      Value<String?> shaftId,
      Value<String?> nockRotation,
      Value<int> rating,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<DateTime?> deletedAt,
      Value<int> rowid,
    });
typedef $$ArrowsTableUpdateCompanionBuilder =
    ArrowsCompanion Function({
      Value<String> id,
      Value<String> endId,
      Value<int> faceIndex,
      Value<double> x,
      Value<double> y,
      Value<double> xMm,
      Value<double> yMm,
      Value<int> score,
      Value<bool> isX,
      Value<int> sequence,
      Value<int?> shaftNumber,
      Value<String?> shaftId,
      Value<String?> nockRotation,
      Value<int> rating,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<DateTime?> deletedAt,
      Value<int> rowid,
    });

final class $$ArrowsTableReferences
    extends BaseReferences<_$AppDatabase, $ArrowsTable, Arrow> {
  $$ArrowsTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $EndsTable _endIdTable(_$AppDatabase db) =>
      db.ends.createAlias($_aliasNameGenerator(db.arrows.endId, db.ends.id));

  $$EndsTableProcessedTableManager get endId {
    final $_column = $_itemColumn<String>('end_id')!;

    final manager = $$EndsTableTableManager(
      $_db,
      $_db.ends,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_endIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $ShaftsTable _shaftIdTable(_$AppDatabase db) => db.shafts.createAlias(
    $_aliasNameGenerator(db.arrows.shaftId, db.shafts.id),
  );

  $$ShaftsTableProcessedTableManager? get shaftId {
    final $_column = $_itemColumn<String>('shaft_id');
    if ($_column == null) return null;
    final manager = $$ShaftsTableTableManager(
      $_db,
      $_db.shafts,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_shaftIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$ArrowsTableFilterComposer
    extends Composer<_$AppDatabase, $ArrowsTable> {
  $$ArrowsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get faceIndex => $composableBuilder(
    column: $table.faceIndex,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get x => $composableBuilder(
    column: $table.x,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get y => $composableBuilder(
    column: $table.y,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get xMm => $composableBuilder(
    column: $table.xMm,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get yMm => $composableBuilder(
    column: $table.yMm,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get score => $composableBuilder(
    column: $table.score,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isX => $composableBuilder(
    column: $table.isX,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get sequence => $composableBuilder(
    column: $table.sequence,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get shaftNumber => $composableBuilder(
    column: $table.shaftNumber,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get nockRotation => $composableBuilder(
    column: $table.nockRotation,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get rating => $composableBuilder(
    column: $table.rating,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get deletedAt => $composableBuilder(
    column: $table.deletedAt,
    builder: (column) => ColumnFilters(column),
  );

  $$EndsTableFilterComposer get endId {
    final $$EndsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.endId,
      referencedTable: $db.ends,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$EndsTableFilterComposer(
            $db: $db,
            $table: $db.ends,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$ShaftsTableFilterComposer get shaftId {
    final $$ShaftsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.shaftId,
      referencedTable: $db.shafts,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ShaftsTableFilterComposer(
            $db: $db,
            $table: $db.shafts,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$ArrowsTableOrderingComposer
    extends Composer<_$AppDatabase, $ArrowsTable> {
  $$ArrowsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get faceIndex => $composableBuilder(
    column: $table.faceIndex,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get x => $composableBuilder(
    column: $table.x,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get y => $composableBuilder(
    column: $table.y,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get xMm => $composableBuilder(
    column: $table.xMm,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get yMm => $composableBuilder(
    column: $table.yMm,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get score => $composableBuilder(
    column: $table.score,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isX => $composableBuilder(
    column: $table.isX,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get sequence => $composableBuilder(
    column: $table.sequence,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get shaftNumber => $composableBuilder(
    column: $table.shaftNumber,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get nockRotation => $composableBuilder(
    column: $table.nockRotation,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get rating => $composableBuilder(
    column: $table.rating,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get deletedAt => $composableBuilder(
    column: $table.deletedAt,
    builder: (column) => ColumnOrderings(column),
  );

  $$EndsTableOrderingComposer get endId {
    final $$EndsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.endId,
      referencedTable: $db.ends,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$EndsTableOrderingComposer(
            $db: $db,
            $table: $db.ends,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$ShaftsTableOrderingComposer get shaftId {
    final $$ShaftsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.shaftId,
      referencedTable: $db.shafts,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ShaftsTableOrderingComposer(
            $db: $db,
            $table: $db.shafts,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$ArrowsTableAnnotationComposer
    extends Composer<_$AppDatabase, $ArrowsTable> {
  $$ArrowsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<int> get faceIndex =>
      $composableBuilder(column: $table.faceIndex, builder: (column) => column);

  GeneratedColumn<double> get x =>
      $composableBuilder(column: $table.x, builder: (column) => column);

  GeneratedColumn<double> get y =>
      $composableBuilder(column: $table.y, builder: (column) => column);

  GeneratedColumn<double> get xMm =>
      $composableBuilder(column: $table.xMm, builder: (column) => column);

  GeneratedColumn<double> get yMm =>
      $composableBuilder(column: $table.yMm, builder: (column) => column);

  GeneratedColumn<int> get score =>
      $composableBuilder(column: $table.score, builder: (column) => column);

  GeneratedColumn<bool> get isX =>
      $composableBuilder(column: $table.isX, builder: (column) => column);

  GeneratedColumn<int> get sequence =>
      $composableBuilder(column: $table.sequence, builder: (column) => column);

  GeneratedColumn<int> get shaftNumber => $composableBuilder(
    column: $table.shaftNumber,
    builder: (column) => column,
  );

  GeneratedColumn<String> get nockRotation => $composableBuilder(
    column: $table.nockRotation,
    builder: (column) => column,
  );

  GeneratedColumn<int> get rating =>
      $composableBuilder(column: $table.rating, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  GeneratedColumn<DateTime> get deletedAt =>
      $composableBuilder(column: $table.deletedAt, builder: (column) => column);

  $$EndsTableAnnotationComposer get endId {
    final $$EndsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.endId,
      referencedTable: $db.ends,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$EndsTableAnnotationComposer(
            $db: $db,
            $table: $db.ends,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$ShaftsTableAnnotationComposer get shaftId {
    final $$ShaftsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.shaftId,
      referencedTable: $db.shafts,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ShaftsTableAnnotationComposer(
            $db: $db,
            $table: $db.shafts,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$ArrowsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $ArrowsTable,
          Arrow,
          $$ArrowsTableFilterComposer,
          $$ArrowsTableOrderingComposer,
          $$ArrowsTableAnnotationComposer,
          $$ArrowsTableCreateCompanionBuilder,
          $$ArrowsTableUpdateCompanionBuilder,
          (Arrow, $$ArrowsTableReferences),
          Arrow,
          PrefetchHooks Function({bool endId, bool shaftId})
        > {
  $$ArrowsTableTableManager(_$AppDatabase db, $ArrowsTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$ArrowsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$ArrowsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$ArrowsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> endId = const Value.absent(),
                Value<int> faceIndex = const Value.absent(),
                Value<double> x = const Value.absent(),
                Value<double> y = const Value.absent(),
                Value<double> xMm = const Value.absent(),
                Value<double> yMm = const Value.absent(),
                Value<int> score = const Value.absent(),
                Value<bool> isX = const Value.absent(),
                Value<int> sequence = const Value.absent(),
                Value<int?> shaftNumber = const Value.absent(),
                Value<String?> shaftId = const Value.absent(),
                Value<String?> nockRotation = const Value.absent(),
                Value<int> rating = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<DateTime?> deletedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => ArrowsCompanion(
                id: id,
                endId: endId,
                faceIndex: faceIndex,
                x: x,
                y: y,
                xMm: xMm,
                yMm: yMm,
                score: score,
                isX: isX,
                sequence: sequence,
                shaftNumber: shaftNumber,
                shaftId: shaftId,
                nockRotation: nockRotation,
                rating: rating,
                createdAt: createdAt,
                updatedAt: updatedAt,
                deletedAt: deletedAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String endId,
                Value<int> faceIndex = const Value.absent(),
                required double x,
                required double y,
                Value<double> xMm = const Value.absent(),
                Value<double> yMm = const Value.absent(),
                required int score,
                Value<bool> isX = const Value.absent(),
                required int sequence,
                Value<int?> shaftNumber = const Value.absent(),
                Value<String?> shaftId = const Value.absent(),
                Value<String?> nockRotation = const Value.absent(),
                Value<int> rating = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<DateTime?> deletedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => ArrowsCompanion.insert(
                id: id,
                endId: endId,
                faceIndex: faceIndex,
                x: x,
                y: y,
                xMm: xMm,
                yMm: yMm,
                score: score,
                isX: isX,
                sequence: sequence,
                shaftNumber: shaftNumber,
                shaftId: shaftId,
                nockRotation: nockRotation,
                rating: rating,
                createdAt: createdAt,
                updatedAt: updatedAt,
                deletedAt: deletedAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) =>
                    (e.readTable(table), $$ArrowsTableReferences(db, table, e)),
              )
              .toList(),
          prefetchHooksCallback: ({endId = false, shaftId = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins:
                  <
                    T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic
                    >
                  >(state) {
                    if (endId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.endId,
                                referencedTable: $$ArrowsTableReferences
                                    ._endIdTable(db),
                                referencedColumn: $$ArrowsTableReferences
                                    ._endIdTable(db)
                                    .id,
                              )
                              as T;
                    }
                    if (shaftId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.shaftId,
                                referencedTable: $$ArrowsTableReferences
                                    ._shaftIdTable(db),
                                referencedColumn: $$ArrowsTableReferences
                                    ._shaftIdTable(db)
                                    .id,
                              )
                              as T;
                    }

                    return state;
                  },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ),
      );
}

typedef $$ArrowsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $ArrowsTable,
      Arrow,
      $$ArrowsTableFilterComposer,
      $$ArrowsTableOrderingComposer,
      $$ArrowsTableAnnotationComposer,
      $$ArrowsTableCreateCompanionBuilder,
      $$ArrowsTableUpdateCompanionBuilder,
      (Arrow, $$ArrowsTableReferences),
      Arrow,
      PrefetchHooks Function({bool endId, bool shaftId})
    >;
typedef $$ImportedScoresTableCreateCompanionBuilder =
    ImportedScoresCompanion Function({
      required String id,
      required DateTime date,
      required String roundName,
      required int score,
      Value<int?> xCount,
      Value<String?> location,
      Value<String?> notes,
      Value<String> sessionType,
      Value<String> source,
      Value<DateTime> importedAt,
      Value<DateTime> updatedAt,
      Value<DateTime?> deletedAt,
      Value<int> rowid,
    });
typedef $$ImportedScoresTableUpdateCompanionBuilder =
    ImportedScoresCompanion Function({
      Value<String> id,
      Value<DateTime> date,
      Value<String> roundName,
      Value<int> score,
      Value<int?> xCount,
      Value<String?> location,
      Value<String?> notes,
      Value<String> sessionType,
      Value<String> source,
      Value<DateTime> importedAt,
      Value<DateTime> updatedAt,
      Value<DateTime?> deletedAt,
      Value<int> rowid,
    });

class $$ImportedScoresTableFilterComposer
    extends Composer<_$AppDatabase, $ImportedScoresTable> {
  $$ImportedScoresTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get date => $composableBuilder(
    column: $table.date,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get roundName => $composableBuilder(
    column: $table.roundName,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get score => $composableBuilder(
    column: $table.score,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get xCount => $composableBuilder(
    column: $table.xCount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get location => $composableBuilder(
    column: $table.location,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get sessionType => $composableBuilder(
    column: $table.sessionType,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get source => $composableBuilder(
    column: $table.source,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get importedAt => $composableBuilder(
    column: $table.importedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get deletedAt => $composableBuilder(
    column: $table.deletedAt,
    builder: (column) => ColumnFilters(column),
  );
}

class $$ImportedScoresTableOrderingComposer
    extends Composer<_$AppDatabase, $ImportedScoresTable> {
  $$ImportedScoresTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get date => $composableBuilder(
    column: $table.date,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get roundName => $composableBuilder(
    column: $table.roundName,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get score => $composableBuilder(
    column: $table.score,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get xCount => $composableBuilder(
    column: $table.xCount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get location => $composableBuilder(
    column: $table.location,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get sessionType => $composableBuilder(
    column: $table.sessionType,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get source => $composableBuilder(
    column: $table.source,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get importedAt => $composableBuilder(
    column: $table.importedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get deletedAt => $composableBuilder(
    column: $table.deletedAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$ImportedScoresTableAnnotationComposer
    extends Composer<_$AppDatabase, $ImportedScoresTable> {
  $$ImportedScoresTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<DateTime> get date =>
      $composableBuilder(column: $table.date, builder: (column) => column);

  GeneratedColumn<String> get roundName =>
      $composableBuilder(column: $table.roundName, builder: (column) => column);

  GeneratedColumn<int> get score =>
      $composableBuilder(column: $table.score, builder: (column) => column);

  GeneratedColumn<int> get xCount =>
      $composableBuilder(column: $table.xCount, builder: (column) => column);

  GeneratedColumn<String> get location =>
      $composableBuilder(column: $table.location, builder: (column) => column);

  GeneratedColumn<String> get notes =>
      $composableBuilder(column: $table.notes, builder: (column) => column);

  GeneratedColumn<String> get sessionType => $composableBuilder(
    column: $table.sessionType,
    builder: (column) => column,
  );

  GeneratedColumn<String> get source =>
      $composableBuilder(column: $table.source, builder: (column) => column);

  GeneratedColumn<DateTime> get importedAt => $composableBuilder(
    column: $table.importedAt,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  GeneratedColumn<DateTime> get deletedAt =>
      $composableBuilder(column: $table.deletedAt, builder: (column) => column);
}

class $$ImportedScoresTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $ImportedScoresTable,
          ImportedScore,
          $$ImportedScoresTableFilterComposer,
          $$ImportedScoresTableOrderingComposer,
          $$ImportedScoresTableAnnotationComposer,
          $$ImportedScoresTableCreateCompanionBuilder,
          $$ImportedScoresTableUpdateCompanionBuilder,
          (
            ImportedScore,
            BaseReferences<_$AppDatabase, $ImportedScoresTable, ImportedScore>,
          ),
          ImportedScore,
          PrefetchHooks Function()
        > {
  $$ImportedScoresTableTableManager(
    _$AppDatabase db,
    $ImportedScoresTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$ImportedScoresTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$ImportedScoresTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$ImportedScoresTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<DateTime> date = const Value.absent(),
                Value<String> roundName = const Value.absent(),
                Value<int> score = const Value.absent(),
                Value<int?> xCount = const Value.absent(),
                Value<String?> location = const Value.absent(),
                Value<String?> notes = const Value.absent(),
                Value<String> sessionType = const Value.absent(),
                Value<String> source = const Value.absent(),
                Value<DateTime> importedAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<DateTime?> deletedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => ImportedScoresCompanion(
                id: id,
                date: date,
                roundName: roundName,
                score: score,
                xCount: xCount,
                location: location,
                notes: notes,
                sessionType: sessionType,
                source: source,
                importedAt: importedAt,
                updatedAt: updatedAt,
                deletedAt: deletedAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required DateTime date,
                required String roundName,
                required int score,
                Value<int?> xCount = const Value.absent(),
                Value<String?> location = const Value.absent(),
                Value<String?> notes = const Value.absent(),
                Value<String> sessionType = const Value.absent(),
                Value<String> source = const Value.absent(),
                Value<DateTime> importedAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<DateTime?> deletedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => ImportedScoresCompanion.insert(
                id: id,
                date: date,
                roundName: roundName,
                score: score,
                xCount: xCount,
                location: location,
                notes: notes,
                sessionType: sessionType,
                source: source,
                importedAt: importedAt,
                updatedAt: updatedAt,
                deletedAt: deletedAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$ImportedScoresTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $ImportedScoresTable,
      ImportedScore,
      $$ImportedScoresTableFilterComposer,
      $$ImportedScoresTableOrderingComposer,
      $$ImportedScoresTableAnnotationComposer,
      $$ImportedScoresTableCreateCompanionBuilder,
      $$ImportedScoresTableUpdateCompanionBuilder,
      (
        ImportedScore,
        BaseReferences<_$AppDatabase, $ImportedScoresTable, ImportedScore>,
      ),
      ImportedScore,
      PrefetchHooks Function()
    >;
typedef $$UserPreferencesTableCreateCompanionBuilder =
    UserPreferencesCompanion Function({
      required String key,
      required String value,
      Value<int> rowid,
    });
typedef $$UserPreferencesTableUpdateCompanionBuilder =
    UserPreferencesCompanion Function({
      Value<String> key,
      Value<String> value,
      Value<int> rowid,
    });

class $$UserPreferencesTableFilterComposer
    extends Composer<_$AppDatabase, $UserPreferencesTable> {
  $$UserPreferencesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get key => $composableBuilder(
    column: $table.key,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get value => $composableBuilder(
    column: $table.value,
    builder: (column) => ColumnFilters(column),
  );
}

class $$UserPreferencesTableOrderingComposer
    extends Composer<_$AppDatabase, $UserPreferencesTable> {
  $$UserPreferencesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get key => $composableBuilder(
    column: $table.key,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get value => $composableBuilder(
    column: $table.value,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$UserPreferencesTableAnnotationComposer
    extends Composer<_$AppDatabase, $UserPreferencesTable> {
  $$UserPreferencesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get key =>
      $composableBuilder(column: $table.key, builder: (column) => column);

  GeneratedColumn<String> get value =>
      $composableBuilder(column: $table.value, builder: (column) => column);
}

class $$UserPreferencesTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $UserPreferencesTable,
          UserPreference,
          $$UserPreferencesTableFilterComposer,
          $$UserPreferencesTableOrderingComposer,
          $$UserPreferencesTableAnnotationComposer,
          $$UserPreferencesTableCreateCompanionBuilder,
          $$UserPreferencesTableUpdateCompanionBuilder,
          (
            UserPreference,
            BaseReferences<
              _$AppDatabase,
              $UserPreferencesTable,
              UserPreference
            >,
          ),
          UserPreference,
          PrefetchHooks Function()
        > {
  $$UserPreferencesTableTableManager(
    _$AppDatabase db,
    $UserPreferencesTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$UserPreferencesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$UserPreferencesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$UserPreferencesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> key = const Value.absent(),
                Value<String> value = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => UserPreferencesCompanion(
                key: key,
                value: value,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String key,
                required String value,
                Value<int> rowid = const Value.absent(),
              }) => UserPreferencesCompanion.insert(
                key: key,
                value: value,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$UserPreferencesTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $UserPreferencesTable,
      UserPreference,
      $$UserPreferencesTableFilterComposer,
      $$UserPreferencesTableOrderingComposer,
      $$UserPreferencesTableAnnotationComposer,
      $$UserPreferencesTableCreateCompanionBuilder,
      $$UserPreferencesTableUpdateCompanionBuilder,
      (
        UserPreference,
        BaseReferences<_$AppDatabase, $UserPreferencesTable, UserPreference>,
      ),
      UserPreference,
      PrefetchHooks Function()
    >;
typedef $$FingerTabsTableCreateCompanionBuilder =
    FingerTabsCompanion Function({
      required String id,
      required String name,
      Value<String?> make,
      Value<String?> model,
      Value<String?> size,
      Value<String?> plateType,
      Value<String?> fingerSpacer,
      Value<String?> notes,
      Value<bool> isDefault,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<DateTime?> deletedAt,
      Value<int> rowid,
    });
typedef $$FingerTabsTableUpdateCompanionBuilder =
    FingerTabsCompanion Function({
      Value<String> id,
      Value<String> name,
      Value<String?> make,
      Value<String?> model,
      Value<String?> size,
      Value<String?> plateType,
      Value<String?> fingerSpacer,
      Value<String?> notes,
      Value<bool> isDefault,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<DateTime?> deletedAt,
      Value<int> rowid,
    });

class $$FingerTabsTableFilterComposer
    extends Composer<_$AppDatabase, $FingerTabsTable> {
  $$FingerTabsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get make => $composableBuilder(
    column: $table.make,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get model => $composableBuilder(
    column: $table.model,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get size => $composableBuilder(
    column: $table.size,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get plateType => $composableBuilder(
    column: $table.plateType,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get fingerSpacer => $composableBuilder(
    column: $table.fingerSpacer,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isDefault => $composableBuilder(
    column: $table.isDefault,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get deletedAt => $composableBuilder(
    column: $table.deletedAt,
    builder: (column) => ColumnFilters(column),
  );
}

class $$FingerTabsTableOrderingComposer
    extends Composer<_$AppDatabase, $FingerTabsTable> {
  $$FingerTabsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get make => $composableBuilder(
    column: $table.make,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get model => $composableBuilder(
    column: $table.model,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get size => $composableBuilder(
    column: $table.size,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get plateType => $composableBuilder(
    column: $table.plateType,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get fingerSpacer => $composableBuilder(
    column: $table.fingerSpacer,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isDefault => $composableBuilder(
    column: $table.isDefault,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get deletedAt => $composableBuilder(
    column: $table.deletedAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$FingerTabsTableAnnotationComposer
    extends Composer<_$AppDatabase, $FingerTabsTable> {
  $$FingerTabsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get make =>
      $composableBuilder(column: $table.make, builder: (column) => column);

  GeneratedColumn<String> get model =>
      $composableBuilder(column: $table.model, builder: (column) => column);

  GeneratedColumn<String> get size =>
      $composableBuilder(column: $table.size, builder: (column) => column);

  GeneratedColumn<String> get plateType =>
      $composableBuilder(column: $table.plateType, builder: (column) => column);

  GeneratedColumn<String> get fingerSpacer => $composableBuilder(
    column: $table.fingerSpacer,
    builder: (column) => column,
  );

  GeneratedColumn<String> get notes =>
      $composableBuilder(column: $table.notes, builder: (column) => column);

  GeneratedColumn<bool> get isDefault =>
      $composableBuilder(column: $table.isDefault, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  GeneratedColumn<DateTime> get deletedAt =>
      $composableBuilder(column: $table.deletedAt, builder: (column) => column);
}

class $$FingerTabsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $FingerTabsTable,
          FingerTab,
          $$FingerTabsTableFilterComposer,
          $$FingerTabsTableOrderingComposer,
          $$FingerTabsTableAnnotationComposer,
          $$FingerTabsTableCreateCompanionBuilder,
          $$FingerTabsTableUpdateCompanionBuilder,
          (
            FingerTab,
            BaseReferences<_$AppDatabase, $FingerTabsTable, FingerTab>,
          ),
          FingerTab,
          PrefetchHooks Function()
        > {
  $$FingerTabsTableTableManager(_$AppDatabase db, $FingerTabsTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$FingerTabsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$FingerTabsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$FingerTabsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<String?> make = const Value.absent(),
                Value<String?> model = const Value.absent(),
                Value<String?> size = const Value.absent(),
                Value<String?> plateType = const Value.absent(),
                Value<String?> fingerSpacer = const Value.absent(),
                Value<String?> notes = const Value.absent(),
                Value<bool> isDefault = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<DateTime?> deletedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => FingerTabsCompanion(
                id: id,
                name: name,
                make: make,
                model: model,
                size: size,
                plateType: plateType,
                fingerSpacer: fingerSpacer,
                notes: notes,
                isDefault: isDefault,
                createdAt: createdAt,
                updatedAt: updatedAt,
                deletedAt: deletedAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String name,
                Value<String?> make = const Value.absent(),
                Value<String?> model = const Value.absent(),
                Value<String?> size = const Value.absent(),
                Value<String?> plateType = const Value.absent(),
                Value<String?> fingerSpacer = const Value.absent(),
                Value<String?> notes = const Value.absent(),
                Value<bool> isDefault = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<DateTime?> deletedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => FingerTabsCompanion.insert(
                id: id,
                name: name,
                make: make,
                model: model,
                size: size,
                plateType: plateType,
                fingerSpacer: fingerSpacer,
                notes: notes,
                isDefault: isDefault,
                createdAt: createdAt,
                updatedAt: updatedAt,
                deletedAt: deletedAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$FingerTabsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $FingerTabsTable,
      FingerTab,
      $$FingerTabsTableFilterComposer,
      $$FingerTabsTableOrderingComposer,
      $$FingerTabsTableAnnotationComposer,
      $$FingerTabsTableCreateCompanionBuilder,
      $$FingerTabsTableUpdateCompanionBuilder,
      (FingerTab, BaseReferences<_$AppDatabase, $FingerTabsTable, FingerTab>),
      FingerTab,
      PrefetchHooks Function()
    >;
typedef $$StabilizersTableCreateCompanionBuilder =
    StabilizersCompanion Function({
      required String id,
      required String bowId,
      Value<String?> name,
      Value<String?> longRodModel,
      Value<double?> longRodLength,
      Value<double?> longRodWeight,
      Value<DateTime?> longRodPurchaseDate,
      Value<String?> leftSideRodModel,
      Value<double?> leftSideRodLength,
      Value<double?> leftSideRodWeight,
      Value<String?> leftWeights,
      Value<double?> leftAngleHorizontal,
      Value<double?> leftAngleVertical,
      Value<String?> rightSideRodModel,
      Value<double?> rightSideRodLength,
      Value<double?> rightSideRodWeight,
      Value<String?> rightWeights,
      Value<double?> rightAngleHorizontal,
      Value<double?> rightAngleVertical,
      Value<String?> sideRodModel,
      Value<double?> sideRodLength,
      Value<double?> sideRodWeight,
      Value<DateTime?> sideRodPurchaseDate,
      Value<double?> extenderLength,
      Value<String?> vbarModel,
      Value<double?> vbarAngleHorizontal,
      Value<double?> vbarAngleVertical,
      Value<String?> longRodWeights,
      Value<String?> weightArrangement,
      Value<String?> setupPhotoPath,
      Value<String?> damperModel,
      Value<String?> damperPositions,
      Value<String?> notes,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<int> rowid,
    });
typedef $$StabilizersTableUpdateCompanionBuilder =
    StabilizersCompanion Function({
      Value<String> id,
      Value<String> bowId,
      Value<String?> name,
      Value<String?> longRodModel,
      Value<double?> longRodLength,
      Value<double?> longRodWeight,
      Value<DateTime?> longRodPurchaseDate,
      Value<String?> leftSideRodModel,
      Value<double?> leftSideRodLength,
      Value<double?> leftSideRodWeight,
      Value<String?> leftWeights,
      Value<double?> leftAngleHorizontal,
      Value<double?> leftAngleVertical,
      Value<String?> rightSideRodModel,
      Value<double?> rightSideRodLength,
      Value<double?> rightSideRodWeight,
      Value<String?> rightWeights,
      Value<double?> rightAngleHorizontal,
      Value<double?> rightAngleVertical,
      Value<String?> sideRodModel,
      Value<double?> sideRodLength,
      Value<double?> sideRodWeight,
      Value<DateTime?> sideRodPurchaseDate,
      Value<double?> extenderLength,
      Value<String?> vbarModel,
      Value<double?> vbarAngleHorizontal,
      Value<double?> vbarAngleVertical,
      Value<String?> longRodWeights,
      Value<String?> weightArrangement,
      Value<String?> setupPhotoPath,
      Value<String?> damperModel,
      Value<String?> damperPositions,
      Value<String?> notes,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<int> rowid,
    });

final class $$StabilizersTableReferences
    extends BaseReferences<_$AppDatabase, $StabilizersTable, Stabilizer> {
  $$StabilizersTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $BowsTable _bowIdTable(_$AppDatabase db) => db.bows.createAlias(
    $_aliasNameGenerator(db.stabilizers.bowId, db.bows.id),
  );

  $$BowsTableProcessedTableManager get bowId {
    final $_column = $_itemColumn<String>('bow_id')!;

    final manager = $$BowsTableTableManager(
      $_db,
      $_db.bows,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_bowIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$StabilizersTableFilterComposer
    extends Composer<_$AppDatabase, $StabilizersTable> {
  $$StabilizersTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get longRodModel => $composableBuilder(
    column: $table.longRodModel,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get longRodLength => $composableBuilder(
    column: $table.longRodLength,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get longRodWeight => $composableBuilder(
    column: $table.longRodWeight,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get longRodPurchaseDate => $composableBuilder(
    column: $table.longRodPurchaseDate,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get leftSideRodModel => $composableBuilder(
    column: $table.leftSideRodModel,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get leftSideRodLength => $composableBuilder(
    column: $table.leftSideRodLength,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get leftSideRodWeight => $composableBuilder(
    column: $table.leftSideRodWeight,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get leftWeights => $composableBuilder(
    column: $table.leftWeights,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get leftAngleHorizontal => $composableBuilder(
    column: $table.leftAngleHorizontal,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get leftAngleVertical => $composableBuilder(
    column: $table.leftAngleVertical,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get rightSideRodModel => $composableBuilder(
    column: $table.rightSideRodModel,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get rightSideRodLength => $composableBuilder(
    column: $table.rightSideRodLength,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get rightSideRodWeight => $composableBuilder(
    column: $table.rightSideRodWeight,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get rightWeights => $composableBuilder(
    column: $table.rightWeights,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get rightAngleHorizontal => $composableBuilder(
    column: $table.rightAngleHorizontal,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get rightAngleVertical => $composableBuilder(
    column: $table.rightAngleVertical,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get sideRodModel => $composableBuilder(
    column: $table.sideRodModel,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get sideRodLength => $composableBuilder(
    column: $table.sideRodLength,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get sideRodWeight => $composableBuilder(
    column: $table.sideRodWeight,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get sideRodPurchaseDate => $composableBuilder(
    column: $table.sideRodPurchaseDate,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get extenderLength => $composableBuilder(
    column: $table.extenderLength,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get vbarModel => $composableBuilder(
    column: $table.vbarModel,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get vbarAngleHorizontal => $composableBuilder(
    column: $table.vbarAngleHorizontal,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get vbarAngleVertical => $composableBuilder(
    column: $table.vbarAngleVertical,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get longRodWeights => $composableBuilder(
    column: $table.longRodWeights,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get weightArrangement => $composableBuilder(
    column: $table.weightArrangement,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get setupPhotoPath => $composableBuilder(
    column: $table.setupPhotoPath,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get damperModel => $composableBuilder(
    column: $table.damperModel,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get damperPositions => $composableBuilder(
    column: $table.damperPositions,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );

  $$BowsTableFilterComposer get bowId {
    final $$BowsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.bowId,
      referencedTable: $db.bows,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$BowsTableFilterComposer(
            $db: $db,
            $table: $db.bows,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$StabilizersTableOrderingComposer
    extends Composer<_$AppDatabase, $StabilizersTable> {
  $$StabilizersTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get longRodModel => $composableBuilder(
    column: $table.longRodModel,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get longRodLength => $composableBuilder(
    column: $table.longRodLength,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get longRodWeight => $composableBuilder(
    column: $table.longRodWeight,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get longRodPurchaseDate => $composableBuilder(
    column: $table.longRodPurchaseDate,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get leftSideRodModel => $composableBuilder(
    column: $table.leftSideRodModel,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get leftSideRodLength => $composableBuilder(
    column: $table.leftSideRodLength,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get leftSideRodWeight => $composableBuilder(
    column: $table.leftSideRodWeight,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get leftWeights => $composableBuilder(
    column: $table.leftWeights,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get leftAngleHorizontal => $composableBuilder(
    column: $table.leftAngleHorizontal,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get leftAngleVertical => $composableBuilder(
    column: $table.leftAngleVertical,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get rightSideRodModel => $composableBuilder(
    column: $table.rightSideRodModel,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get rightSideRodLength => $composableBuilder(
    column: $table.rightSideRodLength,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get rightSideRodWeight => $composableBuilder(
    column: $table.rightSideRodWeight,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get rightWeights => $composableBuilder(
    column: $table.rightWeights,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get rightAngleHorizontal => $composableBuilder(
    column: $table.rightAngleHorizontal,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get rightAngleVertical => $composableBuilder(
    column: $table.rightAngleVertical,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get sideRodModel => $composableBuilder(
    column: $table.sideRodModel,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get sideRodLength => $composableBuilder(
    column: $table.sideRodLength,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get sideRodWeight => $composableBuilder(
    column: $table.sideRodWeight,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get sideRodPurchaseDate => $composableBuilder(
    column: $table.sideRodPurchaseDate,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get extenderLength => $composableBuilder(
    column: $table.extenderLength,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get vbarModel => $composableBuilder(
    column: $table.vbarModel,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get vbarAngleHorizontal => $composableBuilder(
    column: $table.vbarAngleHorizontal,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get vbarAngleVertical => $composableBuilder(
    column: $table.vbarAngleVertical,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get longRodWeights => $composableBuilder(
    column: $table.longRodWeights,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get weightArrangement => $composableBuilder(
    column: $table.weightArrangement,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get setupPhotoPath => $composableBuilder(
    column: $table.setupPhotoPath,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get damperModel => $composableBuilder(
    column: $table.damperModel,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get damperPositions => $composableBuilder(
    column: $table.damperPositions,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  $$BowsTableOrderingComposer get bowId {
    final $$BowsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.bowId,
      referencedTable: $db.bows,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$BowsTableOrderingComposer(
            $db: $db,
            $table: $db.bows,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$StabilizersTableAnnotationComposer
    extends Composer<_$AppDatabase, $StabilizersTable> {
  $$StabilizersTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get longRodModel => $composableBuilder(
    column: $table.longRodModel,
    builder: (column) => column,
  );

  GeneratedColumn<double> get longRodLength => $composableBuilder(
    column: $table.longRodLength,
    builder: (column) => column,
  );

  GeneratedColumn<double> get longRodWeight => $composableBuilder(
    column: $table.longRodWeight,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get longRodPurchaseDate => $composableBuilder(
    column: $table.longRodPurchaseDate,
    builder: (column) => column,
  );

  GeneratedColumn<String> get leftSideRodModel => $composableBuilder(
    column: $table.leftSideRodModel,
    builder: (column) => column,
  );

  GeneratedColumn<double> get leftSideRodLength => $composableBuilder(
    column: $table.leftSideRodLength,
    builder: (column) => column,
  );

  GeneratedColumn<double> get leftSideRodWeight => $composableBuilder(
    column: $table.leftSideRodWeight,
    builder: (column) => column,
  );

  GeneratedColumn<String> get leftWeights => $composableBuilder(
    column: $table.leftWeights,
    builder: (column) => column,
  );

  GeneratedColumn<double> get leftAngleHorizontal => $composableBuilder(
    column: $table.leftAngleHorizontal,
    builder: (column) => column,
  );

  GeneratedColumn<double> get leftAngleVertical => $composableBuilder(
    column: $table.leftAngleVertical,
    builder: (column) => column,
  );

  GeneratedColumn<String> get rightSideRodModel => $composableBuilder(
    column: $table.rightSideRodModel,
    builder: (column) => column,
  );

  GeneratedColumn<double> get rightSideRodLength => $composableBuilder(
    column: $table.rightSideRodLength,
    builder: (column) => column,
  );

  GeneratedColumn<double> get rightSideRodWeight => $composableBuilder(
    column: $table.rightSideRodWeight,
    builder: (column) => column,
  );

  GeneratedColumn<String> get rightWeights => $composableBuilder(
    column: $table.rightWeights,
    builder: (column) => column,
  );

  GeneratedColumn<double> get rightAngleHorizontal => $composableBuilder(
    column: $table.rightAngleHorizontal,
    builder: (column) => column,
  );

  GeneratedColumn<double> get rightAngleVertical => $composableBuilder(
    column: $table.rightAngleVertical,
    builder: (column) => column,
  );

  GeneratedColumn<String> get sideRodModel => $composableBuilder(
    column: $table.sideRodModel,
    builder: (column) => column,
  );

  GeneratedColumn<double> get sideRodLength => $composableBuilder(
    column: $table.sideRodLength,
    builder: (column) => column,
  );

  GeneratedColumn<double> get sideRodWeight => $composableBuilder(
    column: $table.sideRodWeight,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get sideRodPurchaseDate => $composableBuilder(
    column: $table.sideRodPurchaseDate,
    builder: (column) => column,
  );

  GeneratedColumn<double> get extenderLength => $composableBuilder(
    column: $table.extenderLength,
    builder: (column) => column,
  );

  GeneratedColumn<String> get vbarModel =>
      $composableBuilder(column: $table.vbarModel, builder: (column) => column);

  GeneratedColumn<double> get vbarAngleHorizontal => $composableBuilder(
    column: $table.vbarAngleHorizontal,
    builder: (column) => column,
  );

  GeneratedColumn<double> get vbarAngleVertical => $composableBuilder(
    column: $table.vbarAngleVertical,
    builder: (column) => column,
  );

  GeneratedColumn<String> get longRodWeights => $composableBuilder(
    column: $table.longRodWeights,
    builder: (column) => column,
  );

  GeneratedColumn<String> get weightArrangement => $composableBuilder(
    column: $table.weightArrangement,
    builder: (column) => column,
  );

  GeneratedColumn<String> get setupPhotoPath => $composableBuilder(
    column: $table.setupPhotoPath,
    builder: (column) => column,
  );

  GeneratedColumn<String> get damperModel => $composableBuilder(
    column: $table.damperModel,
    builder: (column) => column,
  );

  GeneratedColumn<String> get damperPositions => $composableBuilder(
    column: $table.damperPositions,
    builder: (column) => column,
  );

  GeneratedColumn<String> get notes =>
      $composableBuilder(column: $table.notes, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  $$BowsTableAnnotationComposer get bowId {
    final $$BowsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.bowId,
      referencedTable: $db.bows,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$BowsTableAnnotationComposer(
            $db: $db,
            $table: $db.bows,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$StabilizersTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $StabilizersTable,
          Stabilizer,
          $$StabilizersTableFilterComposer,
          $$StabilizersTableOrderingComposer,
          $$StabilizersTableAnnotationComposer,
          $$StabilizersTableCreateCompanionBuilder,
          $$StabilizersTableUpdateCompanionBuilder,
          (Stabilizer, $$StabilizersTableReferences),
          Stabilizer,
          PrefetchHooks Function({bool bowId})
        > {
  $$StabilizersTableTableManager(_$AppDatabase db, $StabilizersTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$StabilizersTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$StabilizersTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$StabilizersTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> bowId = const Value.absent(),
                Value<String?> name = const Value.absent(),
                Value<String?> longRodModel = const Value.absent(),
                Value<double?> longRodLength = const Value.absent(),
                Value<double?> longRodWeight = const Value.absent(),
                Value<DateTime?> longRodPurchaseDate = const Value.absent(),
                Value<String?> leftSideRodModel = const Value.absent(),
                Value<double?> leftSideRodLength = const Value.absent(),
                Value<double?> leftSideRodWeight = const Value.absent(),
                Value<String?> leftWeights = const Value.absent(),
                Value<double?> leftAngleHorizontal = const Value.absent(),
                Value<double?> leftAngleVertical = const Value.absent(),
                Value<String?> rightSideRodModel = const Value.absent(),
                Value<double?> rightSideRodLength = const Value.absent(),
                Value<double?> rightSideRodWeight = const Value.absent(),
                Value<String?> rightWeights = const Value.absent(),
                Value<double?> rightAngleHorizontal = const Value.absent(),
                Value<double?> rightAngleVertical = const Value.absent(),
                Value<String?> sideRodModel = const Value.absent(),
                Value<double?> sideRodLength = const Value.absent(),
                Value<double?> sideRodWeight = const Value.absent(),
                Value<DateTime?> sideRodPurchaseDate = const Value.absent(),
                Value<double?> extenderLength = const Value.absent(),
                Value<String?> vbarModel = const Value.absent(),
                Value<double?> vbarAngleHorizontal = const Value.absent(),
                Value<double?> vbarAngleVertical = const Value.absent(),
                Value<String?> longRodWeights = const Value.absent(),
                Value<String?> weightArrangement = const Value.absent(),
                Value<String?> setupPhotoPath = const Value.absent(),
                Value<String?> damperModel = const Value.absent(),
                Value<String?> damperPositions = const Value.absent(),
                Value<String?> notes = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => StabilizersCompanion(
                id: id,
                bowId: bowId,
                name: name,
                longRodModel: longRodModel,
                longRodLength: longRodLength,
                longRodWeight: longRodWeight,
                longRodPurchaseDate: longRodPurchaseDate,
                leftSideRodModel: leftSideRodModel,
                leftSideRodLength: leftSideRodLength,
                leftSideRodWeight: leftSideRodWeight,
                leftWeights: leftWeights,
                leftAngleHorizontal: leftAngleHorizontal,
                leftAngleVertical: leftAngleVertical,
                rightSideRodModel: rightSideRodModel,
                rightSideRodLength: rightSideRodLength,
                rightSideRodWeight: rightSideRodWeight,
                rightWeights: rightWeights,
                rightAngleHorizontal: rightAngleHorizontal,
                rightAngleVertical: rightAngleVertical,
                sideRodModel: sideRodModel,
                sideRodLength: sideRodLength,
                sideRodWeight: sideRodWeight,
                sideRodPurchaseDate: sideRodPurchaseDate,
                extenderLength: extenderLength,
                vbarModel: vbarModel,
                vbarAngleHorizontal: vbarAngleHorizontal,
                vbarAngleVertical: vbarAngleVertical,
                longRodWeights: longRodWeights,
                weightArrangement: weightArrangement,
                setupPhotoPath: setupPhotoPath,
                damperModel: damperModel,
                damperPositions: damperPositions,
                notes: notes,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String bowId,
                Value<String?> name = const Value.absent(),
                Value<String?> longRodModel = const Value.absent(),
                Value<double?> longRodLength = const Value.absent(),
                Value<double?> longRodWeight = const Value.absent(),
                Value<DateTime?> longRodPurchaseDate = const Value.absent(),
                Value<String?> leftSideRodModel = const Value.absent(),
                Value<double?> leftSideRodLength = const Value.absent(),
                Value<double?> leftSideRodWeight = const Value.absent(),
                Value<String?> leftWeights = const Value.absent(),
                Value<double?> leftAngleHorizontal = const Value.absent(),
                Value<double?> leftAngleVertical = const Value.absent(),
                Value<String?> rightSideRodModel = const Value.absent(),
                Value<double?> rightSideRodLength = const Value.absent(),
                Value<double?> rightSideRodWeight = const Value.absent(),
                Value<String?> rightWeights = const Value.absent(),
                Value<double?> rightAngleHorizontal = const Value.absent(),
                Value<double?> rightAngleVertical = const Value.absent(),
                Value<String?> sideRodModel = const Value.absent(),
                Value<double?> sideRodLength = const Value.absent(),
                Value<double?> sideRodWeight = const Value.absent(),
                Value<DateTime?> sideRodPurchaseDate = const Value.absent(),
                Value<double?> extenderLength = const Value.absent(),
                Value<String?> vbarModel = const Value.absent(),
                Value<double?> vbarAngleHorizontal = const Value.absent(),
                Value<double?> vbarAngleVertical = const Value.absent(),
                Value<String?> longRodWeights = const Value.absent(),
                Value<String?> weightArrangement = const Value.absent(),
                Value<String?> setupPhotoPath = const Value.absent(),
                Value<String?> damperModel = const Value.absent(),
                Value<String?> damperPositions = const Value.absent(),
                Value<String?> notes = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => StabilizersCompanion.insert(
                id: id,
                bowId: bowId,
                name: name,
                longRodModel: longRodModel,
                longRodLength: longRodLength,
                longRodWeight: longRodWeight,
                longRodPurchaseDate: longRodPurchaseDate,
                leftSideRodModel: leftSideRodModel,
                leftSideRodLength: leftSideRodLength,
                leftSideRodWeight: leftSideRodWeight,
                leftWeights: leftWeights,
                leftAngleHorizontal: leftAngleHorizontal,
                leftAngleVertical: leftAngleVertical,
                rightSideRodModel: rightSideRodModel,
                rightSideRodLength: rightSideRodLength,
                rightSideRodWeight: rightSideRodWeight,
                rightWeights: rightWeights,
                rightAngleHorizontal: rightAngleHorizontal,
                rightAngleVertical: rightAngleVertical,
                sideRodModel: sideRodModel,
                sideRodLength: sideRodLength,
                sideRodWeight: sideRodWeight,
                sideRodPurchaseDate: sideRodPurchaseDate,
                extenderLength: extenderLength,
                vbarModel: vbarModel,
                vbarAngleHorizontal: vbarAngleHorizontal,
                vbarAngleVertical: vbarAngleVertical,
                longRodWeights: longRodWeights,
                weightArrangement: weightArrangement,
                setupPhotoPath: setupPhotoPath,
                damperModel: damperModel,
                damperPositions: damperPositions,
                notes: notes,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$StabilizersTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback: ({bowId = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins:
                  <
                    T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic
                    >
                  >(state) {
                    if (bowId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.bowId,
                                referencedTable: $$StabilizersTableReferences
                                    ._bowIdTable(db),
                                referencedColumn: $$StabilizersTableReferences
                                    ._bowIdTable(db)
                                    .id,
                              )
                              as T;
                    }

                    return state;
                  },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ),
      );
}

typedef $$StabilizersTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $StabilizersTable,
      Stabilizer,
      $$StabilizersTableFilterComposer,
      $$StabilizersTableOrderingComposer,
      $$StabilizersTableAnnotationComposer,
      $$StabilizersTableCreateCompanionBuilder,
      $$StabilizersTableUpdateCompanionBuilder,
      (Stabilizer, $$StabilizersTableReferences),
      Stabilizer,
      PrefetchHooks Function({bool bowId})
    >;
typedef $$BowStringsTableCreateCompanionBuilder =
    BowStringsCompanion Function({
      required String id,
      required String bowId,
      Value<String?> name,
      Value<String?> material,
      Value<int?> strandCount,
      Value<String?> servingMaterial,
      Value<double?> stringLength,
      Value<String?> color,
      Value<bool> isActive,
      Value<DateTime?> purchaseDate,
      Value<DateTime?> retiredAt,
      Value<String?> notes,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<int> rowid,
    });
typedef $$BowStringsTableUpdateCompanionBuilder =
    BowStringsCompanion Function({
      Value<String> id,
      Value<String> bowId,
      Value<String?> name,
      Value<String?> material,
      Value<int?> strandCount,
      Value<String?> servingMaterial,
      Value<double?> stringLength,
      Value<String?> color,
      Value<bool> isActive,
      Value<DateTime?> purchaseDate,
      Value<DateTime?> retiredAt,
      Value<String?> notes,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<int> rowid,
    });

final class $$BowStringsTableReferences
    extends BaseReferences<_$AppDatabase, $BowStringsTable, BowString> {
  $$BowStringsTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $BowsTable _bowIdTable(_$AppDatabase db) => db.bows.createAlias(
    $_aliasNameGenerator(db.bowStrings.bowId, db.bows.id),
  );

  $$BowsTableProcessedTableManager get bowId {
    final $_column = $_itemColumn<String>('bow_id')!;

    final manager = $$BowsTableTableManager(
      $_db,
      $_db.bows,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_bowIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$BowStringsTableFilterComposer
    extends Composer<_$AppDatabase, $BowStringsTable> {
  $$BowStringsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get material => $composableBuilder(
    column: $table.material,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get strandCount => $composableBuilder(
    column: $table.strandCount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get servingMaterial => $composableBuilder(
    column: $table.servingMaterial,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get stringLength => $composableBuilder(
    column: $table.stringLength,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get color => $composableBuilder(
    column: $table.color,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isActive => $composableBuilder(
    column: $table.isActive,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get purchaseDate => $composableBuilder(
    column: $table.purchaseDate,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get retiredAt => $composableBuilder(
    column: $table.retiredAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );

  $$BowsTableFilterComposer get bowId {
    final $$BowsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.bowId,
      referencedTable: $db.bows,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$BowsTableFilterComposer(
            $db: $db,
            $table: $db.bows,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$BowStringsTableOrderingComposer
    extends Composer<_$AppDatabase, $BowStringsTable> {
  $$BowStringsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get material => $composableBuilder(
    column: $table.material,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get strandCount => $composableBuilder(
    column: $table.strandCount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get servingMaterial => $composableBuilder(
    column: $table.servingMaterial,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get stringLength => $composableBuilder(
    column: $table.stringLength,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get color => $composableBuilder(
    column: $table.color,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isActive => $composableBuilder(
    column: $table.isActive,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get purchaseDate => $composableBuilder(
    column: $table.purchaseDate,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get retiredAt => $composableBuilder(
    column: $table.retiredAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  $$BowsTableOrderingComposer get bowId {
    final $$BowsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.bowId,
      referencedTable: $db.bows,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$BowsTableOrderingComposer(
            $db: $db,
            $table: $db.bows,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$BowStringsTableAnnotationComposer
    extends Composer<_$AppDatabase, $BowStringsTable> {
  $$BowStringsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get material =>
      $composableBuilder(column: $table.material, builder: (column) => column);

  GeneratedColumn<int> get strandCount => $composableBuilder(
    column: $table.strandCount,
    builder: (column) => column,
  );

  GeneratedColumn<String> get servingMaterial => $composableBuilder(
    column: $table.servingMaterial,
    builder: (column) => column,
  );

  GeneratedColumn<double> get stringLength => $composableBuilder(
    column: $table.stringLength,
    builder: (column) => column,
  );

  GeneratedColumn<String> get color =>
      $composableBuilder(column: $table.color, builder: (column) => column);

  GeneratedColumn<bool> get isActive =>
      $composableBuilder(column: $table.isActive, builder: (column) => column);

  GeneratedColumn<DateTime> get purchaseDate => $composableBuilder(
    column: $table.purchaseDate,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get retiredAt =>
      $composableBuilder(column: $table.retiredAt, builder: (column) => column);

  GeneratedColumn<String> get notes =>
      $composableBuilder(column: $table.notes, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  $$BowsTableAnnotationComposer get bowId {
    final $$BowsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.bowId,
      referencedTable: $db.bows,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$BowsTableAnnotationComposer(
            $db: $db,
            $table: $db.bows,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$BowStringsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $BowStringsTable,
          BowString,
          $$BowStringsTableFilterComposer,
          $$BowStringsTableOrderingComposer,
          $$BowStringsTableAnnotationComposer,
          $$BowStringsTableCreateCompanionBuilder,
          $$BowStringsTableUpdateCompanionBuilder,
          (BowString, $$BowStringsTableReferences),
          BowString,
          PrefetchHooks Function({bool bowId})
        > {
  $$BowStringsTableTableManager(_$AppDatabase db, $BowStringsTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$BowStringsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$BowStringsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$BowStringsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> bowId = const Value.absent(),
                Value<String?> name = const Value.absent(),
                Value<String?> material = const Value.absent(),
                Value<int?> strandCount = const Value.absent(),
                Value<String?> servingMaterial = const Value.absent(),
                Value<double?> stringLength = const Value.absent(),
                Value<String?> color = const Value.absent(),
                Value<bool> isActive = const Value.absent(),
                Value<DateTime?> purchaseDate = const Value.absent(),
                Value<DateTime?> retiredAt = const Value.absent(),
                Value<String?> notes = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => BowStringsCompanion(
                id: id,
                bowId: bowId,
                name: name,
                material: material,
                strandCount: strandCount,
                servingMaterial: servingMaterial,
                stringLength: stringLength,
                color: color,
                isActive: isActive,
                purchaseDate: purchaseDate,
                retiredAt: retiredAt,
                notes: notes,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String bowId,
                Value<String?> name = const Value.absent(),
                Value<String?> material = const Value.absent(),
                Value<int?> strandCount = const Value.absent(),
                Value<String?> servingMaterial = const Value.absent(),
                Value<double?> stringLength = const Value.absent(),
                Value<String?> color = const Value.absent(),
                Value<bool> isActive = const Value.absent(),
                Value<DateTime?> purchaseDate = const Value.absent(),
                Value<DateTime?> retiredAt = const Value.absent(),
                Value<String?> notes = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => BowStringsCompanion.insert(
                id: id,
                bowId: bowId,
                name: name,
                material: material,
                strandCount: strandCount,
                servingMaterial: servingMaterial,
                stringLength: stringLength,
                color: color,
                isActive: isActive,
                purchaseDate: purchaseDate,
                retiredAt: retiredAt,
                notes: notes,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$BowStringsTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback: ({bowId = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins:
                  <
                    T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic
                    >
                  >(state) {
                    if (bowId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.bowId,
                                referencedTable: $$BowStringsTableReferences
                                    ._bowIdTable(db),
                                referencedColumn: $$BowStringsTableReferences
                                    ._bowIdTable(db)
                                    .id,
                              )
                              as T;
                    }

                    return state;
                  },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ),
      );
}

typedef $$BowStringsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $BowStringsTable,
      BowString,
      $$BowStringsTableFilterComposer,
      $$BowStringsTableOrderingComposer,
      $$BowStringsTableAnnotationComposer,
      $$BowStringsTableCreateCompanionBuilder,
      $$BowStringsTableUpdateCompanionBuilder,
      (BowString, $$BowStringsTableReferences),
      BowString,
      PrefetchHooks Function({bool bowId})
    >;
typedef $$VolumeEntriesTableCreateCompanionBuilder =
    VolumeEntriesCompanion Function({
      required String id,
      required DateTime date,
      required int arrowCount,
      Value<String?> title,
      Value<String?> notes,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<DateTime?> deletedAt,
      Value<int> rowid,
    });
typedef $$VolumeEntriesTableUpdateCompanionBuilder =
    VolumeEntriesCompanion Function({
      Value<String> id,
      Value<DateTime> date,
      Value<int> arrowCount,
      Value<String?> title,
      Value<String?> notes,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<DateTime?> deletedAt,
      Value<int> rowid,
    });

class $$VolumeEntriesTableFilterComposer
    extends Composer<_$AppDatabase, $VolumeEntriesTable> {
  $$VolumeEntriesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get date => $composableBuilder(
    column: $table.date,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get arrowCount => $composableBuilder(
    column: $table.arrowCount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get title => $composableBuilder(
    column: $table.title,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get deletedAt => $composableBuilder(
    column: $table.deletedAt,
    builder: (column) => ColumnFilters(column),
  );
}

class $$VolumeEntriesTableOrderingComposer
    extends Composer<_$AppDatabase, $VolumeEntriesTable> {
  $$VolumeEntriesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get date => $composableBuilder(
    column: $table.date,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get arrowCount => $composableBuilder(
    column: $table.arrowCount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get title => $composableBuilder(
    column: $table.title,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get deletedAt => $composableBuilder(
    column: $table.deletedAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$VolumeEntriesTableAnnotationComposer
    extends Composer<_$AppDatabase, $VolumeEntriesTable> {
  $$VolumeEntriesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<DateTime> get date =>
      $composableBuilder(column: $table.date, builder: (column) => column);

  GeneratedColumn<int> get arrowCount => $composableBuilder(
    column: $table.arrowCount,
    builder: (column) => column,
  );

  GeneratedColumn<String> get title =>
      $composableBuilder(column: $table.title, builder: (column) => column);

  GeneratedColumn<String> get notes =>
      $composableBuilder(column: $table.notes, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  GeneratedColumn<DateTime> get deletedAt =>
      $composableBuilder(column: $table.deletedAt, builder: (column) => column);
}

class $$VolumeEntriesTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $VolumeEntriesTable,
          VolumeEntry,
          $$VolumeEntriesTableFilterComposer,
          $$VolumeEntriesTableOrderingComposer,
          $$VolumeEntriesTableAnnotationComposer,
          $$VolumeEntriesTableCreateCompanionBuilder,
          $$VolumeEntriesTableUpdateCompanionBuilder,
          (
            VolumeEntry,
            BaseReferences<_$AppDatabase, $VolumeEntriesTable, VolumeEntry>,
          ),
          VolumeEntry,
          PrefetchHooks Function()
        > {
  $$VolumeEntriesTableTableManager(_$AppDatabase db, $VolumeEntriesTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$VolumeEntriesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$VolumeEntriesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$VolumeEntriesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<DateTime> date = const Value.absent(),
                Value<int> arrowCount = const Value.absent(),
                Value<String?> title = const Value.absent(),
                Value<String?> notes = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<DateTime?> deletedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => VolumeEntriesCompanion(
                id: id,
                date: date,
                arrowCount: arrowCount,
                title: title,
                notes: notes,
                createdAt: createdAt,
                updatedAt: updatedAt,
                deletedAt: deletedAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required DateTime date,
                required int arrowCount,
                Value<String?> title = const Value.absent(),
                Value<String?> notes = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<DateTime?> deletedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => VolumeEntriesCompanion.insert(
                id: id,
                date: date,
                arrowCount: arrowCount,
                title: title,
                notes: notes,
                createdAt: createdAt,
                updatedAt: updatedAt,
                deletedAt: deletedAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$VolumeEntriesTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $VolumeEntriesTable,
      VolumeEntry,
      $$VolumeEntriesTableFilterComposer,
      $$VolumeEntriesTableOrderingComposer,
      $$VolumeEntriesTableAnnotationComposer,
      $$VolumeEntriesTableCreateCompanionBuilder,
      $$VolumeEntriesTableUpdateCompanionBuilder,
      (
        VolumeEntry,
        BaseReferences<_$AppDatabase, $VolumeEntriesTable, VolumeEntry>,
      ),
      VolumeEntry,
      PrefetchHooks Function()
    >;
typedef $$OlyExerciseTypesTableCreateCompanionBuilder =
    OlyExerciseTypesCompanion Function({
      required String id,
      required String name,
      Value<String?> description,
      Value<double> intensity,
      Value<String> category,
      Value<String?> firstIntroducedAt,
      Value<int> sortOrder,
      Value<int> rowid,
    });
typedef $$OlyExerciseTypesTableUpdateCompanionBuilder =
    OlyExerciseTypesCompanion Function({
      Value<String> id,
      Value<String> name,
      Value<String?> description,
      Value<double> intensity,
      Value<String> category,
      Value<String?> firstIntroducedAt,
      Value<int> sortOrder,
      Value<int> rowid,
    });

final class $$OlyExerciseTypesTableReferences
    extends
        BaseReferences<_$AppDatabase, $OlyExerciseTypesTable, OlyExerciseType> {
  $$OlyExerciseTypesTableReferences(
    super.$_db,
    super.$_table,
    super.$_typedResult,
  );

  static MultiTypedResultKey<
    $OlySessionExercisesTable,
    List<OlySessionExercise>
  >
  _olySessionExercisesRefsTable(_$AppDatabase db) =>
      MultiTypedResultKey.fromTable(
        db.olySessionExercises,
        aliasName: $_aliasNameGenerator(
          db.olyExerciseTypes.id,
          db.olySessionExercises.exerciseTypeId,
        ),
      );

  $$OlySessionExercisesTableProcessedTableManager get olySessionExercisesRefs {
    final manager = $$OlySessionExercisesTableTableManager(
      $_db,
      $_db.olySessionExercises,
    ).filter((f) => f.exerciseTypeId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(
      _olySessionExercisesRefsTable($_db),
    );
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$OlyExerciseTypesTableFilterComposer
    extends Composer<_$AppDatabase, $OlyExerciseTypesTable> {
  $$OlyExerciseTypesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get description => $composableBuilder(
    column: $table.description,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get intensity => $composableBuilder(
    column: $table.intensity,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get category => $composableBuilder(
    column: $table.category,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get firstIntroducedAt => $composableBuilder(
    column: $table.firstIntroducedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get sortOrder => $composableBuilder(
    column: $table.sortOrder,
    builder: (column) => ColumnFilters(column),
  );

  Expression<bool> olySessionExercisesRefs(
    Expression<bool> Function($$OlySessionExercisesTableFilterComposer f) f,
  ) {
    final $$OlySessionExercisesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.olySessionExercises,
      getReferencedColumn: (t) => t.exerciseTypeId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$OlySessionExercisesTableFilterComposer(
            $db: $db,
            $table: $db.olySessionExercises,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$OlyExerciseTypesTableOrderingComposer
    extends Composer<_$AppDatabase, $OlyExerciseTypesTable> {
  $$OlyExerciseTypesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get description => $composableBuilder(
    column: $table.description,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get intensity => $composableBuilder(
    column: $table.intensity,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get category => $composableBuilder(
    column: $table.category,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get firstIntroducedAt => $composableBuilder(
    column: $table.firstIntroducedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get sortOrder => $composableBuilder(
    column: $table.sortOrder,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$OlyExerciseTypesTableAnnotationComposer
    extends Composer<_$AppDatabase, $OlyExerciseTypesTable> {
  $$OlyExerciseTypesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get description => $composableBuilder(
    column: $table.description,
    builder: (column) => column,
  );

  GeneratedColumn<double> get intensity =>
      $composableBuilder(column: $table.intensity, builder: (column) => column);

  GeneratedColumn<String> get category =>
      $composableBuilder(column: $table.category, builder: (column) => column);

  GeneratedColumn<String> get firstIntroducedAt => $composableBuilder(
    column: $table.firstIntroducedAt,
    builder: (column) => column,
  );

  GeneratedColumn<int> get sortOrder =>
      $composableBuilder(column: $table.sortOrder, builder: (column) => column);

  Expression<T> olySessionExercisesRefs<T extends Object>(
    Expression<T> Function($$OlySessionExercisesTableAnnotationComposer a) f,
  ) {
    final $$OlySessionExercisesTableAnnotationComposer composer =
        $composerBuilder(
          composer: this,
          getCurrentColumn: (t) => t.id,
          referencedTable: $db.olySessionExercises,
          getReferencedColumn: (t) => t.exerciseTypeId,
          builder:
              (
                joinBuilder, {
                $addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer,
              }) => $$OlySessionExercisesTableAnnotationComposer(
                $db: $db,
                $table: $db.olySessionExercises,
                $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                joinBuilder: joinBuilder,
                $removeJoinBuilderFromRootComposer:
                    $removeJoinBuilderFromRootComposer,
              ),
        );
    return f(composer);
  }
}

class $$OlyExerciseTypesTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $OlyExerciseTypesTable,
          OlyExerciseType,
          $$OlyExerciseTypesTableFilterComposer,
          $$OlyExerciseTypesTableOrderingComposer,
          $$OlyExerciseTypesTableAnnotationComposer,
          $$OlyExerciseTypesTableCreateCompanionBuilder,
          $$OlyExerciseTypesTableUpdateCompanionBuilder,
          (OlyExerciseType, $$OlyExerciseTypesTableReferences),
          OlyExerciseType,
          PrefetchHooks Function({bool olySessionExercisesRefs})
        > {
  $$OlyExerciseTypesTableTableManager(
    _$AppDatabase db,
    $OlyExerciseTypesTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$OlyExerciseTypesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$OlyExerciseTypesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$OlyExerciseTypesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<String?> description = const Value.absent(),
                Value<double> intensity = const Value.absent(),
                Value<String> category = const Value.absent(),
                Value<String?> firstIntroducedAt = const Value.absent(),
                Value<int> sortOrder = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => OlyExerciseTypesCompanion(
                id: id,
                name: name,
                description: description,
                intensity: intensity,
                category: category,
                firstIntroducedAt: firstIntroducedAt,
                sortOrder: sortOrder,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String name,
                Value<String?> description = const Value.absent(),
                Value<double> intensity = const Value.absent(),
                Value<String> category = const Value.absent(),
                Value<String?> firstIntroducedAt = const Value.absent(),
                Value<int> sortOrder = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => OlyExerciseTypesCompanion.insert(
                id: id,
                name: name,
                description: description,
                intensity: intensity,
                category: category,
                firstIntroducedAt: firstIntroducedAt,
                sortOrder: sortOrder,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$OlyExerciseTypesTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback: ({olySessionExercisesRefs = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [
                if (olySessionExercisesRefs) db.olySessionExercises,
              ],
              addJoins: null,
              getPrefetchedDataCallback: (items) async {
                return [
                  if (olySessionExercisesRefs)
                    await $_getPrefetchedData<
                      OlyExerciseType,
                      $OlyExerciseTypesTable,
                      OlySessionExercise
                    >(
                      currentTable: table,
                      referencedTable: $$OlyExerciseTypesTableReferences
                          ._olySessionExercisesRefsTable(db),
                      managerFromTypedResult: (p0) =>
                          $$OlyExerciseTypesTableReferences(
                            db,
                            table,
                            p0,
                          ).olySessionExercisesRefs,
                      referencedItemsForCurrentItem: (item, referencedItems) =>
                          referencedItems.where(
                            (e) => e.exerciseTypeId == item.id,
                          ),
                      typedResults: items,
                    ),
                ];
              },
            );
          },
        ),
      );
}

typedef $$OlyExerciseTypesTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $OlyExerciseTypesTable,
      OlyExerciseType,
      $$OlyExerciseTypesTableFilterComposer,
      $$OlyExerciseTypesTableOrderingComposer,
      $$OlyExerciseTypesTableAnnotationComposer,
      $$OlyExerciseTypesTableCreateCompanionBuilder,
      $$OlyExerciseTypesTableUpdateCompanionBuilder,
      (OlyExerciseType, $$OlyExerciseTypesTableReferences),
      OlyExerciseType,
      PrefetchHooks Function({bool olySessionExercisesRefs})
    >;
typedef $$OlySessionTemplatesTableCreateCompanionBuilder =
    OlySessionTemplatesCompanion Function({
      required String id,
      required String version,
      required String name,
      Value<String?> focus,
      required int durationMinutes,
      required int volumeLoad,
      required int adjustedVolumeLoad,
      required double workRatio,
      required double adjustedWorkRatio,
      Value<String?> requirements,
      Value<String> equipment,
      Value<String?> notes,
      Value<int> sortOrder,
      Value<DateTime> createdAt,
      Value<int> rowid,
    });
typedef $$OlySessionTemplatesTableUpdateCompanionBuilder =
    OlySessionTemplatesCompanion Function({
      Value<String> id,
      Value<String> version,
      Value<String> name,
      Value<String?> focus,
      Value<int> durationMinutes,
      Value<int> volumeLoad,
      Value<int> adjustedVolumeLoad,
      Value<double> workRatio,
      Value<double> adjustedWorkRatio,
      Value<String?> requirements,
      Value<String> equipment,
      Value<String?> notes,
      Value<int> sortOrder,
      Value<DateTime> createdAt,
      Value<int> rowid,
    });

final class $$OlySessionTemplatesTableReferences
    extends
        BaseReferences<
          _$AppDatabase,
          $OlySessionTemplatesTable,
          OlySessionTemplate
        > {
  $$OlySessionTemplatesTableReferences(
    super.$_db,
    super.$_table,
    super.$_typedResult,
  );

  static MultiTypedResultKey<
    $OlySessionExercisesTable,
    List<OlySessionExercise>
  >
  _olySessionExercisesRefsTable(_$AppDatabase db) =>
      MultiTypedResultKey.fromTable(
        db.olySessionExercises,
        aliasName: $_aliasNameGenerator(
          db.olySessionTemplates.id,
          db.olySessionExercises.sessionTemplateId,
        ),
      );

  $$OlySessionExercisesTableProcessedTableManager get olySessionExercisesRefs {
    final manager =
        $$OlySessionExercisesTableTableManager(
          $_db,
          $_db.olySessionExercises,
        ).filter(
          (f) => f.sessionTemplateId.id.sqlEquals($_itemColumn<String>('id')!),
        );

    final cache = $_typedResult.readTableOrNull(
      _olySessionExercisesRefsTable($_db),
    );
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$OlySessionTemplatesTableFilterComposer
    extends Composer<_$AppDatabase, $OlySessionTemplatesTable> {
  $$OlySessionTemplatesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get version => $composableBuilder(
    column: $table.version,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get focus => $composableBuilder(
    column: $table.focus,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get durationMinutes => $composableBuilder(
    column: $table.durationMinutes,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get volumeLoad => $composableBuilder(
    column: $table.volumeLoad,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get adjustedVolumeLoad => $composableBuilder(
    column: $table.adjustedVolumeLoad,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get workRatio => $composableBuilder(
    column: $table.workRatio,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get adjustedWorkRatio => $composableBuilder(
    column: $table.adjustedWorkRatio,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get requirements => $composableBuilder(
    column: $table.requirements,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get equipment => $composableBuilder(
    column: $table.equipment,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get sortOrder => $composableBuilder(
    column: $table.sortOrder,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  Expression<bool> olySessionExercisesRefs(
    Expression<bool> Function($$OlySessionExercisesTableFilterComposer f) f,
  ) {
    final $$OlySessionExercisesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.olySessionExercises,
      getReferencedColumn: (t) => t.sessionTemplateId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$OlySessionExercisesTableFilterComposer(
            $db: $db,
            $table: $db.olySessionExercises,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$OlySessionTemplatesTableOrderingComposer
    extends Composer<_$AppDatabase, $OlySessionTemplatesTable> {
  $$OlySessionTemplatesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get version => $composableBuilder(
    column: $table.version,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get focus => $composableBuilder(
    column: $table.focus,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get durationMinutes => $composableBuilder(
    column: $table.durationMinutes,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get volumeLoad => $composableBuilder(
    column: $table.volumeLoad,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get adjustedVolumeLoad => $composableBuilder(
    column: $table.adjustedVolumeLoad,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get workRatio => $composableBuilder(
    column: $table.workRatio,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get adjustedWorkRatio => $composableBuilder(
    column: $table.adjustedWorkRatio,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get requirements => $composableBuilder(
    column: $table.requirements,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get equipment => $composableBuilder(
    column: $table.equipment,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get sortOrder => $composableBuilder(
    column: $table.sortOrder,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$OlySessionTemplatesTableAnnotationComposer
    extends Composer<_$AppDatabase, $OlySessionTemplatesTable> {
  $$OlySessionTemplatesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get version =>
      $composableBuilder(column: $table.version, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get focus =>
      $composableBuilder(column: $table.focus, builder: (column) => column);

  GeneratedColumn<int> get durationMinutes => $composableBuilder(
    column: $table.durationMinutes,
    builder: (column) => column,
  );

  GeneratedColumn<int> get volumeLoad => $composableBuilder(
    column: $table.volumeLoad,
    builder: (column) => column,
  );

  GeneratedColumn<int> get adjustedVolumeLoad => $composableBuilder(
    column: $table.adjustedVolumeLoad,
    builder: (column) => column,
  );

  GeneratedColumn<double> get workRatio =>
      $composableBuilder(column: $table.workRatio, builder: (column) => column);

  GeneratedColumn<double> get adjustedWorkRatio => $composableBuilder(
    column: $table.adjustedWorkRatio,
    builder: (column) => column,
  );

  GeneratedColumn<String> get requirements => $composableBuilder(
    column: $table.requirements,
    builder: (column) => column,
  );

  GeneratedColumn<String> get equipment =>
      $composableBuilder(column: $table.equipment, builder: (column) => column);

  GeneratedColumn<String> get notes =>
      $composableBuilder(column: $table.notes, builder: (column) => column);

  GeneratedColumn<int> get sortOrder =>
      $composableBuilder(column: $table.sortOrder, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  Expression<T> olySessionExercisesRefs<T extends Object>(
    Expression<T> Function($$OlySessionExercisesTableAnnotationComposer a) f,
  ) {
    final $$OlySessionExercisesTableAnnotationComposer composer =
        $composerBuilder(
          composer: this,
          getCurrentColumn: (t) => t.id,
          referencedTable: $db.olySessionExercises,
          getReferencedColumn: (t) => t.sessionTemplateId,
          builder:
              (
                joinBuilder, {
                $addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer,
              }) => $$OlySessionExercisesTableAnnotationComposer(
                $db: $db,
                $table: $db.olySessionExercises,
                $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                joinBuilder: joinBuilder,
                $removeJoinBuilderFromRootComposer:
                    $removeJoinBuilderFromRootComposer,
              ),
        );
    return f(composer);
  }
}

class $$OlySessionTemplatesTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $OlySessionTemplatesTable,
          OlySessionTemplate,
          $$OlySessionTemplatesTableFilterComposer,
          $$OlySessionTemplatesTableOrderingComposer,
          $$OlySessionTemplatesTableAnnotationComposer,
          $$OlySessionTemplatesTableCreateCompanionBuilder,
          $$OlySessionTemplatesTableUpdateCompanionBuilder,
          (OlySessionTemplate, $$OlySessionTemplatesTableReferences),
          OlySessionTemplate,
          PrefetchHooks Function({bool olySessionExercisesRefs})
        > {
  $$OlySessionTemplatesTableTableManager(
    _$AppDatabase db,
    $OlySessionTemplatesTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$OlySessionTemplatesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$OlySessionTemplatesTableOrderingComposer(
                $db: db,
                $table: table,
              ),
          createComputedFieldComposer: () =>
              $$OlySessionTemplatesTableAnnotationComposer(
                $db: db,
                $table: table,
              ),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> version = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<String?> focus = const Value.absent(),
                Value<int> durationMinutes = const Value.absent(),
                Value<int> volumeLoad = const Value.absent(),
                Value<int> adjustedVolumeLoad = const Value.absent(),
                Value<double> workRatio = const Value.absent(),
                Value<double> adjustedWorkRatio = const Value.absent(),
                Value<String?> requirements = const Value.absent(),
                Value<String> equipment = const Value.absent(),
                Value<String?> notes = const Value.absent(),
                Value<int> sortOrder = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => OlySessionTemplatesCompanion(
                id: id,
                version: version,
                name: name,
                focus: focus,
                durationMinutes: durationMinutes,
                volumeLoad: volumeLoad,
                adjustedVolumeLoad: adjustedVolumeLoad,
                workRatio: workRatio,
                adjustedWorkRatio: adjustedWorkRatio,
                requirements: requirements,
                equipment: equipment,
                notes: notes,
                sortOrder: sortOrder,
                createdAt: createdAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String version,
                required String name,
                Value<String?> focus = const Value.absent(),
                required int durationMinutes,
                required int volumeLoad,
                required int adjustedVolumeLoad,
                required double workRatio,
                required double adjustedWorkRatio,
                Value<String?> requirements = const Value.absent(),
                Value<String> equipment = const Value.absent(),
                Value<String?> notes = const Value.absent(),
                Value<int> sortOrder = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => OlySessionTemplatesCompanion.insert(
                id: id,
                version: version,
                name: name,
                focus: focus,
                durationMinutes: durationMinutes,
                volumeLoad: volumeLoad,
                adjustedVolumeLoad: adjustedVolumeLoad,
                workRatio: workRatio,
                adjustedWorkRatio: adjustedWorkRatio,
                requirements: requirements,
                equipment: equipment,
                notes: notes,
                sortOrder: sortOrder,
                createdAt: createdAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$OlySessionTemplatesTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback: ({olySessionExercisesRefs = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [
                if (olySessionExercisesRefs) db.olySessionExercises,
              ],
              addJoins: null,
              getPrefetchedDataCallback: (items) async {
                return [
                  if (olySessionExercisesRefs)
                    await $_getPrefetchedData<
                      OlySessionTemplate,
                      $OlySessionTemplatesTable,
                      OlySessionExercise
                    >(
                      currentTable: table,
                      referencedTable: $$OlySessionTemplatesTableReferences
                          ._olySessionExercisesRefsTable(db),
                      managerFromTypedResult: (p0) =>
                          $$OlySessionTemplatesTableReferences(
                            db,
                            table,
                            p0,
                          ).olySessionExercisesRefs,
                      referencedItemsForCurrentItem: (item, referencedItems) =>
                          referencedItems.where(
                            (e) => e.sessionTemplateId == item.id,
                          ),
                      typedResults: items,
                    ),
                ];
              },
            );
          },
        ),
      );
}

typedef $$OlySessionTemplatesTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $OlySessionTemplatesTable,
      OlySessionTemplate,
      $$OlySessionTemplatesTableFilterComposer,
      $$OlySessionTemplatesTableOrderingComposer,
      $$OlySessionTemplatesTableAnnotationComposer,
      $$OlySessionTemplatesTableCreateCompanionBuilder,
      $$OlySessionTemplatesTableUpdateCompanionBuilder,
      (OlySessionTemplate, $$OlySessionTemplatesTableReferences),
      OlySessionTemplate,
      PrefetchHooks Function({bool olySessionExercisesRefs})
    >;
typedef $$OlySessionExercisesTableCreateCompanionBuilder =
    OlySessionExercisesCompanion Function({
      required String id,
      required String sessionTemplateId,
      required String exerciseTypeId,
      required int exerciseOrder,
      required int reps,
      required int workSeconds,
      required int restSeconds,
      Value<String?> details,
      Value<double?> intensityOverride,
      Value<int> rowid,
    });
typedef $$OlySessionExercisesTableUpdateCompanionBuilder =
    OlySessionExercisesCompanion Function({
      Value<String> id,
      Value<String> sessionTemplateId,
      Value<String> exerciseTypeId,
      Value<int> exerciseOrder,
      Value<int> reps,
      Value<int> workSeconds,
      Value<int> restSeconds,
      Value<String?> details,
      Value<double?> intensityOverride,
      Value<int> rowid,
    });

final class $$OlySessionExercisesTableReferences
    extends
        BaseReferences<
          _$AppDatabase,
          $OlySessionExercisesTable,
          OlySessionExercise
        > {
  $$OlySessionExercisesTableReferences(
    super.$_db,
    super.$_table,
    super.$_typedResult,
  );

  static $OlySessionTemplatesTable _sessionTemplateIdTable(_$AppDatabase db) =>
      db.olySessionTemplates.createAlias(
        $_aliasNameGenerator(
          db.olySessionExercises.sessionTemplateId,
          db.olySessionTemplates.id,
        ),
      );

  $$OlySessionTemplatesTableProcessedTableManager get sessionTemplateId {
    final $_column = $_itemColumn<String>('session_template_id')!;

    final manager = $$OlySessionTemplatesTableTableManager(
      $_db,
      $_db.olySessionTemplates,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_sessionTemplateIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $OlyExerciseTypesTable _exerciseTypeIdTable(_$AppDatabase db) =>
      db.olyExerciseTypes.createAlias(
        $_aliasNameGenerator(
          db.olySessionExercises.exerciseTypeId,
          db.olyExerciseTypes.id,
        ),
      );

  $$OlyExerciseTypesTableProcessedTableManager get exerciseTypeId {
    final $_column = $_itemColumn<String>('exercise_type_id')!;

    final manager = $$OlyExerciseTypesTableTableManager(
      $_db,
      $_db.olyExerciseTypes,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_exerciseTypeIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$OlySessionExercisesTableFilterComposer
    extends Composer<_$AppDatabase, $OlySessionExercisesTable> {
  $$OlySessionExercisesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get exerciseOrder => $composableBuilder(
    column: $table.exerciseOrder,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get reps => $composableBuilder(
    column: $table.reps,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get workSeconds => $composableBuilder(
    column: $table.workSeconds,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get restSeconds => $composableBuilder(
    column: $table.restSeconds,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get details => $composableBuilder(
    column: $table.details,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get intensityOverride => $composableBuilder(
    column: $table.intensityOverride,
    builder: (column) => ColumnFilters(column),
  );

  $$OlySessionTemplatesTableFilterComposer get sessionTemplateId {
    final $$OlySessionTemplatesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.sessionTemplateId,
      referencedTable: $db.olySessionTemplates,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$OlySessionTemplatesTableFilterComposer(
            $db: $db,
            $table: $db.olySessionTemplates,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$OlyExerciseTypesTableFilterComposer get exerciseTypeId {
    final $$OlyExerciseTypesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.exerciseTypeId,
      referencedTable: $db.olyExerciseTypes,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$OlyExerciseTypesTableFilterComposer(
            $db: $db,
            $table: $db.olyExerciseTypes,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$OlySessionExercisesTableOrderingComposer
    extends Composer<_$AppDatabase, $OlySessionExercisesTable> {
  $$OlySessionExercisesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get exerciseOrder => $composableBuilder(
    column: $table.exerciseOrder,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get reps => $composableBuilder(
    column: $table.reps,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get workSeconds => $composableBuilder(
    column: $table.workSeconds,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get restSeconds => $composableBuilder(
    column: $table.restSeconds,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get details => $composableBuilder(
    column: $table.details,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get intensityOverride => $composableBuilder(
    column: $table.intensityOverride,
    builder: (column) => ColumnOrderings(column),
  );

  $$OlySessionTemplatesTableOrderingComposer get sessionTemplateId {
    final $$OlySessionTemplatesTableOrderingComposer composer =
        $composerBuilder(
          composer: this,
          getCurrentColumn: (t) => t.sessionTemplateId,
          referencedTable: $db.olySessionTemplates,
          getReferencedColumn: (t) => t.id,
          builder:
              (
                joinBuilder, {
                $addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer,
              }) => $$OlySessionTemplatesTableOrderingComposer(
                $db: $db,
                $table: $db.olySessionTemplates,
                $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                joinBuilder: joinBuilder,
                $removeJoinBuilderFromRootComposer:
                    $removeJoinBuilderFromRootComposer,
              ),
        );
    return composer;
  }

  $$OlyExerciseTypesTableOrderingComposer get exerciseTypeId {
    final $$OlyExerciseTypesTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.exerciseTypeId,
      referencedTable: $db.olyExerciseTypes,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$OlyExerciseTypesTableOrderingComposer(
            $db: $db,
            $table: $db.olyExerciseTypes,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$OlySessionExercisesTableAnnotationComposer
    extends Composer<_$AppDatabase, $OlySessionExercisesTable> {
  $$OlySessionExercisesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<int> get exerciseOrder => $composableBuilder(
    column: $table.exerciseOrder,
    builder: (column) => column,
  );

  GeneratedColumn<int> get reps =>
      $composableBuilder(column: $table.reps, builder: (column) => column);

  GeneratedColumn<int> get workSeconds => $composableBuilder(
    column: $table.workSeconds,
    builder: (column) => column,
  );

  GeneratedColumn<int> get restSeconds => $composableBuilder(
    column: $table.restSeconds,
    builder: (column) => column,
  );

  GeneratedColumn<String> get details =>
      $composableBuilder(column: $table.details, builder: (column) => column);

  GeneratedColumn<double> get intensityOverride => $composableBuilder(
    column: $table.intensityOverride,
    builder: (column) => column,
  );

  $$OlySessionTemplatesTableAnnotationComposer get sessionTemplateId {
    final $$OlySessionTemplatesTableAnnotationComposer composer =
        $composerBuilder(
          composer: this,
          getCurrentColumn: (t) => t.sessionTemplateId,
          referencedTable: $db.olySessionTemplates,
          getReferencedColumn: (t) => t.id,
          builder:
              (
                joinBuilder, {
                $addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer,
              }) => $$OlySessionTemplatesTableAnnotationComposer(
                $db: $db,
                $table: $db.olySessionTemplates,
                $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                joinBuilder: joinBuilder,
                $removeJoinBuilderFromRootComposer:
                    $removeJoinBuilderFromRootComposer,
              ),
        );
    return composer;
  }

  $$OlyExerciseTypesTableAnnotationComposer get exerciseTypeId {
    final $$OlyExerciseTypesTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.exerciseTypeId,
      referencedTable: $db.olyExerciseTypes,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$OlyExerciseTypesTableAnnotationComposer(
            $db: $db,
            $table: $db.olyExerciseTypes,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$OlySessionExercisesTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $OlySessionExercisesTable,
          OlySessionExercise,
          $$OlySessionExercisesTableFilterComposer,
          $$OlySessionExercisesTableOrderingComposer,
          $$OlySessionExercisesTableAnnotationComposer,
          $$OlySessionExercisesTableCreateCompanionBuilder,
          $$OlySessionExercisesTableUpdateCompanionBuilder,
          (OlySessionExercise, $$OlySessionExercisesTableReferences),
          OlySessionExercise,
          PrefetchHooks Function({bool sessionTemplateId, bool exerciseTypeId})
        > {
  $$OlySessionExercisesTableTableManager(
    _$AppDatabase db,
    $OlySessionExercisesTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$OlySessionExercisesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$OlySessionExercisesTableOrderingComposer(
                $db: db,
                $table: table,
              ),
          createComputedFieldComposer: () =>
              $$OlySessionExercisesTableAnnotationComposer(
                $db: db,
                $table: table,
              ),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> sessionTemplateId = const Value.absent(),
                Value<String> exerciseTypeId = const Value.absent(),
                Value<int> exerciseOrder = const Value.absent(),
                Value<int> reps = const Value.absent(),
                Value<int> workSeconds = const Value.absent(),
                Value<int> restSeconds = const Value.absent(),
                Value<String?> details = const Value.absent(),
                Value<double?> intensityOverride = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => OlySessionExercisesCompanion(
                id: id,
                sessionTemplateId: sessionTemplateId,
                exerciseTypeId: exerciseTypeId,
                exerciseOrder: exerciseOrder,
                reps: reps,
                workSeconds: workSeconds,
                restSeconds: restSeconds,
                details: details,
                intensityOverride: intensityOverride,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String sessionTemplateId,
                required String exerciseTypeId,
                required int exerciseOrder,
                required int reps,
                required int workSeconds,
                required int restSeconds,
                Value<String?> details = const Value.absent(),
                Value<double?> intensityOverride = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => OlySessionExercisesCompanion.insert(
                id: id,
                sessionTemplateId: sessionTemplateId,
                exerciseTypeId: exerciseTypeId,
                exerciseOrder: exerciseOrder,
                reps: reps,
                workSeconds: workSeconds,
                restSeconds: restSeconds,
                details: details,
                intensityOverride: intensityOverride,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$OlySessionExercisesTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback:
              ({sessionTemplateId = false, exerciseTypeId = false}) {
                return PrefetchHooks(
                  db: db,
                  explicitlyWatchedTables: [],
                  addJoins:
                      <
                        T extends TableManagerState<
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic
                        >
                      >(state) {
                        if (sessionTemplateId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.sessionTemplateId,
                                    referencedTable:
                                        $$OlySessionExercisesTableReferences
                                            ._sessionTemplateIdTable(db),
                                    referencedColumn:
                                        $$OlySessionExercisesTableReferences
                                            ._sessionTemplateIdTable(db)
                                            .id,
                                  )
                                  as T;
                        }
                        if (exerciseTypeId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.exerciseTypeId,
                                    referencedTable:
                                        $$OlySessionExercisesTableReferences
                                            ._exerciseTypeIdTable(db),
                                    referencedColumn:
                                        $$OlySessionExercisesTableReferences
                                            ._exerciseTypeIdTable(db)
                                            .id,
                                  )
                                  as T;
                        }

                        return state;
                      },
                  getPrefetchedDataCallback: (items) async {
                    return [];
                  },
                );
              },
        ),
      );
}

typedef $$OlySessionExercisesTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $OlySessionExercisesTable,
      OlySessionExercise,
      $$OlySessionExercisesTableFilterComposer,
      $$OlySessionExercisesTableOrderingComposer,
      $$OlySessionExercisesTableAnnotationComposer,
      $$OlySessionExercisesTableCreateCompanionBuilder,
      $$OlySessionExercisesTableUpdateCompanionBuilder,
      (OlySessionExercise, $$OlySessionExercisesTableReferences),
      OlySessionExercise,
      PrefetchHooks Function({bool sessionTemplateId, bool exerciseTypeId})
    >;
typedef $$OlyTrainingLogsTableCreateCompanionBuilder =
    OlyTrainingLogsCompanion Function({
      required String id,
      Value<String?> sessionTemplateId,
      required String sessionVersion,
      required String sessionName,
      required int plannedDurationSeconds,
      required int actualDurationSeconds,
      required int plannedExercises,
      required int completedExercises,
      required int totalHoldSeconds,
      required int totalRestSeconds,
      Value<int?> feedbackShaking,
      Value<int?> feedbackStructure,
      Value<int?> feedbackRest,
      Value<String?> progressionSuggestion,
      Value<String?> suggestedNextVersion,
      Value<String?> notes,
      required DateTime startedAt,
      required DateTime completedAt,
      Value<DateTime> createdAt,
      Value<DateTime?> deletedAt,
      Value<int> rowid,
    });
typedef $$OlyTrainingLogsTableUpdateCompanionBuilder =
    OlyTrainingLogsCompanion Function({
      Value<String> id,
      Value<String?> sessionTemplateId,
      Value<String> sessionVersion,
      Value<String> sessionName,
      Value<int> plannedDurationSeconds,
      Value<int> actualDurationSeconds,
      Value<int> plannedExercises,
      Value<int> completedExercises,
      Value<int> totalHoldSeconds,
      Value<int> totalRestSeconds,
      Value<int?> feedbackShaking,
      Value<int?> feedbackStructure,
      Value<int?> feedbackRest,
      Value<String?> progressionSuggestion,
      Value<String?> suggestedNextVersion,
      Value<String?> notes,
      Value<DateTime> startedAt,
      Value<DateTime> completedAt,
      Value<DateTime> createdAt,
      Value<DateTime?> deletedAt,
      Value<int> rowid,
    });

class $$OlyTrainingLogsTableFilterComposer
    extends Composer<_$AppDatabase, $OlyTrainingLogsTable> {
  $$OlyTrainingLogsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get sessionTemplateId => $composableBuilder(
    column: $table.sessionTemplateId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get sessionVersion => $composableBuilder(
    column: $table.sessionVersion,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get sessionName => $composableBuilder(
    column: $table.sessionName,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get plannedDurationSeconds => $composableBuilder(
    column: $table.plannedDurationSeconds,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get actualDurationSeconds => $composableBuilder(
    column: $table.actualDurationSeconds,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get plannedExercises => $composableBuilder(
    column: $table.plannedExercises,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get completedExercises => $composableBuilder(
    column: $table.completedExercises,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get totalHoldSeconds => $composableBuilder(
    column: $table.totalHoldSeconds,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get totalRestSeconds => $composableBuilder(
    column: $table.totalRestSeconds,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get feedbackShaking => $composableBuilder(
    column: $table.feedbackShaking,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get feedbackStructure => $composableBuilder(
    column: $table.feedbackStructure,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get feedbackRest => $composableBuilder(
    column: $table.feedbackRest,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get progressionSuggestion => $composableBuilder(
    column: $table.progressionSuggestion,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get suggestedNextVersion => $composableBuilder(
    column: $table.suggestedNextVersion,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get startedAt => $composableBuilder(
    column: $table.startedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get completedAt => $composableBuilder(
    column: $table.completedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get deletedAt => $composableBuilder(
    column: $table.deletedAt,
    builder: (column) => ColumnFilters(column),
  );
}

class $$OlyTrainingLogsTableOrderingComposer
    extends Composer<_$AppDatabase, $OlyTrainingLogsTable> {
  $$OlyTrainingLogsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get sessionTemplateId => $composableBuilder(
    column: $table.sessionTemplateId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get sessionVersion => $composableBuilder(
    column: $table.sessionVersion,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get sessionName => $composableBuilder(
    column: $table.sessionName,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get plannedDurationSeconds => $composableBuilder(
    column: $table.plannedDurationSeconds,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get actualDurationSeconds => $composableBuilder(
    column: $table.actualDurationSeconds,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get plannedExercises => $composableBuilder(
    column: $table.plannedExercises,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get completedExercises => $composableBuilder(
    column: $table.completedExercises,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get totalHoldSeconds => $composableBuilder(
    column: $table.totalHoldSeconds,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get totalRestSeconds => $composableBuilder(
    column: $table.totalRestSeconds,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get feedbackShaking => $composableBuilder(
    column: $table.feedbackShaking,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get feedbackStructure => $composableBuilder(
    column: $table.feedbackStructure,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get feedbackRest => $composableBuilder(
    column: $table.feedbackRest,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get progressionSuggestion => $composableBuilder(
    column: $table.progressionSuggestion,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get suggestedNextVersion => $composableBuilder(
    column: $table.suggestedNextVersion,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get startedAt => $composableBuilder(
    column: $table.startedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get completedAt => $composableBuilder(
    column: $table.completedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get deletedAt => $composableBuilder(
    column: $table.deletedAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$OlyTrainingLogsTableAnnotationComposer
    extends Composer<_$AppDatabase, $OlyTrainingLogsTable> {
  $$OlyTrainingLogsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get sessionTemplateId => $composableBuilder(
    column: $table.sessionTemplateId,
    builder: (column) => column,
  );

  GeneratedColumn<String> get sessionVersion => $composableBuilder(
    column: $table.sessionVersion,
    builder: (column) => column,
  );

  GeneratedColumn<String> get sessionName => $composableBuilder(
    column: $table.sessionName,
    builder: (column) => column,
  );

  GeneratedColumn<int> get plannedDurationSeconds => $composableBuilder(
    column: $table.plannedDurationSeconds,
    builder: (column) => column,
  );

  GeneratedColumn<int> get actualDurationSeconds => $composableBuilder(
    column: $table.actualDurationSeconds,
    builder: (column) => column,
  );

  GeneratedColumn<int> get plannedExercises => $composableBuilder(
    column: $table.plannedExercises,
    builder: (column) => column,
  );

  GeneratedColumn<int> get completedExercises => $composableBuilder(
    column: $table.completedExercises,
    builder: (column) => column,
  );

  GeneratedColumn<int> get totalHoldSeconds => $composableBuilder(
    column: $table.totalHoldSeconds,
    builder: (column) => column,
  );

  GeneratedColumn<int> get totalRestSeconds => $composableBuilder(
    column: $table.totalRestSeconds,
    builder: (column) => column,
  );

  GeneratedColumn<int> get feedbackShaking => $composableBuilder(
    column: $table.feedbackShaking,
    builder: (column) => column,
  );

  GeneratedColumn<int> get feedbackStructure => $composableBuilder(
    column: $table.feedbackStructure,
    builder: (column) => column,
  );

  GeneratedColumn<int> get feedbackRest => $composableBuilder(
    column: $table.feedbackRest,
    builder: (column) => column,
  );

  GeneratedColumn<String> get progressionSuggestion => $composableBuilder(
    column: $table.progressionSuggestion,
    builder: (column) => column,
  );

  GeneratedColumn<String> get suggestedNextVersion => $composableBuilder(
    column: $table.suggestedNextVersion,
    builder: (column) => column,
  );

  GeneratedColumn<String> get notes =>
      $composableBuilder(column: $table.notes, builder: (column) => column);

  GeneratedColumn<DateTime> get startedAt =>
      $composableBuilder(column: $table.startedAt, builder: (column) => column);

  GeneratedColumn<DateTime> get completedAt => $composableBuilder(
    column: $table.completedAt,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get deletedAt =>
      $composableBuilder(column: $table.deletedAt, builder: (column) => column);
}

class $$OlyTrainingLogsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $OlyTrainingLogsTable,
          OlyTrainingLog,
          $$OlyTrainingLogsTableFilterComposer,
          $$OlyTrainingLogsTableOrderingComposer,
          $$OlyTrainingLogsTableAnnotationComposer,
          $$OlyTrainingLogsTableCreateCompanionBuilder,
          $$OlyTrainingLogsTableUpdateCompanionBuilder,
          (
            OlyTrainingLog,
            BaseReferences<
              _$AppDatabase,
              $OlyTrainingLogsTable,
              OlyTrainingLog
            >,
          ),
          OlyTrainingLog,
          PrefetchHooks Function()
        > {
  $$OlyTrainingLogsTableTableManager(
    _$AppDatabase db,
    $OlyTrainingLogsTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$OlyTrainingLogsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$OlyTrainingLogsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$OlyTrainingLogsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String?> sessionTemplateId = const Value.absent(),
                Value<String> sessionVersion = const Value.absent(),
                Value<String> sessionName = const Value.absent(),
                Value<int> plannedDurationSeconds = const Value.absent(),
                Value<int> actualDurationSeconds = const Value.absent(),
                Value<int> plannedExercises = const Value.absent(),
                Value<int> completedExercises = const Value.absent(),
                Value<int> totalHoldSeconds = const Value.absent(),
                Value<int> totalRestSeconds = const Value.absent(),
                Value<int?> feedbackShaking = const Value.absent(),
                Value<int?> feedbackStructure = const Value.absent(),
                Value<int?> feedbackRest = const Value.absent(),
                Value<String?> progressionSuggestion = const Value.absent(),
                Value<String?> suggestedNextVersion = const Value.absent(),
                Value<String?> notes = const Value.absent(),
                Value<DateTime> startedAt = const Value.absent(),
                Value<DateTime> completedAt = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime?> deletedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => OlyTrainingLogsCompanion(
                id: id,
                sessionTemplateId: sessionTemplateId,
                sessionVersion: sessionVersion,
                sessionName: sessionName,
                plannedDurationSeconds: plannedDurationSeconds,
                actualDurationSeconds: actualDurationSeconds,
                plannedExercises: plannedExercises,
                completedExercises: completedExercises,
                totalHoldSeconds: totalHoldSeconds,
                totalRestSeconds: totalRestSeconds,
                feedbackShaking: feedbackShaking,
                feedbackStructure: feedbackStructure,
                feedbackRest: feedbackRest,
                progressionSuggestion: progressionSuggestion,
                suggestedNextVersion: suggestedNextVersion,
                notes: notes,
                startedAt: startedAt,
                completedAt: completedAt,
                createdAt: createdAt,
                deletedAt: deletedAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                Value<String?> sessionTemplateId = const Value.absent(),
                required String sessionVersion,
                required String sessionName,
                required int plannedDurationSeconds,
                required int actualDurationSeconds,
                required int plannedExercises,
                required int completedExercises,
                required int totalHoldSeconds,
                required int totalRestSeconds,
                Value<int?> feedbackShaking = const Value.absent(),
                Value<int?> feedbackStructure = const Value.absent(),
                Value<int?> feedbackRest = const Value.absent(),
                Value<String?> progressionSuggestion = const Value.absent(),
                Value<String?> suggestedNextVersion = const Value.absent(),
                Value<String?> notes = const Value.absent(),
                required DateTime startedAt,
                required DateTime completedAt,
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime?> deletedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => OlyTrainingLogsCompanion.insert(
                id: id,
                sessionTemplateId: sessionTemplateId,
                sessionVersion: sessionVersion,
                sessionName: sessionName,
                plannedDurationSeconds: plannedDurationSeconds,
                actualDurationSeconds: actualDurationSeconds,
                plannedExercises: plannedExercises,
                completedExercises: completedExercises,
                totalHoldSeconds: totalHoldSeconds,
                totalRestSeconds: totalRestSeconds,
                feedbackShaking: feedbackShaking,
                feedbackStructure: feedbackStructure,
                feedbackRest: feedbackRest,
                progressionSuggestion: progressionSuggestion,
                suggestedNextVersion: suggestedNextVersion,
                notes: notes,
                startedAt: startedAt,
                completedAt: completedAt,
                createdAt: createdAt,
                deletedAt: deletedAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$OlyTrainingLogsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $OlyTrainingLogsTable,
      OlyTrainingLog,
      $$OlyTrainingLogsTableFilterComposer,
      $$OlyTrainingLogsTableOrderingComposer,
      $$OlyTrainingLogsTableAnnotationComposer,
      $$OlyTrainingLogsTableCreateCompanionBuilder,
      $$OlyTrainingLogsTableUpdateCompanionBuilder,
      (
        OlyTrainingLog,
        BaseReferences<_$AppDatabase, $OlyTrainingLogsTable, OlyTrainingLog>,
      ),
      OlyTrainingLog,
      PrefetchHooks Function()
    >;
typedef $$UserTrainingProgressTableCreateCompanionBuilder =
    UserTrainingProgressCompanion Function({
      required String id,
      Value<String> currentLevel,
      Value<int> sessionsAtCurrentLevel,
      Value<DateTime?> lastSessionAt,
      Value<String?> lastSessionVersion,
      Value<int> totalSessionsCompleted,
      Value<bool> hasCompletedAssessment,
      Value<int?> assessmentMaxHoldSeconds,
      Value<DateTime?> assessmentDate,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<int> rowid,
    });
typedef $$UserTrainingProgressTableUpdateCompanionBuilder =
    UserTrainingProgressCompanion Function({
      Value<String> id,
      Value<String> currentLevel,
      Value<int> sessionsAtCurrentLevel,
      Value<DateTime?> lastSessionAt,
      Value<String?> lastSessionVersion,
      Value<int> totalSessionsCompleted,
      Value<bool> hasCompletedAssessment,
      Value<int?> assessmentMaxHoldSeconds,
      Value<DateTime?> assessmentDate,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<int> rowid,
    });

class $$UserTrainingProgressTableFilterComposer
    extends Composer<_$AppDatabase, $UserTrainingProgressTable> {
  $$UserTrainingProgressTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get currentLevel => $composableBuilder(
    column: $table.currentLevel,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get sessionsAtCurrentLevel => $composableBuilder(
    column: $table.sessionsAtCurrentLevel,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get lastSessionAt => $composableBuilder(
    column: $table.lastSessionAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get lastSessionVersion => $composableBuilder(
    column: $table.lastSessionVersion,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get totalSessionsCompleted => $composableBuilder(
    column: $table.totalSessionsCompleted,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get hasCompletedAssessment => $composableBuilder(
    column: $table.hasCompletedAssessment,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get assessmentMaxHoldSeconds => $composableBuilder(
    column: $table.assessmentMaxHoldSeconds,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get assessmentDate => $composableBuilder(
    column: $table.assessmentDate,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );
}

class $$UserTrainingProgressTableOrderingComposer
    extends Composer<_$AppDatabase, $UserTrainingProgressTable> {
  $$UserTrainingProgressTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get currentLevel => $composableBuilder(
    column: $table.currentLevel,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get sessionsAtCurrentLevel => $composableBuilder(
    column: $table.sessionsAtCurrentLevel,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get lastSessionAt => $composableBuilder(
    column: $table.lastSessionAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get lastSessionVersion => $composableBuilder(
    column: $table.lastSessionVersion,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get totalSessionsCompleted => $composableBuilder(
    column: $table.totalSessionsCompleted,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get hasCompletedAssessment => $composableBuilder(
    column: $table.hasCompletedAssessment,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get assessmentMaxHoldSeconds => $composableBuilder(
    column: $table.assessmentMaxHoldSeconds,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get assessmentDate => $composableBuilder(
    column: $table.assessmentDate,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$UserTrainingProgressTableAnnotationComposer
    extends Composer<_$AppDatabase, $UserTrainingProgressTable> {
  $$UserTrainingProgressTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get currentLevel => $composableBuilder(
    column: $table.currentLevel,
    builder: (column) => column,
  );

  GeneratedColumn<int> get sessionsAtCurrentLevel => $composableBuilder(
    column: $table.sessionsAtCurrentLevel,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get lastSessionAt => $composableBuilder(
    column: $table.lastSessionAt,
    builder: (column) => column,
  );

  GeneratedColumn<String> get lastSessionVersion => $composableBuilder(
    column: $table.lastSessionVersion,
    builder: (column) => column,
  );

  GeneratedColumn<int> get totalSessionsCompleted => $composableBuilder(
    column: $table.totalSessionsCompleted,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get hasCompletedAssessment => $composableBuilder(
    column: $table.hasCompletedAssessment,
    builder: (column) => column,
  );

  GeneratedColumn<int> get assessmentMaxHoldSeconds => $composableBuilder(
    column: $table.assessmentMaxHoldSeconds,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get assessmentDate => $composableBuilder(
    column: $table.assessmentDate,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);
}

class $$UserTrainingProgressTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $UserTrainingProgressTable,
          UserTrainingProgressData,
          $$UserTrainingProgressTableFilterComposer,
          $$UserTrainingProgressTableOrderingComposer,
          $$UserTrainingProgressTableAnnotationComposer,
          $$UserTrainingProgressTableCreateCompanionBuilder,
          $$UserTrainingProgressTableUpdateCompanionBuilder,
          (
            UserTrainingProgressData,
            BaseReferences<
              _$AppDatabase,
              $UserTrainingProgressTable,
              UserTrainingProgressData
            >,
          ),
          UserTrainingProgressData,
          PrefetchHooks Function()
        > {
  $$UserTrainingProgressTableTableManager(
    _$AppDatabase db,
    $UserTrainingProgressTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$UserTrainingProgressTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$UserTrainingProgressTableOrderingComposer(
                $db: db,
                $table: table,
              ),
          createComputedFieldComposer: () =>
              $$UserTrainingProgressTableAnnotationComposer(
                $db: db,
                $table: table,
              ),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> currentLevel = const Value.absent(),
                Value<int> sessionsAtCurrentLevel = const Value.absent(),
                Value<DateTime?> lastSessionAt = const Value.absent(),
                Value<String?> lastSessionVersion = const Value.absent(),
                Value<int> totalSessionsCompleted = const Value.absent(),
                Value<bool> hasCompletedAssessment = const Value.absent(),
                Value<int?> assessmentMaxHoldSeconds = const Value.absent(),
                Value<DateTime?> assessmentDate = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => UserTrainingProgressCompanion(
                id: id,
                currentLevel: currentLevel,
                sessionsAtCurrentLevel: sessionsAtCurrentLevel,
                lastSessionAt: lastSessionAt,
                lastSessionVersion: lastSessionVersion,
                totalSessionsCompleted: totalSessionsCompleted,
                hasCompletedAssessment: hasCompletedAssessment,
                assessmentMaxHoldSeconds: assessmentMaxHoldSeconds,
                assessmentDate: assessmentDate,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                Value<String> currentLevel = const Value.absent(),
                Value<int> sessionsAtCurrentLevel = const Value.absent(),
                Value<DateTime?> lastSessionAt = const Value.absent(),
                Value<String?> lastSessionVersion = const Value.absent(),
                Value<int> totalSessionsCompleted = const Value.absent(),
                Value<bool> hasCompletedAssessment = const Value.absent(),
                Value<int?> assessmentMaxHoldSeconds = const Value.absent(),
                Value<DateTime?> assessmentDate = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => UserTrainingProgressCompanion.insert(
                id: id,
                currentLevel: currentLevel,
                sessionsAtCurrentLevel: sessionsAtCurrentLevel,
                lastSessionAt: lastSessionAt,
                lastSessionVersion: lastSessionVersion,
                totalSessionsCompleted: totalSessionsCompleted,
                hasCompletedAssessment: hasCompletedAssessment,
                assessmentMaxHoldSeconds: assessmentMaxHoldSeconds,
                assessmentDate: assessmentDate,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$UserTrainingProgressTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $UserTrainingProgressTable,
      UserTrainingProgressData,
      $$UserTrainingProgressTableFilterComposer,
      $$UserTrainingProgressTableOrderingComposer,
      $$UserTrainingProgressTableAnnotationComposer,
      $$UserTrainingProgressTableCreateCompanionBuilder,
      $$UserTrainingProgressTableUpdateCompanionBuilder,
      (
        UserTrainingProgressData,
        BaseReferences<
          _$AppDatabase,
          $UserTrainingProgressTable,
          UserTrainingProgressData
        >,
      ),
      UserTrainingProgressData,
      PrefetchHooks Function()
    >;
typedef $$BreathTrainingLogsTableCreateCompanionBuilder =
    BreathTrainingLogsCompanion Function({
      required String id,
      required String sessionType,
      Value<int?> totalHoldSeconds,
      Value<int?> bestHoldThisSession,
      Value<int?> bestExhaleSeconds,
      Value<int?> rounds,
      Value<String?> difficulty,
      Value<int?> durationMinutes,
      required DateTime completedAt,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<DateTime?> deletedAt,
      Value<int> rowid,
    });
typedef $$BreathTrainingLogsTableUpdateCompanionBuilder =
    BreathTrainingLogsCompanion Function({
      Value<String> id,
      Value<String> sessionType,
      Value<int?> totalHoldSeconds,
      Value<int?> bestHoldThisSession,
      Value<int?> bestExhaleSeconds,
      Value<int?> rounds,
      Value<String?> difficulty,
      Value<int?> durationMinutes,
      Value<DateTime> completedAt,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<DateTime?> deletedAt,
      Value<int> rowid,
    });

final class $$BreathTrainingLogsTableReferences
    extends
        BaseReferences<
          _$AppDatabase,
          $BreathTrainingLogsTable,
          BreathTrainingLog
        > {
  $$BreathTrainingLogsTableReferences(
    super.$_db,
    super.$_table,
    super.$_typedResult,
  );

  static MultiTypedResultKey<$BreathHoldAwardsTable, List<BreathHoldAward>>
  _breathHoldAwardsRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.breathHoldAwards,
    aliasName: $_aliasNameGenerator(
      db.breathTrainingLogs.id,
      db.breathHoldAwards.sessionLogId,
    ),
  );

  $$BreathHoldAwardsTableProcessedTableManager get breathHoldAwardsRefs {
    final manager = $$BreathHoldAwardsTableTableManager(
      $_db,
      $_db.breathHoldAwards,
    ).filter((f) => f.sessionLogId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(
      _breathHoldAwardsRefsTable($_db),
    );
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$BreathTrainingLogsTableFilterComposer
    extends Composer<_$AppDatabase, $BreathTrainingLogsTable> {
  $$BreathTrainingLogsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get sessionType => $composableBuilder(
    column: $table.sessionType,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get totalHoldSeconds => $composableBuilder(
    column: $table.totalHoldSeconds,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get bestHoldThisSession => $composableBuilder(
    column: $table.bestHoldThisSession,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get bestExhaleSeconds => $composableBuilder(
    column: $table.bestExhaleSeconds,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get rounds => $composableBuilder(
    column: $table.rounds,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get difficulty => $composableBuilder(
    column: $table.difficulty,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get durationMinutes => $composableBuilder(
    column: $table.durationMinutes,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get completedAt => $composableBuilder(
    column: $table.completedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get deletedAt => $composableBuilder(
    column: $table.deletedAt,
    builder: (column) => ColumnFilters(column),
  );

  Expression<bool> breathHoldAwardsRefs(
    Expression<bool> Function($$BreathHoldAwardsTableFilterComposer f) f,
  ) {
    final $$BreathHoldAwardsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.breathHoldAwards,
      getReferencedColumn: (t) => t.sessionLogId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$BreathHoldAwardsTableFilterComposer(
            $db: $db,
            $table: $db.breathHoldAwards,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$BreathTrainingLogsTableOrderingComposer
    extends Composer<_$AppDatabase, $BreathTrainingLogsTable> {
  $$BreathTrainingLogsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get sessionType => $composableBuilder(
    column: $table.sessionType,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get totalHoldSeconds => $composableBuilder(
    column: $table.totalHoldSeconds,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get bestHoldThisSession => $composableBuilder(
    column: $table.bestHoldThisSession,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get bestExhaleSeconds => $composableBuilder(
    column: $table.bestExhaleSeconds,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get rounds => $composableBuilder(
    column: $table.rounds,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get difficulty => $composableBuilder(
    column: $table.difficulty,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get durationMinutes => $composableBuilder(
    column: $table.durationMinutes,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get completedAt => $composableBuilder(
    column: $table.completedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get deletedAt => $composableBuilder(
    column: $table.deletedAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$BreathTrainingLogsTableAnnotationComposer
    extends Composer<_$AppDatabase, $BreathTrainingLogsTable> {
  $$BreathTrainingLogsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get sessionType => $composableBuilder(
    column: $table.sessionType,
    builder: (column) => column,
  );

  GeneratedColumn<int> get totalHoldSeconds => $composableBuilder(
    column: $table.totalHoldSeconds,
    builder: (column) => column,
  );

  GeneratedColumn<int> get bestHoldThisSession => $composableBuilder(
    column: $table.bestHoldThisSession,
    builder: (column) => column,
  );

  GeneratedColumn<int> get bestExhaleSeconds => $composableBuilder(
    column: $table.bestExhaleSeconds,
    builder: (column) => column,
  );

  GeneratedColumn<int> get rounds =>
      $composableBuilder(column: $table.rounds, builder: (column) => column);

  GeneratedColumn<String> get difficulty => $composableBuilder(
    column: $table.difficulty,
    builder: (column) => column,
  );

  GeneratedColumn<int> get durationMinutes => $composableBuilder(
    column: $table.durationMinutes,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get completedAt => $composableBuilder(
    column: $table.completedAt,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  GeneratedColumn<DateTime> get deletedAt =>
      $composableBuilder(column: $table.deletedAt, builder: (column) => column);

  Expression<T> breathHoldAwardsRefs<T extends Object>(
    Expression<T> Function($$BreathHoldAwardsTableAnnotationComposer a) f,
  ) {
    final $$BreathHoldAwardsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.breathHoldAwards,
      getReferencedColumn: (t) => t.sessionLogId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$BreathHoldAwardsTableAnnotationComposer(
            $db: $db,
            $table: $db.breathHoldAwards,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$BreathTrainingLogsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $BreathTrainingLogsTable,
          BreathTrainingLog,
          $$BreathTrainingLogsTableFilterComposer,
          $$BreathTrainingLogsTableOrderingComposer,
          $$BreathTrainingLogsTableAnnotationComposer,
          $$BreathTrainingLogsTableCreateCompanionBuilder,
          $$BreathTrainingLogsTableUpdateCompanionBuilder,
          (BreathTrainingLog, $$BreathTrainingLogsTableReferences),
          BreathTrainingLog,
          PrefetchHooks Function({bool breathHoldAwardsRefs})
        > {
  $$BreathTrainingLogsTableTableManager(
    _$AppDatabase db,
    $BreathTrainingLogsTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$BreathTrainingLogsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$BreathTrainingLogsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$BreathTrainingLogsTableAnnotationComposer(
                $db: db,
                $table: table,
              ),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> sessionType = const Value.absent(),
                Value<int?> totalHoldSeconds = const Value.absent(),
                Value<int?> bestHoldThisSession = const Value.absent(),
                Value<int?> bestExhaleSeconds = const Value.absent(),
                Value<int?> rounds = const Value.absent(),
                Value<String?> difficulty = const Value.absent(),
                Value<int?> durationMinutes = const Value.absent(),
                Value<DateTime> completedAt = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<DateTime?> deletedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => BreathTrainingLogsCompanion(
                id: id,
                sessionType: sessionType,
                totalHoldSeconds: totalHoldSeconds,
                bestHoldThisSession: bestHoldThisSession,
                bestExhaleSeconds: bestExhaleSeconds,
                rounds: rounds,
                difficulty: difficulty,
                durationMinutes: durationMinutes,
                completedAt: completedAt,
                createdAt: createdAt,
                updatedAt: updatedAt,
                deletedAt: deletedAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String sessionType,
                Value<int?> totalHoldSeconds = const Value.absent(),
                Value<int?> bestHoldThisSession = const Value.absent(),
                Value<int?> bestExhaleSeconds = const Value.absent(),
                Value<int?> rounds = const Value.absent(),
                Value<String?> difficulty = const Value.absent(),
                Value<int?> durationMinutes = const Value.absent(),
                required DateTime completedAt,
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<DateTime?> deletedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => BreathTrainingLogsCompanion.insert(
                id: id,
                sessionType: sessionType,
                totalHoldSeconds: totalHoldSeconds,
                bestHoldThisSession: bestHoldThisSession,
                bestExhaleSeconds: bestExhaleSeconds,
                rounds: rounds,
                difficulty: difficulty,
                durationMinutes: durationMinutes,
                completedAt: completedAt,
                createdAt: createdAt,
                updatedAt: updatedAt,
                deletedAt: deletedAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$BreathTrainingLogsTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback: ({breathHoldAwardsRefs = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [
                if (breathHoldAwardsRefs) db.breathHoldAwards,
              ],
              addJoins: null,
              getPrefetchedDataCallback: (items) async {
                return [
                  if (breathHoldAwardsRefs)
                    await $_getPrefetchedData<
                      BreathTrainingLog,
                      $BreathTrainingLogsTable,
                      BreathHoldAward
                    >(
                      currentTable: table,
                      referencedTable: $$BreathTrainingLogsTableReferences
                          ._breathHoldAwardsRefsTable(db),
                      managerFromTypedResult: (p0) =>
                          $$BreathTrainingLogsTableReferences(
                            db,
                            table,
                            p0,
                          ).breathHoldAwardsRefs,
                      referencedItemsForCurrentItem: (item, referencedItems) =>
                          referencedItems.where(
                            (e) => e.sessionLogId == item.id,
                          ),
                      typedResults: items,
                    ),
                ];
              },
            );
          },
        ),
      );
}

typedef $$BreathTrainingLogsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $BreathTrainingLogsTable,
      BreathTrainingLog,
      $$BreathTrainingLogsTableFilterComposer,
      $$BreathTrainingLogsTableOrderingComposer,
      $$BreathTrainingLogsTableAnnotationComposer,
      $$BreathTrainingLogsTableCreateCompanionBuilder,
      $$BreathTrainingLogsTableUpdateCompanionBuilder,
      (BreathTrainingLog, $$BreathTrainingLogsTableReferences),
      BreathTrainingLog,
      PrefetchHooks Function({bool breathHoldAwardsRefs})
    >;
typedef $$BreathHoldAwardsTableCreateCompanionBuilder =
    BreathHoldAwardsCompanion Function({
      required String id,
      required int secondsThreshold,
      required String title,
      Value<String?> sessionLogId,
      required DateTime earnedAt,
      Value<DateTime> createdAt,
      Value<int> rowid,
    });
typedef $$BreathHoldAwardsTableUpdateCompanionBuilder =
    BreathHoldAwardsCompanion Function({
      Value<String> id,
      Value<int> secondsThreshold,
      Value<String> title,
      Value<String?> sessionLogId,
      Value<DateTime> earnedAt,
      Value<DateTime> createdAt,
      Value<int> rowid,
    });

final class $$BreathHoldAwardsTableReferences
    extends
        BaseReferences<_$AppDatabase, $BreathHoldAwardsTable, BreathHoldAward> {
  $$BreathHoldAwardsTableReferences(
    super.$_db,
    super.$_table,
    super.$_typedResult,
  );

  static $BreathTrainingLogsTable _sessionLogIdTable(_$AppDatabase db) =>
      db.breathTrainingLogs.createAlias(
        $_aliasNameGenerator(
          db.breathHoldAwards.sessionLogId,
          db.breathTrainingLogs.id,
        ),
      );

  $$BreathTrainingLogsTableProcessedTableManager? get sessionLogId {
    final $_column = $_itemColumn<String>('session_log_id');
    if ($_column == null) return null;
    final manager = $$BreathTrainingLogsTableTableManager(
      $_db,
      $_db.breathTrainingLogs,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_sessionLogIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$BreathHoldAwardsTableFilterComposer
    extends Composer<_$AppDatabase, $BreathHoldAwardsTable> {
  $$BreathHoldAwardsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get secondsThreshold => $composableBuilder(
    column: $table.secondsThreshold,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get title => $composableBuilder(
    column: $table.title,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get earnedAt => $composableBuilder(
    column: $table.earnedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  $$BreathTrainingLogsTableFilterComposer get sessionLogId {
    final $$BreathTrainingLogsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.sessionLogId,
      referencedTable: $db.breathTrainingLogs,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$BreathTrainingLogsTableFilterComposer(
            $db: $db,
            $table: $db.breathTrainingLogs,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$BreathHoldAwardsTableOrderingComposer
    extends Composer<_$AppDatabase, $BreathHoldAwardsTable> {
  $$BreathHoldAwardsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get secondsThreshold => $composableBuilder(
    column: $table.secondsThreshold,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get title => $composableBuilder(
    column: $table.title,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get earnedAt => $composableBuilder(
    column: $table.earnedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  $$BreathTrainingLogsTableOrderingComposer get sessionLogId {
    final $$BreathTrainingLogsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.sessionLogId,
      referencedTable: $db.breathTrainingLogs,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$BreathTrainingLogsTableOrderingComposer(
            $db: $db,
            $table: $db.breathTrainingLogs,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$BreathHoldAwardsTableAnnotationComposer
    extends Composer<_$AppDatabase, $BreathHoldAwardsTable> {
  $$BreathHoldAwardsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<int> get secondsThreshold => $composableBuilder(
    column: $table.secondsThreshold,
    builder: (column) => column,
  );

  GeneratedColumn<String> get title =>
      $composableBuilder(column: $table.title, builder: (column) => column);

  GeneratedColumn<DateTime> get earnedAt =>
      $composableBuilder(column: $table.earnedAt, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  $$BreathTrainingLogsTableAnnotationComposer get sessionLogId {
    final $$BreathTrainingLogsTableAnnotationComposer composer =
        $composerBuilder(
          composer: this,
          getCurrentColumn: (t) => t.sessionLogId,
          referencedTable: $db.breathTrainingLogs,
          getReferencedColumn: (t) => t.id,
          builder:
              (
                joinBuilder, {
                $addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer,
              }) => $$BreathTrainingLogsTableAnnotationComposer(
                $db: $db,
                $table: $db.breathTrainingLogs,
                $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                joinBuilder: joinBuilder,
                $removeJoinBuilderFromRootComposer:
                    $removeJoinBuilderFromRootComposer,
              ),
        );
    return composer;
  }
}

class $$BreathHoldAwardsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $BreathHoldAwardsTable,
          BreathHoldAward,
          $$BreathHoldAwardsTableFilterComposer,
          $$BreathHoldAwardsTableOrderingComposer,
          $$BreathHoldAwardsTableAnnotationComposer,
          $$BreathHoldAwardsTableCreateCompanionBuilder,
          $$BreathHoldAwardsTableUpdateCompanionBuilder,
          (BreathHoldAward, $$BreathHoldAwardsTableReferences),
          BreathHoldAward,
          PrefetchHooks Function({bool sessionLogId})
        > {
  $$BreathHoldAwardsTableTableManager(
    _$AppDatabase db,
    $BreathHoldAwardsTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$BreathHoldAwardsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$BreathHoldAwardsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$BreathHoldAwardsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<int> secondsThreshold = const Value.absent(),
                Value<String> title = const Value.absent(),
                Value<String?> sessionLogId = const Value.absent(),
                Value<DateTime> earnedAt = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => BreathHoldAwardsCompanion(
                id: id,
                secondsThreshold: secondsThreshold,
                title: title,
                sessionLogId: sessionLogId,
                earnedAt: earnedAt,
                createdAt: createdAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required int secondsThreshold,
                required String title,
                Value<String?> sessionLogId = const Value.absent(),
                required DateTime earnedAt,
                Value<DateTime> createdAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => BreathHoldAwardsCompanion.insert(
                id: id,
                secondsThreshold: secondsThreshold,
                title: title,
                sessionLogId: sessionLogId,
                earnedAt: earnedAt,
                createdAt: createdAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$BreathHoldAwardsTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback: ({sessionLogId = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins:
                  <
                    T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic
                    >
                  >(state) {
                    if (sessionLogId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.sessionLogId,
                                referencedTable:
                                    $$BreathHoldAwardsTableReferences
                                        ._sessionLogIdTable(db),
                                referencedColumn:
                                    $$BreathHoldAwardsTableReferences
                                        ._sessionLogIdTable(db)
                                        .id,
                              )
                              as T;
                    }

                    return state;
                  },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ),
      );
}

typedef $$BreathHoldAwardsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $BreathHoldAwardsTable,
      BreathHoldAward,
      $$BreathHoldAwardsTableFilterComposer,
      $$BreathHoldAwardsTableOrderingComposer,
      $$BreathHoldAwardsTableAnnotationComposer,
      $$BreathHoldAwardsTableCreateCompanionBuilder,
      $$BreathHoldAwardsTableUpdateCompanionBuilder,
      (BreathHoldAward, $$BreathHoldAwardsTableReferences),
      BreathHoldAward,
      PrefetchHooks Function({bool sessionLogId})
    >;
typedef $$MilestonesTableCreateCompanionBuilder =
    MilestonesCompanion Function({
      required String id,
      required DateTime date,
      required String title,
      Value<String?> description,
      Value<String> color,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<DateTime?> deletedAt,
      Value<int> rowid,
    });
typedef $$MilestonesTableUpdateCompanionBuilder =
    MilestonesCompanion Function({
      Value<String> id,
      Value<DateTime> date,
      Value<String> title,
      Value<String?> description,
      Value<String> color,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<DateTime?> deletedAt,
      Value<int> rowid,
    });

class $$MilestonesTableFilterComposer
    extends Composer<_$AppDatabase, $MilestonesTable> {
  $$MilestonesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get date => $composableBuilder(
    column: $table.date,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get title => $composableBuilder(
    column: $table.title,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get description => $composableBuilder(
    column: $table.description,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get color => $composableBuilder(
    column: $table.color,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get deletedAt => $composableBuilder(
    column: $table.deletedAt,
    builder: (column) => ColumnFilters(column),
  );
}

class $$MilestonesTableOrderingComposer
    extends Composer<_$AppDatabase, $MilestonesTable> {
  $$MilestonesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get date => $composableBuilder(
    column: $table.date,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get title => $composableBuilder(
    column: $table.title,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get description => $composableBuilder(
    column: $table.description,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get color => $composableBuilder(
    column: $table.color,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get deletedAt => $composableBuilder(
    column: $table.deletedAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$MilestonesTableAnnotationComposer
    extends Composer<_$AppDatabase, $MilestonesTable> {
  $$MilestonesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<DateTime> get date =>
      $composableBuilder(column: $table.date, builder: (column) => column);

  GeneratedColumn<String> get title =>
      $composableBuilder(column: $table.title, builder: (column) => column);

  GeneratedColumn<String> get description => $composableBuilder(
    column: $table.description,
    builder: (column) => column,
  );

  GeneratedColumn<String> get color =>
      $composableBuilder(column: $table.color, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  GeneratedColumn<DateTime> get deletedAt =>
      $composableBuilder(column: $table.deletedAt, builder: (column) => column);
}

class $$MilestonesTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $MilestonesTable,
          Milestone,
          $$MilestonesTableFilterComposer,
          $$MilestonesTableOrderingComposer,
          $$MilestonesTableAnnotationComposer,
          $$MilestonesTableCreateCompanionBuilder,
          $$MilestonesTableUpdateCompanionBuilder,
          (
            Milestone,
            BaseReferences<_$AppDatabase, $MilestonesTable, Milestone>,
          ),
          Milestone,
          PrefetchHooks Function()
        > {
  $$MilestonesTableTableManager(_$AppDatabase db, $MilestonesTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$MilestonesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$MilestonesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$MilestonesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<DateTime> date = const Value.absent(),
                Value<String> title = const Value.absent(),
                Value<String?> description = const Value.absent(),
                Value<String> color = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<DateTime?> deletedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => MilestonesCompanion(
                id: id,
                date: date,
                title: title,
                description: description,
                color: color,
                createdAt: createdAt,
                updatedAt: updatedAt,
                deletedAt: deletedAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required DateTime date,
                required String title,
                Value<String?> description = const Value.absent(),
                Value<String> color = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<DateTime?> deletedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => MilestonesCompanion.insert(
                id: id,
                date: date,
                title: title,
                description: description,
                color: color,
                createdAt: createdAt,
                updatedAt: updatedAt,
                deletedAt: deletedAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$MilestonesTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $MilestonesTable,
      Milestone,
      $$MilestonesTableFilterComposer,
      $$MilestonesTableOrderingComposer,
      $$MilestonesTableAnnotationComposer,
      $$MilestonesTableCreateCompanionBuilder,
      $$MilestonesTableUpdateCompanionBuilder,
      (Milestone, BaseReferences<_$AppDatabase, $MilestonesTable, Milestone>),
      Milestone,
      PrefetchHooks Function()
    >;
typedef $$VolumeImportsTableCreateCompanionBuilder =
    VolumeImportsCompanion Function({
      required String id,
      required String name,
      required String rawData,
      Value<String?> columnMapping,
      required int rowCount,
      Value<int> importedCount,
      Value<DateTime> createdAt,
      Value<int> rowid,
    });
typedef $$VolumeImportsTableUpdateCompanionBuilder =
    VolumeImportsCompanion Function({
      Value<String> id,
      Value<String> name,
      Value<String> rawData,
      Value<String?> columnMapping,
      Value<int> rowCount,
      Value<int> importedCount,
      Value<DateTime> createdAt,
      Value<int> rowid,
    });

class $$VolumeImportsTableFilterComposer
    extends Composer<_$AppDatabase, $VolumeImportsTable> {
  $$VolumeImportsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get rawData => $composableBuilder(
    column: $table.rawData,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get columnMapping => $composableBuilder(
    column: $table.columnMapping,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get rowCount => $composableBuilder(
    column: $table.rowCount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get importedCount => $composableBuilder(
    column: $table.importedCount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );
}

class $$VolumeImportsTableOrderingComposer
    extends Composer<_$AppDatabase, $VolumeImportsTable> {
  $$VolumeImportsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get rawData => $composableBuilder(
    column: $table.rawData,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get columnMapping => $composableBuilder(
    column: $table.columnMapping,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get rowCount => $composableBuilder(
    column: $table.rowCount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get importedCount => $composableBuilder(
    column: $table.importedCount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$VolumeImportsTableAnnotationComposer
    extends Composer<_$AppDatabase, $VolumeImportsTable> {
  $$VolumeImportsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get rawData =>
      $composableBuilder(column: $table.rawData, builder: (column) => column);

  GeneratedColumn<String> get columnMapping => $composableBuilder(
    column: $table.columnMapping,
    builder: (column) => column,
  );

  GeneratedColumn<int> get rowCount =>
      $composableBuilder(column: $table.rowCount, builder: (column) => column);

  GeneratedColumn<int> get importedCount => $composableBuilder(
    column: $table.importedCount,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);
}

class $$VolumeImportsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $VolumeImportsTable,
          VolumeImport,
          $$VolumeImportsTableFilterComposer,
          $$VolumeImportsTableOrderingComposer,
          $$VolumeImportsTableAnnotationComposer,
          $$VolumeImportsTableCreateCompanionBuilder,
          $$VolumeImportsTableUpdateCompanionBuilder,
          (
            VolumeImport,
            BaseReferences<_$AppDatabase, $VolumeImportsTable, VolumeImport>,
          ),
          VolumeImport,
          PrefetchHooks Function()
        > {
  $$VolumeImportsTableTableManager(_$AppDatabase db, $VolumeImportsTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$VolumeImportsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$VolumeImportsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$VolumeImportsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<String> rawData = const Value.absent(),
                Value<String?> columnMapping = const Value.absent(),
                Value<int> rowCount = const Value.absent(),
                Value<int> importedCount = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => VolumeImportsCompanion(
                id: id,
                name: name,
                rawData: rawData,
                columnMapping: columnMapping,
                rowCount: rowCount,
                importedCount: importedCount,
                createdAt: createdAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String name,
                required String rawData,
                Value<String?> columnMapping = const Value.absent(),
                required int rowCount,
                Value<int> importedCount = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => VolumeImportsCompanion.insert(
                id: id,
                name: name,
                rawData: rawData,
                columnMapping: columnMapping,
                rowCount: rowCount,
                importedCount: importedCount,
                createdAt: createdAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$VolumeImportsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $VolumeImportsTable,
      VolumeImport,
      $$VolumeImportsTableFilterComposer,
      $$VolumeImportsTableOrderingComposer,
      $$VolumeImportsTableAnnotationComposer,
      $$VolumeImportsTableCreateCompanionBuilder,
      $$VolumeImportsTableUpdateCompanionBuilder,
      (
        VolumeImport,
        BaseReferences<_$AppDatabase, $VolumeImportsTable, VolumeImport>,
      ),
      VolumeImport,
      PrefetchHooks Function()
    >;
typedef $$KitSnapshotsTableCreateCompanionBuilder =
    KitSnapshotsCompanion Function({
      required String id,
      Value<String?> sessionId,
      Value<String?> bowId,
      Value<String?> quiverId,
      required DateTime snapshotDate,
      Value<int?> score,
      Value<int?> maxScore,
      Value<String?> roundName,
      Value<String?> reason,
      Value<String?> bowName,
      Value<String?> bowType,
      Value<String?> bowSettings,
      Value<String?> quiverName,
      Value<String?> arrowSettings,
      Value<String?> notes,
      Value<DateTime> createdAt,
      Value<int> rowid,
    });
typedef $$KitSnapshotsTableUpdateCompanionBuilder =
    KitSnapshotsCompanion Function({
      Value<String> id,
      Value<String?> sessionId,
      Value<String?> bowId,
      Value<String?> quiverId,
      Value<DateTime> snapshotDate,
      Value<int?> score,
      Value<int?> maxScore,
      Value<String?> roundName,
      Value<String?> reason,
      Value<String?> bowName,
      Value<String?> bowType,
      Value<String?> bowSettings,
      Value<String?> quiverName,
      Value<String?> arrowSettings,
      Value<String?> notes,
      Value<DateTime> createdAt,
      Value<int> rowid,
    });

class $$KitSnapshotsTableFilterComposer
    extends Composer<_$AppDatabase, $KitSnapshotsTable> {
  $$KitSnapshotsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get sessionId => $composableBuilder(
    column: $table.sessionId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get bowId => $composableBuilder(
    column: $table.bowId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get quiverId => $composableBuilder(
    column: $table.quiverId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get snapshotDate => $composableBuilder(
    column: $table.snapshotDate,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get score => $composableBuilder(
    column: $table.score,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get maxScore => $composableBuilder(
    column: $table.maxScore,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get roundName => $composableBuilder(
    column: $table.roundName,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get reason => $composableBuilder(
    column: $table.reason,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get bowName => $composableBuilder(
    column: $table.bowName,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get bowType => $composableBuilder(
    column: $table.bowType,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get bowSettings => $composableBuilder(
    column: $table.bowSettings,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get quiverName => $composableBuilder(
    column: $table.quiverName,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get arrowSettings => $composableBuilder(
    column: $table.arrowSettings,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );
}

class $$KitSnapshotsTableOrderingComposer
    extends Composer<_$AppDatabase, $KitSnapshotsTable> {
  $$KitSnapshotsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get sessionId => $composableBuilder(
    column: $table.sessionId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get bowId => $composableBuilder(
    column: $table.bowId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get quiverId => $composableBuilder(
    column: $table.quiverId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get snapshotDate => $composableBuilder(
    column: $table.snapshotDate,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get score => $composableBuilder(
    column: $table.score,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get maxScore => $composableBuilder(
    column: $table.maxScore,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get roundName => $composableBuilder(
    column: $table.roundName,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get reason => $composableBuilder(
    column: $table.reason,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get bowName => $composableBuilder(
    column: $table.bowName,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get bowType => $composableBuilder(
    column: $table.bowType,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get bowSettings => $composableBuilder(
    column: $table.bowSettings,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get quiverName => $composableBuilder(
    column: $table.quiverName,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get arrowSettings => $composableBuilder(
    column: $table.arrowSettings,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$KitSnapshotsTableAnnotationComposer
    extends Composer<_$AppDatabase, $KitSnapshotsTable> {
  $$KitSnapshotsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get sessionId =>
      $composableBuilder(column: $table.sessionId, builder: (column) => column);

  GeneratedColumn<String> get bowId =>
      $composableBuilder(column: $table.bowId, builder: (column) => column);

  GeneratedColumn<String> get quiverId =>
      $composableBuilder(column: $table.quiverId, builder: (column) => column);

  GeneratedColumn<DateTime> get snapshotDate => $composableBuilder(
    column: $table.snapshotDate,
    builder: (column) => column,
  );

  GeneratedColumn<int> get score =>
      $composableBuilder(column: $table.score, builder: (column) => column);

  GeneratedColumn<int> get maxScore =>
      $composableBuilder(column: $table.maxScore, builder: (column) => column);

  GeneratedColumn<String> get roundName =>
      $composableBuilder(column: $table.roundName, builder: (column) => column);

  GeneratedColumn<String> get reason =>
      $composableBuilder(column: $table.reason, builder: (column) => column);

  GeneratedColumn<String> get bowName =>
      $composableBuilder(column: $table.bowName, builder: (column) => column);

  GeneratedColumn<String> get bowType =>
      $composableBuilder(column: $table.bowType, builder: (column) => column);

  GeneratedColumn<String> get bowSettings => $composableBuilder(
    column: $table.bowSettings,
    builder: (column) => column,
  );

  GeneratedColumn<String> get quiverName => $composableBuilder(
    column: $table.quiverName,
    builder: (column) => column,
  );

  GeneratedColumn<String> get arrowSettings => $composableBuilder(
    column: $table.arrowSettings,
    builder: (column) => column,
  );

  GeneratedColumn<String> get notes =>
      $composableBuilder(column: $table.notes, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);
}

class $$KitSnapshotsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $KitSnapshotsTable,
          KitSnapshot,
          $$KitSnapshotsTableFilterComposer,
          $$KitSnapshotsTableOrderingComposer,
          $$KitSnapshotsTableAnnotationComposer,
          $$KitSnapshotsTableCreateCompanionBuilder,
          $$KitSnapshotsTableUpdateCompanionBuilder,
          (
            KitSnapshot,
            BaseReferences<_$AppDatabase, $KitSnapshotsTable, KitSnapshot>,
          ),
          KitSnapshot,
          PrefetchHooks Function()
        > {
  $$KitSnapshotsTableTableManager(_$AppDatabase db, $KitSnapshotsTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$KitSnapshotsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$KitSnapshotsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$KitSnapshotsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String?> sessionId = const Value.absent(),
                Value<String?> bowId = const Value.absent(),
                Value<String?> quiverId = const Value.absent(),
                Value<DateTime> snapshotDate = const Value.absent(),
                Value<int?> score = const Value.absent(),
                Value<int?> maxScore = const Value.absent(),
                Value<String?> roundName = const Value.absent(),
                Value<String?> reason = const Value.absent(),
                Value<String?> bowName = const Value.absent(),
                Value<String?> bowType = const Value.absent(),
                Value<String?> bowSettings = const Value.absent(),
                Value<String?> quiverName = const Value.absent(),
                Value<String?> arrowSettings = const Value.absent(),
                Value<String?> notes = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => KitSnapshotsCompanion(
                id: id,
                sessionId: sessionId,
                bowId: bowId,
                quiverId: quiverId,
                snapshotDate: snapshotDate,
                score: score,
                maxScore: maxScore,
                roundName: roundName,
                reason: reason,
                bowName: bowName,
                bowType: bowType,
                bowSettings: bowSettings,
                quiverName: quiverName,
                arrowSettings: arrowSettings,
                notes: notes,
                createdAt: createdAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                Value<String?> sessionId = const Value.absent(),
                Value<String?> bowId = const Value.absent(),
                Value<String?> quiverId = const Value.absent(),
                required DateTime snapshotDate,
                Value<int?> score = const Value.absent(),
                Value<int?> maxScore = const Value.absent(),
                Value<String?> roundName = const Value.absent(),
                Value<String?> reason = const Value.absent(),
                Value<String?> bowName = const Value.absent(),
                Value<String?> bowType = const Value.absent(),
                Value<String?> bowSettings = const Value.absent(),
                Value<String?> quiverName = const Value.absent(),
                Value<String?> arrowSettings = const Value.absent(),
                Value<String?> notes = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => KitSnapshotsCompanion.insert(
                id: id,
                sessionId: sessionId,
                bowId: bowId,
                quiverId: quiverId,
                snapshotDate: snapshotDate,
                score: score,
                maxScore: maxScore,
                roundName: roundName,
                reason: reason,
                bowName: bowName,
                bowType: bowType,
                bowSettings: bowSettings,
                quiverName: quiverName,
                arrowSettings: arrowSettings,
                notes: notes,
                createdAt: createdAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$KitSnapshotsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $KitSnapshotsTable,
      KitSnapshot,
      $$KitSnapshotsTableFilterComposer,
      $$KitSnapshotsTableOrderingComposer,
      $$KitSnapshotsTableAnnotationComposer,
      $$KitSnapshotsTableCreateCompanionBuilder,
      $$KitSnapshotsTableUpdateCompanionBuilder,
      (
        KitSnapshot,
        BaseReferences<_$AppDatabase, $KitSnapshotsTable, KitSnapshot>,
      ),
      KitSnapshot,
      PrefetchHooks Function()
    >;
typedef $$TuningSessionsTableCreateCompanionBuilder =
    TuningSessionsCompanion Function({
      required String id,
      Value<String?> bowId,
      required DateTime date,
      required String bowType,
      required String tuningType,
      Value<String?> results,
      Value<String?> notes,
      Value<DateTime> createdAt,
      Value<int> rowid,
    });
typedef $$TuningSessionsTableUpdateCompanionBuilder =
    TuningSessionsCompanion Function({
      Value<String> id,
      Value<String?> bowId,
      Value<DateTime> date,
      Value<String> bowType,
      Value<String> tuningType,
      Value<String?> results,
      Value<String?> notes,
      Value<DateTime> createdAt,
      Value<int> rowid,
    });

final class $$TuningSessionsTableReferences
    extends BaseReferences<_$AppDatabase, $TuningSessionsTable, TuningSession> {
  $$TuningSessionsTableReferences(
    super.$_db,
    super.$_table,
    super.$_typedResult,
  );

  static $BowsTable _bowIdTable(_$AppDatabase db) => db.bows.createAlias(
    $_aliasNameGenerator(db.tuningSessions.bowId, db.bows.id),
  );

  $$BowsTableProcessedTableManager? get bowId {
    final $_column = $_itemColumn<String>('bow_id');
    if ($_column == null) return null;
    final manager = $$BowsTableTableManager(
      $_db,
      $_db.bows,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_bowIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$TuningSessionsTableFilterComposer
    extends Composer<_$AppDatabase, $TuningSessionsTable> {
  $$TuningSessionsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get date => $composableBuilder(
    column: $table.date,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get bowType => $composableBuilder(
    column: $table.bowType,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get tuningType => $composableBuilder(
    column: $table.tuningType,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get results => $composableBuilder(
    column: $table.results,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  $$BowsTableFilterComposer get bowId {
    final $$BowsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.bowId,
      referencedTable: $db.bows,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$BowsTableFilterComposer(
            $db: $db,
            $table: $db.bows,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$TuningSessionsTableOrderingComposer
    extends Composer<_$AppDatabase, $TuningSessionsTable> {
  $$TuningSessionsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get date => $composableBuilder(
    column: $table.date,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get bowType => $composableBuilder(
    column: $table.bowType,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get tuningType => $composableBuilder(
    column: $table.tuningType,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get results => $composableBuilder(
    column: $table.results,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  $$BowsTableOrderingComposer get bowId {
    final $$BowsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.bowId,
      referencedTable: $db.bows,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$BowsTableOrderingComposer(
            $db: $db,
            $table: $db.bows,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$TuningSessionsTableAnnotationComposer
    extends Composer<_$AppDatabase, $TuningSessionsTable> {
  $$TuningSessionsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<DateTime> get date =>
      $composableBuilder(column: $table.date, builder: (column) => column);

  GeneratedColumn<String> get bowType =>
      $composableBuilder(column: $table.bowType, builder: (column) => column);

  GeneratedColumn<String> get tuningType => $composableBuilder(
    column: $table.tuningType,
    builder: (column) => column,
  );

  GeneratedColumn<String> get results =>
      $composableBuilder(column: $table.results, builder: (column) => column);

  GeneratedColumn<String> get notes =>
      $composableBuilder(column: $table.notes, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  $$BowsTableAnnotationComposer get bowId {
    final $$BowsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.bowId,
      referencedTable: $db.bows,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$BowsTableAnnotationComposer(
            $db: $db,
            $table: $db.bows,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$TuningSessionsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $TuningSessionsTable,
          TuningSession,
          $$TuningSessionsTableFilterComposer,
          $$TuningSessionsTableOrderingComposer,
          $$TuningSessionsTableAnnotationComposer,
          $$TuningSessionsTableCreateCompanionBuilder,
          $$TuningSessionsTableUpdateCompanionBuilder,
          (TuningSession, $$TuningSessionsTableReferences),
          TuningSession,
          PrefetchHooks Function({bool bowId})
        > {
  $$TuningSessionsTableTableManager(
    _$AppDatabase db,
    $TuningSessionsTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$TuningSessionsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$TuningSessionsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$TuningSessionsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String?> bowId = const Value.absent(),
                Value<DateTime> date = const Value.absent(),
                Value<String> bowType = const Value.absent(),
                Value<String> tuningType = const Value.absent(),
                Value<String?> results = const Value.absent(),
                Value<String?> notes = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => TuningSessionsCompanion(
                id: id,
                bowId: bowId,
                date: date,
                bowType: bowType,
                tuningType: tuningType,
                results: results,
                notes: notes,
                createdAt: createdAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                Value<String?> bowId = const Value.absent(),
                required DateTime date,
                required String bowType,
                required String tuningType,
                Value<String?> results = const Value.absent(),
                Value<String?> notes = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => TuningSessionsCompanion.insert(
                id: id,
                bowId: bowId,
                date: date,
                bowType: bowType,
                tuningType: tuningType,
                results: results,
                notes: notes,
                createdAt: createdAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$TuningSessionsTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback: ({bowId = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins:
                  <
                    T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic
                    >
                  >(state) {
                    if (bowId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.bowId,
                                referencedTable: $$TuningSessionsTableReferences
                                    ._bowIdTable(db),
                                referencedColumn:
                                    $$TuningSessionsTableReferences
                                        ._bowIdTable(db)
                                        .id,
                              )
                              as T;
                    }

                    return state;
                  },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ),
      );
}

typedef $$TuningSessionsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $TuningSessionsTable,
      TuningSession,
      $$TuningSessionsTableFilterComposer,
      $$TuningSessionsTableOrderingComposer,
      $$TuningSessionsTableAnnotationComposer,
      $$TuningSessionsTableCreateCompanionBuilder,
      $$TuningSessionsTableUpdateCompanionBuilder,
      (TuningSession, $$TuningSessionsTableReferences),
      TuningSession,
      PrefetchHooks Function({bool bowId})
    >;
typedef $$SkillLevelsTableCreateCompanionBuilder =
    SkillLevelsCompanion Function({
      required String id,
      required String name,
      Value<String?> description,
      Value<int> currentLevel,
      Value<int> currentXp,
      Value<DateTime?> lastLevelUpAt,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<int> rowid,
    });
typedef $$SkillLevelsTableUpdateCompanionBuilder =
    SkillLevelsCompanion Function({
      Value<String> id,
      Value<String> name,
      Value<String?> description,
      Value<int> currentLevel,
      Value<int> currentXp,
      Value<DateTime?> lastLevelUpAt,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<int> rowid,
    });

class $$SkillLevelsTableFilterComposer
    extends Composer<_$AppDatabase, $SkillLevelsTable> {
  $$SkillLevelsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get description => $composableBuilder(
    column: $table.description,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get currentLevel => $composableBuilder(
    column: $table.currentLevel,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get currentXp => $composableBuilder(
    column: $table.currentXp,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get lastLevelUpAt => $composableBuilder(
    column: $table.lastLevelUpAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );
}

class $$SkillLevelsTableOrderingComposer
    extends Composer<_$AppDatabase, $SkillLevelsTable> {
  $$SkillLevelsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get description => $composableBuilder(
    column: $table.description,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get currentLevel => $composableBuilder(
    column: $table.currentLevel,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get currentXp => $composableBuilder(
    column: $table.currentXp,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get lastLevelUpAt => $composableBuilder(
    column: $table.lastLevelUpAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$SkillLevelsTableAnnotationComposer
    extends Composer<_$AppDatabase, $SkillLevelsTable> {
  $$SkillLevelsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get description => $composableBuilder(
    column: $table.description,
    builder: (column) => column,
  );

  GeneratedColumn<int> get currentLevel => $composableBuilder(
    column: $table.currentLevel,
    builder: (column) => column,
  );

  GeneratedColumn<int> get currentXp =>
      $composableBuilder(column: $table.currentXp, builder: (column) => column);

  GeneratedColumn<DateTime> get lastLevelUpAt => $composableBuilder(
    column: $table.lastLevelUpAt,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);
}

class $$SkillLevelsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $SkillLevelsTable,
          SkillLevel,
          $$SkillLevelsTableFilterComposer,
          $$SkillLevelsTableOrderingComposer,
          $$SkillLevelsTableAnnotationComposer,
          $$SkillLevelsTableCreateCompanionBuilder,
          $$SkillLevelsTableUpdateCompanionBuilder,
          (
            SkillLevel,
            BaseReferences<_$AppDatabase, $SkillLevelsTable, SkillLevel>,
          ),
          SkillLevel,
          PrefetchHooks Function()
        > {
  $$SkillLevelsTableTableManager(_$AppDatabase db, $SkillLevelsTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$SkillLevelsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$SkillLevelsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$SkillLevelsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<String?> description = const Value.absent(),
                Value<int> currentLevel = const Value.absent(),
                Value<int> currentXp = const Value.absent(),
                Value<DateTime?> lastLevelUpAt = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => SkillLevelsCompanion(
                id: id,
                name: name,
                description: description,
                currentLevel: currentLevel,
                currentXp: currentXp,
                lastLevelUpAt: lastLevelUpAt,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String name,
                Value<String?> description = const Value.absent(),
                Value<int> currentLevel = const Value.absent(),
                Value<int> currentXp = const Value.absent(),
                Value<DateTime?> lastLevelUpAt = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => SkillLevelsCompanion.insert(
                id: id,
                name: name,
                description: description,
                currentLevel: currentLevel,
                currentXp: currentXp,
                lastLevelUpAt: lastLevelUpAt,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$SkillLevelsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $SkillLevelsTable,
      SkillLevel,
      $$SkillLevelsTableFilterComposer,
      $$SkillLevelsTableOrderingComposer,
      $$SkillLevelsTableAnnotationComposer,
      $$SkillLevelsTableCreateCompanionBuilder,
      $$SkillLevelsTableUpdateCompanionBuilder,
      (
        SkillLevel,
        BaseReferences<_$AppDatabase, $SkillLevelsTable, SkillLevel>,
      ),
      SkillLevel,
      PrefetchHooks Function()
    >;
typedef $$XpHistoryTableCreateCompanionBuilder =
    XpHistoryCompanion Function({
      required String id,
      required String skillId,
      required int xpAmount,
      required String source,
      Value<String?> sourceId,
      Value<String?> reason,
      Value<DateTime> earnedAt,
      Value<int> rowid,
    });
typedef $$XpHistoryTableUpdateCompanionBuilder =
    XpHistoryCompanion Function({
      Value<String> id,
      Value<String> skillId,
      Value<int> xpAmount,
      Value<String> source,
      Value<String?> sourceId,
      Value<String?> reason,
      Value<DateTime> earnedAt,
      Value<int> rowid,
    });

class $$XpHistoryTableFilterComposer
    extends Composer<_$AppDatabase, $XpHistoryTable> {
  $$XpHistoryTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get skillId => $composableBuilder(
    column: $table.skillId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get xpAmount => $composableBuilder(
    column: $table.xpAmount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get source => $composableBuilder(
    column: $table.source,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get sourceId => $composableBuilder(
    column: $table.sourceId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get reason => $composableBuilder(
    column: $table.reason,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get earnedAt => $composableBuilder(
    column: $table.earnedAt,
    builder: (column) => ColumnFilters(column),
  );
}

class $$XpHistoryTableOrderingComposer
    extends Composer<_$AppDatabase, $XpHistoryTable> {
  $$XpHistoryTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get skillId => $composableBuilder(
    column: $table.skillId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get xpAmount => $composableBuilder(
    column: $table.xpAmount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get source => $composableBuilder(
    column: $table.source,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get sourceId => $composableBuilder(
    column: $table.sourceId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get reason => $composableBuilder(
    column: $table.reason,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get earnedAt => $composableBuilder(
    column: $table.earnedAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$XpHistoryTableAnnotationComposer
    extends Composer<_$AppDatabase, $XpHistoryTable> {
  $$XpHistoryTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get skillId =>
      $composableBuilder(column: $table.skillId, builder: (column) => column);

  GeneratedColumn<int> get xpAmount =>
      $composableBuilder(column: $table.xpAmount, builder: (column) => column);

  GeneratedColumn<String> get source =>
      $composableBuilder(column: $table.source, builder: (column) => column);

  GeneratedColumn<String> get sourceId =>
      $composableBuilder(column: $table.sourceId, builder: (column) => column);

  GeneratedColumn<String> get reason =>
      $composableBuilder(column: $table.reason, builder: (column) => column);

  GeneratedColumn<DateTime> get earnedAt =>
      $composableBuilder(column: $table.earnedAt, builder: (column) => column);
}

class $$XpHistoryTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $XpHistoryTable,
          XpHistoryData,
          $$XpHistoryTableFilterComposer,
          $$XpHistoryTableOrderingComposer,
          $$XpHistoryTableAnnotationComposer,
          $$XpHistoryTableCreateCompanionBuilder,
          $$XpHistoryTableUpdateCompanionBuilder,
          (
            XpHistoryData,
            BaseReferences<_$AppDatabase, $XpHistoryTable, XpHistoryData>,
          ),
          XpHistoryData,
          PrefetchHooks Function()
        > {
  $$XpHistoryTableTableManager(_$AppDatabase db, $XpHistoryTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$XpHistoryTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$XpHistoryTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$XpHistoryTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> skillId = const Value.absent(),
                Value<int> xpAmount = const Value.absent(),
                Value<String> source = const Value.absent(),
                Value<String?> sourceId = const Value.absent(),
                Value<String?> reason = const Value.absent(),
                Value<DateTime> earnedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => XpHistoryCompanion(
                id: id,
                skillId: skillId,
                xpAmount: xpAmount,
                source: source,
                sourceId: sourceId,
                reason: reason,
                earnedAt: earnedAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String skillId,
                required int xpAmount,
                required String source,
                Value<String?> sourceId = const Value.absent(),
                Value<String?> reason = const Value.absent(),
                Value<DateTime> earnedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => XpHistoryCompanion.insert(
                id: id,
                skillId: skillId,
                xpAmount: xpAmount,
                source: source,
                sourceId: sourceId,
                reason: reason,
                earnedAt: earnedAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$XpHistoryTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $XpHistoryTable,
      XpHistoryData,
      $$XpHistoryTableFilterComposer,
      $$XpHistoryTableOrderingComposer,
      $$XpHistoryTableAnnotationComposer,
      $$XpHistoryTableCreateCompanionBuilder,
      $$XpHistoryTableUpdateCompanionBuilder,
      (
        XpHistoryData,
        BaseReferences<_$AppDatabase, $XpHistoryTable, XpHistoryData>,
      ),
      XpHistoryData,
      PrefetchHooks Function()
    >;
typedef $$SightMarksTableCreateCompanionBuilder =
    SightMarksCompanion Function({
      required String id,
      required String bowId,
      required double distance,
      Value<String> unit,
      required String sightValue,
      Value<String?> weatherData,
      Value<double?> elevationDelta,
      Value<double?> slopeAngle,
      Value<String?> sessionId,
      Value<int?> endNumber,
      Value<int?> shotCount,
      Value<double?> confidenceScore,
      Value<String?> venueId,
      Value<bool> isIndoor,
      Value<DateTime> recordedAt,
      Value<DateTime?> updatedAt,
      Value<DateTime?> deletedAt,
      Value<int> rowid,
    });
typedef $$SightMarksTableUpdateCompanionBuilder =
    SightMarksCompanion Function({
      Value<String> id,
      Value<String> bowId,
      Value<double> distance,
      Value<String> unit,
      Value<String> sightValue,
      Value<String?> weatherData,
      Value<double?> elevationDelta,
      Value<double?> slopeAngle,
      Value<String?> sessionId,
      Value<int?> endNumber,
      Value<int?> shotCount,
      Value<double?> confidenceScore,
      Value<String?> venueId,
      Value<bool> isIndoor,
      Value<DateTime> recordedAt,
      Value<DateTime?> updatedAt,
      Value<DateTime?> deletedAt,
      Value<int> rowid,
    });

final class $$SightMarksTableReferences
    extends BaseReferences<_$AppDatabase, $SightMarksTable, SightMark> {
  $$SightMarksTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $BowsTable _bowIdTable(_$AppDatabase db) => db.bows.createAlias(
    $_aliasNameGenerator(db.sightMarks.bowId, db.bows.id),
  );

  $$BowsTableProcessedTableManager get bowId {
    final $_column = $_itemColumn<String>('bow_id')!;

    final manager = $$BowsTableTableManager(
      $_db,
      $_db.bows,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_bowIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$SightMarksTableFilterComposer
    extends Composer<_$AppDatabase, $SightMarksTable> {
  $$SightMarksTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get distance => $composableBuilder(
    column: $table.distance,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get unit => $composableBuilder(
    column: $table.unit,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get sightValue => $composableBuilder(
    column: $table.sightValue,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get weatherData => $composableBuilder(
    column: $table.weatherData,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get elevationDelta => $composableBuilder(
    column: $table.elevationDelta,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get slopeAngle => $composableBuilder(
    column: $table.slopeAngle,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get sessionId => $composableBuilder(
    column: $table.sessionId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get endNumber => $composableBuilder(
    column: $table.endNumber,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get shotCount => $composableBuilder(
    column: $table.shotCount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get confidenceScore => $composableBuilder(
    column: $table.confidenceScore,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get venueId => $composableBuilder(
    column: $table.venueId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isIndoor => $composableBuilder(
    column: $table.isIndoor,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get recordedAt => $composableBuilder(
    column: $table.recordedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get deletedAt => $composableBuilder(
    column: $table.deletedAt,
    builder: (column) => ColumnFilters(column),
  );

  $$BowsTableFilterComposer get bowId {
    final $$BowsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.bowId,
      referencedTable: $db.bows,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$BowsTableFilterComposer(
            $db: $db,
            $table: $db.bows,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$SightMarksTableOrderingComposer
    extends Composer<_$AppDatabase, $SightMarksTable> {
  $$SightMarksTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get distance => $composableBuilder(
    column: $table.distance,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get unit => $composableBuilder(
    column: $table.unit,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get sightValue => $composableBuilder(
    column: $table.sightValue,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get weatherData => $composableBuilder(
    column: $table.weatherData,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get elevationDelta => $composableBuilder(
    column: $table.elevationDelta,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get slopeAngle => $composableBuilder(
    column: $table.slopeAngle,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get sessionId => $composableBuilder(
    column: $table.sessionId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get endNumber => $composableBuilder(
    column: $table.endNumber,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get shotCount => $composableBuilder(
    column: $table.shotCount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get confidenceScore => $composableBuilder(
    column: $table.confidenceScore,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get venueId => $composableBuilder(
    column: $table.venueId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isIndoor => $composableBuilder(
    column: $table.isIndoor,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get recordedAt => $composableBuilder(
    column: $table.recordedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get deletedAt => $composableBuilder(
    column: $table.deletedAt,
    builder: (column) => ColumnOrderings(column),
  );

  $$BowsTableOrderingComposer get bowId {
    final $$BowsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.bowId,
      referencedTable: $db.bows,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$BowsTableOrderingComposer(
            $db: $db,
            $table: $db.bows,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$SightMarksTableAnnotationComposer
    extends Composer<_$AppDatabase, $SightMarksTable> {
  $$SightMarksTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<double> get distance =>
      $composableBuilder(column: $table.distance, builder: (column) => column);

  GeneratedColumn<String> get unit =>
      $composableBuilder(column: $table.unit, builder: (column) => column);

  GeneratedColumn<String> get sightValue => $composableBuilder(
    column: $table.sightValue,
    builder: (column) => column,
  );

  GeneratedColumn<String> get weatherData => $composableBuilder(
    column: $table.weatherData,
    builder: (column) => column,
  );

  GeneratedColumn<double> get elevationDelta => $composableBuilder(
    column: $table.elevationDelta,
    builder: (column) => column,
  );

  GeneratedColumn<double> get slopeAngle => $composableBuilder(
    column: $table.slopeAngle,
    builder: (column) => column,
  );

  GeneratedColumn<String> get sessionId =>
      $composableBuilder(column: $table.sessionId, builder: (column) => column);

  GeneratedColumn<int> get endNumber =>
      $composableBuilder(column: $table.endNumber, builder: (column) => column);

  GeneratedColumn<int> get shotCount =>
      $composableBuilder(column: $table.shotCount, builder: (column) => column);

  GeneratedColumn<double> get confidenceScore => $composableBuilder(
    column: $table.confidenceScore,
    builder: (column) => column,
  );

  GeneratedColumn<String> get venueId =>
      $composableBuilder(column: $table.venueId, builder: (column) => column);

  GeneratedColumn<bool> get isIndoor =>
      $composableBuilder(column: $table.isIndoor, builder: (column) => column);

  GeneratedColumn<DateTime> get recordedAt => $composableBuilder(
    column: $table.recordedAt,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  GeneratedColumn<DateTime> get deletedAt =>
      $composableBuilder(column: $table.deletedAt, builder: (column) => column);

  $$BowsTableAnnotationComposer get bowId {
    final $$BowsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.bowId,
      referencedTable: $db.bows,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$BowsTableAnnotationComposer(
            $db: $db,
            $table: $db.bows,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$SightMarksTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $SightMarksTable,
          SightMark,
          $$SightMarksTableFilterComposer,
          $$SightMarksTableOrderingComposer,
          $$SightMarksTableAnnotationComposer,
          $$SightMarksTableCreateCompanionBuilder,
          $$SightMarksTableUpdateCompanionBuilder,
          (SightMark, $$SightMarksTableReferences),
          SightMark,
          PrefetchHooks Function({bool bowId})
        > {
  $$SightMarksTableTableManager(_$AppDatabase db, $SightMarksTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$SightMarksTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$SightMarksTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$SightMarksTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> bowId = const Value.absent(),
                Value<double> distance = const Value.absent(),
                Value<String> unit = const Value.absent(),
                Value<String> sightValue = const Value.absent(),
                Value<String?> weatherData = const Value.absent(),
                Value<double?> elevationDelta = const Value.absent(),
                Value<double?> slopeAngle = const Value.absent(),
                Value<String?> sessionId = const Value.absent(),
                Value<int?> endNumber = const Value.absent(),
                Value<int?> shotCount = const Value.absent(),
                Value<double?> confidenceScore = const Value.absent(),
                Value<String?> venueId = const Value.absent(),
                Value<bool> isIndoor = const Value.absent(),
                Value<DateTime> recordedAt = const Value.absent(),
                Value<DateTime?> updatedAt = const Value.absent(),
                Value<DateTime?> deletedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => SightMarksCompanion(
                id: id,
                bowId: bowId,
                distance: distance,
                unit: unit,
                sightValue: sightValue,
                weatherData: weatherData,
                elevationDelta: elevationDelta,
                slopeAngle: slopeAngle,
                sessionId: sessionId,
                endNumber: endNumber,
                shotCount: shotCount,
                confidenceScore: confidenceScore,
                venueId: venueId,
                isIndoor: isIndoor,
                recordedAt: recordedAt,
                updatedAt: updatedAt,
                deletedAt: deletedAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String bowId,
                required double distance,
                Value<String> unit = const Value.absent(),
                required String sightValue,
                Value<String?> weatherData = const Value.absent(),
                Value<double?> elevationDelta = const Value.absent(),
                Value<double?> slopeAngle = const Value.absent(),
                Value<String?> sessionId = const Value.absent(),
                Value<int?> endNumber = const Value.absent(),
                Value<int?> shotCount = const Value.absent(),
                Value<double?> confidenceScore = const Value.absent(),
                Value<String?> venueId = const Value.absent(),
                Value<bool> isIndoor = const Value.absent(),
                Value<DateTime> recordedAt = const Value.absent(),
                Value<DateTime?> updatedAt = const Value.absent(),
                Value<DateTime?> deletedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => SightMarksCompanion.insert(
                id: id,
                bowId: bowId,
                distance: distance,
                unit: unit,
                sightValue: sightValue,
                weatherData: weatherData,
                elevationDelta: elevationDelta,
                slopeAngle: slopeAngle,
                sessionId: sessionId,
                endNumber: endNumber,
                shotCount: shotCount,
                confidenceScore: confidenceScore,
                venueId: venueId,
                isIndoor: isIndoor,
                recordedAt: recordedAt,
                updatedAt: updatedAt,
                deletedAt: deletedAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$SightMarksTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback: ({bowId = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins:
                  <
                    T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic
                    >
                  >(state) {
                    if (bowId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.bowId,
                                referencedTable: $$SightMarksTableReferences
                                    ._bowIdTable(db),
                                referencedColumn: $$SightMarksTableReferences
                                    ._bowIdTable(db)
                                    .id,
                              )
                              as T;
                    }

                    return state;
                  },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ),
      );
}

typedef $$SightMarksTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $SightMarksTable,
      SightMark,
      $$SightMarksTableFilterComposer,
      $$SightMarksTableOrderingComposer,
      $$SightMarksTableAnnotationComposer,
      $$SightMarksTableCreateCompanionBuilder,
      $$SightMarksTableUpdateCompanionBuilder,
      (SightMark, $$SightMarksTableReferences),
      SightMark,
      PrefetchHooks Function({bool bowId})
    >;
typedef $$SightMarkPreferencesTableTableCreateCompanionBuilder =
    SightMarkPreferencesTableCompanion Function({
      required String bowId,
      Value<String> notationStyle,
      Value<int> decimalPlaces,
      Value<DateTime> createdAt,
      Value<DateTime?> updatedAt,
      Value<int> rowid,
    });
typedef $$SightMarkPreferencesTableTableUpdateCompanionBuilder =
    SightMarkPreferencesTableCompanion Function({
      Value<String> bowId,
      Value<String> notationStyle,
      Value<int> decimalPlaces,
      Value<DateTime> createdAt,
      Value<DateTime?> updatedAt,
      Value<int> rowid,
    });

final class $$SightMarkPreferencesTableTableReferences
    extends
        BaseReferences<
          _$AppDatabase,
          $SightMarkPreferencesTableTable,
          SightMarkPreferencesTableData
        > {
  $$SightMarkPreferencesTableTableReferences(
    super.$_db,
    super.$_table,
    super.$_typedResult,
  );

  static $BowsTable _bowIdTable(_$AppDatabase db) => db.bows.createAlias(
    $_aliasNameGenerator(db.sightMarkPreferencesTable.bowId, db.bows.id),
  );

  $$BowsTableProcessedTableManager get bowId {
    final $_column = $_itemColumn<String>('bow_id')!;

    final manager = $$BowsTableTableManager(
      $_db,
      $_db.bows,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_bowIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$SightMarkPreferencesTableTableFilterComposer
    extends Composer<_$AppDatabase, $SightMarkPreferencesTableTable> {
  $$SightMarkPreferencesTableTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get notationStyle => $composableBuilder(
    column: $table.notationStyle,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get decimalPlaces => $composableBuilder(
    column: $table.decimalPlaces,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );

  $$BowsTableFilterComposer get bowId {
    final $$BowsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.bowId,
      referencedTable: $db.bows,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$BowsTableFilterComposer(
            $db: $db,
            $table: $db.bows,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$SightMarkPreferencesTableTableOrderingComposer
    extends Composer<_$AppDatabase, $SightMarkPreferencesTableTable> {
  $$SightMarkPreferencesTableTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get notationStyle => $composableBuilder(
    column: $table.notationStyle,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get decimalPlaces => $composableBuilder(
    column: $table.decimalPlaces,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  $$BowsTableOrderingComposer get bowId {
    final $$BowsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.bowId,
      referencedTable: $db.bows,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$BowsTableOrderingComposer(
            $db: $db,
            $table: $db.bows,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$SightMarkPreferencesTableTableAnnotationComposer
    extends Composer<_$AppDatabase, $SightMarkPreferencesTableTable> {
  $$SightMarkPreferencesTableTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get notationStyle => $composableBuilder(
    column: $table.notationStyle,
    builder: (column) => column,
  );

  GeneratedColumn<int> get decimalPlaces => $composableBuilder(
    column: $table.decimalPlaces,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  $$BowsTableAnnotationComposer get bowId {
    final $$BowsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.bowId,
      referencedTable: $db.bows,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$BowsTableAnnotationComposer(
            $db: $db,
            $table: $db.bows,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$SightMarkPreferencesTableTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $SightMarkPreferencesTableTable,
          SightMarkPreferencesTableData,
          $$SightMarkPreferencesTableTableFilterComposer,
          $$SightMarkPreferencesTableTableOrderingComposer,
          $$SightMarkPreferencesTableTableAnnotationComposer,
          $$SightMarkPreferencesTableTableCreateCompanionBuilder,
          $$SightMarkPreferencesTableTableUpdateCompanionBuilder,
          (
            SightMarkPreferencesTableData,
            $$SightMarkPreferencesTableTableReferences,
          ),
          SightMarkPreferencesTableData,
          PrefetchHooks Function({bool bowId})
        > {
  $$SightMarkPreferencesTableTableTableManager(
    _$AppDatabase db,
    $SightMarkPreferencesTableTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$SightMarkPreferencesTableTableFilterComposer(
                $db: db,
                $table: table,
              ),
          createOrderingComposer: () =>
              $$SightMarkPreferencesTableTableOrderingComposer(
                $db: db,
                $table: table,
              ),
          createComputedFieldComposer: () =>
              $$SightMarkPreferencesTableTableAnnotationComposer(
                $db: db,
                $table: table,
              ),
          updateCompanionCallback:
              ({
                Value<String> bowId = const Value.absent(),
                Value<String> notationStyle = const Value.absent(),
                Value<int> decimalPlaces = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime?> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => SightMarkPreferencesTableCompanion(
                bowId: bowId,
                notationStyle: notationStyle,
                decimalPlaces: decimalPlaces,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String bowId,
                Value<String> notationStyle = const Value.absent(),
                Value<int> decimalPlaces = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime?> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => SightMarkPreferencesTableCompanion.insert(
                bowId: bowId,
                notationStyle: notationStyle,
                decimalPlaces: decimalPlaces,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$SightMarkPreferencesTableTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback: ({bowId = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins:
                  <
                    T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic
                    >
                  >(state) {
                    if (bowId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.bowId,
                                referencedTable:
                                    $$SightMarkPreferencesTableTableReferences
                                        ._bowIdTable(db),
                                referencedColumn:
                                    $$SightMarkPreferencesTableTableReferences
                                        ._bowIdTable(db)
                                        .id,
                              )
                              as T;
                    }

                    return state;
                  },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ),
      );
}

typedef $$SightMarkPreferencesTableTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $SightMarkPreferencesTableTable,
      SightMarkPreferencesTableData,
      $$SightMarkPreferencesTableTableFilterComposer,
      $$SightMarkPreferencesTableTableOrderingComposer,
      $$SightMarkPreferencesTableTableAnnotationComposer,
      $$SightMarkPreferencesTableTableCreateCompanionBuilder,
      $$SightMarkPreferencesTableTableUpdateCompanionBuilder,
      (
        SightMarkPreferencesTableData,
        $$SightMarkPreferencesTableTableReferences,
      ),
      SightMarkPreferencesTableData,
      PrefetchHooks Function({bool bowId})
    >;
typedef $$AngleCorrectionProfilesTableCreateCompanionBuilder =
    AngleCorrectionProfilesCompanion Function({
      required String id,
      required String bowId,
      required double arrowSpeedFps,
      required double uphillFactor,
      required double downhillFactor,
      Value<int> uphillDataPoints,
      Value<int> downhillDataPoints,
      Value<double> confidenceScore,
      Value<DateTime> lastUpdated,
      Value<int> rowid,
    });
typedef $$AngleCorrectionProfilesTableUpdateCompanionBuilder =
    AngleCorrectionProfilesCompanion Function({
      Value<String> id,
      Value<String> bowId,
      Value<double> arrowSpeedFps,
      Value<double> uphillFactor,
      Value<double> downhillFactor,
      Value<int> uphillDataPoints,
      Value<int> downhillDataPoints,
      Value<double> confidenceScore,
      Value<DateTime> lastUpdated,
      Value<int> rowid,
    });

final class $$AngleCorrectionProfilesTableReferences
    extends
        BaseReferences<
          _$AppDatabase,
          $AngleCorrectionProfilesTable,
          AngleCorrectionProfile
        > {
  $$AngleCorrectionProfilesTableReferences(
    super.$_db,
    super.$_table,
    super.$_typedResult,
  );

  static $BowsTable _bowIdTable(_$AppDatabase db) => db.bows.createAlias(
    $_aliasNameGenerator(db.angleCorrectionProfiles.bowId, db.bows.id),
  );

  $$BowsTableProcessedTableManager get bowId {
    final $_column = $_itemColumn<String>('bow_id')!;

    final manager = $$BowsTableTableManager(
      $_db,
      $_db.bows,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_bowIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$AngleCorrectionProfilesTableFilterComposer
    extends Composer<_$AppDatabase, $AngleCorrectionProfilesTable> {
  $$AngleCorrectionProfilesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get arrowSpeedFps => $composableBuilder(
    column: $table.arrowSpeedFps,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get uphillFactor => $composableBuilder(
    column: $table.uphillFactor,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get downhillFactor => $composableBuilder(
    column: $table.downhillFactor,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get uphillDataPoints => $composableBuilder(
    column: $table.uphillDataPoints,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get downhillDataPoints => $composableBuilder(
    column: $table.downhillDataPoints,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get confidenceScore => $composableBuilder(
    column: $table.confidenceScore,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get lastUpdated => $composableBuilder(
    column: $table.lastUpdated,
    builder: (column) => ColumnFilters(column),
  );

  $$BowsTableFilterComposer get bowId {
    final $$BowsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.bowId,
      referencedTable: $db.bows,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$BowsTableFilterComposer(
            $db: $db,
            $table: $db.bows,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$AngleCorrectionProfilesTableOrderingComposer
    extends Composer<_$AppDatabase, $AngleCorrectionProfilesTable> {
  $$AngleCorrectionProfilesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get arrowSpeedFps => $composableBuilder(
    column: $table.arrowSpeedFps,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get uphillFactor => $composableBuilder(
    column: $table.uphillFactor,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get downhillFactor => $composableBuilder(
    column: $table.downhillFactor,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get uphillDataPoints => $composableBuilder(
    column: $table.uphillDataPoints,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get downhillDataPoints => $composableBuilder(
    column: $table.downhillDataPoints,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get confidenceScore => $composableBuilder(
    column: $table.confidenceScore,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get lastUpdated => $composableBuilder(
    column: $table.lastUpdated,
    builder: (column) => ColumnOrderings(column),
  );

  $$BowsTableOrderingComposer get bowId {
    final $$BowsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.bowId,
      referencedTable: $db.bows,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$BowsTableOrderingComposer(
            $db: $db,
            $table: $db.bows,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$AngleCorrectionProfilesTableAnnotationComposer
    extends Composer<_$AppDatabase, $AngleCorrectionProfilesTable> {
  $$AngleCorrectionProfilesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<double> get arrowSpeedFps => $composableBuilder(
    column: $table.arrowSpeedFps,
    builder: (column) => column,
  );

  GeneratedColumn<double> get uphillFactor => $composableBuilder(
    column: $table.uphillFactor,
    builder: (column) => column,
  );

  GeneratedColumn<double> get downhillFactor => $composableBuilder(
    column: $table.downhillFactor,
    builder: (column) => column,
  );

  GeneratedColumn<int> get uphillDataPoints => $composableBuilder(
    column: $table.uphillDataPoints,
    builder: (column) => column,
  );

  GeneratedColumn<int> get downhillDataPoints => $composableBuilder(
    column: $table.downhillDataPoints,
    builder: (column) => column,
  );

  GeneratedColumn<double> get confidenceScore => $composableBuilder(
    column: $table.confidenceScore,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get lastUpdated => $composableBuilder(
    column: $table.lastUpdated,
    builder: (column) => column,
  );

  $$BowsTableAnnotationComposer get bowId {
    final $$BowsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.bowId,
      referencedTable: $db.bows,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$BowsTableAnnotationComposer(
            $db: $db,
            $table: $db.bows,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$AngleCorrectionProfilesTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $AngleCorrectionProfilesTable,
          AngleCorrectionProfile,
          $$AngleCorrectionProfilesTableFilterComposer,
          $$AngleCorrectionProfilesTableOrderingComposer,
          $$AngleCorrectionProfilesTableAnnotationComposer,
          $$AngleCorrectionProfilesTableCreateCompanionBuilder,
          $$AngleCorrectionProfilesTableUpdateCompanionBuilder,
          (AngleCorrectionProfile, $$AngleCorrectionProfilesTableReferences),
          AngleCorrectionProfile,
          PrefetchHooks Function({bool bowId})
        > {
  $$AngleCorrectionProfilesTableTableManager(
    _$AppDatabase db,
    $AngleCorrectionProfilesTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$AngleCorrectionProfilesTableFilterComposer(
                $db: db,
                $table: table,
              ),
          createOrderingComposer: () =>
              $$AngleCorrectionProfilesTableOrderingComposer(
                $db: db,
                $table: table,
              ),
          createComputedFieldComposer: () =>
              $$AngleCorrectionProfilesTableAnnotationComposer(
                $db: db,
                $table: table,
              ),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> bowId = const Value.absent(),
                Value<double> arrowSpeedFps = const Value.absent(),
                Value<double> uphillFactor = const Value.absent(),
                Value<double> downhillFactor = const Value.absent(),
                Value<int> uphillDataPoints = const Value.absent(),
                Value<int> downhillDataPoints = const Value.absent(),
                Value<double> confidenceScore = const Value.absent(),
                Value<DateTime> lastUpdated = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => AngleCorrectionProfilesCompanion(
                id: id,
                bowId: bowId,
                arrowSpeedFps: arrowSpeedFps,
                uphillFactor: uphillFactor,
                downhillFactor: downhillFactor,
                uphillDataPoints: uphillDataPoints,
                downhillDataPoints: downhillDataPoints,
                confidenceScore: confidenceScore,
                lastUpdated: lastUpdated,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String bowId,
                required double arrowSpeedFps,
                required double uphillFactor,
                required double downhillFactor,
                Value<int> uphillDataPoints = const Value.absent(),
                Value<int> downhillDataPoints = const Value.absent(),
                Value<double> confidenceScore = const Value.absent(),
                Value<DateTime> lastUpdated = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => AngleCorrectionProfilesCompanion.insert(
                id: id,
                bowId: bowId,
                arrowSpeedFps: arrowSpeedFps,
                uphillFactor: uphillFactor,
                downhillFactor: downhillFactor,
                uphillDataPoints: uphillDataPoints,
                downhillDataPoints: downhillDataPoints,
                confidenceScore: confidenceScore,
                lastUpdated: lastUpdated,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$AngleCorrectionProfilesTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback: ({bowId = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins:
                  <
                    T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic
                    >
                  >(state) {
                    if (bowId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.bowId,
                                referencedTable:
                                    $$AngleCorrectionProfilesTableReferences
                                        ._bowIdTable(db),
                                referencedColumn:
                                    $$AngleCorrectionProfilesTableReferences
                                        ._bowIdTable(db)
                                        .id,
                              )
                              as T;
                    }

                    return state;
                  },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ),
      );
}

typedef $$AngleCorrectionProfilesTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $AngleCorrectionProfilesTable,
      AngleCorrectionProfile,
      $$AngleCorrectionProfilesTableFilterComposer,
      $$AngleCorrectionProfilesTableOrderingComposer,
      $$AngleCorrectionProfilesTableAnnotationComposer,
      $$AngleCorrectionProfilesTableCreateCompanionBuilder,
      $$AngleCorrectionProfilesTableUpdateCompanionBuilder,
      (AngleCorrectionProfile, $$AngleCorrectionProfilesTableReferences),
      AngleCorrectionProfile,
      PrefetchHooks Function({bool bowId})
    >;
typedef $$VenuesTableCreateCompanionBuilder =
    VenuesCompanion Function({
      required String id,
      required String name,
      Value<double?> latitude,
      Value<double?> longitude,
      Value<String> temperatureRegion,
      Value<String?> notes,
      Value<DateTime> createdAt,
      Value<DateTime?> updatedAt,
      Value<int> rowid,
    });
typedef $$VenuesTableUpdateCompanionBuilder =
    VenuesCompanion Function({
      Value<String> id,
      Value<String> name,
      Value<double?> latitude,
      Value<double?> longitude,
      Value<String> temperatureRegion,
      Value<String?> notes,
      Value<DateTime> createdAt,
      Value<DateTime?> updatedAt,
      Value<int> rowid,
    });

final class $$VenuesTableReferences
    extends BaseReferences<_$AppDatabase, $VenuesTable, Venue> {
  $$VenuesTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static MultiTypedResultKey<$FieldCoursesTable, List<FieldCourse>>
  _fieldCoursesRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.fieldCourses,
    aliasName: $_aliasNameGenerator(db.venues.id, db.fieldCourses.venueId),
  );

  $$FieldCoursesTableProcessedTableManager get fieldCoursesRefs {
    final manager = $$FieldCoursesTableTableManager(
      $_db,
      $_db.fieldCourses,
    ).filter((f) => f.venueId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_fieldCoursesRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$VenuesTableFilterComposer
    extends Composer<_$AppDatabase, $VenuesTable> {
  $$VenuesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get latitude => $composableBuilder(
    column: $table.latitude,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get longitude => $composableBuilder(
    column: $table.longitude,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get temperatureRegion => $composableBuilder(
    column: $table.temperatureRegion,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );

  Expression<bool> fieldCoursesRefs(
    Expression<bool> Function($$FieldCoursesTableFilterComposer f) f,
  ) {
    final $$FieldCoursesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.fieldCourses,
      getReferencedColumn: (t) => t.venueId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$FieldCoursesTableFilterComposer(
            $db: $db,
            $table: $db.fieldCourses,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$VenuesTableOrderingComposer
    extends Composer<_$AppDatabase, $VenuesTable> {
  $$VenuesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get latitude => $composableBuilder(
    column: $table.latitude,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get longitude => $composableBuilder(
    column: $table.longitude,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get temperatureRegion => $composableBuilder(
    column: $table.temperatureRegion,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$VenuesTableAnnotationComposer
    extends Composer<_$AppDatabase, $VenuesTable> {
  $$VenuesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<double> get latitude =>
      $composableBuilder(column: $table.latitude, builder: (column) => column);

  GeneratedColumn<double> get longitude =>
      $composableBuilder(column: $table.longitude, builder: (column) => column);

  GeneratedColumn<String> get temperatureRegion => $composableBuilder(
    column: $table.temperatureRegion,
    builder: (column) => column,
  );

  GeneratedColumn<String> get notes =>
      $composableBuilder(column: $table.notes, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  Expression<T> fieldCoursesRefs<T extends Object>(
    Expression<T> Function($$FieldCoursesTableAnnotationComposer a) f,
  ) {
    final $$FieldCoursesTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.fieldCourses,
      getReferencedColumn: (t) => t.venueId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$FieldCoursesTableAnnotationComposer(
            $db: $db,
            $table: $db.fieldCourses,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$VenuesTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $VenuesTable,
          Venue,
          $$VenuesTableFilterComposer,
          $$VenuesTableOrderingComposer,
          $$VenuesTableAnnotationComposer,
          $$VenuesTableCreateCompanionBuilder,
          $$VenuesTableUpdateCompanionBuilder,
          (Venue, $$VenuesTableReferences),
          Venue,
          PrefetchHooks Function({bool fieldCoursesRefs})
        > {
  $$VenuesTableTableManager(_$AppDatabase db, $VenuesTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$VenuesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$VenuesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$VenuesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<double?> latitude = const Value.absent(),
                Value<double?> longitude = const Value.absent(),
                Value<String> temperatureRegion = const Value.absent(),
                Value<String?> notes = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime?> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => VenuesCompanion(
                id: id,
                name: name,
                latitude: latitude,
                longitude: longitude,
                temperatureRegion: temperatureRegion,
                notes: notes,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String name,
                Value<double?> latitude = const Value.absent(),
                Value<double?> longitude = const Value.absent(),
                Value<String> temperatureRegion = const Value.absent(),
                Value<String?> notes = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime?> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => VenuesCompanion.insert(
                id: id,
                name: name,
                latitude: latitude,
                longitude: longitude,
                temperatureRegion: temperatureRegion,
                notes: notes,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) =>
                    (e.readTable(table), $$VenuesTableReferences(db, table, e)),
              )
              .toList(),
          prefetchHooksCallback: ({fieldCoursesRefs = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [if (fieldCoursesRefs) db.fieldCourses],
              addJoins: null,
              getPrefetchedDataCallback: (items) async {
                return [
                  if (fieldCoursesRefs)
                    await $_getPrefetchedData<Venue, $VenuesTable, FieldCourse>(
                      currentTable: table,
                      referencedTable: $$VenuesTableReferences
                          ._fieldCoursesRefsTable(db),
                      managerFromTypedResult: (p0) => $$VenuesTableReferences(
                        db,
                        table,
                        p0,
                      ).fieldCoursesRefs,
                      referencedItemsForCurrentItem: (item, referencedItems) =>
                          referencedItems.where((e) => e.venueId == item.id),
                      typedResults: items,
                    ),
                ];
              },
            );
          },
        ),
      );
}

typedef $$VenuesTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $VenuesTable,
      Venue,
      $$VenuesTableFilterComposer,
      $$VenuesTableOrderingComposer,
      $$VenuesTableAnnotationComposer,
      $$VenuesTableCreateCompanionBuilder,
      $$VenuesTableUpdateCompanionBuilder,
      (Venue, $$VenuesTableReferences),
      Venue,
      PrefetchHooks Function({bool fieldCoursesRefs})
    >;
typedef $$RegisteredTargetsTableCreateCompanionBuilder =
    RegisteredTargetsCompanion Function({
      required String id,
      required String targetType,
      required String imagePath,
      Value<bool> isTripleSpot,
      Value<DateTime> createdAt,
      Value<int> rowid,
    });
typedef $$RegisteredTargetsTableUpdateCompanionBuilder =
    RegisteredTargetsCompanion Function({
      Value<String> id,
      Value<String> targetType,
      Value<String> imagePath,
      Value<bool> isTripleSpot,
      Value<DateTime> createdAt,
      Value<int> rowid,
    });

class $$RegisteredTargetsTableFilterComposer
    extends Composer<_$AppDatabase, $RegisteredTargetsTable> {
  $$RegisteredTargetsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get targetType => $composableBuilder(
    column: $table.targetType,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get imagePath => $composableBuilder(
    column: $table.imagePath,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isTripleSpot => $composableBuilder(
    column: $table.isTripleSpot,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );
}

class $$RegisteredTargetsTableOrderingComposer
    extends Composer<_$AppDatabase, $RegisteredTargetsTable> {
  $$RegisteredTargetsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get targetType => $composableBuilder(
    column: $table.targetType,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get imagePath => $composableBuilder(
    column: $table.imagePath,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isTripleSpot => $composableBuilder(
    column: $table.isTripleSpot,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$RegisteredTargetsTableAnnotationComposer
    extends Composer<_$AppDatabase, $RegisteredTargetsTable> {
  $$RegisteredTargetsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get targetType => $composableBuilder(
    column: $table.targetType,
    builder: (column) => column,
  );

  GeneratedColumn<String> get imagePath =>
      $composableBuilder(column: $table.imagePath, builder: (column) => column);

  GeneratedColumn<bool> get isTripleSpot => $composableBuilder(
    column: $table.isTripleSpot,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);
}

class $$RegisteredTargetsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $RegisteredTargetsTable,
          RegisteredTarget,
          $$RegisteredTargetsTableFilterComposer,
          $$RegisteredTargetsTableOrderingComposer,
          $$RegisteredTargetsTableAnnotationComposer,
          $$RegisteredTargetsTableCreateCompanionBuilder,
          $$RegisteredTargetsTableUpdateCompanionBuilder,
          (
            RegisteredTarget,
            BaseReferences<
              _$AppDatabase,
              $RegisteredTargetsTable,
              RegisteredTarget
            >,
          ),
          RegisteredTarget,
          PrefetchHooks Function()
        > {
  $$RegisteredTargetsTableTableManager(
    _$AppDatabase db,
    $RegisteredTargetsTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$RegisteredTargetsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$RegisteredTargetsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$RegisteredTargetsTableAnnotationComposer(
                $db: db,
                $table: table,
              ),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> targetType = const Value.absent(),
                Value<String> imagePath = const Value.absent(),
                Value<bool> isTripleSpot = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => RegisteredTargetsCompanion(
                id: id,
                targetType: targetType,
                imagePath: imagePath,
                isTripleSpot: isTripleSpot,
                createdAt: createdAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String targetType,
                required String imagePath,
                Value<bool> isTripleSpot = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => RegisteredTargetsCompanion.insert(
                id: id,
                targetType: targetType,
                imagePath: imagePath,
                isTripleSpot: isTripleSpot,
                createdAt: createdAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$RegisteredTargetsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $RegisteredTargetsTable,
      RegisteredTarget,
      $$RegisteredTargetsTableFilterComposer,
      $$RegisteredTargetsTableOrderingComposer,
      $$RegisteredTargetsTableAnnotationComposer,
      $$RegisteredTargetsTableCreateCompanionBuilder,
      $$RegisteredTargetsTableUpdateCompanionBuilder,
      (
        RegisteredTarget,
        BaseReferences<
          _$AppDatabase,
          $RegisteredTargetsTable,
          RegisteredTarget
        >,
      ),
      RegisteredTarget,
      PrefetchHooks Function()
    >;
typedef $$AutoPlotUsageTableCreateCompanionBuilder =
    AutoPlotUsageCompanion Function({
      required String id,
      required String yearMonth,
      Value<int> scanCount,
      Value<int> rowid,
    });
typedef $$AutoPlotUsageTableUpdateCompanionBuilder =
    AutoPlotUsageCompanion Function({
      Value<String> id,
      Value<String> yearMonth,
      Value<int> scanCount,
      Value<int> rowid,
    });

class $$AutoPlotUsageTableFilterComposer
    extends Composer<_$AppDatabase, $AutoPlotUsageTable> {
  $$AutoPlotUsageTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get yearMonth => $composableBuilder(
    column: $table.yearMonth,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get scanCount => $composableBuilder(
    column: $table.scanCount,
    builder: (column) => ColumnFilters(column),
  );
}

class $$AutoPlotUsageTableOrderingComposer
    extends Composer<_$AppDatabase, $AutoPlotUsageTable> {
  $$AutoPlotUsageTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get yearMonth => $composableBuilder(
    column: $table.yearMonth,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get scanCount => $composableBuilder(
    column: $table.scanCount,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$AutoPlotUsageTableAnnotationComposer
    extends Composer<_$AppDatabase, $AutoPlotUsageTable> {
  $$AutoPlotUsageTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get yearMonth =>
      $composableBuilder(column: $table.yearMonth, builder: (column) => column);

  GeneratedColumn<int> get scanCount =>
      $composableBuilder(column: $table.scanCount, builder: (column) => column);
}

class $$AutoPlotUsageTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $AutoPlotUsageTable,
          AutoPlotUsageData,
          $$AutoPlotUsageTableFilterComposer,
          $$AutoPlotUsageTableOrderingComposer,
          $$AutoPlotUsageTableAnnotationComposer,
          $$AutoPlotUsageTableCreateCompanionBuilder,
          $$AutoPlotUsageTableUpdateCompanionBuilder,
          (
            AutoPlotUsageData,
            BaseReferences<
              _$AppDatabase,
              $AutoPlotUsageTable,
              AutoPlotUsageData
            >,
          ),
          AutoPlotUsageData,
          PrefetchHooks Function()
        > {
  $$AutoPlotUsageTableTableManager(_$AppDatabase db, $AutoPlotUsageTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$AutoPlotUsageTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$AutoPlotUsageTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$AutoPlotUsageTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> yearMonth = const Value.absent(),
                Value<int> scanCount = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => AutoPlotUsageCompanion(
                id: id,
                yearMonth: yearMonth,
                scanCount: scanCount,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String yearMonth,
                Value<int> scanCount = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => AutoPlotUsageCompanion.insert(
                id: id,
                yearMonth: yearMonth,
                scanCount: scanCount,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$AutoPlotUsageTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $AutoPlotUsageTable,
      AutoPlotUsageData,
      $$AutoPlotUsageTableFilterComposer,
      $$AutoPlotUsageTableOrderingComposer,
      $$AutoPlotUsageTableAnnotationComposer,
      $$AutoPlotUsageTableCreateCompanionBuilder,
      $$AutoPlotUsageTableUpdateCompanionBuilder,
      (
        AutoPlotUsageData,
        BaseReferences<_$AppDatabase, $AutoPlotUsageTable, AutoPlotUsageData>,
      ),
      AutoPlotUsageData,
      PrefetchHooks Function()
    >;
typedef $$UserProfilesTableCreateCompanionBuilder =
    UserProfilesCompanion Function({
      required String id,
      Value<String> primaryBowType,
      Value<String> handedness,
      Value<double?> drawLength,
      Value<String?> name,
      Value<String?> clubName,
      Value<int?> yearsShootingStart,
      Value<double> shootingFrequency,
      Value<String> competitionLevels,
      Value<String?> gender,
      Value<DateTime?> dateOfBirth,
      Value<String?> notes,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<int> rowid,
    });
typedef $$UserProfilesTableUpdateCompanionBuilder =
    UserProfilesCompanion Function({
      Value<String> id,
      Value<String> primaryBowType,
      Value<String> handedness,
      Value<double?> drawLength,
      Value<String?> name,
      Value<String?> clubName,
      Value<int?> yearsShootingStart,
      Value<double> shootingFrequency,
      Value<String> competitionLevels,
      Value<String?> gender,
      Value<DateTime?> dateOfBirth,
      Value<String?> notes,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<int> rowid,
    });

final class $$UserProfilesTableReferences
    extends BaseReferences<_$AppDatabase, $UserProfilesTable, UserProfile> {
  $$UserProfilesTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static MultiTypedResultKey<$FederationsTable, List<Federation>>
  _federationsRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.federations,
    aliasName: $_aliasNameGenerator(
      db.userProfiles.id,
      db.federations.profileId,
    ),
  );

  $$FederationsTableProcessedTableManager get federationsRefs {
    final manager = $$FederationsTableTableManager(
      $_db,
      $_db.federations,
    ).filter((f) => f.profileId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_federationsRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$ClassificationsTable, List<Classification>>
  _classificationsRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.classifications,
    aliasName: $_aliasNameGenerator(
      db.userProfiles.id,
      db.classifications.profileId,
    ),
  );

  $$ClassificationsTableProcessedTableManager get classificationsRefs {
    final manager = $$ClassificationsTableTableManager(
      $_db,
      $_db.classifications,
    ).filter((f) => f.profileId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(
      _classificationsRefsTable($_db),
    );
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$UserProfilesTableFilterComposer
    extends Composer<_$AppDatabase, $UserProfilesTable> {
  $$UserProfilesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get primaryBowType => $composableBuilder(
    column: $table.primaryBowType,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get handedness => $composableBuilder(
    column: $table.handedness,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get drawLength => $composableBuilder(
    column: $table.drawLength,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get clubName => $composableBuilder(
    column: $table.clubName,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get yearsShootingStart => $composableBuilder(
    column: $table.yearsShootingStart,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get shootingFrequency => $composableBuilder(
    column: $table.shootingFrequency,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get competitionLevels => $composableBuilder(
    column: $table.competitionLevels,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get gender => $composableBuilder(
    column: $table.gender,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get dateOfBirth => $composableBuilder(
    column: $table.dateOfBirth,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );

  Expression<bool> federationsRefs(
    Expression<bool> Function($$FederationsTableFilterComposer f) f,
  ) {
    final $$FederationsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.federations,
      getReferencedColumn: (t) => t.profileId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$FederationsTableFilterComposer(
            $db: $db,
            $table: $db.federations,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> classificationsRefs(
    Expression<bool> Function($$ClassificationsTableFilterComposer f) f,
  ) {
    final $$ClassificationsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.classifications,
      getReferencedColumn: (t) => t.profileId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ClassificationsTableFilterComposer(
            $db: $db,
            $table: $db.classifications,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$UserProfilesTableOrderingComposer
    extends Composer<_$AppDatabase, $UserProfilesTable> {
  $$UserProfilesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get primaryBowType => $composableBuilder(
    column: $table.primaryBowType,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get handedness => $composableBuilder(
    column: $table.handedness,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get drawLength => $composableBuilder(
    column: $table.drawLength,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get clubName => $composableBuilder(
    column: $table.clubName,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get yearsShootingStart => $composableBuilder(
    column: $table.yearsShootingStart,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get shootingFrequency => $composableBuilder(
    column: $table.shootingFrequency,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get competitionLevels => $composableBuilder(
    column: $table.competitionLevels,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get gender => $composableBuilder(
    column: $table.gender,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get dateOfBirth => $composableBuilder(
    column: $table.dateOfBirth,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$UserProfilesTableAnnotationComposer
    extends Composer<_$AppDatabase, $UserProfilesTable> {
  $$UserProfilesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get primaryBowType => $composableBuilder(
    column: $table.primaryBowType,
    builder: (column) => column,
  );

  GeneratedColumn<String> get handedness => $composableBuilder(
    column: $table.handedness,
    builder: (column) => column,
  );

  GeneratedColumn<double> get drawLength => $composableBuilder(
    column: $table.drawLength,
    builder: (column) => column,
  );

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get clubName =>
      $composableBuilder(column: $table.clubName, builder: (column) => column);

  GeneratedColumn<int> get yearsShootingStart => $composableBuilder(
    column: $table.yearsShootingStart,
    builder: (column) => column,
  );

  GeneratedColumn<double> get shootingFrequency => $composableBuilder(
    column: $table.shootingFrequency,
    builder: (column) => column,
  );

  GeneratedColumn<String> get competitionLevels => $composableBuilder(
    column: $table.competitionLevels,
    builder: (column) => column,
  );

  GeneratedColumn<String> get gender =>
      $composableBuilder(column: $table.gender, builder: (column) => column);

  GeneratedColumn<DateTime> get dateOfBirth => $composableBuilder(
    column: $table.dateOfBirth,
    builder: (column) => column,
  );

  GeneratedColumn<String> get notes =>
      $composableBuilder(column: $table.notes, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  Expression<T> federationsRefs<T extends Object>(
    Expression<T> Function($$FederationsTableAnnotationComposer a) f,
  ) {
    final $$FederationsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.federations,
      getReferencedColumn: (t) => t.profileId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$FederationsTableAnnotationComposer(
            $db: $db,
            $table: $db.federations,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> classificationsRefs<T extends Object>(
    Expression<T> Function($$ClassificationsTableAnnotationComposer a) f,
  ) {
    final $$ClassificationsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.classifications,
      getReferencedColumn: (t) => t.profileId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ClassificationsTableAnnotationComposer(
            $db: $db,
            $table: $db.classifications,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$UserProfilesTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $UserProfilesTable,
          UserProfile,
          $$UserProfilesTableFilterComposer,
          $$UserProfilesTableOrderingComposer,
          $$UserProfilesTableAnnotationComposer,
          $$UserProfilesTableCreateCompanionBuilder,
          $$UserProfilesTableUpdateCompanionBuilder,
          (UserProfile, $$UserProfilesTableReferences),
          UserProfile,
          PrefetchHooks Function({
            bool federationsRefs,
            bool classificationsRefs,
          })
        > {
  $$UserProfilesTableTableManager(_$AppDatabase db, $UserProfilesTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$UserProfilesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$UserProfilesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$UserProfilesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> primaryBowType = const Value.absent(),
                Value<String> handedness = const Value.absent(),
                Value<double?> drawLength = const Value.absent(),
                Value<String?> name = const Value.absent(),
                Value<String?> clubName = const Value.absent(),
                Value<int?> yearsShootingStart = const Value.absent(),
                Value<double> shootingFrequency = const Value.absent(),
                Value<String> competitionLevels = const Value.absent(),
                Value<String?> gender = const Value.absent(),
                Value<DateTime?> dateOfBirth = const Value.absent(),
                Value<String?> notes = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => UserProfilesCompanion(
                id: id,
                primaryBowType: primaryBowType,
                handedness: handedness,
                drawLength: drawLength,
                name: name,
                clubName: clubName,
                yearsShootingStart: yearsShootingStart,
                shootingFrequency: shootingFrequency,
                competitionLevels: competitionLevels,
                gender: gender,
                dateOfBirth: dateOfBirth,
                notes: notes,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                Value<String> primaryBowType = const Value.absent(),
                Value<String> handedness = const Value.absent(),
                Value<double?> drawLength = const Value.absent(),
                Value<String?> name = const Value.absent(),
                Value<String?> clubName = const Value.absent(),
                Value<int?> yearsShootingStart = const Value.absent(),
                Value<double> shootingFrequency = const Value.absent(),
                Value<String> competitionLevels = const Value.absent(),
                Value<String?> gender = const Value.absent(),
                Value<DateTime?> dateOfBirth = const Value.absent(),
                Value<String?> notes = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => UserProfilesCompanion.insert(
                id: id,
                primaryBowType: primaryBowType,
                handedness: handedness,
                drawLength: drawLength,
                name: name,
                clubName: clubName,
                yearsShootingStart: yearsShootingStart,
                shootingFrequency: shootingFrequency,
                competitionLevels: competitionLevels,
                gender: gender,
                dateOfBirth: dateOfBirth,
                notes: notes,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$UserProfilesTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback:
              ({federationsRefs = false, classificationsRefs = false}) {
                return PrefetchHooks(
                  db: db,
                  explicitlyWatchedTables: [
                    if (federationsRefs) db.federations,
                    if (classificationsRefs) db.classifications,
                  ],
                  addJoins: null,
                  getPrefetchedDataCallback: (items) async {
                    return [
                      if (federationsRefs)
                        await $_getPrefetchedData<
                          UserProfile,
                          $UserProfilesTable,
                          Federation
                        >(
                          currentTable: table,
                          referencedTable: $$UserProfilesTableReferences
                              ._federationsRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$UserProfilesTableReferences(
                                db,
                                table,
                                p0,
                              ).federationsRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.profileId == item.id,
                              ),
                          typedResults: items,
                        ),
                      if (classificationsRefs)
                        await $_getPrefetchedData<
                          UserProfile,
                          $UserProfilesTable,
                          Classification
                        >(
                          currentTable: table,
                          referencedTable: $$UserProfilesTableReferences
                              ._classificationsRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$UserProfilesTableReferences(
                                db,
                                table,
                                p0,
                              ).classificationsRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.profileId == item.id,
                              ),
                          typedResults: items,
                        ),
                    ];
                  },
                );
              },
        ),
      );
}

typedef $$UserProfilesTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $UserProfilesTable,
      UserProfile,
      $$UserProfilesTableFilterComposer,
      $$UserProfilesTableOrderingComposer,
      $$UserProfilesTableAnnotationComposer,
      $$UserProfilesTableCreateCompanionBuilder,
      $$UserProfilesTableUpdateCompanionBuilder,
      (UserProfile, $$UserProfilesTableReferences),
      UserProfile,
      PrefetchHooks Function({bool federationsRefs, bool classificationsRefs})
    >;
typedef $$FederationsTableCreateCompanionBuilder =
    FederationsCompanion Function({
      required String id,
      required String profileId,
      required String federationName,
      Value<String?> membershipNumber,
      Value<String?> cardImagePath,
      Value<DateTime?> expiryDate,
      Value<bool> isPrimary,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<DateTime?> deletedAt,
      Value<int> rowid,
    });
typedef $$FederationsTableUpdateCompanionBuilder =
    FederationsCompanion Function({
      Value<String> id,
      Value<String> profileId,
      Value<String> federationName,
      Value<String?> membershipNumber,
      Value<String?> cardImagePath,
      Value<DateTime?> expiryDate,
      Value<bool> isPrimary,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<DateTime?> deletedAt,
      Value<int> rowid,
    });

final class $$FederationsTableReferences
    extends BaseReferences<_$AppDatabase, $FederationsTable, Federation> {
  $$FederationsTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $UserProfilesTable _profileIdTable(_$AppDatabase db) =>
      db.userProfiles.createAlias(
        $_aliasNameGenerator(db.federations.profileId, db.userProfiles.id),
      );

  $$UserProfilesTableProcessedTableManager get profileId {
    final $_column = $_itemColumn<String>('profile_id')!;

    final manager = $$UserProfilesTableTableManager(
      $_db,
      $_db.userProfiles,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_profileIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$FederationsTableFilterComposer
    extends Composer<_$AppDatabase, $FederationsTable> {
  $$FederationsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get federationName => $composableBuilder(
    column: $table.federationName,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get membershipNumber => $composableBuilder(
    column: $table.membershipNumber,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get cardImagePath => $composableBuilder(
    column: $table.cardImagePath,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get expiryDate => $composableBuilder(
    column: $table.expiryDate,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isPrimary => $composableBuilder(
    column: $table.isPrimary,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get deletedAt => $composableBuilder(
    column: $table.deletedAt,
    builder: (column) => ColumnFilters(column),
  );

  $$UserProfilesTableFilterComposer get profileId {
    final $$UserProfilesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.profileId,
      referencedTable: $db.userProfiles,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UserProfilesTableFilterComposer(
            $db: $db,
            $table: $db.userProfiles,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$FederationsTableOrderingComposer
    extends Composer<_$AppDatabase, $FederationsTable> {
  $$FederationsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get federationName => $composableBuilder(
    column: $table.federationName,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get membershipNumber => $composableBuilder(
    column: $table.membershipNumber,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get cardImagePath => $composableBuilder(
    column: $table.cardImagePath,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get expiryDate => $composableBuilder(
    column: $table.expiryDate,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isPrimary => $composableBuilder(
    column: $table.isPrimary,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get deletedAt => $composableBuilder(
    column: $table.deletedAt,
    builder: (column) => ColumnOrderings(column),
  );

  $$UserProfilesTableOrderingComposer get profileId {
    final $$UserProfilesTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.profileId,
      referencedTable: $db.userProfiles,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UserProfilesTableOrderingComposer(
            $db: $db,
            $table: $db.userProfiles,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$FederationsTableAnnotationComposer
    extends Composer<_$AppDatabase, $FederationsTable> {
  $$FederationsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get federationName => $composableBuilder(
    column: $table.federationName,
    builder: (column) => column,
  );

  GeneratedColumn<String> get membershipNumber => $composableBuilder(
    column: $table.membershipNumber,
    builder: (column) => column,
  );

  GeneratedColumn<String> get cardImagePath => $composableBuilder(
    column: $table.cardImagePath,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get expiryDate => $composableBuilder(
    column: $table.expiryDate,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get isPrimary =>
      $composableBuilder(column: $table.isPrimary, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  GeneratedColumn<DateTime> get deletedAt =>
      $composableBuilder(column: $table.deletedAt, builder: (column) => column);

  $$UserProfilesTableAnnotationComposer get profileId {
    final $$UserProfilesTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.profileId,
      referencedTable: $db.userProfiles,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UserProfilesTableAnnotationComposer(
            $db: $db,
            $table: $db.userProfiles,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$FederationsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $FederationsTable,
          Federation,
          $$FederationsTableFilterComposer,
          $$FederationsTableOrderingComposer,
          $$FederationsTableAnnotationComposer,
          $$FederationsTableCreateCompanionBuilder,
          $$FederationsTableUpdateCompanionBuilder,
          (Federation, $$FederationsTableReferences),
          Federation,
          PrefetchHooks Function({bool profileId})
        > {
  $$FederationsTableTableManager(_$AppDatabase db, $FederationsTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$FederationsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$FederationsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$FederationsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> profileId = const Value.absent(),
                Value<String> federationName = const Value.absent(),
                Value<String?> membershipNumber = const Value.absent(),
                Value<String?> cardImagePath = const Value.absent(),
                Value<DateTime?> expiryDate = const Value.absent(),
                Value<bool> isPrimary = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<DateTime?> deletedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => FederationsCompanion(
                id: id,
                profileId: profileId,
                federationName: federationName,
                membershipNumber: membershipNumber,
                cardImagePath: cardImagePath,
                expiryDate: expiryDate,
                isPrimary: isPrimary,
                createdAt: createdAt,
                updatedAt: updatedAt,
                deletedAt: deletedAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String profileId,
                required String federationName,
                Value<String?> membershipNumber = const Value.absent(),
                Value<String?> cardImagePath = const Value.absent(),
                Value<DateTime?> expiryDate = const Value.absent(),
                Value<bool> isPrimary = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<DateTime?> deletedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => FederationsCompanion.insert(
                id: id,
                profileId: profileId,
                federationName: federationName,
                membershipNumber: membershipNumber,
                cardImagePath: cardImagePath,
                expiryDate: expiryDate,
                isPrimary: isPrimary,
                createdAt: createdAt,
                updatedAt: updatedAt,
                deletedAt: deletedAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$FederationsTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback: ({profileId = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins:
                  <
                    T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic
                    >
                  >(state) {
                    if (profileId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.profileId,
                                referencedTable: $$FederationsTableReferences
                                    ._profileIdTable(db),
                                referencedColumn: $$FederationsTableReferences
                                    ._profileIdTable(db)
                                    .id,
                              )
                              as T;
                    }

                    return state;
                  },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ),
      );
}

typedef $$FederationsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $FederationsTable,
      Federation,
      $$FederationsTableFilterComposer,
      $$FederationsTableOrderingComposer,
      $$FederationsTableAnnotationComposer,
      $$FederationsTableCreateCompanionBuilder,
      $$FederationsTableUpdateCompanionBuilder,
      (Federation, $$FederationsTableReferences),
      Federation,
      PrefetchHooks Function({bool profileId})
    >;
typedef $$ClassificationsTableCreateCompanionBuilder =
    ClassificationsCompanion Function({
      required String id,
      required String profileId,
      required String classification,
      required String classificationScope,
      required String bowstyle,
      Value<String?> firstSessionId,
      Value<DateTime?> firstAchievedAt,
      Value<int?> firstScore,
      Value<String?> firstRoundId,
      Value<String?> secondSessionId,
      Value<DateTime?> secondAchievedAt,
      Value<int?> secondScore,
      Value<String?> secondRoundId,
      Value<bool> isClaimed,
      Value<DateTime?> claimedAt,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<int> rowid,
    });
typedef $$ClassificationsTableUpdateCompanionBuilder =
    ClassificationsCompanion Function({
      Value<String> id,
      Value<String> profileId,
      Value<String> classification,
      Value<String> classificationScope,
      Value<String> bowstyle,
      Value<String?> firstSessionId,
      Value<DateTime?> firstAchievedAt,
      Value<int?> firstScore,
      Value<String?> firstRoundId,
      Value<String?> secondSessionId,
      Value<DateTime?> secondAchievedAt,
      Value<int?> secondScore,
      Value<String?> secondRoundId,
      Value<bool> isClaimed,
      Value<DateTime?> claimedAt,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<int> rowid,
    });

final class $$ClassificationsTableReferences
    extends
        BaseReferences<_$AppDatabase, $ClassificationsTable, Classification> {
  $$ClassificationsTableReferences(
    super.$_db,
    super.$_table,
    super.$_typedResult,
  );

  static $UserProfilesTable _profileIdTable(_$AppDatabase db) =>
      db.userProfiles.createAlias(
        $_aliasNameGenerator(db.classifications.profileId, db.userProfiles.id),
      );

  $$UserProfilesTableProcessedTableManager get profileId {
    final $_column = $_itemColumn<String>('profile_id')!;

    final manager = $$UserProfilesTableTableManager(
      $_db,
      $_db.userProfiles,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_profileIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $SessionsTable _firstSessionIdTable(_$AppDatabase db) =>
      db.sessions.createAlias(
        $_aliasNameGenerator(db.classifications.firstSessionId, db.sessions.id),
      );

  $$SessionsTableProcessedTableManager? get firstSessionId {
    final $_column = $_itemColumn<String>('first_session_id');
    if ($_column == null) return null;
    final manager = $$SessionsTableTableManager(
      $_db,
      $_db.sessions,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_firstSessionIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $SessionsTable _secondSessionIdTable(_$AppDatabase db) =>
      db.sessions.createAlias(
        $_aliasNameGenerator(
          db.classifications.secondSessionId,
          db.sessions.id,
        ),
      );

  $$SessionsTableProcessedTableManager? get secondSessionId {
    final $_column = $_itemColumn<String>('second_session_id');
    if ($_column == null) return null;
    final manager = $$SessionsTableTableManager(
      $_db,
      $_db.sessions,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_secondSessionIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$ClassificationsTableFilterComposer
    extends Composer<_$AppDatabase, $ClassificationsTable> {
  $$ClassificationsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get classification => $composableBuilder(
    column: $table.classification,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get classificationScope => $composableBuilder(
    column: $table.classificationScope,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get bowstyle => $composableBuilder(
    column: $table.bowstyle,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get firstAchievedAt => $composableBuilder(
    column: $table.firstAchievedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get firstScore => $composableBuilder(
    column: $table.firstScore,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get firstRoundId => $composableBuilder(
    column: $table.firstRoundId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get secondAchievedAt => $composableBuilder(
    column: $table.secondAchievedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get secondScore => $composableBuilder(
    column: $table.secondScore,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get secondRoundId => $composableBuilder(
    column: $table.secondRoundId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isClaimed => $composableBuilder(
    column: $table.isClaimed,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get claimedAt => $composableBuilder(
    column: $table.claimedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );

  $$UserProfilesTableFilterComposer get profileId {
    final $$UserProfilesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.profileId,
      referencedTable: $db.userProfiles,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UserProfilesTableFilterComposer(
            $db: $db,
            $table: $db.userProfiles,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$SessionsTableFilterComposer get firstSessionId {
    final $$SessionsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.firstSessionId,
      referencedTable: $db.sessions,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SessionsTableFilterComposer(
            $db: $db,
            $table: $db.sessions,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$SessionsTableFilterComposer get secondSessionId {
    final $$SessionsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.secondSessionId,
      referencedTable: $db.sessions,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SessionsTableFilterComposer(
            $db: $db,
            $table: $db.sessions,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$ClassificationsTableOrderingComposer
    extends Composer<_$AppDatabase, $ClassificationsTable> {
  $$ClassificationsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get classification => $composableBuilder(
    column: $table.classification,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get classificationScope => $composableBuilder(
    column: $table.classificationScope,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get bowstyle => $composableBuilder(
    column: $table.bowstyle,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get firstAchievedAt => $composableBuilder(
    column: $table.firstAchievedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get firstScore => $composableBuilder(
    column: $table.firstScore,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get firstRoundId => $composableBuilder(
    column: $table.firstRoundId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get secondAchievedAt => $composableBuilder(
    column: $table.secondAchievedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get secondScore => $composableBuilder(
    column: $table.secondScore,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get secondRoundId => $composableBuilder(
    column: $table.secondRoundId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isClaimed => $composableBuilder(
    column: $table.isClaimed,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get claimedAt => $composableBuilder(
    column: $table.claimedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  $$UserProfilesTableOrderingComposer get profileId {
    final $$UserProfilesTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.profileId,
      referencedTable: $db.userProfiles,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UserProfilesTableOrderingComposer(
            $db: $db,
            $table: $db.userProfiles,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$SessionsTableOrderingComposer get firstSessionId {
    final $$SessionsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.firstSessionId,
      referencedTable: $db.sessions,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SessionsTableOrderingComposer(
            $db: $db,
            $table: $db.sessions,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$SessionsTableOrderingComposer get secondSessionId {
    final $$SessionsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.secondSessionId,
      referencedTable: $db.sessions,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SessionsTableOrderingComposer(
            $db: $db,
            $table: $db.sessions,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$ClassificationsTableAnnotationComposer
    extends Composer<_$AppDatabase, $ClassificationsTable> {
  $$ClassificationsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get classification => $composableBuilder(
    column: $table.classification,
    builder: (column) => column,
  );

  GeneratedColumn<String> get classificationScope => $composableBuilder(
    column: $table.classificationScope,
    builder: (column) => column,
  );

  GeneratedColumn<String> get bowstyle =>
      $composableBuilder(column: $table.bowstyle, builder: (column) => column);

  GeneratedColumn<DateTime> get firstAchievedAt => $composableBuilder(
    column: $table.firstAchievedAt,
    builder: (column) => column,
  );

  GeneratedColumn<int> get firstScore => $composableBuilder(
    column: $table.firstScore,
    builder: (column) => column,
  );

  GeneratedColumn<String> get firstRoundId => $composableBuilder(
    column: $table.firstRoundId,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get secondAchievedAt => $composableBuilder(
    column: $table.secondAchievedAt,
    builder: (column) => column,
  );

  GeneratedColumn<int> get secondScore => $composableBuilder(
    column: $table.secondScore,
    builder: (column) => column,
  );

  GeneratedColumn<String> get secondRoundId => $composableBuilder(
    column: $table.secondRoundId,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get isClaimed =>
      $composableBuilder(column: $table.isClaimed, builder: (column) => column);

  GeneratedColumn<DateTime> get claimedAt =>
      $composableBuilder(column: $table.claimedAt, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  $$UserProfilesTableAnnotationComposer get profileId {
    final $$UserProfilesTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.profileId,
      referencedTable: $db.userProfiles,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UserProfilesTableAnnotationComposer(
            $db: $db,
            $table: $db.userProfiles,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$SessionsTableAnnotationComposer get firstSessionId {
    final $$SessionsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.firstSessionId,
      referencedTable: $db.sessions,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SessionsTableAnnotationComposer(
            $db: $db,
            $table: $db.sessions,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$SessionsTableAnnotationComposer get secondSessionId {
    final $$SessionsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.secondSessionId,
      referencedTable: $db.sessions,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SessionsTableAnnotationComposer(
            $db: $db,
            $table: $db.sessions,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$ClassificationsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $ClassificationsTable,
          Classification,
          $$ClassificationsTableFilterComposer,
          $$ClassificationsTableOrderingComposer,
          $$ClassificationsTableAnnotationComposer,
          $$ClassificationsTableCreateCompanionBuilder,
          $$ClassificationsTableUpdateCompanionBuilder,
          (Classification, $$ClassificationsTableReferences),
          Classification,
          PrefetchHooks Function({
            bool profileId,
            bool firstSessionId,
            bool secondSessionId,
          })
        > {
  $$ClassificationsTableTableManager(
    _$AppDatabase db,
    $ClassificationsTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$ClassificationsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$ClassificationsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$ClassificationsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> profileId = const Value.absent(),
                Value<String> classification = const Value.absent(),
                Value<String> classificationScope = const Value.absent(),
                Value<String> bowstyle = const Value.absent(),
                Value<String?> firstSessionId = const Value.absent(),
                Value<DateTime?> firstAchievedAt = const Value.absent(),
                Value<int?> firstScore = const Value.absent(),
                Value<String?> firstRoundId = const Value.absent(),
                Value<String?> secondSessionId = const Value.absent(),
                Value<DateTime?> secondAchievedAt = const Value.absent(),
                Value<int?> secondScore = const Value.absent(),
                Value<String?> secondRoundId = const Value.absent(),
                Value<bool> isClaimed = const Value.absent(),
                Value<DateTime?> claimedAt = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => ClassificationsCompanion(
                id: id,
                profileId: profileId,
                classification: classification,
                classificationScope: classificationScope,
                bowstyle: bowstyle,
                firstSessionId: firstSessionId,
                firstAchievedAt: firstAchievedAt,
                firstScore: firstScore,
                firstRoundId: firstRoundId,
                secondSessionId: secondSessionId,
                secondAchievedAt: secondAchievedAt,
                secondScore: secondScore,
                secondRoundId: secondRoundId,
                isClaimed: isClaimed,
                claimedAt: claimedAt,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String profileId,
                required String classification,
                required String classificationScope,
                required String bowstyle,
                Value<String?> firstSessionId = const Value.absent(),
                Value<DateTime?> firstAchievedAt = const Value.absent(),
                Value<int?> firstScore = const Value.absent(),
                Value<String?> firstRoundId = const Value.absent(),
                Value<String?> secondSessionId = const Value.absent(),
                Value<DateTime?> secondAchievedAt = const Value.absent(),
                Value<int?> secondScore = const Value.absent(),
                Value<String?> secondRoundId = const Value.absent(),
                Value<bool> isClaimed = const Value.absent(),
                Value<DateTime?> claimedAt = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => ClassificationsCompanion.insert(
                id: id,
                profileId: profileId,
                classification: classification,
                classificationScope: classificationScope,
                bowstyle: bowstyle,
                firstSessionId: firstSessionId,
                firstAchievedAt: firstAchievedAt,
                firstScore: firstScore,
                firstRoundId: firstRoundId,
                secondSessionId: secondSessionId,
                secondAchievedAt: secondAchievedAt,
                secondScore: secondScore,
                secondRoundId: secondRoundId,
                isClaimed: isClaimed,
                claimedAt: claimedAt,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$ClassificationsTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback:
              ({
                profileId = false,
                firstSessionId = false,
                secondSessionId = false,
              }) {
                return PrefetchHooks(
                  db: db,
                  explicitlyWatchedTables: [],
                  addJoins:
                      <
                        T extends TableManagerState<
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic
                        >
                      >(state) {
                        if (profileId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.profileId,
                                    referencedTable:
                                        $$ClassificationsTableReferences
                                            ._profileIdTable(db),
                                    referencedColumn:
                                        $$ClassificationsTableReferences
                                            ._profileIdTable(db)
                                            .id,
                                  )
                                  as T;
                        }
                        if (firstSessionId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.firstSessionId,
                                    referencedTable:
                                        $$ClassificationsTableReferences
                                            ._firstSessionIdTable(db),
                                    referencedColumn:
                                        $$ClassificationsTableReferences
                                            ._firstSessionIdTable(db)
                                            .id,
                                  )
                                  as T;
                        }
                        if (secondSessionId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.secondSessionId,
                                    referencedTable:
                                        $$ClassificationsTableReferences
                                            ._secondSessionIdTable(db),
                                    referencedColumn:
                                        $$ClassificationsTableReferences
                                            ._secondSessionIdTable(db)
                                            .id,
                                  )
                                  as T;
                        }

                        return state;
                      },
                  getPrefetchedDataCallback: (items) async {
                    return [];
                  },
                );
              },
        ),
      );
}

typedef $$ClassificationsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $ClassificationsTable,
      Classification,
      $$ClassificationsTableFilterComposer,
      $$ClassificationsTableOrderingComposer,
      $$ClassificationsTableAnnotationComposer,
      $$ClassificationsTableCreateCompanionBuilder,
      $$ClassificationsTableUpdateCompanionBuilder,
      (Classification, $$ClassificationsTableReferences),
      Classification,
      PrefetchHooks Function({
        bool profileId,
        bool firstSessionId,
        bool secondSessionId,
      })
    >;
typedef $$AchievementsTableCreateCompanionBuilder =
    AchievementsCompanion Function({
      required String id,
      required String achievementType,
      Value<String?> skillId,
      Value<String?> roundTypeId,
      Value<int?> score,
      required String title,
      Value<String?> description,
      Value<bool> isCompetitionPb,
      Value<DateTime> earnedAt,
      Value<int> rowid,
    });
typedef $$AchievementsTableUpdateCompanionBuilder =
    AchievementsCompanion Function({
      Value<String> id,
      Value<String> achievementType,
      Value<String?> skillId,
      Value<String?> roundTypeId,
      Value<int?> score,
      Value<String> title,
      Value<String?> description,
      Value<bool> isCompetitionPb,
      Value<DateTime> earnedAt,
      Value<int> rowid,
    });

class $$AchievementsTableFilterComposer
    extends Composer<_$AppDatabase, $AchievementsTable> {
  $$AchievementsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get achievementType => $composableBuilder(
    column: $table.achievementType,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get skillId => $composableBuilder(
    column: $table.skillId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get roundTypeId => $composableBuilder(
    column: $table.roundTypeId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get score => $composableBuilder(
    column: $table.score,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get title => $composableBuilder(
    column: $table.title,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get description => $composableBuilder(
    column: $table.description,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isCompetitionPb => $composableBuilder(
    column: $table.isCompetitionPb,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get earnedAt => $composableBuilder(
    column: $table.earnedAt,
    builder: (column) => ColumnFilters(column),
  );
}

class $$AchievementsTableOrderingComposer
    extends Composer<_$AppDatabase, $AchievementsTable> {
  $$AchievementsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get achievementType => $composableBuilder(
    column: $table.achievementType,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get skillId => $composableBuilder(
    column: $table.skillId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get roundTypeId => $composableBuilder(
    column: $table.roundTypeId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get score => $composableBuilder(
    column: $table.score,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get title => $composableBuilder(
    column: $table.title,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get description => $composableBuilder(
    column: $table.description,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isCompetitionPb => $composableBuilder(
    column: $table.isCompetitionPb,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get earnedAt => $composableBuilder(
    column: $table.earnedAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$AchievementsTableAnnotationComposer
    extends Composer<_$AppDatabase, $AchievementsTable> {
  $$AchievementsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get achievementType => $composableBuilder(
    column: $table.achievementType,
    builder: (column) => column,
  );

  GeneratedColumn<String> get skillId =>
      $composableBuilder(column: $table.skillId, builder: (column) => column);

  GeneratedColumn<String> get roundTypeId => $composableBuilder(
    column: $table.roundTypeId,
    builder: (column) => column,
  );

  GeneratedColumn<int> get score =>
      $composableBuilder(column: $table.score, builder: (column) => column);

  GeneratedColumn<String> get title =>
      $composableBuilder(column: $table.title, builder: (column) => column);

  GeneratedColumn<String> get description => $composableBuilder(
    column: $table.description,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get isCompetitionPb => $composableBuilder(
    column: $table.isCompetitionPb,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get earnedAt =>
      $composableBuilder(column: $table.earnedAt, builder: (column) => column);
}

class $$AchievementsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $AchievementsTable,
          Achievement,
          $$AchievementsTableFilterComposer,
          $$AchievementsTableOrderingComposer,
          $$AchievementsTableAnnotationComposer,
          $$AchievementsTableCreateCompanionBuilder,
          $$AchievementsTableUpdateCompanionBuilder,
          (
            Achievement,
            BaseReferences<_$AppDatabase, $AchievementsTable, Achievement>,
          ),
          Achievement,
          PrefetchHooks Function()
        > {
  $$AchievementsTableTableManager(_$AppDatabase db, $AchievementsTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$AchievementsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$AchievementsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$AchievementsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> achievementType = const Value.absent(),
                Value<String?> skillId = const Value.absent(),
                Value<String?> roundTypeId = const Value.absent(),
                Value<int?> score = const Value.absent(),
                Value<String> title = const Value.absent(),
                Value<String?> description = const Value.absent(),
                Value<bool> isCompetitionPb = const Value.absent(),
                Value<DateTime> earnedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => AchievementsCompanion(
                id: id,
                achievementType: achievementType,
                skillId: skillId,
                roundTypeId: roundTypeId,
                score: score,
                title: title,
                description: description,
                isCompetitionPb: isCompetitionPb,
                earnedAt: earnedAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String achievementType,
                Value<String?> skillId = const Value.absent(),
                Value<String?> roundTypeId = const Value.absent(),
                Value<int?> score = const Value.absent(),
                required String title,
                Value<String?> description = const Value.absent(),
                Value<bool> isCompetitionPb = const Value.absent(),
                Value<DateTime> earnedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => AchievementsCompanion.insert(
                id: id,
                achievementType: achievementType,
                skillId: skillId,
                roundTypeId: roundTypeId,
                score: score,
                title: title,
                description: description,
                isCompetitionPb: isCompetitionPb,
                earnedAt: earnedAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$AchievementsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $AchievementsTable,
      Achievement,
      $$AchievementsTableFilterComposer,
      $$AchievementsTableOrderingComposer,
      $$AchievementsTableAnnotationComposer,
      $$AchievementsTableCreateCompanionBuilder,
      $$AchievementsTableUpdateCompanionBuilder,
      (
        Achievement,
        BaseReferences<_$AppDatabase, $AchievementsTable, Achievement>,
      ),
      Achievement,
      PrefetchHooks Function()
    >;
typedef $$EntitlementsTableCreateCompanionBuilder =
    EntitlementsCompanion Function({
      required String id,
      Value<String> tier,
      Value<String?> stripeCustomerId,
      Value<String?> stripeSubscriptionId,
      Value<DateTime?> expiresAt,
      Value<DateTime?> graceEndsAt,
      Value<bool> isLegacy3dAiming,
      Value<String?> legacyEmail,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<int> rowid,
    });
typedef $$EntitlementsTableUpdateCompanionBuilder =
    EntitlementsCompanion Function({
      Value<String> id,
      Value<String> tier,
      Value<String?> stripeCustomerId,
      Value<String?> stripeSubscriptionId,
      Value<DateTime?> expiresAt,
      Value<DateTime?> graceEndsAt,
      Value<bool> isLegacy3dAiming,
      Value<String?> legacyEmail,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<int> rowid,
    });

class $$EntitlementsTableFilterComposer
    extends Composer<_$AppDatabase, $EntitlementsTable> {
  $$EntitlementsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get tier => $composableBuilder(
    column: $table.tier,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get stripeCustomerId => $composableBuilder(
    column: $table.stripeCustomerId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get stripeSubscriptionId => $composableBuilder(
    column: $table.stripeSubscriptionId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get expiresAt => $composableBuilder(
    column: $table.expiresAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get graceEndsAt => $composableBuilder(
    column: $table.graceEndsAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isLegacy3dAiming => $composableBuilder(
    column: $table.isLegacy3dAiming,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get legacyEmail => $composableBuilder(
    column: $table.legacyEmail,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );
}

class $$EntitlementsTableOrderingComposer
    extends Composer<_$AppDatabase, $EntitlementsTable> {
  $$EntitlementsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get tier => $composableBuilder(
    column: $table.tier,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get stripeCustomerId => $composableBuilder(
    column: $table.stripeCustomerId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get stripeSubscriptionId => $composableBuilder(
    column: $table.stripeSubscriptionId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get expiresAt => $composableBuilder(
    column: $table.expiresAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get graceEndsAt => $composableBuilder(
    column: $table.graceEndsAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isLegacy3dAiming => $composableBuilder(
    column: $table.isLegacy3dAiming,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get legacyEmail => $composableBuilder(
    column: $table.legacyEmail,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$EntitlementsTableAnnotationComposer
    extends Composer<_$AppDatabase, $EntitlementsTable> {
  $$EntitlementsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get tier =>
      $composableBuilder(column: $table.tier, builder: (column) => column);

  GeneratedColumn<String> get stripeCustomerId => $composableBuilder(
    column: $table.stripeCustomerId,
    builder: (column) => column,
  );

  GeneratedColumn<String> get stripeSubscriptionId => $composableBuilder(
    column: $table.stripeSubscriptionId,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get expiresAt =>
      $composableBuilder(column: $table.expiresAt, builder: (column) => column);

  GeneratedColumn<DateTime> get graceEndsAt => $composableBuilder(
    column: $table.graceEndsAt,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get isLegacy3dAiming => $composableBuilder(
    column: $table.isLegacy3dAiming,
    builder: (column) => column,
  );

  GeneratedColumn<String> get legacyEmail => $composableBuilder(
    column: $table.legacyEmail,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);
}

class $$EntitlementsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $EntitlementsTable,
          Entitlement,
          $$EntitlementsTableFilterComposer,
          $$EntitlementsTableOrderingComposer,
          $$EntitlementsTableAnnotationComposer,
          $$EntitlementsTableCreateCompanionBuilder,
          $$EntitlementsTableUpdateCompanionBuilder,
          (
            Entitlement,
            BaseReferences<_$AppDatabase, $EntitlementsTable, Entitlement>,
          ),
          Entitlement,
          PrefetchHooks Function()
        > {
  $$EntitlementsTableTableManager(_$AppDatabase db, $EntitlementsTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$EntitlementsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$EntitlementsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$EntitlementsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> tier = const Value.absent(),
                Value<String?> stripeCustomerId = const Value.absent(),
                Value<String?> stripeSubscriptionId = const Value.absent(),
                Value<DateTime?> expiresAt = const Value.absent(),
                Value<DateTime?> graceEndsAt = const Value.absent(),
                Value<bool> isLegacy3dAiming = const Value.absent(),
                Value<String?> legacyEmail = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => EntitlementsCompanion(
                id: id,
                tier: tier,
                stripeCustomerId: stripeCustomerId,
                stripeSubscriptionId: stripeSubscriptionId,
                expiresAt: expiresAt,
                graceEndsAt: graceEndsAt,
                isLegacy3dAiming: isLegacy3dAiming,
                legacyEmail: legacyEmail,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                Value<String> tier = const Value.absent(),
                Value<String?> stripeCustomerId = const Value.absent(),
                Value<String?> stripeSubscriptionId = const Value.absent(),
                Value<DateTime?> expiresAt = const Value.absent(),
                Value<DateTime?> graceEndsAt = const Value.absent(),
                Value<bool> isLegacy3dAiming = const Value.absent(),
                Value<String?> legacyEmail = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => EntitlementsCompanion.insert(
                id: id,
                tier: tier,
                stripeCustomerId: stripeCustomerId,
                stripeSubscriptionId: stripeSubscriptionId,
                expiresAt: expiresAt,
                graceEndsAt: graceEndsAt,
                isLegacy3dAiming: isLegacy3dAiming,
                legacyEmail: legacyEmail,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$EntitlementsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $EntitlementsTable,
      Entitlement,
      $$EntitlementsTableFilterComposer,
      $$EntitlementsTableOrderingComposer,
      $$EntitlementsTableAnnotationComposer,
      $$EntitlementsTableCreateCompanionBuilder,
      $$EntitlementsTableUpdateCompanionBuilder,
      (
        Entitlement,
        BaseReferences<_$AppDatabase, $EntitlementsTable, Entitlement>,
      ),
      Entitlement,
      PrefetchHooks Function()
    >;
typedef $$CourseProgressTableCreateCompanionBuilder =
    CourseProgressCompanion Function({
      required String id,
      required String courseId,
      required String lessonId,
      Value<int> progressSeconds,
      required int durationSeconds,
      Value<bool> isCompleted,
      Value<DateTime?> lastWatchedAt,
      Value<DateTime?> completedAt,
      Value<DateTime> createdAt,
      Value<int> rowid,
    });
typedef $$CourseProgressTableUpdateCompanionBuilder =
    CourseProgressCompanion Function({
      Value<String> id,
      Value<String> courseId,
      Value<String> lessonId,
      Value<int> progressSeconds,
      Value<int> durationSeconds,
      Value<bool> isCompleted,
      Value<DateTime?> lastWatchedAt,
      Value<DateTime?> completedAt,
      Value<DateTime> createdAt,
      Value<int> rowid,
    });

class $$CourseProgressTableFilterComposer
    extends Composer<_$AppDatabase, $CourseProgressTable> {
  $$CourseProgressTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get courseId => $composableBuilder(
    column: $table.courseId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get lessonId => $composableBuilder(
    column: $table.lessonId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get progressSeconds => $composableBuilder(
    column: $table.progressSeconds,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get durationSeconds => $composableBuilder(
    column: $table.durationSeconds,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isCompleted => $composableBuilder(
    column: $table.isCompleted,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get lastWatchedAt => $composableBuilder(
    column: $table.lastWatchedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get completedAt => $composableBuilder(
    column: $table.completedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );
}

class $$CourseProgressTableOrderingComposer
    extends Composer<_$AppDatabase, $CourseProgressTable> {
  $$CourseProgressTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get courseId => $composableBuilder(
    column: $table.courseId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get lessonId => $composableBuilder(
    column: $table.lessonId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get progressSeconds => $composableBuilder(
    column: $table.progressSeconds,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get durationSeconds => $composableBuilder(
    column: $table.durationSeconds,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isCompleted => $composableBuilder(
    column: $table.isCompleted,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get lastWatchedAt => $composableBuilder(
    column: $table.lastWatchedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get completedAt => $composableBuilder(
    column: $table.completedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$CourseProgressTableAnnotationComposer
    extends Composer<_$AppDatabase, $CourseProgressTable> {
  $$CourseProgressTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get courseId =>
      $composableBuilder(column: $table.courseId, builder: (column) => column);

  GeneratedColumn<String> get lessonId =>
      $composableBuilder(column: $table.lessonId, builder: (column) => column);

  GeneratedColumn<int> get progressSeconds => $composableBuilder(
    column: $table.progressSeconds,
    builder: (column) => column,
  );

  GeneratedColumn<int> get durationSeconds => $composableBuilder(
    column: $table.durationSeconds,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get isCompleted => $composableBuilder(
    column: $table.isCompleted,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get lastWatchedAt => $composableBuilder(
    column: $table.lastWatchedAt,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get completedAt => $composableBuilder(
    column: $table.completedAt,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);
}

class $$CourseProgressTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $CourseProgressTable,
          CourseProgressData,
          $$CourseProgressTableFilterComposer,
          $$CourseProgressTableOrderingComposer,
          $$CourseProgressTableAnnotationComposer,
          $$CourseProgressTableCreateCompanionBuilder,
          $$CourseProgressTableUpdateCompanionBuilder,
          (
            CourseProgressData,
            BaseReferences<
              _$AppDatabase,
              $CourseProgressTable,
              CourseProgressData
            >,
          ),
          CourseProgressData,
          PrefetchHooks Function()
        > {
  $$CourseProgressTableTableManager(
    _$AppDatabase db,
    $CourseProgressTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$CourseProgressTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$CourseProgressTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$CourseProgressTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> courseId = const Value.absent(),
                Value<String> lessonId = const Value.absent(),
                Value<int> progressSeconds = const Value.absent(),
                Value<int> durationSeconds = const Value.absent(),
                Value<bool> isCompleted = const Value.absent(),
                Value<DateTime?> lastWatchedAt = const Value.absent(),
                Value<DateTime?> completedAt = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => CourseProgressCompanion(
                id: id,
                courseId: courseId,
                lessonId: lessonId,
                progressSeconds: progressSeconds,
                durationSeconds: durationSeconds,
                isCompleted: isCompleted,
                lastWatchedAt: lastWatchedAt,
                completedAt: completedAt,
                createdAt: createdAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String courseId,
                required String lessonId,
                Value<int> progressSeconds = const Value.absent(),
                required int durationSeconds,
                Value<bool> isCompleted = const Value.absent(),
                Value<DateTime?> lastWatchedAt = const Value.absent(),
                Value<DateTime?> completedAt = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => CourseProgressCompanion.insert(
                id: id,
                courseId: courseId,
                lessonId: lessonId,
                progressSeconds: progressSeconds,
                durationSeconds: durationSeconds,
                isCompleted: isCompleted,
                lastWatchedAt: lastWatchedAt,
                completedAt: completedAt,
                createdAt: createdAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$CourseProgressTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $CourseProgressTable,
      CourseProgressData,
      $$CourseProgressTableFilterComposer,
      $$CourseProgressTableOrderingComposer,
      $$CourseProgressTableAnnotationComposer,
      $$CourseProgressTableCreateCompanionBuilder,
      $$CourseProgressTableUpdateCompanionBuilder,
      (
        CourseProgressData,
        BaseReferences<_$AppDatabase, $CourseProgressTable, CourseProgressData>,
      ),
      CourseProgressData,
      PrefetchHooks Function()
    >;
typedef $$PurchasesTableCreateCompanionBuilder =
    PurchasesCompanion Function({
      required String id,
      required String productId,
      Value<String?> stripePaymentId,
      Value<double?> amountPaid,
      Value<String> source,
      Value<DateTime> purchasedAt,
      Value<int> rowid,
    });
typedef $$PurchasesTableUpdateCompanionBuilder =
    PurchasesCompanion Function({
      Value<String> id,
      Value<String> productId,
      Value<String?> stripePaymentId,
      Value<double?> amountPaid,
      Value<String> source,
      Value<DateTime> purchasedAt,
      Value<int> rowid,
    });

class $$PurchasesTableFilterComposer
    extends Composer<_$AppDatabase, $PurchasesTable> {
  $$PurchasesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get productId => $composableBuilder(
    column: $table.productId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get stripePaymentId => $composableBuilder(
    column: $table.stripePaymentId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get amountPaid => $composableBuilder(
    column: $table.amountPaid,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get source => $composableBuilder(
    column: $table.source,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get purchasedAt => $composableBuilder(
    column: $table.purchasedAt,
    builder: (column) => ColumnFilters(column),
  );
}

class $$PurchasesTableOrderingComposer
    extends Composer<_$AppDatabase, $PurchasesTable> {
  $$PurchasesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get productId => $composableBuilder(
    column: $table.productId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get stripePaymentId => $composableBuilder(
    column: $table.stripePaymentId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get amountPaid => $composableBuilder(
    column: $table.amountPaid,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get source => $composableBuilder(
    column: $table.source,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get purchasedAt => $composableBuilder(
    column: $table.purchasedAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$PurchasesTableAnnotationComposer
    extends Composer<_$AppDatabase, $PurchasesTable> {
  $$PurchasesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get productId =>
      $composableBuilder(column: $table.productId, builder: (column) => column);

  GeneratedColumn<String> get stripePaymentId => $composableBuilder(
    column: $table.stripePaymentId,
    builder: (column) => column,
  );

  GeneratedColumn<double> get amountPaid => $composableBuilder(
    column: $table.amountPaid,
    builder: (column) => column,
  );

  GeneratedColumn<String> get source =>
      $composableBuilder(column: $table.source, builder: (column) => column);

  GeneratedColumn<DateTime> get purchasedAt => $composableBuilder(
    column: $table.purchasedAt,
    builder: (column) => column,
  );
}

class $$PurchasesTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $PurchasesTable,
          Purchase,
          $$PurchasesTableFilterComposer,
          $$PurchasesTableOrderingComposer,
          $$PurchasesTableAnnotationComposer,
          $$PurchasesTableCreateCompanionBuilder,
          $$PurchasesTableUpdateCompanionBuilder,
          (Purchase, BaseReferences<_$AppDatabase, $PurchasesTable, Purchase>),
          Purchase,
          PrefetchHooks Function()
        > {
  $$PurchasesTableTableManager(_$AppDatabase db, $PurchasesTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$PurchasesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$PurchasesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$PurchasesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> productId = const Value.absent(),
                Value<String?> stripePaymentId = const Value.absent(),
                Value<double?> amountPaid = const Value.absent(),
                Value<String> source = const Value.absent(),
                Value<DateTime> purchasedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => PurchasesCompanion(
                id: id,
                productId: productId,
                stripePaymentId: stripePaymentId,
                amountPaid: amountPaid,
                source: source,
                purchasedAt: purchasedAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String productId,
                Value<String?> stripePaymentId = const Value.absent(),
                Value<double?> amountPaid = const Value.absent(),
                Value<String> source = const Value.absent(),
                Value<DateTime> purchasedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => PurchasesCompanion.insert(
                id: id,
                productId: productId,
                stripePaymentId: stripePaymentId,
                amountPaid: amountPaid,
                source: source,
                purchasedAt: purchasedAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$PurchasesTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $PurchasesTable,
      Purchase,
      $$PurchasesTableFilterComposer,
      $$PurchasesTableOrderingComposer,
      $$PurchasesTableAnnotationComposer,
      $$PurchasesTableCreateCompanionBuilder,
      $$PurchasesTableUpdateCompanionBuilder,
      (Purchase, BaseReferences<_$AppDatabase, $PurchasesTable, Purchase>),
      Purchase,
      PrefetchHooks Function()
    >;
typedef $$SyncQueueTableCreateCompanionBuilder =
    SyncQueueCompanion Function({
      required String id,
      required String entityType,
      required String entityId,
      required String operation,
      required String payload,
      Value<int> retryCount,
      Value<DateTime> createdAt,
      Value<DateTime?> lastAttemptAt,
      Value<String?> lastError,
      Value<int> rowid,
    });
typedef $$SyncQueueTableUpdateCompanionBuilder =
    SyncQueueCompanion Function({
      Value<String> id,
      Value<String> entityType,
      Value<String> entityId,
      Value<String> operation,
      Value<String> payload,
      Value<int> retryCount,
      Value<DateTime> createdAt,
      Value<DateTime?> lastAttemptAt,
      Value<String?> lastError,
      Value<int> rowid,
    });

class $$SyncQueueTableFilterComposer
    extends Composer<_$AppDatabase, $SyncQueueTable> {
  $$SyncQueueTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get entityType => $composableBuilder(
    column: $table.entityType,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get entityId => $composableBuilder(
    column: $table.entityId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get operation => $composableBuilder(
    column: $table.operation,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get payload => $composableBuilder(
    column: $table.payload,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get retryCount => $composableBuilder(
    column: $table.retryCount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get lastAttemptAt => $composableBuilder(
    column: $table.lastAttemptAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get lastError => $composableBuilder(
    column: $table.lastError,
    builder: (column) => ColumnFilters(column),
  );
}

class $$SyncQueueTableOrderingComposer
    extends Composer<_$AppDatabase, $SyncQueueTable> {
  $$SyncQueueTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get entityType => $composableBuilder(
    column: $table.entityType,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get entityId => $composableBuilder(
    column: $table.entityId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get operation => $composableBuilder(
    column: $table.operation,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get payload => $composableBuilder(
    column: $table.payload,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get retryCount => $composableBuilder(
    column: $table.retryCount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get lastAttemptAt => $composableBuilder(
    column: $table.lastAttemptAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get lastError => $composableBuilder(
    column: $table.lastError,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$SyncQueueTableAnnotationComposer
    extends Composer<_$AppDatabase, $SyncQueueTable> {
  $$SyncQueueTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get entityType => $composableBuilder(
    column: $table.entityType,
    builder: (column) => column,
  );

  GeneratedColumn<String> get entityId =>
      $composableBuilder(column: $table.entityId, builder: (column) => column);

  GeneratedColumn<String> get operation =>
      $composableBuilder(column: $table.operation, builder: (column) => column);

  GeneratedColumn<String> get payload =>
      $composableBuilder(column: $table.payload, builder: (column) => column);

  GeneratedColumn<int> get retryCount => $composableBuilder(
    column: $table.retryCount,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get lastAttemptAt => $composableBuilder(
    column: $table.lastAttemptAt,
    builder: (column) => column,
  );

  GeneratedColumn<String> get lastError =>
      $composableBuilder(column: $table.lastError, builder: (column) => column);
}

class $$SyncQueueTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $SyncQueueTable,
          SyncQueueData,
          $$SyncQueueTableFilterComposer,
          $$SyncQueueTableOrderingComposer,
          $$SyncQueueTableAnnotationComposer,
          $$SyncQueueTableCreateCompanionBuilder,
          $$SyncQueueTableUpdateCompanionBuilder,
          (
            SyncQueueData,
            BaseReferences<_$AppDatabase, $SyncQueueTable, SyncQueueData>,
          ),
          SyncQueueData,
          PrefetchHooks Function()
        > {
  $$SyncQueueTableTableManager(_$AppDatabase db, $SyncQueueTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$SyncQueueTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$SyncQueueTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$SyncQueueTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> entityType = const Value.absent(),
                Value<String> entityId = const Value.absent(),
                Value<String> operation = const Value.absent(),
                Value<String> payload = const Value.absent(),
                Value<int> retryCount = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime?> lastAttemptAt = const Value.absent(),
                Value<String?> lastError = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => SyncQueueCompanion(
                id: id,
                entityType: entityType,
                entityId: entityId,
                operation: operation,
                payload: payload,
                retryCount: retryCount,
                createdAt: createdAt,
                lastAttemptAt: lastAttemptAt,
                lastError: lastError,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String entityType,
                required String entityId,
                required String operation,
                required String payload,
                Value<int> retryCount = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime?> lastAttemptAt = const Value.absent(),
                Value<String?> lastError = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => SyncQueueCompanion.insert(
                id: id,
                entityType: entityType,
                entityId: entityId,
                operation: operation,
                payload: payload,
                retryCount: retryCount,
                createdAt: createdAt,
                lastAttemptAt: lastAttemptAt,
                lastError: lastError,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$SyncQueueTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $SyncQueueTable,
      SyncQueueData,
      $$SyncQueueTableFilterComposer,
      $$SyncQueueTableOrderingComposer,
      $$SyncQueueTableAnnotationComposer,
      $$SyncQueueTableCreateCompanionBuilder,
      $$SyncQueueTableUpdateCompanionBuilder,
      (
        SyncQueueData,
        BaseReferences<_$AppDatabase, $SyncQueueTable, SyncQueueData>,
      ),
      SyncQueueData,
      PrefetchHooks Function()
    >;
typedef $$SyncMetadataTableCreateCompanionBuilder =
    SyncMetadataCompanion Function({
      required String entityType,
      Value<DateTime?> lastSyncedAt,
      Value<int> rowid,
    });
typedef $$SyncMetadataTableUpdateCompanionBuilder =
    SyncMetadataCompanion Function({
      Value<String> entityType,
      Value<DateTime?> lastSyncedAt,
      Value<int> rowid,
    });

class $$SyncMetadataTableFilterComposer
    extends Composer<_$AppDatabase, $SyncMetadataTable> {
  $$SyncMetadataTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get entityType => $composableBuilder(
    column: $table.entityType,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get lastSyncedAt => $composableBuilder(
    column: $table.lastSyncedAt,
    builder: (column) => ColumnFilters(column),
  );
}

class $$SyncMetadataTableOrderingComposer
    extends Composer<_$AppDatabase, $SyncMetadataTable> {
  $$SyncMetadataTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get entityType => $composableBuilder(
    column: $table.entityType,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get lastSyncedAt => $composableBuilder(
    column: $table.lastSyncedAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$SyncMetadataTableAnnotationComposer
    extends Composer<_$AppDatabase, $SyncMetadataTable> {
  $$SyncMetadataTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get entityType => $composableBuilder(
    column: $table.entityType,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get lastSyncedAt => $composableBuilder(
    column: $table.lastSyncedAt,
    builder: (column) => column,
  );
}

class $$SyncMetadataTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $SyncMetadataTable,
          SyncMetadataData,
          $$SyncMetadataTableFilterComposer,
          $$SyncMetadataTableOrderingComposer,
          $$SyncMetadataTableAnnotationComposer,
          $$SyncMetadataTableCreateCompanionBuilder,
          $$SyncMetadataTableUpdateCompanionBuilder,
          (
            SyncMetadataData,
            BaseReferences<_$AppDatabase, $SyncMetadataTable, SyncMetadataData>,
          ),
          SyncMetadataData,
          PrefetchHooks Function()
        > {
  $$SyncMetadataTableTableManager(_$AppDatabase db, $SyncMetadataTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$SyncMetadataTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$SyncMetadataTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$SyncMetadataTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> entityType = const Value.absent(),
                Value<DateTime?> lastSyncedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => SyncMetadataCompanion(
                entityType: entityType,
                lastSyncedAt: lastSyncedAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String entityType,
                Value<DateTime?> lastSyncedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => SyncMetadataCompanion.insert(
                entityType: entityType,
                lastSyncedAt: lastSyncedAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$SyncMetadataTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $SyncMetadataTable,
      SyncMetadataData,
      $$SyncMetadataTableFilterComposer,
      $$SyncMetadataTableOrderingComposer,
      $$SyncMetadataTableAnnotationComposer,
      $$SyncMetadataTableCreateCompanionBuilder,
      $$SyncMetadataTableUpdateCompanionBuilder,
      (
        SyncMetadataData,
        BaseReferences<_$AppDatabase, $SyncMetadataTable, SyncMetadataData>,
      ),
      SyncMetadataData,
      PrefetchHooks Function()
    >;
typedef $$FieldCoursesTableCreateCompanionBuilder =
    FieldCoursesCompanion Function({
      required String id,
      required String name,
      Value<String?> venueId,
      required String roundType,
      Value<int> targetCount,
      Value<String?> notes,
      Value<DateTime> createdAt,
      Value<DateTime?> updatedAt,
      Value<DateTime?> deletedAt,
      Value<int> rowid,
    });
typedef $$FieldCoursesTableUpdateCompanionBuilder =
    FieldCoursesCompanion Function({
      Value<String> id,
      Value<String> name,
      Value<String?> venueId,
      Value<String> roundType,
      Value<int> targetCount,
      Value<String?> notes,
      Value<DateTime> createdAt,
      Value<DateTime?> updatedAt,
      Value<DateTime?> deletedAt,
      Value<int> rowid,
    });

final class $$FieldCoursesTableReferences
    extends BaseReferences<_$AppDatabase, $FieldCoursesTable, FieldCourse> {
  $$FieldCoursesTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $VenuesTable _venueIdTable(_$AppDatabase db) => db.venues.createAlias(
    $_aliasNameGenerator(db.fieldCourses.venueId, db.venues.id),
  );

  $$VenuesTableProcessedTableManager? get venueId {
    final $_column = $_itemColumn<String>('venue_id');
    if ($_column == null) return null;
    final manager = $$VenuesTableTableManager(
      $_db,
      $_db.venues,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_venueIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static MultiTypedResultKey<$FieldCourseTargetsTable, List<FieldCourseTarget>>
  _fieldCourseTargetsRefsTable(_$AppDatabase db) =>
      MultiTypedResultKey.fromTable(
        db.fieldCourseTargets,
        aliasName: $_aliasNameGenerator(
          db.fieldCourses.id,
          db.fieldCourseTargets.courseId,
        ),
      );

  $$FieldCourseTargetsTableProcessedTableManager get fieldCourseTargetsRefs {
    final manager = $$FieldCourseTargetsTableTableManager(
      $_db,
      $_db.fieldCourseTargets,
    ).filter((f) => f.courseId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(
      _fieldCourseTargetsRefsTable($_db),
    );
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$FieldSessionMetaTable, List<FieldSessionMetaData>>
  _fieldSessionMetaRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.fieldSessionMeta,
    aliasName: $_aliasNameGenerator(
      db.fieldCourses.id,
      db.fieldSessionMeta.courseId,
    ),
  );

  $$FieldSessionMetaTableProcessedTableManager get fieldSessionMetaRefs {
    final manager = $$FieldSessionMetaTableTableManager(
      $_db,
      $_db.fieldSessionMeta,
    ).filter((f) => f.courseId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(
      _fieldSessionMetaRefsTable($_db),
    );
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$FieldCoursesTableFilterComposer
    extends Composer<_$AppDatabase, $FieldCoursesTable> {
  $$FieldCoursesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get roundType => $composableBuilder(
    column: $table.roundType,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get targetCount => $composableBuilder(
    column: $table.targetCount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get deletedAt => $composableBuilder(
    column: $table.deletedAt,
    builder: (column) => ColumnFilters(column),
  );

  $$VenuesTableFilterComposer get venueId {
    final $$VenuesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.venueId,
      referencedTable: $db.venues,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$VenuesTableFilterComposer(
            $db: $db,
            $table: $db.venues,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<bool> fieldCourseTargetsRefs(
    Expression<bool> Function($$FieldCourseTargetsTableFilterComposer f) f,
  ) {
    final $$FieldCourseTargetsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.fieldCourseTargets,
      getReferencedColumn: (t) => t.courseId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$FieldCourseTargetsTableFilterComposer(
            $db: $db,
            $table: $db.fieldCourseTargets,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> fieldSessionMetaRefs(
    Expression<bool> Function($$FieldSessionMetaTableFilterComposer f) f,
  ) {
    final $$FieldSessionMetaTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.fieldSessionMeta,
      getReferencedColumn: (t) => t.courseId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$FieldSessionMetaTableFilterComposer(
            $db: $db,
            $table: $db.fieldSessionMeta,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$FieldCoursesTableOrderingComposer
    extends Composer<_$AppDatabase, $FieldCoursesTable> {
  $$FieldCoursesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get roundType => $composableBuilder(
    column: $table.roundType,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get targetCount => $composableBuilder(
    column: $table.targetCount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get deletedAt => $composableBuilder(
    column: $table.deletedAt,
    builder: (column) => ColumnOrderings(column),
  );

  $$VenuesTableOrderingComposer get venueId {
    final $$VenuesTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.venueId,
      referencedTable: $db.venues,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$VenuesTableOrderingComposer(
            $db: $db,
            $table: $db.venues,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$FieldCoursesTableAnnotationComposer
    extends Composer<_$AppDatabase, $FieldCoursesTable> {
  $$FieldCoursesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get roundType =>
      $composableBuilder(column: $table.roundType, builder: (column) => column);

  GeneratedColumn<int> get targetCount => $composableBuilder(
    column: $table.targetCount,
    builder: (column) => column,
  );

  GeneratedColumn<String> get notes =>
      $composableBuilder(column: $table.notes, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  GeneratedColumn<DateTime> get deletedAt =>
      $composableBuilder(column: $table.deletedAt, builder: (column) => column);

  $$VenuesTableAnnotationComposer get venueId {
    final $$VenuesTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.venueId,
      referencedTable: $db.venues,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$VenuesTableAnnotationComposer(
            $db: $db,
            $table: $db.venues,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<T> fieldCourseTargetsRefs<T extends Object>(
    Expression<T> Function($$FieldCourseTargetsTableAnnotationComposer a) f,
  ) {
    final $$FieldCourseTargetsTableAnnotationComposer composer =
        $composerBuilder(
          composer: this,
          getCurrentColumn: (t) => t.id,
          referencedTable: $db.fieldCourseTargets,
          getReferencedColumn: (t) => t.courseId,
          builder:
              (
                joinBuilder, {
                $addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer,
              }) => $$FieldCourseTargetsTableAnnotationComposer(
                $db: $db,
                $table: $db.fieldCourseTargets,
                $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                joinBuilder: joinBuilder,
                $removeJoinBuilderFromRootComposer:
                    $removeJoinBuilderFromRootComposer,
              ),
        );
    return f(composer);
  }

  Expression<T> fieldSessionMetaRefs<T extends Object>(
    Expression<T> Function($$FieldSessionMetaTableAnnotationComposer a) f,
  ) {
    final $$FieldSessionMetaTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.fieldSessionMeta,
      getReferencedColumn: (t) => t.courseId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$FieldSessionMetaTableAnnotationComposer(
            $db: $db,
            $table: $db.fieldSessionMeta,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$FieldCoursesTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $FieldCoursesTable,
          FieldCourse,
          $$FieldCoursesTableFilterComposer,
          $$FieldCoursesTableOrderingComposer,
          $$FieldCoursesTableAnnotationComposer,
          $$FieldCoursesTableCreateCompanionBuilder,
          $$FieldCoursesTableUpdateCompanionBuilder,
          (FieldCourse, $$FieldCoursesTableReferences),
          FieldCourse,
          PrefetchHooks Function({
            bool venueId,
            bool fieldCourseTargetsRefs,
            bool fieldSessionMetaRefs,
          })
        > {
  $$FieldCoursesTableTableManager(_$AppDatabase db, $FieldCoursesTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$FieldCoursesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$FieldCoursesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$FieldCoursesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<String?> venueId = const Value.absent(),
                Value<String> roundType = const Value.absent(),
                Value<int> targetCount = const Value.absent(),
                Value<String?> notes = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime?> updatedAt = const Value.absent(),
                Value<DateTime?> deletedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => FieldCoursesCompanion(
                id: id,
                name: name,
                venueId: venueId,
                roundType: roundType,
                targetCount: targetCount,
                notes: notes,
                createdAt: createdAt,
                updatedAt: updatedAt,
                deletedAt: deletedAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String name,
                Value<String?> venueId = const Value.absent(),
                required String roundType,
                Value<int> targetCount = const Value.absent(),
                Value<String?> notes = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime?> updatedAt = const Value.absent(),
                Value<DateTime?> deletedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => FieldCoursesCompanion.insert(
                id: id,
                name: name,
                venueId: venueId,
                roundType: roundType,
                targetCount: targetCount,
                notes: notes,
                createdAt: createdAt,
                updatedAt: updatedAt,
                deletedAt: deletedAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$FieldCoursesTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback:
              ({
                venueId = false,
                fieldCourseTargetsRefs = false,
                fieldSessionMetaRefs = false,
              }) {
                return PrefetchHooks(
                  db: db,
                  explicitlyWatchedTables: [
                    if (fieldCourseTargetsRefs) db.fieldCourseTargets,
                    if (fieldSessionMetaRefs) db.fieldSessionMeta,
                  ],
                  addJoins:
                      <
                        T extends TableManagerState<
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic
                        >
                      >(state) {
                        if (venueId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.venueId,
                                    referencedTable:
                                        $$FieldCoursesTableReferences
                                            ._venueIdTable(db),
                                    referencedColumn:
                                        $$FieldCoursesTableReferences
                                            ._venueIdTable(db)
                                            .id,
                                  )
                                  as T;
                        }

                        return state;
                      },
                  getPrefetchedDataCallback: (items) async {
                    return [
                      if (fieldCourseTargetsRefs)
                        await $_getPrefetchedData<
                          FieldCourse,
                          $FieldCoursesTable,
                          FieldCourseTarget
                        >(
                          currentTable: table,
                          referencedTable: $$FieldCoursesTableReferences
                              ._fieldCourseTargetsRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$FieldCoursesTableReferences(
                                db,
                                table,
                                p0,
                              ).fieldCourseTargetsRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.courseId == item.id,
                              ),
                          typedResults: items,
                        ),
                      if (fieldSessionMetaRefs)
                        await $_getPrefetchedData<
                          FieldCourse,
                          $FieldCoursesTable,
                          FieldSessionMetaData
                        >(
                          currentTable: table,
                          referencedTable: $$FieldCoursesTableReferences
                              ._fieldSessionMetaRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$FieldCoursesTableReferences(
                                db,
                                table,
                                p0,
                              ).fieldSessionMetaRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.courseId == item.id,
                              ),
                          typedResults: items,
                        ),
                    ];
                  },
                );
              },
        ),
      );
}

typedef $$FieldCoursesTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $FieldCoursesTable,
      FieldCourse,
      $$FieldCoursesTableFilterComposer,
      $$FieldCoursesTableOrderingComposer,
      $$FieldCoursesTableAnnotationComposer,
      $$FieldCoursesTableCreateCompanionBuilder,
      $$FieldCoursesTableUpdateCompanionBuilder,
      (FieldCourse, $$FieldCoursesTableReferences),
      FieldCourse,
      PrefetchHooks Function({
        bool venueId,
        bool fieldCourseTargetsRefs,
        bool fieldSessionMetaRefs,
      })
    >;
typedef $$FieldCourseTargetsTableCreateCompanionBuilder =
    FieldCourseTargetsCompanion Function({
      required String id,
      required String courseId,
      required int targetNumber,
      required String pegConfig,
      required int faceSize,
      required double primaryDistance,
      Value<String> unit,
      Value<bool> isWalkUp,
      Value<bool> isWalkDown,
      Value<int> arrowsRequired,
      Value<String?> notes,
      Value<int> rowid,
    });
typedef $$FieldCourseTargetsTableUpdateCompanionBuilder =
    FieldCourseTargetsCompanion Function({
      Value<String> id,
      Value<String> courseId,
      Value<int> targetNumber,
      Value<String> pegConfig,
      Value<int> faceSize,
      Value<double> primaryDistance,
      Value<String> unit,
      Value<bool> isWalkUp,
      Value<bool> isWalkDown,
      Value<int> arrowsRequired,
      Value<String?> notes,
      Value<int> rowid,
    });

final class $$FieldCourseTargetsTableReferences
    extends
        BaseReferences<
          _$AppDatabase,
          $FieldCourseTargetsTable,
          FieldCourseTarget
        > {
  $$FieldCourseTargetsTableReferences(
    super.$_db,
    super.$_table,
    super.$_typedResult,
  );

  static $FieldCoursesTable _courseIdTable(_$AppDatabase db) =>
      db.fieldCourses.createAlias(
        $_aliasNameGenerator(
          db.fieldCourseTargets.courseId,
          db.fieldCourses.id,
        ),
      );

  $$FieldCoursesTableProcessedTableManager get courseId {
    final $_column = $_itemColumn<String>('course_id')!;

    final manager = $$FieldCoursesTableTableManager(
      $_db,
      $_db.fieldCourses,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_courseIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static MultiTypedResultKey<
    $FieldCourseSightMarksTable,
    List<FieldCourseSightMark>
  >
  _fieldCourseSightMarksRefsTable(_$AppDatabase db) =>
      MultiTypedResultKey.fromTable(
        db.fieldCourseSightMarks,
        aliasName: $_aliasNameGenerator(
          db.fieldCourseTargets.id,
          db.fieldCourseSightMarks.courseTargetId,
        ),
      );

  $$FieldCourseSightMarksTableProcessedTableManager
  get fieldCourseSightMarksRefs {
    final manager = $$FieldCourseSightMarksTableTableManager(
      $_db,
      $_db.fieldCourseSightMarks,
    ).filter((f) => f.courseTargetId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(
      _fieldCourseSightMarksRefsTable($_db),
    );
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<
    $FieldSessionTargetsTable,
    List<FieldSessionTarget>
  >
  _fieldSessionTargetsRefsTable(_$AppDatabase db) =>
      MultiTypedResultKey.fromTable(
        db.fieldSessionTargets,
        aliasName: $_aliasNameGenerator(
          db.fieldCourseTargets.id,
          db.fieldSessionTargets.courseTargetId,
        ),
      );

  $$FieldSessionTargetsTableProcessedTableManager get fieldSessionTargetsRefs {
    final manager = $$FieldSessionTargetsTableTableManager(
      $_db,
      $_db.fieldSessionTargets,
    ).filter((f) => f.courseTargetId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(
      _fieldSessionTargetsRefsTable($_db),
    );
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$FieldCourseTargetsTableFilterComposer
    extends Composer<_$AppDatabase, $FieldCourseTargetsTable> {
  $$FieldCourseTargetsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get targetNumber => $composableBuilder(
    column: $table.targetNumber,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get pegConfig => $composableBuilder(
    column: $table.pegConfig,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get faceSize => $composableBuilder(
    column: $table.faceSize,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get primaryDistance => $composableBuilder(
    column: $table.primaryDistance,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get unit => $composableBuilder(
    column: $table.unit,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isWalkUp => $composableBuilder(
    column: $table.isWalkUp,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isWalkDown => $composableBuilder(
    column: $table.isWalkDown,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get arrowsRequired => $composableBuilder(
    column: $table.arrowsRequired,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnFilters(column),
  );

  $$FieldCoursesTableFilterComposer get courseId {
    final $$FieldCoursesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.courseId,
      referencedTable: $db.fieldCourses,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$FieldCoursesTableFilterComposer(
            $db: $db,
            $table: $db.fieldCourses,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<bool> fieldCourseSightMarksRefs(
    Expression<bool> Function($$FieldCourseSightMarksTableFilterComposer f) f,
  ) {
    final $$FieldCourseSightMarksTableFilterComposer composer =
        $composerBuilder(
          composer: this,
          getCurrentColumn: (t) => t.id,
          referencedTable: $db.fieldCourseSightMarks,
          getReferencedColumn: (t) => t.courseTargetId,
          builder:
              (
                joinBuilder, {
                $addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer,
              }) => $$FieldCourseSightMarksTableFilterComposer(
                $db: $db,
                $table: $db.fieldCourseSightMarks,
                $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                joinBuilder: joinBuilder,
                $removeJoinBuilderFromRootComposer:
                    $removeJoinBuilderFromRootComposer,
              ),
        );
    return f(composer);
  }

  Expression<bool> fieldSessionTargetsRefs(
    Expression<bool> Function($$FieldSessionTargetsTableFilterComposer f) f,
  ) {
    final $$FieldSessionTargetsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.fieldSessionTargets,
      getReferencedColumn: (t) => t.courseTargetId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$FieldSessionTargetsTableFilterComposer(
            $db: $db,
            $table: $db.fieldSessionTargets,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$FieldCourseTargetsTableOrderingComposer
    extends Composer<_$AppDatabase, $FieldCourseTargetsTable> {
  $$FieldCourseTargetsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get targetNumber => $composableBuilder(
    column: $table.targetNumber,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get pegConfig => $composableBuilder(
    column: $table.pegConfig,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get faceSize => $composableBuilder(
    column: $table.faceSize,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get primaryDistance => $composableBuilder(
    column: $table.primaryDistance,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get unit => $composableBuilder(
    column: $table.unit,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isWalkUp => $composableBuilder(
    column: $table.isWalkUp,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isWalkDown => $composableBuilder(
    column: $table.isWalkDown,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get arrowsRequired => $composableBuilder(
    column: $table.arrowsRequired,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnOrderings(column),
  );

  $$FieldCoursesTableOrderingComposer get courseId {
    final $$FieldCoursesTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.courseId,
      referencedTable: $db.fieldCourses,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$FieldCoursesTableOrderingComposer(
            $db: $db,
            $table: $db.fieldCourses,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$FieldCourseTargetsTableAnnotationComposer
    extends Composer<_$AppDatabase, $FieldCourseTargetsTable> {
  $$FieldCourseTargetsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<int> get targetNumber => $composableBuilder(
    column: $table.targetNumber,
    builder: (column) => column,
  );

  GeneratedColumn<String> get pegConfig =>
      $composableBuilder(column: $table.pegConfig, builder: (column) => column);

  GeneratedColumn<int> get faceSize =>
      $composableBuilder(column: $table.faceSize, builder: (column) => column);

  GeneratedColumn<double> get primaryDistance => $composableBuilder(
    column: $table.primaryDistance,
    builder: (column) => column,
  );

  GeneratedColumn<String> get unit =>
      $composableBuilder(column: $table.unit, builder: (column) => column);

  GeneratedColumn<bool> get isWalkUp =>
      $composableBuilder(column: $table.isWalkUp, builder: (column) => column);

  GeneratedColumn<bool> get isWalkDown => $composableBuilder(
    column: $table.isWalkDown,
    builder: (column) => column,
  );

  GeneratedColumn<int> get arrowsRequired => $composableBuilder(
    column: $table.arrowsRequired,
    builder: (column) => column,
  );

  GeneratedColumn<String> get notes =>
      $composableBuilder(column: $table.notes, builder: (column) => column);

  $$FieldCoursesTableAnnotationComposer get courseId {
    final $$FieldCoursesTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.courseId,
      referencedTable: $db.fieldCourses,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$FieldCoursesTableAnnotationComposer(
            $db: $db,
            $table: $db.fieldCourses,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<T> fieldCourseSightMarksRefs<T extends Object>(
    Expression<T> Function($$FieldCourseSightMarksTableAnnotationComposer a) f,
  ) {
    final $$FieldCourseSightMarksTableAnnotationComposer composer =
        $composerBuilder(
          composer: this,
          getCurrentColumn: (t) => t.id,
          referencedTable: $db.fieldCourseSightMarks,
          getReferencedColumn: (t) => t.courseTargetId,
          builder:
              (
                joinBuilder, {
                $addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer,
              }) => $$FieldCourseSightMarksTableAnnotationComposer(
                $db: $db,
                $table: $db.fieldCourseSightMarks,
                $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                joinBuilder: joinBuilder,
                $removeJoinBuilderFromRootComposer:
                    $removeJoinBuilderFromRootComposer,
              ),
        );
    return f(composer);
  }

  Expression<T> fieldSessionTargetsRefs<T extends Object>(
    Expression<T> Function($$FieldSessionTargetsTableAnnotationComposer a) f,
  ) {
    final $$FieldSessionTargetsTableAnnotationComposer composer =
        $composerBuilder(
          composer: this,
          getCurrentColumn: (t) => t.id,
          referencedTable: $db.fieldSessionTargets,
          getReferencedColumn: (t) => t.courseTargetId,
          builder:
              (
                joinBuilder, {
                $addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer,
              }) => $$FieldSessionTargetsTableAnnotationComposer(
                $db: $db,
                $table: $db.fieldSessionTargets,
                $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                joinBuilder: joinBuilder,
                $removeJoinBuilderFromRootComposer:
                    $removeJoinBuilderFromRootComposer,
              ),
        );
    return f(composer);
  }
}

class $$FieldCourseTargetsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $FieldCourseTargetsTable,
          FieldCourseTarget,
          $$FieldCourseTargetsTableFilterComposer,
          $$FieldCourseTargetsTableOrderingComposer,
          $$FieldCourseTargetsTableAnnotationComposer,
          $$FieldCourseTargetsTableCreateCompanionBuilder,
          $$FieldCourseTargetsTableUpdateCompanionBuilder,
          (FieldCourseTarget, $$FieldCourseTargetsTableReferences),
          FieldCourseTarget,
          PrefetchHooks Function({
            bool courseId,
            bool fieldCourseSightMarksRefs,
            bool fieldSessionTargetsRefs,
          })
        > {
  $$FieldCourseTargetsTableTableManager(
    _$AppDatabase db,
    $FieldCourseTargetsTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$FieldCourseTargetsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$FieldCourseTargetsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$FieldCourseTargetsTableAnnotationComposer(
                $db: db,
                $table: table,
              ),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> courseId = const Value.absent(),
                Value<int> targetNumber = const Value.absent(),
                Value<String> pegConfig = const Value.absent(),
                Value<int> faceSize = const Value.absent(),
                Value<double> primaryDistance = const Value.absent(),
                Value<String> unit = const Value.absent(),
                Value<bool> isWalkUp = const Value.absent(),
                Value<bool> isWalkDown = const Value.absent(),
                Value<int> arrowsRequired = const Value.absent(),
                Value<String?> notes = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => FieldCourseTargetsCompanion(
                id: id,
                courseId: courseId,
                targetNumber: targetNumber,
                pegConfig: pegConfig,
                faceSize: faceSize,
                primaryDistance: primaryDistance,
                unit: unit,
                isWalkUp: isWalkUp,
                isWalkDown: isWalkDown,
                arrowsRequired: arrowsRequired,
                notes: notes,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String courseId,
                required int targetNumber,
                required String pegConfig,
                required int faceSize,
                required double primaryDistance,
                Value<String> unit = const Value.absent(),
                Value<bool> isWalkUp = const Value.absent(),
                Value<bool> isWalkDown = const Value.absent(),
                Value<int> arrowsRequired = const Value.absent(),
                Value<String?> notes = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => FieldCourseTargetsCompanion.insert(
                id: id,
                courseId: courseId,
                targetNumber: targetNumber,
                pegConfig: pegConfig,
                faceSize: faceSize,
                primaryDistance: primaryDistance,
                unit: unit,
                isWalkUp: isWalkUp,
                isWalkDown: isWalkDown,
                arrowsRequired: arrowsRequired,
                notes: notes,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$FieldCourseTargetsTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback:
              ({
                courseId = false,
                fieldCourseSightMarksRefs = false,
                fieldSessionTargetsRefs = false,
              }) {
                return PrefetchHooks(
                  db: db,
                  explicitlyWatchedTables: [
                    if (fieldCourseSightMarksRefs) db.fieldCourseSightMarks,
                    if (fieldSessionTargetsRefs) db.fieldSessionTargets,
                  ],
                  addJoins:
                      <
                        T extends TableManagerState<
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic
                        >
                      >(state) {
                        if (courseId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.courseId,
                                    referencedTable:
                                        $$FieldCourseTargetsTableReferences
                                            ._courseIdTable(db),
                                    referencedColumn:
                                        $$FieldCourseTargetsTableReferences
                                            ._courseIdTable(db)
                                            .id,
                                  )
                                  as T;
                        }

                        return state;
                      },
                  getPrefetchedDataCallback: (items) async {
                    return [
                      if (fieldCourseSightMarksRefs)
                        await $_getPrefetchedData<
                          FieldCourseTarget,
                          $FieldCourseTargetsTable,
                          FieldCourseSightMark
                        >(
                          currentTable: table,
                          referencedTable: $$FieldCourseTargetsTableReferences
                              ._fieldCourseSightMarksRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$FieldCourseTargetsTableReferences(
                                db,
                                table,
                                p0,
                              ).fieldCourseSightMarksRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.courseTargetId == item.id,
                              ),
                          typedResults: items,
                        ),
                      if (fieldSessionTargetsRefs)
                        await $_getPrefetchedData<
                          FieldCourseTarget,
                          $FieldCourseTargetsTable,
                          FieldSessionTarget
                        >(
                          currentTable: table,
                          referencedTable: $$FieldCourseTargetsTableReferences
                              ._fieldSessionTargetsRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$FieldCourseTargetsTableReferences(
                                db,
                                table,
                                p0,
                              ).fieldSessionTargetsRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.courseTargetId == item.id,
                              ),
                          typedResults: items,
                        ),
                    ];
                  },
                );
              },
        ),
      );
}

typedef $$FieldCourseTargetsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $FieldCourseTargetsTable,
      FieldCourseTarget,
      $$FieldCourseTargetsTableFilterComposer,
      $$FieldCourseTargetsTableOrderingComposer,
      $$FieldCourseTargetsTableAnnotationComposer,
      $$FieldCourseTargetsTableCreateCompanionBuilder,
      $$FieldCourseTargetsTableUpdateCompanionBuilder,
      (FieldCourseTarget, $$FieldCourseTargetsTableReferences),
      FieldCourseTarget,
      PrefetchHooks Function({
        bool courseId,
        bool fieldCourseSightMarksRefs,
        bool fieldSessionTargetsRefs,
      })
    >;
typedef $$FieldCourseSightMarksTableCreateCompanionBuilder =
    FieldCourseSightMarksCompanion Function({
      required String id,
      required String courseTargetId,
      required String bowId,
      required double calculatedMark,
      required double actualMark,
      required double differential,
      Value<double?> confidenceScore,
      Value<String?> weatherData,
      Value<int> shotCount,
      Value<DateTime> recordedAt,
      Value<int> rowid,
    });
typedef $$FieldCourseSightMarksTableUpdateCompanionBuilder =
    FieldCourseSightMarksCompanion Function({
      Value<String> id,
      Value<String> courseTargetId,
      Value<String> bowId,
      Value<double> calculatedMark,
      Value<double> actualMark,
      Value<double> differential,
      Value<double?> confidenceScore,
      Value<String?> weatherData,
      Value<int> shotCount,
      Value<DateTime> recordedAt,
      Value<int> rowid,
    });

final class $$FieldCourseSightMarksTableReferences
    extends
        BaseReferences<
          _$AppDatabase,
          $FieldCourseSightMarksTable,
          FieldCourseSightMark
        > {
  $$FieldCourseSightMarksTableReferences(
    super.$_db,
    super.$_table,
    super.$_typedResult,
  );

  static $FieldCourseTargetsTable _courseTargetIdTable(_$AppDatabase db) =>
      db.fieldCourseTargets.createAlias(
        $_aliasNameGenerator(
          db.fieldCourseSightMarks.courseTargetId,
          db.fieldCourseTargets.id,
        ),
      );

  $$FieldCourseTargetsTableProcessedTableManager get courseTargetId {
    final $_column = $_itemColumn<String>('course_target_id')!;

    final manager = $$FieldCourseTargetsTableTableManager(
      $_db,
      $_db.fieldCourseTargets,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_courseTargetIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $BowsTable _bowIdTable(_$AppDatabase db) => db.bows.createAlias(
    $_aliasNameGenerator(db.fieldCourseSightMarks.bowId, db.bows.id),
  );

  $$BowsTableProcessedTableManager get bowId {
    final $_column = $_itemColumn<String>('bow_id')!;

    final manager = $$BowsTableTableManager(
      $_db,
      $_db.bows,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_bowIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$FieldCourseSightMarksTableFilterComposer
    extends Composer<_$AppDatabase, $FieldCourseSightMarksTable> {
  $$FieldCourseSightMarksTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get calculatedMark => $composableBuilder(
    column: $table.calculatedMark,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get actualMark => $composableBuilder(
    column: $table.actualMark,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get differential => $composableBuilder(
    column: $table.differential,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get confidenceScore => $composableBuilder(
    column: $table.confidenceScore,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get weatherData => $composableBuilder(
    column: $table.weatherData,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get shotCount => $composableBuilder(
    column: $table.shotCount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get recordedAt => $composableBuilder(
    column: $table.recordedAt,
    builder: (column) => ColumnFilters(column),
  );

  $$FieldCourseTargetsTableFilterComposer get courseTargetId {
    final $$FieldCourseTargetsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.courseTargetId,
      referencedTable: $db.fieldCourseTargets,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$FieldCourseTargetsTableFilterComposer(
            $db: $db,
            $table: $db.fieldCourseTargets,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$BowsTableFilterComposer get bowId {
    final $$BowsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.bowId,
      referencedTable: $db.bows,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$BowsTableFilterComposer(
            $db: $db,
            $table: $db.bows,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$FieldCourseSightMarksTableOrderingComposer
    extends Composer<_$AppDatabase, $FieldCourseSightMarksTable> {
  $$FieldCourseSightMarksTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get calculatedMark => $composableBuilder(
    column: $table.calculatedMark,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get actualMark => $composableBuilder(
    column: $table.actualMark,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get differential => $composableBuilder(
    column: $table.differential,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get confidenceScore => $composableBuilder(
    column: $table.confidenceScore,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get weatherData => $composableBuilder(
    column: $table.weatherData,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get shotCount => $composableBuilder(
    column: $table.shotCount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get recordedAt => $composableBuilder(
    column: $table.recordedAt,
    builder: (column) => ColumnOrderings(column),
  );

  $$FieldCourseTargetsTableOrderingComposer get courseTargetId {
    final $$FieldCourseTargetsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.courseTargetId,
      referencedTable: $db.fieldCourseTargets,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$FieldCourseTargetsTableOrderingComposer(
            $db: $db,
            $table: $db.fieldCourseTargets,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$BowsTableOrderingComposer get bowId {
    final $$BowsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.bowId,
      referencedTable: $db.bows,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$BowsTableOrderingComposer(
            $db: $db,
            $table: $db.bows,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$FieldCourseSightMarksTableAnnotationComposer
    extends Composer<_$AppDatabase, $FieldCourseSightMarksTable> {
  $$FieldCourseSightMarksTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<double> get calculatedMark => $composableBuilder(
    column: $table.calculatedMark,
    builder: (column) => column,
  );

  GeneratedColumn<double> get actualMark => $composableBuilder(
    column: $table.actualMark,
    builder: (column) => column,
  );

  GeneratedColumn<double> get differential => $composableBuilder(
    column: $table.differential,
    builder: (column) => column,
  );

  GeneratedColumn<double> get confidenceScore => $composableBuilder(
    column: $table.confidenceScore,
    builder: (column) => column,
  );

  GeneratedColumn<String> get weatherData => $composableBuilder(
    column: $table.weatherData,
    builder: (column) => column,
  );

  GeneratedColumn<int> get shotCount =>
      $composableBuilder(column: $table.shotCount, builder: (column) => column);

  GeneratedColumn<DateTime> get recordedAt => $composableBuilder(
    column: $table.recordedAt,
    builder: (column) => column,
  );

  $$FieldCourseTargetsTableAnnotationComposer get courseTargetId {
    final $$FieldCourseTargetsTableAnnotationComposer composer =
        $composerBuilder(
          composer: this,
          getCurrentColumn: (t) => t.courseTargetId,
          referencedTable: $db.fieldCourseTargets,
          getReferencedColumn: (t) => t.id,
          builder:
              (
                joinBuilder, {
                $addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer,
              }) => $$FieldCourseTargetsTableAnnotationComposer(
                $db: $db,
                $table: $db.fieldCourseTargets,
                $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                joinBuilder: joinBuilder,
                $removeJoinBuilderFromRootComposer:
                    $removeJoinBuilderFromRootComposer,
              ),
        );
    return composer;
  }

  $$BowsTableAnnotationComposer get bowId {
    final $$BowsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.bowId,
      referencedTable: $db.bows,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$BowsTableAnnotationComposer(
            $db: $db,
            $table: $db.bows,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$FieldCourseSightMarksTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $FieldCourseSightMarksTable,
          FieldCourseSightMark,
          $$FieldCourseSightMarksTableFilterComposer,
          $$FieldCourseSightMarksTableOrderingComposer,
          $$FieldCourseSightMarksTableAnnotationComposer,
          $$FieldCourseSightMarksTableCreateCompanionBuilder,
          $$FieldCourseSightMarksTableUpdateCompanionBuilder,
          (FieldCourseSightMark, $$FieldCourseSightMarksTableReferences),
          FieldCourseSightMark,
          PrefetchHooks Function({bool courseTargetId, bool bowId})
        > {
  $$FieldCourseSightMarksTableTableManager(
    _$AppDatabase db,
    $FieldCourseSightMarksTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$FieldCourseSightMarksTableFilterComposer(
                $db: db,
                $table: table,
              ),
          createOrderingComposer: () =>
              $$FieldCourseSightMarksTableOrderingComposer(
                $db: db,
                $table: table,
              ),
          createComputedFieldComposer: () =>
              $$FieldCourseSightMarksTableAnnotationComposer(
                $db: db,
                $table: table,
              ),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> courseTargetId = const Value.absent(),
                Value<String> bowId = const Value.absent(),
                Value<double> calculatedMark = const Value.absent(),
                Value<double> actualMark = const Value.absent(),
                Value<double> differential = const Value.absent(),
                Value<double?> confidenceScore = const Value.absent(),
                Value<String?> weatherData = const Value.absent(),
                Value<int> shotCount = const Value.absent(),
                Value<DateTime> recordedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => FieldCourseSightMarksCompanion(
                id: id,
                courseTargetId: courseTargetId,
                bowId: bowId,
                calculatedMark: calculatedMark,
                actualMark: actualMark,
                differential: differential,
                confidenceScore: confidenceScore,
                weatherData: weatherData,
                shotCount: shotCount,
                recordedAt: recordedAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String courseTargetId,
                required String bowId,
                required double calculatedMark,
                required double actualMark,
                required double differential,
                Value<double?> confidenceScore = const Value.absent(),
                Value<String?> weatherData = const Value.absent(),
                Value<int> shotCount = const Value.absent(),
                Value<DateTime> recordedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => FieldCourseSightMarksCompanion.insert(
                id: id,
                courseTargetId: courseTargetId,
                bowId: bowId,
                calculatedMark: calculatedMark,
                actualMark: actualMark,
                differential: differential,
                confidenceScore: confidenceScore,
                weatherData: weatherData,
                shotCount: shotCount,
                recordedAt: recordedAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$FieldCourseSightMarksTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback: ({courseTargetId = false, bowId = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins:
                  <
                    T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic
                    >
                  >(state) {
                    if (courseTargetId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.courseTargetId,
                                referencedTable:
                                    $$FieldCourseSightMarksTableReferences
                                        ._courseTargetIdTable(db),
                                referencedColumn:
                                    $$FieldCourseSightMarksTableReferences
                                        ._courseTargetIdTable(db)
                                        .id,
                              )
                              as T;
                    }
                    if (bowId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.bowId,
                                referencedTable:
                                    $$FieldCourseSightMarksTableReferences
                                        ._bowIdTable(db),
                                referencedColumn:
                                    $$FieldCourseSightMarksTableReferences
                                        ._bowIdTable(db)
                                        .id,
                              )
                              as T;
                    }

                    return state;
                  },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ),
      );
}

typedef $$FieldCourseSightMarksTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $FieldCourseSightMarksTable,
      FieldCourseSightMark,
      $$FieldCourseSightMarksTableFilterComposer,
      $$FieldCourseSightMarksTableOrderingComposer,
      $$FieldCourseSightMarksTableAnnotationComposer,
      $$FieldCourseSightMarksTableCreateCompanionBuilder,
      $$FieldCourseSightMarksTableUpdateCompanionBuilder,
      (FieldCourseSightMark, $$FieldCourseSightMarksTableReferences),
      FieldCourseSightMark,
      PrefetchHooks Function({bool courseTargetId, bool bowId})
    >;
typedef $$FieldSessionTargetsTableCreateCompanionBuilder =
    FieldSessionTargetsCompanion Function({
      required String id,
      required String sessionId,
      Value<String?> courseTargetId,
      required int targetNumber,
      Value<int> totalScore,
      Value<int> xCount,
      required String arrowScores,
      Value<String?> sightMarkUsed,
      Value<int?> station,
      Value<bool?> wasHit,
      Value<DateTime?> completedAt,
      Value<int> rowid,
    });
typedef $$FieldSessionTargetsTableUpdateCompanionBuilder =
    FieldSessionTargetsCompanion Function({
      Value<String> id,
      Value<String> sessionId,
      Value<String?> courseTargetId,
      Value<int> targetNumber,
      Value<int> totalScore,
      Value<int> xCount,
      Value<String> arrowScores,
      Value<String?> sightMarkUsed,
      Value<int?> station,
      Value<bool?> wasHit,
      Value<DateTime?> completedAt,
      Value<int> rowid,
    });

final class $$FieldSessionTargetsTableReferences
    extends
        BaseReferences<
          _$AppDatabase,
          $FieldSessionTargetsTable,
          FieldSessionTarget
        > {
  $$FieldSessionTargetsTableReferences(
    super.$_db,
    super.$_table,
    super.$_typedResult,
  );

  static $SessionsTable _sessionIdTable(_$AppDatabase db) =>
      db.sessions.createAlias(
        $_aliasNameGenerator(db.fieldSessionTargets.sessionId, db.sessions.id),
      );

  $$SessionsTableProcessedTableManager get sessionId {
    final $_column = $_itemColumn<String>('session_id')!;

    final manager = $$SessionsTableTableManager(
      $_db,
      $_db.sessions,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_sessionIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $FieldCourseTargetsTable _courseTargetIdTable(_$AppDatabase db) =>
      db.fieldCourseTargets.createAlias(
        $_aliasNameGenerator(
          db.fieldSessionTargets.courseTargetId,
          db.fieldCourseTargets.id,
        ),
      );

  $$FieldCourseTargetsTableProcessedTableManager? get courseTargetId {
    final $_column = $_itemColumn<String>('course_target_id');
    if ($_column == null) return null;
    final manager = $$FieldCourseTargetsTableTableManager(
      $_db,
      $_db.fieldCourseTargets,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_courseTargetIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$FieldSessionTargetsTableFilterComposer
    extends Composer<_$AppDatabase, $FieldSessionTargetsTable> {
  $$FieldSessionTargetsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get targetNumber => $composableBuilder(
    column: $table.targetNumber,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get totalScore => $composableBuilder(
    column: $table.totalScore,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get xCount => $composableBuilder(
    column: $table.xCount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get arrowScores => $composableBuilder(
    column: $table.arrowScores,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get sightMarkUsed => $composableBuilder(
    column: $table.sightMarkUsed,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get station => $composableBuilder(
    column: $table.station,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get wasHit => $composableBuilder(
    column: $table.wasHit,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get completedAt => $composableBuilder(
    column: $table.completedAt,
    builder: (column) => ColumnFilters(column),
  );

  $$SessionsTableFilterComposer get sessionId {
    final $$SessionsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.sessionId,
      referencedTable: $db.sessions,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SessionsTableFilterComposer(
            $db: $db,
            $table: $db.sessions,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$FieldCourseTargetsTableFilterComposer get courseTargetId {
    final $$FieldCourseTargetsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.courseTargetId,
      referencedTable: $db.fieldCourseTargets,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$FieldCourseTargetsTableFilterComposer(
            $db: $db,
            $table: $db.fieldCourseTargets,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$FieldSessionTargetsTableOrderingComposer
    extends Composer<_$AppDatabase, $FieldSessionTargetsTable> {
  $$FieldSessionTargetsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get targetNumber => $composableBuilder(
    column: $table.targetNumber,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get totalScore => $composableBuilder(
    column: $table.totalScore,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get xCount => $composableBuilder(
    column: $table.xCount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get arrowScores => $composableBuilder(
    column: $table.arrowScores,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get sightMarkUsed => $composableBuilder(
    column: $table.sightMarkUsed,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get station => $composableBuilder(
    column: $table.station,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get wasHit => $composableBuilder(
    column: $table.wasHit,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get completedAt => $composableBuilder(
    column: $table.completedAt,
    builder: (column) => ColumnOrderings(column),
  );

  $$SessionsTableOrderingComposer get sessionId {
    final $$SessionsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.sessionId,
      referencedTable: $db.sessions,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SessionsTableOrderingComposer(
            $db: $db,
            $table: $db.sessions,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$FieldCourseTargetsTableOrderingComposer get courseTargetId {
    final $$FieldCourseTargetsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.courseTargetId,
      referencedTable: $db.fieldCourseTargets,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$FieldCourseTargetsTableOrderingComposer(
            $db: $db,
            $table: $db.fieldCourseTargets,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$FieldSessionTargetsTableAnnotationComposer
    extends Composer<_$AppDatabase, $FieldSessionTargetsTable> {
  $$FieldSessionTargetsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<int> get targetNumber => $composableBuilder(
    column: $table.targetNumber,
    builder: (column) => column,
  );

  GeneratedColumn<int> get totalScore => $composableBuilder(
    column: $table.totalScore,
    builder: (column) => column,
  );

  GeneratedColumn<int> get xCount =>
      $composableBuilder(column: $table.xCount, builder: (column) => column);

  GeneratedColumn<String> get arrowScores => $composableBuilder(
    column: $table.arrowScores,
    builder: (column) => column,
  );

  GeneratedColumn<String> get sightMarkUsed => $composableBuilder(
    column: $table.sightMarkUsed,
    builder: (column) => column,
  );

  GeneratedColumn<int> get station =>
      $composableBuilder(column: $table.station, builder: (column) => column);

  GeneratedColumn<bool> get wasHit =>
      $composableBuilder(column: $table.wasHit, builder: (column) => column);

  GeneratedColumn<DateTime> get completedAt => $composableBuilder(
    column: $table.completedAt,
    builder: (column) => column,
  );

  $$SessionsTableAnnotationComposer get sessionId {
    final $$SessionsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.sessionId,
      referencedTable: $db.sessions,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SessionsTableAnnotationComposer(
            $db: $db,
            $table: $db.sessions,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$FieldCourseTargetsTableAnnotationComposer get courseTargetId {
    final $$FieldCourseTargetsTableAnnotationComposer composer =
        $composerBuilder(
          composer: this,
          getCurrentColumn: (t) => t.courseTargetId,
          referencedTable: $db.fieldCourseTargets,
          getReferencedColumn: (t) => t.id,
          builder:
              (
                joinBuilder, {
                $addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer,
              }) => $$FieldCourseTargetsTableAnnotationComposer(
                $db: $db,
                $table: $db.fieldCourseTargets,
                $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                joinBuilder: joinBuilder,
                $removeJoinBuilderFromRootComposer:
                    $removeJoinBuilderFromRootComposer,
              ),
        );
    return composer;
  }
}

class $$FieldSessionTargetsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $FieldSessionTargetsTable,
          FieldSessionTarget,
          $$FieldSessionTargetsTableFilterComposer,
          $$FieldSessionTargetsTableOrderingComposer,
          $$FieldSessionTargetsTableAnnotationComposer,
          $$FieldSessionTargetsTableCreateCompanionBuilder,
          $$FieldSessionTargetsTableUpdateCompanionBuilder,
          (FieldSessionTarget, $$FieldSessionTargetsTableReferences),
          FieldSessionTarget,
          PrefetchHooks Function({bool sessionId, bool courseTargetId})
        > {
  $$FieldSessionTargetsTableTableManager(
    _$AppDatabase db,
    $FieldSessionTargetsTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$FieldSessionTargetsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$FieldSessionTargetsTableOrderingComposer(
                $db: db,
                $table: table,
              ),
          createComputedFieldComposer: () =>
              $$FieldSessionTargetsTableAnnotationComposer(
                $db: db,
                $table: table,
              ),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> sessionId = const Value.absent(),
                Value<String?> courseTargetId = const Value.absent(),
                Value<int> targetNumber = const Value.absent(),
                Value<int> totalScore = const Value.absent(),
                Value<int> xCount = const Value.absent(),
                Value<String> arrowScores = const Value.absent(),
                Value<String?> sightMarkUsed = const Value.absent(),
                Value<int?> station = const Value.absent(),
                Value<bool?> wasHit = const Value.absent(),
                Value<DateTime?> completedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => FieldSessionTargetsCompanion(
                id: id,
                sessionId: sessionId,
                courseTargetId: courseTargetId,
                targetNumber: targetNumber,
                totalScore: totalScore,
                xCount: xCount,
                arrowScores: arrowScores,
                sightMarkUsed: sightMarkUsed,
                station: station,
                wasHit: wasHit,
                completedAt: completedAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String sessionId,
                Value<String?> courseTargetId = const Value.absent(),
                required int targetNumber,
                Value<int> totalScore = const Value.absent(),
                Value<int> xCount = const Value.absent(),
                required String arrowScores,
                Value<String?> sightMarkUsed = const Value.absent(),
                Value<int?> station = const Value.absent(),
                Value<bool?> wasHit = const Value.absent(),
                Value<DateTime?> completedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => FieldSessionTargetsCompanion.insert(
                id: id,
                sessionId: sessionId,
                courseTargetId: courseTargetId,
                targetNumber: targetNumber,
                totalScore: totalScore,
                xCount: xCount,
                arrowScores: arrowScores,
                sightMarkUsed: sightMarkUsed,
                station: station,
                wasHit: wasHit,
                completedAt: completedAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$FieldSessionTargetsTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback: ({sessionId = false, courseTargetId = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins:
                  <
                    T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic
                    >
                  >(state) {
                    if (sessionId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.sessionId,
                                referencedTable:
                                    $$FieldSessionTargetsTableReferences
                                        ._sessionIdTable(db),
                                referencedColumn:
                                    $$FieldSessionTargetsTableReferences
                                        ._sessionIdTable(db)
                                        .id,
                              )
                              as T;
                    }
                    if (courseTargetId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.courseTargetId,
                                referencedTable:
                                    $$FieldSessionTargetsTableReferences
                                        ._courseTargetIdTable(db),
                                referencedColumn:
                                    $$FieldSessionTargetsTableReferences
                                        ._courseTargetIdTable(db)
                                        .id,
                              )
                              as T;
                    }

                    return state;
                  },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ),
      );
}

typedef $$FieldSessionTargetsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $FieldSessionTargetsTable,
      FieldSessionTarget,
      $$FieldSessionTargetsTableFilterComposer,
      $$FieldSessionTargetsTableOrderingComposer,
      $$FieldSessionTargetsTableAnnotationComposer,
      $$FieldSessionTargetsTableCreateCompanionBuilder,
      $$FieldSessionTargetsTableUpdateCompanionBuilder,
      (FieldSessionTarget, $$FieldSessionTargetsTableReferences),
      FieldSessionTarget,
      PrefetchHooks Function({bool sessionId, bool courseTargetId})
    >;
typedef $$FieldSessionMetaTableCreateCompanionBuilder =
    FieldSessionMetaCompanion Function({
      required String sessionId,
      Value<String?> courseId,
      required String roundType,
      Value<bool> isNewCourseCreation,
      Value<int> currentTargetNumber,
      Value<String> usedPegs,
      Value<int> rowid,
    });
typedef $$FieldSessionMetaTableUpdateCompanionBuilder =
    FieldSessionMetaCompanion Function({
      Value<String> sessionId,
      Value<String?> courseId,
      Value<String> roundType,
      Value<bool> isNewCourseCreation,
      Value<int> currentTargetNumber,
      Value<String> usedPegs,
      Value<int> rowid,
    });

final class $$FieldSessionMetaTableReferences
    extends
        BaseReferences<
          _$AppDatabase,
          $FieldSessionMetaTable,
          FieldSessionMetaData
        > {
  $$FieldSessionMetaTableReferences(
    super.$_db,
    super.$_table,
    super.$_typedResult,
  );

  static $SessionsTable _sessionIdTable(_$AppDatabase db) =>
      db.sessions.createAlias(
        $_aliasNameGenerator(db.fieldSessionMeta.sessionId, db.sessions.id),
      );

  $$SessionsTableProcessedTableManager get sessionId {
    final $_column = $_itemColumn<String>('session_id')!;

    final manager = $$SessionsTableTableManager(
      $_db,
      $_db.sessions,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_sessionIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $FieldCoursesTable _courseIdTable(_$AppDatabase db) =>
      db.fieldCourses.createAlias(
        $_aliasNameGenerator(db.fieldSessionMeta.courseId, db.fieldCourses.id),
      );

  $$FieldCoursesTableProcessedTableManager? get courseId {
    final $_column = $_itemColumn<String>('course_id');
    if ($_column == null) return null;
    final manager = $$FieldCoursesTableTableManager(
      $_db,
      $_db.fieldCourses,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_courseIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$FieldSessionMetaTableFilterComposer
    extends Composer<_$AppDatabase, $FieldSessionMetaTable> {
  $$FieldSessionMetaTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get roundType => $composableBuilder(
    column: $table.roundType,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isNewCourseCreation => $composableBuilder(
    column: $table.isNewCourseCreation,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get currentTargetNumber => $composableBuilder(
    column: $table.currentTargetNumber,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get usedPegs => $composableBuilder(
    column: $table.usedPegs,
    builder: (column) => ColumnFilters(column),
  );

  $$SessionsTableFilterComposer get sessionId {
    final $$SessionsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.sessionId,
      referencedTable: $db.sessions,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SessionsTableFilterComposer(
            $db: $db,
            $table: $db.sessions,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$FieldCoursesTableFilterComposer get courseId {
    final $$FieldCoursesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.courseId,
      referencedTable: $db.fieldCourses,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$FieldCoursesTableFilterComposer(
            $db: $db,
            $table: $db.fieldCourses,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$FieldSessionMetaTableOrderingComposer
    extends Composer<_$AppDatabase, $FieldSessionMetaTable> {
  $$FieldSessionMetaTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get roundType => $composableBuilder(
    column: $table.roundType,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isNewCourseCreation => $composableBuilder(
    column: $table.isNewCourseCreation,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get currentTargetNumber => $composableBuilder(
    column: $table.currentTargetNumber,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get usedPegs => $composableBuilder(
    column: $table.usedPegs,
    builder: (column) => ColumnOrderings(column),
  );

  $$SessionsTableOrderingComposer get sessionId {
    final $$SessionsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.sessionId,
      referencedTable: $db.sessions,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SessionsTableOrderingComposer(
            $db: $db,
            $table: $db.sessions,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$FieldCoursesTableOrderingComposer get courseId {
    final $$FieldCoursesTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.courseId,
      referencedTable: $db.fieldCourses,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$FieldCoursesTableOrderingComposer(
            $db: $db,
            $table: $db.fieldCourses,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$FieldSessionMetaTableAnnotationComposer
    extends Composer<_$AppDatabase, $FieldSessionMetaTable> {
  $$FieldSessionMetaTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get roundType =>
      $composableBuilder(column: $table.roundType, builder: (column) => column);

  GeneratedColumn<bool> get isNewCourseCreation => $composableBuilder(
    column: $table.isNewCourseCreation,
    builder: (column) => column,
  );

  GeneratedColumn<int> get currentTargetNumber => $composableBuilder(
    column: $table.currentTargetNumber,
    builder: (column) => column,
  );

  GeneratedColumn<String> get usedPegs =>
      $composableBuilder(column: $table.usedPegs, builder: (column) => column);

  $$SessionsTableAnnotationComposer get sessionId {
    final $$SessionsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.sessionId,
      referencedTable: $db.sessions,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SessionsTableAnnotationComposer(
            $db: $db,
            $table: $db.sessions,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$FieldCoursesTableAnnotationComposer get courseId {
    final $$FieldCoursesTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.courseId,
      referencedTable: $db.fieldCourses,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$FieldCoursesTableAnnotationComposer(
            $db: $db,
            $table: $db.fieldCourses,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$FieldSessionMetaTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $FieldSessionMetaTable,
          FieldSessionMetaData,
          $$FieldSessionMetaTableFilterComposer,
          $$FieldSessionMetaTableOrderingComposer,
          $$FieldSessionMetaTableAnnotationComposer,
          $$FieldSessionMetaTableCreateCompanionBuilder,
          $$FieldSessionMetaTableUpdateCompanionBuilder,
          (FieldSessionMetaData, $$FieldSessionMetaTableReferences),
          FieldSessionMetaData,
          PrefetchHooks Function({bool sessionId, bool courseId})
        > {
  $$FieldSessionMetaTableTableManager(
    _$AppDatabase db,
    $FieldSessionMetaTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$FieldSessionMetaTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$FieldSessionMetaTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$FieldSessionMetaTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> sessionId = const Value.absent(),
                Value<String?> courseId = const Value.absent(),
                Value<String> roundType = const Value.absent(),
                Value<bool> isNewCourseCreation = const Value.absent(),
                Value<int> currentTargetNumber = const Value.absent(),
                Value<String> usedPegs = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => FieldSessionMetaCompanion(
                sessionId: sessionId,
                courseId: courseId,
                roundType: roundType,
                isNewCourseCreation: isNewCourseCreation,
                currentTargetNumber: currentTargetNumber,
                usedPegs: usedPegs,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String sessionId,
                Value<String?> courseId = const Value.absent(),
                required String roundType,
                Value<bool> isNewCourseCreation = const Value.absent(),
                Value<int> currentTargetNumber = const Value.absent(),
                Value<String> usedPegs = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => FieldSessionMetaCompanion.insert(
                sessionId: sessionId,
                courseId: courseId,
                roundType: roundType,
                isNewCourseCreation: isNewCourseCreation,
                currentTargetNumber: currentTargetNumber,
                usedPegs: usedPegs,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$FieldSessionMetaTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback: ({sessionId = false, courseId = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins:
                  <
                    T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic
                    >
                  >(state) {
                    if (sessionId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.sessionId,
                                referencedTable:
                                    $$FieldSessionMetaTableReferences
                                        ._sessionIdTable(db),
                                referencedColumn:
                                    $$FieldSessionMetaTableReferences
                                        ._sessionIdTable(db)
                                        .id,
                              )
                              as T;
                    }
                    if (courseId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.courseId,
                                referencedTable:
                                    $$FieldSessionMetaTableReferences
                                        ._courseIdTable(db),
                                referencedColumn:
                                    $$FieldSessionMetaTableReferences
                                        ._courseIdTable(db)
                                        .id,
                              )
                              as T;
                    }

                    return state;
                  },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ),
      );
}

typedef $$FieldSessionMetaTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $FieldSessionMetaTable,
      FieldSessionMetaData,
      $$FieldSessionMetaTableFilterComposer,
      $$FieldSessionMetaTableOrderingComposer,
      $$FieldSessionMetaTableAnnotationComposer,
      $$FieldSessionMetaTableCreateCompanionBuilder,
      $$FieldSessionMetaTableUpdateCompanionBuilder,
      (FieldSessionMetaData, $$FieldSessionMetaTableReferences),
      FieldSessionMetaData,
      PrefetchHooks Function({bool sessionId, bool courseId})
    >;

class $AppDatabaseManager {
  final _$AppDatabase _db;
  $AppDatabaseManager(this._db);
  $$RoundTypesTableTableManager get roundTypes =>
      $$RoundTypesTableTableManager(_db, _db.roundTypes);
  $$BowsTableTableManager get bows => $$BowsTableTableManager(_db, _db.bows);
  $$QuiversTableTableManager get quivers =>
      $$QuiversTableTableManager(_db, _db.quivers);
  $$SessionsTableTableManager get sessions =>
      $$SessionsTableTableManager(_db, _db.sessions);
  $$EndsTableTableManager get ends => $$EndsTableTableManager(_db, _db.ends);
  $$ShaftsTableTableManager get shafts =>
      $$ShaftsTableTableManager(_db, _db.shafts);
  $$ArrowsTableTableManager get arrows =>
      $$ArrowsTableTableManager(_db, _db.arrows);
  $$ImportedScoresTableTableManager get importedScores =>
      $$ImportedScoresTableTableManager(_db, _db.importedScores);
  $$UserPreferencesTableTableManager get userPreferences =>
      $$UserPreferencesTableTableManager(_db, _db.userPreferences);
  $$FingerTabsTableTableManager get fingerTabs =>
      $$FingerTabsTableTableManager(_db, _db.fingerTabs);
  $$StabilizersTableTableManager get stabilizers =>
      $$StabilizersTableTableManager(_db, _db.stabilizers);
  $$BowStringsTableTableManager get bowStrings =>
      $$BowStringsTableTableManager(_db, _db.bowStrings);
  $$VolumeEntriesTableTableManager get volumeEntries =>
      $$VolumeEntriesTableTableManager(_db, _db.volumeEntries);
  $$OlyExerciseTypesTableTableManager get olyExerciseTypes =>
      $$OlyExerciseTypesTableTableManager(_db, _db.olyExerciseTypes);
  $$OlySessionTemplatesTableTableManager get olySessionTemplates =>
      $$OlySessionTemplatesTableTableManager(_db, _db.olySessionTemplates);
  $$OlySessionExercisesTableTableManager get olySessionExercises =>
      $$OlySessionExercisesTableTableManager(_db, _db.olySessionExercises);
  $$OlyTrainingLogsTableTableManager get olyTrainingLogs =>
      $$OlyTrainingLogsTableTableManager(_db, _db.olyTrainingLogs);
  $$UserTrainingProgressTableTableManager get userTrainingProgress =>
      $$UserTrainingProgressTableTableManager(_db, _db.userTrainingProgress);
  $$BreathTrainingLogsTableTableManager get breathTrainingLogs =>
      $$BreathTrainingLogsTableTableManager(_db, _db.breathTrainingLogs);
  $$BreathHoldAwardsTableTableManager get breathHoldAwards =>
      $$BreathHoldAwardsTableTableManager(_db, _db.breathHoldAwards);
  $$MilestonesTableTableManager get milestones =>
      $$MilestonesTableTableManager(_db, _db.milestones);
  $$VolumeImportsTableTableManager get volumeImports =>
      $$VolumeImportsTableTableManager(_db, _db.volumeImports);
  $$KitSnapshotsTableTableManager get kitSnapshots =>
      $$KitSnapshotsTableTableManager(_db, _db.kitSnapshots);
  $$TuningSessionsTableTableManager get tuningSessions =>
      $$TuningSessionsTableTableManager(_db, _db.tuningSessions);
  $$SkillLevelsTableTableManager get skillLevels =>
      $$SkillLevelsTableTableManager(_db, _db.skillLevels);
  $$XpHistoryTableTableManager get xpHistory =>
      $$XpHistoryTableTableManager(_db, _db.xpHistory);
  $$SightMarksTableTableManager get sightMarks =>
      $$SightMarksTableTableManager(_db, _db.sightMarks);
  $$SightMarkPreferencesTableTableTableManager get sightMarkPreferencesTable =>
      $$SightMarkPreferencesTableTableTableManager(
        _db,
        _db.sightMarkPreferencesTable,
      );
  $$AngleCorrectionProfilesTableTableManager get angleCorrectionProfiles =>
      $$AngleCorrectionProfilesTableTableManager(
        _db,
        _db.angleCorrectionProfiles,
      );
  $$VenuesTableTableManager get venues =>
      $$VenuesTableTableManager(_db, _db.venues);
  $$RegisteredTargetsTableTableManager get registeredTargets =>
      $$RegisteredTargetsTableTableManager(_db, _db.registeredTargets);
  $$AutoPlotUsageTableTableManager get autoPlotUsage =>
      $$AutoPlotUsageTableTableManager(_db, _db.autoPlotUsage);
  $$UserProfilesTableTableManager get userProfiles =>
      $$UserProfilesTableTableManager(_db, _db.userProfiles);
  $$FederationsTableTableManager get federations =>
      $$FederationsTableTableManager(_db, _db.federations);
  $$ClassificationsTableTableManager get classifications =>
      $$ClassificationsTableTableManager(_db, _db.classifications);
  $$AchievementsTableTableManager get achievements =>
      $$AchievementsTableTableManager(_db, _db.achievements);
  $$EntitlementsTableTableManager get entitlements =>
      $$EntitlementsTableTableManager(_db, _db.entitlements);
  $$CourseProgressTableTableManager get courseProgress =>
      $$CourseProgressTableTableManager(_db, _db.courseProgress);
  $$PurchasesTableTableManager get purchases =>
      $$PurchasesTableTableManager(_db, _db.purchases);
  $$SyncQueueTableTableManager get syncQueue =>
      $$SyncQueueTableTableManager(_db, _db.syncQueue);
  $$SyncMetadataTableTableManager get syncMetadata =>
      $$SyncMetadataTableTableManager(_db, _db.syncMetadata);
  $$FieldCoursesTableTableManager get fieldCourses =>
      $$FieldCoursesTableTableManager(_db, _db.fieldCourses);
  $$FieldCourseTargetsTableTableManager get fieldCourseTargets =>
      $$FieldCourseTargetsTableTableManager(_db, _db.fieldCourseTargets);
  $$FieldCourseSightMarksTableTableManager get fieldCourseSightMarks =>
      $$FieldCourseSightMarksTableTableManager(_db, _db.fieldCourseSightMarks);
  $$FieldSessionTargetsTableTableManager get fieldSessionTargets =>
      $$FieldSessionTargetsTableTableManager(_db, _db.fieldSessionTargets);
  $$FieldSessionMetaTableTableManager get fieldSessionMeta =>
      $$FieldSessionMetaTableTableManager(_db, _db.fieldSessionMeta);
}
